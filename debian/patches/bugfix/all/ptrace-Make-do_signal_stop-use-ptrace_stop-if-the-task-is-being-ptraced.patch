commit 5224fa3660ad3881d2f2ad726d22614117963f10
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 23 10:37:00 2011 +0100

    ptrace: Make do_signal_stop() use ptrace_stop() if the task is being ptraced
    
    A ptraced task would still stop at do_signal_stop() when it's stopping
    for stop signals and do_signal_stop() behaves the same whether the
    task is ptraced or not.  However, in addition to stopping,
    ptrace_stop() also does ptrace specific stuff like calling
    architecture specific callbacks, so this behavior makes the code more
    fragile and difficult to understand.
    
    This patch makes do_signal_stop() test whether the task is ptraced and
    use ptrace_stop() if so.  This renders tracehook_notify_jctl() rather
    pointless as the ptrace notification is now handled by ptrace_stop()
    regardless of the return value from the tracehook.  It probably is a
    good idea to update it.
    
    This doesn't solve the whole problem as tasks already in stopped state
    would stay in the regular stop when ptrace attached.  That part will
    be handled by the next patch.
    
    Oleg pointed out that this makes a userland-visible change.  Before,
    SIGCONT would be able to wake up a task in group stop even if the task
    is ptraced if the tracer hasn't issued another ptrace command
    afterwards (as the next ptrace commands transitions the state into
    TASK_TRACED which ignores SIGCONT wakeups).  With this and the next
    patch, SIGCONT may race with the transition into TASK_TRACED and is
    ignored if the tracee already entered TASK_TRACED.
    
    Another userland visible change of this and the next patch is that the
    ptracee's state would now be TASK_TRACED where it used to be
    TASK_STOPPED, which is visible via fs/proc.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Oleg Nesterov <oleg@redhat.com>
    Cc: Roland McGrath <roland@redhat.com>
    Cc: Jan Kratochvil <jan.kratochvil@redhat.com>
    [dannf: backported to Debian's 2.6.32]

diff --git a/kernel/signal.c b/kernel/signal.c
index adc676d..7cc7efe 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -1720,7 +1720,6 @@ void ptrace_notify(int exit_code)
 static int do_signal_stop(int signr)
 {
 	struct signal_struct *sig = current->signal;
-	int notify = 0;
 
 	if (!(current->group_stop & GROUP_STOP_PENDING)) {
 		unsigned int gstop = GROUP_STOP_PENDING | GROUP_STOP_CONSUME;
@@ -1750,29 +1749,37 @@ static int do_signal_stop(int signr)
 			} else
 				task_clear_group_stop_pending(t);
 	}
-	/*
-	 * If there are no other threads in the group, or if there is
-	 * a group stop in progress and we are the last to stop, report
-	 * to the parent.  When ptraced, every thread reports itself.
-	 */
-	if (task_participate_group_stop(current))
-		notify = CLD_STOPPED;
-	if (task_ptrace(current))
-		notify = CLD_STOPPED;
 
 	current->exit_code = sig->group_exit_code;
 	__set_current_state(TASK_STOPPED);
 
-	spin_unlock_irq(&current->sighand->siglock);
+	if (likely(!task_ptrace(current))) {
+		int notify = 0;
 
-	if (notify) {
-		read_lock(&tasklist_lock);
-		do_notify_parent_cldstop(current, notify);
-		read_unlock(&tasklist_lock);
-	}
+		/*
+		 * If there are no other threads in the group, or if there
+		 * is a group stop in progress and we are the last to stop,
+		 * report to the parent.
+		 */
+		if (task_participate_group_stop(current))
+			notify = CLD_STOPPED;
 
-	/* Now we don't run again until woken by SIGCONT or SIGKILL */
-	schedule();
+		spin_unlock_irq(&current->sighand->siglock);
+
+		if (notify) {
+			read_lock(&tasklist_lock);
+			do_notify_parent_cldstop(current, notify);
+			read_unlock(&tasklist_lock);
+		}
+
+		/* Now we don't run again until woken by SIGCONT or SIGKILL */
+		schedule();
+
+		spin_lock_irq(&current->sighand->siglock);
+	} else
+		ptrace_stop(current->exit_code, CLD_STOPPED, 0, NULL);
+
+	spin_unlock_irq(&current->sighand->siglock);
 
 	tracehook_finish_jctl();
 	current->exit_code = 0;
