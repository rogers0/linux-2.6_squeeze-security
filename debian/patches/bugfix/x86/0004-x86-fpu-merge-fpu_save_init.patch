From 826b8d08b8528d2b025021e43c9a5c16713f9b47 Mon Sep 17 00:00:00 2001
From: Brian Gerst <brgerst@gmail.com>
Date: Fri, 3 Sep 2010 21:17:19 -0400
Subject: [PATCH 04/15] x86, fpu: Merge fpu_save_init()

commit b2b57fe053c9cf8b8af5a0e826a465996afed0ff upstream.

Make 64-bit use the 32-bit version of fpu_save_init().  Remove
unused clear_fpu_state().

Signed-off-by: Brian Gerst <brgerst@gmail.com>
Acked-by: Pekka Enberg <penberg@kernel.org>
Cc: Suresh Siddha <suresh.b.siddha@intel.com>
LKML-Reference: <1283563039-3466-13-git-send-email-brgerst@gmail.com>
Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
[bwh: Backported to 2.6.32:
 - We don't have struct fpu
 - The AMD FXSAVE workaround looks a bit different
 - Adjust context]
Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
---
 arch/x86/include/asm/i387.h | 45 +++++----------------------------------------
 1 file changed, 5 insertions(+), 40 deletions(-)

diff --git a/arch/x86/include/asm/i387.h b/arch/x86/include/asm/i387.h
index 6e4bfa9..a404dfe 100644
--- a/arch/x86/include/asm/i387.h
+++ b/arch/x86/include/asm/i387.h
@@ -81,31 +81,6 @@ static inline int fxrstor_checking(struct i387_fxsave_struct *fx)
 	return err;
 }
 
-/* AMD CPUs don't save/restore FDP/FIP/FOP unless an exception
-   is pending. Clear the x87 state here by setting it to fixed
-   values. The kernel data segment can be sometimes 0 and sometimes
-   new user value. Both should be ok.
-   Use the PDA as safe address because it should be already in L1. */
-static inline void clear_fpu_state(struct task_struct *tsk)
-{
-	struct xsave_struct *xstate = &tsk->thread.xstate->xsave;
-	struct i387_fxsave_struct *fx = &tsk->thread.xstate->fxsave;
-
-	/*
-	 * xsave header may indicate the init state of the FP.
-	 */
-	if ((task_thread_info(tsk)->status & TS_XSAVE) &&
-	    !(xstate->xsave_hdr.xstate_bv & XSTATE_FP))
-		return;
-
-	if (unlikely(fx->swd & X87_FSW_ES))
-		asm volatile("fnclex");
-	alternative_input(ASM_NOP8 ASM_NOP2,
-			  "    emms\n"		/* clear stack tags */
-			  "    fildl %%gs:0",	/* load to clear state */
-			  X86_FEATURE_FXSAVE_LEAK);
-}
-
 static inline int fxsave_user(struct i387_fxsave_struct __user *fx)
 {
 	int err;
@@ -157,16 +132,6 @@ static inline void fxsave(struct task_struct *tsk)
 #endif
 }
 
-static inline void fpu_save_init(struct task_struct *tsk)
-{
-	if (task_thread_info(tsk)->status & TS_XSAVE)
-		xsave(tsk);
-	else
-		fxsave(tsk);
-
-	clear_fpu_state(tsk);
-}
-
 #else  /* CONFIG_X86_32 */
 
 #ifdef CONFIG_MATH_EMULATION
@@ -204,6 +169,8 @@ static inline void fxsave(struct task_struct *tsk)
 		     : [fx] "=m" (tsk->thread.xstate->fxsave));
 }
 
+#endif	/* CONFIG_X86_64 */
+
 /* We need a safe address that is cheap to find and that is already
    in L1 during context switch. The best choices are unfortunately
    different for UP and SMP */
@@ -224,7 +191,7 @@ static inline void fpu_save_init(struct task_struct *tsk)
 		/*
 		 * xsave header may indicate the init state of the FP.
 		 */
-		if (!(tsk->thread.xstate.xsave.xsave_hdr.xstate_bv & XSTATE_FP))
+		if (!(tsk->thread.xstate->xsave.xsave_hdr.xstate_bv & XSTATE_FP))
 			return;
 	} else if (use_fxsr()) {
 		fxsave(tsk);
@@ -234,7 +201,7 @@ static inline void fpu_save_init(struct task_struct *tsk)
 		return;
 	}
 
-	if (unlikely(tsk->thread.xstate.fxsave->swd & X87_FSW_ES))
+	if (unlikely(tsk->thread.xstate->fxsave.swd & X87_FSW_ES))
 		asm volatile("fnclex");
 
 	/* AMD K7/K8 CPUs don't save/restore FDP/FIP/FOP unless an exception
@@ -244,13 +211,11 @@ static inline void fpu_save_init(struct task_struct *tsk)
 		asm volatile(
 			"fnclex\n\t"
 			"emms\n\t"
-			"fildl %[addr]"        /* set F?P to defined value */
+			"fildl %P[addr]"        /* set F?P to defined value */
 			: : [addr] "m" (safe_address));
 	}
 }
 
-#endif	/* CONFIG_X86_64 */
-
 static inline void __save_init_fpu(struct task_struct *tsk)
 {
 	fpu_save_init(tsk);
