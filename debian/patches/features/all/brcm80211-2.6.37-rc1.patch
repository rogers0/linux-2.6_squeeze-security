commit 45f4d0243525b6bc747c946937ced437b135a84d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Oct 30 11:06:57 2010 +0200

    staging: Final semaphore cleanup
    
    Fixup the last remaining users of DECLARE_MUTEX and init_MUTEX.
    
    Scripted conversion, resulting code is binary equivalent.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    LKML-Reference: <20100907125057.278833764@linutronix.de>

commit 5af634789c93b97cfb314a102436716be8fbc577
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 28 09:55:53 2010 -0700

    Staging: brcm80211: fix usage of roundup in structures
    
    Now that the roundup macro is sane, it can't be used in structure
    definitions, or the build breaks..  For now, create a "broken_roundup()"
    macro to get everything building again, but in the end, fixing these
    structures to use a proper size value is the correct thing to do.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a4ac0d847af9dd34d5953a5e264400326144b6b2
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Thu Oct 21 11:37:53 2010 -0700

    staging: brcm80211: brcmfmac: Removed codeversion from firmware filenames.
    
    The basename-apiversion-codeversion construction for firmware filenames is not
    used by most other firmware files, adds complexity, and is not providing any
    value.  Rename the firmware files using just basename-apiversion.
    
    Users of the brcmfmac driver will need to update the linux-firmware package
    to get the renamed files, or manually rename their installed firmware files.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 0a00bc2019ea54875b7263b1b0340c556379708a
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Thu Oct 21 11:04:12 2010 -0700

    staging: brcm80211: Remove unnecessary header files.
    
    These header files are no longer needed.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 30e4352349623fbe02d2709e96bc3d2a93aafbab
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Thu Oct 21 11:04:11 2010 -0700

    staging: brcm80211: Remove unnecessary includes from bcmutils.c
    
    Removed includ of bcmip.h and vlan.h, as they're no longer needed.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ab3275a6b57cd42d25dc1f32123ac5d1fb438984
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Thu Oct 21 11:04:10 2010 -0700

    staging: brcm80211: Removed unnecessary pktsetprio() function.
    
    This function is completely unnecessary, as packet classification is done
    higher up in the stack.  As used, the function actually mis-classifies frames
    in some cases since it overwrites the classification done by the stack.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a1c16ed2664205dd69c0ea0ec6945f7f10d3edf9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 21 11:17:44 2010 -0700

    Staging: brcm80211: remove typedefs.h
    
    It's not needed anymore, so remove it and clean up the .h inclusion mess
    a bit to get everything to build properly again.
    
    Wow, this needs some unwinding...
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit f024c48a77c3c20d99de8f3424e8d3a061896885
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 21 10:50:21 2010 -0700

    Staging: brcm80211: remove uintptr typedef usage
    
    Use a unsigned long, that is the proper type for this type of thing on
    Linux.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit cd389a34a182639e8b6bf0e812fe8ec038bfddc5
Author: nohee ko <noheek@broadcom.com>
Date:   Sun Oct 17 10:51:24 2010 -0700

    staging: brcm80211: brcmfmac: add debugfs, display wi-fi statistics
    
    Add debugfs to display wi-fi profile/statistics.
    Initially some profile parameters such as dtim_period,
    beacon_int will be seen at
    /sys/kernel/debug/ieee80211/phy#/netdev:eth#.
    This will provide users with current connection status.
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 1e0645c3236b8ae44d10abb6a1304784359a3ea8
Author: nohee ko <noheek@broadcom.com>
Date:   Sun Oct 17 10:42:18 2010 -0700

    staging: brcm80211: brcmfmac: add profile, beacon_int, dtim_period
    
    Add profile, beacon_int & dtim_period.
    This profile can be seen through debugfs.
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit c5ca038fa5ff48f9b7019b57800ff16857778ef6
Author: nohee ko <noheek@broadcom.com>
Date:   Sun Oct 17 10:38:35 2010 -0700

    staging: brcm80211: brcmfmac: enable passive, active scan selection
    
    Enable passive, active scan selection.
    Previously it did active scan and reported
    probe response result regardless of active_scan
    flag
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit f49200c36738a315eb094a3ed8260f00d1bafee0
Author: nohee ko <noheek@broadcom.com>
Date:   Sun Oct 17 10:33:19 2010 -0700

    staging: brcm80211: brcmfmac: remove unnecessary cflags, WL_ISCAN_DISABLED & WL_ROAM_DISABLED
    
    Remove unnecessary cflags, WL_ISCAN_DISABLED
    and WL_ROAM_DISABLED. Iscan is ON and Roam by FW
    is OFF by default.
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit da6830ac3969c9480e05ed2b21eee64e21a101d2
Author: mike.rapoport@gmail.com <mike.rapoport@gmail.com>
Date:   Wed Oct 13 00:09:13 2010 +0200

    staging: brcm80211: remove unrefrenced malloced field
    
    from 'struct osl_info' structure
    
    Signed-off-by: Mike Rapoport <mike.rapoport@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 182acb3ca59ba2d31485f7225177c069cebdc161
Author: mike.rapoport@gmail.com <mike.rapoport@gmail.com>
Date:   Wed Oct 13 00:09:12 2010 +0200

    staging: brcm80211: replace MFREE with kfree
    
    Signed-off-by: Mike Rapoport <mike.rapoport@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 199d217c52dcc961dfd5928e5cbc32cc8a9140d9
Author: mike.rapoport@gmail.com <mike.rapoport@gmail.com>
Date:   Wed Oct 13 00:09:11 2010 +0200

    staging: brcm80211: remove unused NATIVE_{MALLOC,MFREE}
    
    Signed-off-by: Mike Rapoport <mike.rapoport@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 5fcc1fcb2ec18094b3a8022b1974c0b2e9f5f73c
Author: mike.rapoport@gmail.com <mike.rapoport@gmail.com>
Date:   Wed Oct 13 00:09:10 2010 +0200

    staging: brcm80211: replace MALLOC() with k[zm]alloc
    
    Signed-off-by: Mike Rapoport <mike.rapoport@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 97e17d0e7bb861c197e50433325bf2f5f9871f90
Author: mike.rapoport@gmail.com <mike.rapoport@gmail.com>
Date:   Wed Oct 13 00:09:09 2010 +0200

    staging: brcm80211: remove osl_malloced()/MALLOCED()
    
    because there are other means to track memory leaks in kernel
    
    Signed-off-by: Mike Rapoport <mike.rapoport@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 6a92fdf1b923fa5b6d6dd08a7bba80fb3d9e5eaf
Author: mike.rapoport@gmail.com <mike.rapoport@gmail.com>
Date:   Wed Oct 13 00:09:08 2010 +0200

    staging: brcm80211: remove DHD_USE_STATIC_BUF
    
    The DHD_USE_STATIC_BUF cannot be enabled in the build configuration,
    remove it.
    
    Signed-off-by: Mike Rapoport <mike.rapoport@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 6ddcfdcf919463469496132731671ebb5f9908e9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 14 12:26:08 2010 -0700

    Staging: brcm80211: fix up compiler warnings I created
    
    I messed up on some of the uintptr conversions, this fixes them up
    properly.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 7383141b0334c0ff670c5c8c3e5f5540229e4ac6
Author: mike.rapoport@gmail.com <mike.rapoport@gmail.com>
Date:   Wed Oct 13 00:09:07 2010 +0200

    staging: brcm80211: remove OSL_DELAY
    
    and use udelay and mdelay instead
    
    Signed-off-by: Mike Rapoport <mike.rapoport@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 5dc56c9f4c91caa58f4be6603cca4623610c4ad5
Author: nohee ko <noheek@broadcom.com>
Date:   Wed Oct 13 14:26:52 2010 -0700

    staging: brcm80211: brcmfmac: bug fix - scan result report
    
    Scan result was reported with some duplicated information.
    Those were about SSID/ rate. With this patch, the duplication
    can be erased.
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 7356f429d24e7ad97c0dec77b0777d5892c7657d
Author: nohee ko <noheek@broadcom.com>
Date:   Wed Oct 13 14:24:25 2010 -0700

    staging: brcm80211: brcmfmac: replace KILL_PROC with send_sig()
    
    logic optimization : replace KILL_PROC with send_sig()
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 4c71ebf4da809dd1379bbadfbc2683b77ecd932f
Author: Brett Rudley <brudley@broadcom.com>
Date:   Tue Oct 12 15:01:58 2010 -0700

    staging: brcm80211: Purge unused bcmwpa.[ch]
    
    Move two macros into wlc_mac80211.h and purge the rest.
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit af73713642c1c02e5afefb0f807f406e835c0b7f
Author: nohee ko <noheek@broadcom.com>
Date:   Tue Oct 12 13:33:29 2010 -0700

    staging: brcm80211: bug fix- rmmod hang problem
    
    Bug fix - rmmod hang problem.
    Can keep both of kthread & down_interruptible.
    And in the meantime, can terminate the threads
    properly during rmmod process.
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit c11b0ef8fe171f0b50999d61e401e4908980a774
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 12 14:04:26 2010 -0700

    Staging: brcm80211: remove sbpciregs_t typedef
    
    don't use a typedef, use a 'struct'.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 3c2c926823305139ef7867dcffa76b3a505a3b02
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 12 13:20:38 2010 -0700

    Staging: brcm80211: util: remove unneeded use of uintptr
    
    uintptr shouldn't be used when you are just casting to a pointer anyway,
    so remove it from these usages.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit e88cf8eb62536661d9fae0158e9713c5e4ddc405
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 12 13:20:19 2010 -0700

    Staging: brcm80211: sys: remove unneeded use of uintptr
    
    uintptr shouldn't be used when you are just casting to a pointer anyway,
    so remove it from these usages.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 159a3b78f95eaf52d129833a45f95ca9eeaa77a7
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 12 13:20:00 2010 -0700

    Staging: brcm80211: phy: remove unneeded use of uintptr
    
    uintptr shouldn't be used when you are just casting to a pointer anyway,
    so remove it from these usages.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 3acf41c5c9c538d22046b5f9822d58c9981e53da
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 12 13:18:17 2010 -0700

    Staging: brcm80211: include: remove unneeded use of uintptr
    
    uintptr shouldn't be used when you are just casting to a pointer anyway,
    so remove it from these usages.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ec1284e104f9a598474cb7979c01633b5d1d550b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 12 13:04:58 2010 -0700

    Staging: brcm80211: bcmsdpcm: remove a bunch of unused macros
    
    These direct memory reading macros are not being used, so remove them.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 0965ae88aff802ff48fa2f35fff29feff2754962
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 12 12:50:15 2010 -0700

    Staging: brcm80211: remove FALSE #define
    
    use the kernel provided 'false' value instead, especially
    as we are using a 'bool' for these variables.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 0f0881b09078fe3a6bc70f05e8ba49a52b2478a2
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 12 12:15:18 2010 -0700

    Staging: brcm80211: remove TRUE #define
    
    use the kernel provided 'true' value instead, especially
    as we are using a 'bool' for these variables.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ba07d0cbc919613ce48acc0a43d6e8ab35cd7748
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Mon Oct 11 16:58:33 2010 +0300

    staging: brcm80211: remove useless bcm_ether_ntoa()
    
    Since we have '%pM' modifier in the kernel's *printf() we don't need to
    convert address to the string beforehand.
    
    Signed-off-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: linux-wireless@vger.kernel.org
    Cc: devel@driverdev.osuosl.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 88b3eaa499ddbe5a36c34840117563bd54ec4ec2
Author: nohee ko <noheek@broadcom.com>
Date:   Mon Oct 11 18:33:45 2010 -0700

    staging: brcm80211: remove duplicated function, wf_channel2mhz
    
    remove duplicated function, wf_channel2mhz
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a9d0fffa934900246ac646fc7b6a4cf9ce1edec2
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Mon Oct 11 10:03:00 2010 -0400

    staging: brcm80211: remove BCMNMIATTACHFN() macro.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 9927fc2eab153cf3c39d505733b1d534d818c2bb
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Mon Oct 11 10:02:59 2010 -0400

    staging: brcm80211: remove BCMUNINITFN() macro.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit b4f790eeb36564c7e4a5b38712f23ebc2b64b45a
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Mon Oct 11 10:02:58 2010 -0400

    staging: brcm80211: remove BCMINITFN() macro.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 2184ccb9f7069a03e0b51f68216ab61cec54b3f6
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Mon Oct 11 10:02:57 2010 -0400

    staging: brcm80211: remove BCMINITDATA() macro.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit eeb8e46b50e33010805a27590f17e008bbd2a339
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Mon Oct 11 10:02:56 2010 -0400

    staging: brcm80211: fix various checkpatch errors.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 94dc5e778042daea25f2198884e2eb8f3bd350ed
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Mon Oct 11 10:02:55 2010 -0400

    staging: brcm80211: s/unsigned char/size_t/ for min_t()
    
    Avoid potential truncation.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit d5642d3ba7b6609e93a688bb39bd5883a270e41f
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Mon Oct 11 12:07:35 2010 +0300

    staging: brcm80211: remove custom string library again
    
    There was a clean up commit for softmac driver. Do the same for fullmac
    implementation.
    
    Here:
     - strtoul and bcm_strtoul are changed to simple_strtoul
     - bcmstrtok -> strsep
    
    All unused functions are deleted.
    
    Signed-off-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 41c7f4167e1312dacfc514d8610dbaaa14cfaea5
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Mon Oct 11 12:07:34 2010 +0300

    staging: brcm80211: clean up custom ctype library again
    
    The similar cleanup was done before for softmac implementation.  But the
    fullmac driver brings this back. Remove it again.
    
    Signed-off-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 53e974db655da7df6f1ac5db8da94cbeb288ab35
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Sun Oct 10 14:07:09 2010 -0400

    staging: brcm80211: fix 'comparison..cast' compiler warnings.
    
    Use min_t() macro instead of min().
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a6cf450e02c0a6a7178e2f8fb9d56bfd829e012b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sun Oct 10 05:52:59 2010 -0700

    Staging: brcm80211: remove __cplusplus markers
    
    It's not needed within the kernel, so remove them.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 22b564b0b6909664bd7adac2fa9f3f0abc46457a
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Sat Oct 9 14:51:15 2010 -0400

    staging: brcm80211: remove BLOCKABLE so no one uses it.
    
    BLOCKABLE() doesn't do what it's supposed to.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 7716314bf9b9767eb1a69a16c68d05f17bc34588
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Sat Oct 9 14:51:14 2010 -0400

    staging: brcm80211: remove kernel_thread() for wl_iscan_thread and wl_event_thread.
    
    Replace kernel_thread() with kthread_run().  Replace pid with tsk,
    and exited with kthread_stop()/kthread_should_stop().
    
    event_tsk, and tsk are NULL when their respective threads are not running.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 5e2773ea93c9084f825ae1954c224ac5863a1acc
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Sat Oct 9 14:51:13 2010 -0400

    staging: brcm80211: remove kernel_thread() for _iscan_sysioc_thread.
    
    Replace kernel_thread() with kthread_run, kthread_stop() and
    kthread_should_stop().  Remove sysioc_pid, sysioc_exit, and DAEMONIZE.
    
    sysioc_tsk is NULL when not running.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit d809dcb9df1766cd4f45dc17cced4857dace4dc2
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Sat Oct 9 14:51:12 2010 -0400

    staging: brcm80211: remove kernel_thread() for _dhd_sysioc_thread.
    
    Replaced kernel_thread() with kthread_run(), kthread_stop(), and
    kthread_should_stop().  Also removed all references to sysioc_pid and
    sysioc_exit.  DAEMONIZE removed because not used in dhd_linux.c.
    
    sysioc_tsk is NULL when not running.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ecd7559d8d0d8daf329016b4db0686376fb5dada
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Sat Oct 9 14:51:11 2010 -0400

    staging: brcm80211: remove kernel_thread() for dhd_dpc_thread.
    
    use kthread_run(), kthread_stop(), and kthread_should_stop().  Removes
    dpc_pid, dpc_exited, and the call to DAEMONIZE.
    
    dpc_tsk is NULL when not running.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 860708d9c8259e087f39505995d4d54b2e499fb9
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Sat Oct 9 14:51:10 2010 -0400

    staging: brcm80211: remove kernel_thread() for dhd_watchdog_thread.
    
    Replaced kernel_thread() with kthread_run().  Used kthread_should_stop()
    in place of watchdog_exited completion.  Replaced watchdog_pid with
    struct task_struct.
    
    watchdog_tsk is NULL when the task is not running.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 839fad996bf0eba85c0c6aa67ba8d89d051b6749
Author: nohee ko <noheek@broadcom.com>
Date:   Sat Oct 9 10:41:05 2010 -0700

    staging: brcm80211: remove unnecessary cflag, LINUX
    
    remove unnecessary cflag, LINUX
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 1e8dd5b9b30ed73889a450ca9903c706c17c1e78
Author: nohee ko <noheek@broadcom.com>
Date:   Sat Oct 9 10:39:49 2010 -0700

    staging: brcm80211: remove unnecessary cflag, CONFIG_CFG80211
    
    remove unnecessary cflag, CONFIG_CFG80211
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 5e33a02ff7cb2898abbdd78fcdc21d02f4b1522c
Author: nohee ko <noheek@broadcom.com>
Date:   Sat Oct 9 10:38:21 2010 -0700

    staging: brcm80211: remove unnecessary cflag, BCMWPA2
    
    remove unnecessary cflag, BCMWPA2.
    BCMDRIVER is already not used.
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ea3b8a2810c445e2fc1bdfee53c1fb93f1b28988
Author: nohee ko <noheek@broadcom.com>
Date:   Sat Oct 9 10:34:38 2010 -0700

    staging: brcm80211: remove duplicated file, bcmutils.c
    
    Remove duplicated file, bcmutils.c under brcm80211/brcmfmac.
    brcm80211/util/bcmutils.c will be shared between softmac
    & fullmac. Makefile, and some other files are also modified
    accordingly
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit cbf6baac775f2e3fb61f88dcaa71e44fb34b6906
Author: Dan Carpenter <error27@gmail.com>
Date:   Sat Oct 9 13:54:06 2010 +0200

    Staging: brcm80211: make interface name buffer smaller
    
    In the original code the interface name was IFNAMSIZ + 1, but that
    caused problems in dhd_ifname2idx() which does:
    	strncmp(dhd->iflist[i]->name, name, IFNAMSIZ)
    
    The wl_event_msg_t struct can only store 16 character names as well.
    
    And thirdly there is a potential buffer overflow in dhd_op_if() because
    if->net->name is IFNAMSIZ and we do:
    	strcpy(ifp->net->name, ifp->name);
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit edae01b94a846b39664420fe0c7561a594bb50a2
Author: Brett Rudley <brudley@broadcom.com>
Date:   Fri Oct 8 15:56:50 2010 -0700

    staging: brcm80211: Purge unused wlc_id_name
    
    Purge unused wlc_id_name_entry
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a9a6073c51ddc4f562b1918ded7e27830e0d9d9f
Author: Brett Rudley <brudley@broadcom.com>
Date:   Fri Oct 8 17:35:02 2010 -0700

    staging: brcm80211: Purge unused packet engine
    
    We're not using the packet engine anymore - goodbye.
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit fb693a712cce5a52bec5d5769b17c2ca93662c61
Author: nohee ko <noheek@broadcom.com>
Date:   Fri Oct 8 18:44:29 2010 -0700

    staging: brcm80211: bug fix- dual band problem
    
    Bug fix for dual band problem. In particular it had an issue
    to connect to 5G band AP.
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 40e5c96b229928b28edd99cdb981ff5e74938d19
Author: Brett Rudley <brudley@broadcom.com>
Date:   Fri Oct 8 13:57:13 2010 -0700

    staging: brcm80211: Coalesce osl_dma_alloc_consistent between fullmac and softmac
    
    Combine dma_alloc routine for full and softmac
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 17b313857dde17c2a122f7a763da335c6378ba1d
Author: Brett Rudley <brudley@broadcom.com>
Date:   Fri Oct 8 13:55:20 2010 -0700

    staging: brcm80211: Purge unused memlist debugging
    
    Purge unused memlist debugging
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 0d2f0724a4b3a5d1631c39b1bbe7c78c4a15a7ac
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 14:28:21 2010 -0700

    Staging: brcm80211: remove BCMATTACHFN macro
    
    It's not doing anything and is a bit silly.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 17c4da1ecfc18ac07c14a7060b1a3841e385ad5a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 14:11:20 2010 -0700

    Staging: brcm80211: remove BCMATTACHDATA macro
    
    It's not even used for anything, not to mention, it is pretty silly.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit b61640d1acba9e2405c4887717fd00286f70c395
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 12:37:39 2010 -0700

    Staging: brcm80211: brcmfmac: fix some comparison warnings
    
    Use min_t() instead of min() in some places to make the
    comparison explicit and resolve some compiler warnings.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a300ce95e49fe079d4ca77370c23ce75db176218
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 12:28:02 2010 -0700

    Staging: brcm80211: sys: fix some comparison warnings
    
    Use min_t() instead of min() in some places to make the
    comparison explicit and resolve some compiler warnings.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 697d600d8fa9d383626041a8dde86555fb758b76
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 12:25:23 2010 -0700

    Staging: brcm80211: sys: wlc_ampdu: fix some comparison warnings
    
    Use min_t() instead of min() in some places to make the comparison
    explicit and resolve some compiler warnings.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit e9e6727fcc6ef9aee763eaa35cc980f5b3a2a68c
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 12:16:08 2010 -0700

    Staging: brcm80211: phy: wlc_phy_n: fix some comparison warnings
    
    Use min_t() instead of min() in some places to make the comparison
    explicit and resolve some compiler warnings.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.d

commit c09cc58692f8a6ae341e955c5712884f920b84ab
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 12:07:33 2010 -0700

    Staging: brcm80211: hnddma.c: fix compiler warning
    
    Change the field types of dma_info_t to make comparing values easier
    (and correct.)  No need to keep rxbufsize as a u16, it can be an
    unsigned int to make things easier.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 96e76e694101c2b09c997bce5f064df0d051b729
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 12:01:30 2010 -0700

    Staging: brcm80211: remove VALID_MASK macro
    
    No one is using it.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit e18d5313c680e5bb8cbdc0dce8f8698c2ab20663
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 11:59:06 2010 -0700

    Staging: brcm80211: remove ROUNDUP macro
    
    And use the kernel provided 'roundup' instead.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 36c63ff6afb1bdc2d93aac6d207d6529177d47f8
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 11:55:40 2010 -0700

    Staging: brcm80211: remove ISALIGNED macro
    
    And use the kernel provided IS_ALIGNED one instead.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit d2733c97faf94ae22f214f3cfb288da3366e6ad5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 11:52:16 2010 -0700

    Staging: brcm80211: remove unused ALIGN_ADDR() macro
    
    It's not used (and there's a kernel provided one if it's ever needed in
    the future), so remove it.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 8d3d6a6945df5c78c7f7882dabdb5638b05b2f5c
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 11:47:11 2010 -0700

    Staging: brcm80211: remove ARRAYSIZE macro
    
    Use the real 'ARRAY_SIZE' definition instead.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ce0f1b8cd1526e800b8f3c1e978ac7c23ed91e2f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 11:44:45 2010 -0700

    Staging: brcm80211: remove OFFSETOF macro
    
    Use the real 'offsetof' definition instead.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 3ea2f4d640479a40847e311282ee73695b6e82cf
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 11:39:43 2010 -0700

    Staging: brcm80211: remove broken MAX() implementation
    
    Use the kernel-provided version, this one is broken.
    
    Note, there are more compiler warnings now, that's due to different
    types being compared, which shows how the original macro was wrong in at
    least one way.  They need to be fixed up.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 7068c2f13983a39a49981891c47c74efb5fb60c7
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 11:34:59 2010 -0700

    Staging: brcm80211: remove broken MIN() implementation
    
    Use the kernel-provided version, this one is broken.
    
    Note, there are more compiler warnings now, that's due to different
    types being compared, which shows how the original macro was wrong in at
    least one way.  They need to be fixed up.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit c03b63c1987f06590ad944ffe7179444909e0285
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 11:20:01 2010 -0700

    Staging: brcm80211: util: remove unneeded usage of uintptr
    
    Double casting is pretty pointless, don't do that.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit f1d0fe0abc2c7643dee6df5ed473d3f1b0e15a97
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 11:13:11 2010 -0700

    Staging: brcm80211: remove unused typedefs in typedefs.h
    
    uint is already defined somewhere else, so just remove this version
    of it.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 3e26416e2f7fc2781c084c4ea51227aef30336de
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 11:11:13 2010 -0700

    Staging: brcm80211: s/int32/s32/
    
    Use the kernel types, don't invent your own.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 66cbd3ab35d35580ddf98304c280a6231685aa41
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 11:05:47 2010 -0700

    Staging: brcm80211: s/uint32/u32/
    
    Use the kernel types, don't invent your own.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 588abaa64b76005f6ab1a7d40770dcef12fd00ad
Author: Brett Rudley <brudley@broadcom.com>
Date:   Thu Oct 7 20:31:46 2010 -0700

    staging: brcm80211: Use proper BRCM_FULLMAC #ifdefs
    
    Make it obvious that DHD_USE_STATIC_BUF is only used as part of FULLMAC build
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 1e3950b8483a1805bd6e6e5ce8749cdafe04ae35
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Thu Oct 7 19:52:11 2010 -0700

    staging: brcm80211: Remove dead code from siutils.c
    
    Removed lots of unused functions from siutils.c
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 51c5651da4bf37f0cbb488d9c6f9044da659c367
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Thu Oct 7 19:52:10 2010 -0700

    staging: brcm80211: Remove dead code from bcmwifi.c
    
    Removed unused functions wf_chspec_ntoa() and wf_chspec_aton().
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 4ca70f7fcbf9a4cd44c52f582ef4cfb678f3f560
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Thu Oct 7 19:52:09 2010 -0700

    staging: brcm80211: Remove dead code from linux_osl.c.
    
    Removed several completely unused functions:
    	osl_malloc_failed
    	osl_pcmcia_attr
    	osl_pcmcia_read_attr
    	osl_pcmcia_write_attr
    	osl_pktdup
    and related macros
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 45fa9a90a696c0123dd9258d6d520029a1f3f9bf
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Thu Oct 7 19:52:08 2010 -0700

    staging: brcm80211: Remove unnecessary hndtcam.h
    
    The header file is unnecessary.  Delete it and don't include it.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 64cb45addaf7f193dfa6396c8e6f5cf1293312c1
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Thu Oct 7 19:52:07 2010 -0700

    staging: brcm80211: Remove unnecessary bitfuncs.h
    
    This header file is no longer included anywhere.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit b2324267a6e96d6513d4ec7799c251b5aae5f4c0
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Thu Oct 7 19:52:06 2010 -0700

    staging: brcm80211: Don't include bitfuncs.h
    
    Remove include of bitfuncs.h, as it's completely uncessary for these files.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit d953a05d04b17b43f3bf4a183131e5c5e223ecaa
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Thu Oct 7 19:52:05 2010 -0700

    staging: brcm80211: Use linux/bitops.h instead of bitfuncs.h
    
    Use ffs() from linux/bitops.h, instead of the locally defined find_msbit().
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 86566325d398409637fe920181306d43f5980541
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Thu Oct 7 19:52:04 2010 -0700

    staging: brcm80211: Remove dead code from aiutils.c
    
    Removed unused function ai_view().
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit e59fe083f683ca2ca56abefad290d110808a6fb5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 7 17:08:21 2010 -0700

    Staging: brcm80211: s/int16/s16/
    
    Use the kernel types, don't invent your own.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 7d4df48eba4cea654ee6fe6e1a51a0600807ed7b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 7 17:04:47 2010 -0700

    Staging: brcm80211: s/uint16/u16/
    
    Use the kernel types, don't invent your own.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 4128dd9afb986321edf0baa8a3aaa3c7c5aa3730
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 7 16:41:32 2010 -0700

    Staging: brcm80211: remove forgotten undef
    
    I forgot to remove the float undefs in typedef.h from previous patches,
    this fixes this issue.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 11465f6a7d43f3584fa6ee4a619a25d944c7af8d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 7 16:38:43 2010 -0700

    Staging: brcm80211: wl_cfg80211.c: fix compiler warnings
    
    size_t should be '%zd' in a printf, not '%d'
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 1a3bf7471e8acaab0e66a6304212218025fe1ec2
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 7 16:34:51 2010 -0700

    Staging: brcm80211: remove some more macros from linuxver.h
    
    These aren't needed anymore, and now we are down to just one broken one,
    and a whole bunch of #include files here.  This can be further factored
    by moving the proper #includes into the different .c files, and not
    leaving them in this one large one.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit f149e6f1daf34c284485254fa020bdd6d6838a2d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 7 16:30:25 2010 -0700

    Staging: brcm80211: remove unused irq typedef
    
    If it's not needed, why define it?
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 878a667394501e03cd27b393b87cf472fa74122c
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 7 16:28:15 2010 -0700

    Staging: brcm80211: remove unneeded pm macro
    
    Use the real type, not a macro.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 624573d0d480a003c9ba042f524f311aef2e7c5f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 7 16:25:58 2010 -0700

    Staging: brcm80211: remove some unused macros
    
    These are all defined by the core kernel, use those versions
    instead of just creating noops.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 8ba9cfdbfc0fe3e84d150d66737210a34846e8a7
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 7 16:23:24 2010 -0700

    Staging: brcm80211: remove unneeded pci macros
    
    These wrapper macros aren't needed, remove them.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 517b12f2a0d9f9e6de680b30242ec6432d2af7f7
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 7 16:20:43 2010 -0700

    Staging: brcm80211: remove free_netdev wrapper
    
    It's incorrect, call the real function.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit c62add38420029de50d1e4c16795211d748dd08b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 7 16:19:11 2010 -0700

    Staging: brcm80211: remove old module macro wrappers
    
    they weren't doing anything, so get rid of them.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 364eb72a3965ddf3291be74562081b1c19813473
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 7 16:11:01 2010 -0700

    Staging: brcm80211: remove MY_INIT_WORK macro
    
    Use the real macro instead.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 960ea740a2c4f2da42fee2cdf7201ea6c477486c
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Wed Oct 6 17:40:06 2010 -0400

    staging: brcm80211: remove ';' after while() in macros.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 76c06459189fdc643165c58ed7b2f3c590eecbb2
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Wed Oct 6 17:40:05 2010 -0400

    staging: brcm80211: wl_cfg80211.c: fix 'assignment in if condition'
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit b3164c71e27e58ef1c0b679e816d643cc1a1553e
Author: nohee ko <noheek@broadcom.com>
Date:   Wed Oct 6 11:07:13 2010 -0700

    staging: brcm80211: bug fix - connection status report
    
    Added connection status report for the case connection fails.
    Originally this logic was missing.
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 194c60720dd96039ba46743743c4d8bc52d56364
Author: nohee ko <noheek@broadcom.com>
Date:   Wed Oct 6 11:56:28 2010 -0700

    staging: brcm80211: removed duplicated file, linux_osl.c
    
    Removed duplicated file, linux_osl.c from brcmfmac.
    linux_osl.c under brcm80211/util/ will be shared
    between softmac & fullmac drivers
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 5a505da957fc2f42ce53e5b0234cdf493f4f3ab0
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Wed Oct 6 10:08:03 2010 -0400

    staging: brcm80211: fix checkpatch macro errors.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit e9887c9d9c37b8af80ae04aad1532d5c46687f8b
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Wed Oct 6 10:08:02 2010 -0400

    staging: brcm80211: fix various checkpatch spacing errors.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 5f782dee8d58247f2a277f142a59c227fd0b500e
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Wed Oct 6 10:08:01 2010 -0400

    staging: brcm80211: fix 'do not init statics to 0 or NULL'
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 6998d33795b921c6c62dde5a0820242da40e3020
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Wed Oct 6 10:08:00 2010 -0400

    staging: brcm80211: fix 'do not init globals to 0 or NULL'
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 81e95f9d4ef8e51195568d44d45b3c98ce8bd271
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Wed Oct 6 10:07:59 2010 -0400

    staging: brcm80211: brcmfmac/*: fix remaining 'assignment in if condition'
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit d11a5c6e683a76a1439b323194921c19e255ceac
Author: nohee ko <noheek@broadcom.com>
Date:   Tue Oct 5 19:08:36 2010 -0700

    staging: brcm80211: remove duplicated file, bcmwifi.c
    
    Remove duplicated file, bcmwifi.c from brcmfmac.
    bcmwifi.c under brcm80211/util/ will be shared
    between softmac & fullmac drivers
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 93ad12cf1a8c3be46d66581a7acaa1c7fce590e2
Author: nohee ko <noheek@broadcom.com>
Date:   Tue Oct 5 18:05:04 2010 -0700

    staging: brcm80211: bug fix for n_ssids usage and update drv_info
    
    -update drv_info so it's visible in "ethtool -i" output
    -remove n_ssids usage. Fixes nullptr deref bug seen before.
    
    Signed-off-by: Grant Grundler <grundler@chromium.org>
    Acked-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 52b0e80e72ab7535896d0af72c720b22ad46a421
Author: Brett Rudley <brudley@broadcom.com>
Date:   Tue Oct 5 16:49:47 2010 -0700

    staging: brcm80211: bcmutils.[ch]: purge unused funcs
    
    Get rid of unused functions in bcmutils.[ch]. Note that bcmutils.h is shared between
    fullmac and softmac
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 5b5a285c7bab3851aa428a2ead14106a3f949788
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 11:28:57 2010 -0700

    Staging: brcm80211: bcmdefs.h: remove unused #defines
    
    There were a number of unused and unneeded defines in here, remove them.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 648a79b994b41a1056886976735ff4b9bbb6ea2c
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 11:20:34 2010 -0700

    Staging: brcm80211: remove STATIC definition
    
    Use 'static', it's the correct thing to do.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit df8501c96cf35eac586cce81c5547060ef22f624
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 11:18:31 2010 -0700

    Staging: brcm80211: remove CONST definition
    
    Use 'const', it's the correct thing to do.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 3deea9049e161965fe3caa2ae1f5f0bc96643465
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 11:15:47 2010 -0700

    Staging: brcm80211: s/ulong/unsigned long/
    
    This changes the usage everywhere in the driver, and removes
    the definition as it should no longer be used anywhere.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit d7e508880b8f674aa82d3d5d9b2de27c034329a3
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 11:11:46 2010 -0700

    Staging: brcm80211: s/ushort/unsigned short/
    
    This changes the usage everywhere in the driver, and removes
    the definition as it should no longer be used anywhere.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 580a0bd9b71d8e4e63e0720e64f339c740448c98
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 11:09:48 2010 -0700

    Staging: brcm80211: s/uchar/unsigned char/
    
    This changes the usage everywhere in the driver, and removes
    the definition as it should no longer be used anywhere.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 562c8850786d8d1a9e3f9f076deb581962c594ab
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 11:04:17 2010 -0700

    Staging: brcm80211: s/int8/s8/
    
    This changes the usage everywhere in the driver, and removes
    the definition as it should no longer be used anywhere.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 3bc4d4922ac80f551c6f314dab101c828fc492b4
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 10:25:05 2010 -0700

    Staging: brcm80211: typedefs.h: remove uint8 definition
    
    It's no longer needed anywhere, so remove it.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit de9bca6377e18d3a41cc19d5b2ef118934702b33
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 10:23:40 2010 -0700

    Staging: brcm80211: include: s/uint8/u8/
    
    Replace uint8 with u8, the correct kernel type to be using here.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit e868ab037f86a0143e9dd6d20e32e34ce9454040
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 10:14:26 2010 -0700

    Staging: brcm80211: phy: s/uint8/u8/
    
    Replace uint8 with u8, the correct kernel type to be using here.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 3fd79f7c0b69d100c376ad116733cdb655bb2cf1
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 10:11:12 2010 -0700

    Staging: brcm80211: brcmfmac: s/uint8/u8/
    
    Replace uint8 with u8, the correct kernel type to be using here.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 41feb5ede1994e2c851f65dec82790544ed364fd
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 10:09:00 2010 -0700

    Staging: brcm80211: sys: s/uint8/u8/
    
    Replace uint8 with u8, the correct kernel type to be using here.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 36ef9a1e983e39c5f5929ce9660b7e01706fceec
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 10:02:49 2010 -0700

    Staging: brcm80211: util: s/uint8/u8/
    
    Replace uint8 with u8, the correct kernel type to be using here.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 42e5386d1c363be058ea4186351bef721539b592
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 09:58:02 2010 -0700

    Staging: brcm80211: typedefs.h: remove NULL definition
    
    No need for a driver to define NULL, the core kernel handles that.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 151da5a562b9ddbe57dcbd24cb3d855faf843516
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 09:56:50 2010 -0700

    Staging: brcm80211: remove unit64 and int64 typedefs
    
    They are not used anywhere, nor should they be defined.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 7848789cbf006127bde475b15b79c5db1be6b2db
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 09:53:41 2010 -0700

    Staging: brcm80211: typedefs.h move types.h to the top of the file
    
    Include other files from the top, it's easier to unwind the logic that
    way.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit cc79cad299395f11a5df9da0d6a8991a118f2b81
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 09:51:42 2010 -0700

    Staging: brcm80211: typedefs.h: remove version.h inclusion
    
    It isn't needed anymore.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 5393ddf14e7071ceeefde74a95bbc6ac9203c579
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 09:50:20 2010 -0700

    Staging: brcm80211: typedefs.h: remove some unused #if logic
    
    We never care about __STRICT_ANSI__ from within the kernel, so remove
    this logic.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a21142b22b8a09d4d683510113c1adf3b3eeced7
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 09:48:23 2010 -0700

    Staging: brcm80211: remove bool redefinition
    
    The core kernel type code handles this properly, no driver
    should ever do it.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 8fbfd3e6d1eccb46cfddcabe4ea0c4860badc424
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 09:43:56 2010 -0700

    Staging: brcm80211: remove redefinition of size_t
    
    No driver should ever do this.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a725ad6c7886b90b34bd4576e10ab4905110c1e7
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 09:42:56 2010 -0700

    Staging: brcm80211: remove PTRSZ definition
    
    It was never used.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a921fdc1a5d565aa7c3258487b90ee86d26dc510
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 09:41:45 2010 -0700

    Staging: brcm80211: remove floating point typedefs
    
    It's not ever used, so remove the typedef.  Floating point isn't used
    in the kernel, so this could never be an issue here.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 2d956e2221929103031f217fd666a10edd05f3a0
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 09:40:02 2010 -0700

    Staging: brcm80211: remove INLINE definition
    
    Use the "real" inline marking for functions.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 2a0b139283935f01faea6e24d8def3c844f8fe1d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 09:35:29 2010 -0700

    Staging: brcm80211: remove UNUSED_PARAMETER macro
    
    It's not needed anywhere.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit b79375827d931dba8eee3ff4e38b243e24d26b5c
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 09:31:19 2010 -0700

    Staging: brcm80211: remove unneeded #ifdef checks
    
    For a .h file, you never need to check it, the .h file does it
    itself.  For the typedef.h file, this is never needed.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ea4381ffb8d72c66ebfaa36c146952c3b302432b
Author: Brett Rudley <brudley@broadcom.com>
Date:   Sat Oct 2 18:08:53 2010 -0700

    staging: brcm80211: Purge unused extern declarations
    
    Purge unused extern declarations
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 6d4e997b62f1a4ca0dc9149d62271f66dbe228c8
Author: Brett Rudley <brudley@broadcom.com>
Date:   Sat Oct 2 18:08:52 2010 -0700

    staging: brcm80211: Purge packets tags
    
    No longer need packet tags
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 035f4c3bbbc5c333ee307ab717f5242b3cc62d2e
Author: Brett Rudley <brudley@broadcom.com>
Date:   Sat Oct 2 18:08:51 2010 -0700

    staging: brcm80211: Purge unused flags and macros from wlc_scb.h
    
    Purge unused flags and macros from wlc_scb.h
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit be217b54d712fe3e270e36c93c71129baaceb27f
Author: Brett Rudley <brudley@broadcom.com>
Date:   Fri Oct 1 18:03:27 2010 -0700

    staging: brcm80211: Purge unused #includes
    
    Purging unused #includes.
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 3327989a51f7d46d854c89bb6047dd68f843a7fd
Author: Brett Rudley <brudley@broadcom.com>
Date:   Fri Oct 1 18:03:27 2010 -0700

    staging: brcm80211: Move #includes out of header
    
    Start the process of moving #includes out of headers and into individual C files.
    For now, this patch addresses the softmac side of the driver, fullmac still to
    be done.
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 34a5fa94eee475f1f0bb3b79afb0da9c71aa1197
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Fri Oct 1 14:05:25 2010 -0700

    staging: brcm80211: Remove unneeded definitions and structures.
    
    Remove definitions and structures that are no longer needed.  Most of the
    remaining ones can probably be replaced with the equivalent ones from
    include/linux/ieee80211.h.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 4594a934dcd8d147beb07edfb58eb3b4457b7399
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Fri Oct 1 14:05:24 2010 -0700

    staging: brcm80211: Remove unnecessary assertions.
    
    Remove assertions on the size of several structures.  These structures are
    never used anywhere.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 93ea8e6e3957f3fce4a3c6596464da881a6af92c
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Fri Oct 1 14:05:23 2010 -0700

    staging: brcm80211: Remove unnecessary debug print routines.
    
    Removed several unused and rarely used debug printout routines that look into
    portions of the frame that are more properly left to the mac80211 stack.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 453fb2cb657c1c8bb705d68219a19f5669a4360b
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Fri Oct 1 14:05:22 2010 -0700

    staging: brcm80211: Remove unused field from wlc_info structure.
    
    Remove an unused field from the wlc_info structure, so that the underlying
    structure can also be cleaned up.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 8518a9e2b013bdb087b535f4fc96ffbe13dc960f
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Fri Oct 1 14:05:21 2010 -0700

    staging: brcm80211: Remove unnecessary assertions.
    
    Remove assertions on the size of several structures.  These structures are
    never used anywhere.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 47127f34e7478ef369b2f14d820a375e368deb5b
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Fri Oct 1 14:05:20 2010 -0700

    staging: brcm80211: Remove unused structure.
    
    Remove the wl_assoc_info_t structure.  It's never used, and depends on
    structures defined in other header files that can now also be cleaned up.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 02266551e8d02456c526422e94e9cbac9c3295df
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Thu Sep 30 15:15:41 2010 -0400

    staging: brcm80211: fix checkpatch error 'assignment in if condition'
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Acked-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 59334c2f1fcc2c5ddb5828d93eba3bd486576cae
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Thu Sep 30 15:15:40 2010 -0400

    staging: brcm80211: fix checkpatch error 'assignment in if condition'
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Acked-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 9b890325d6b34354552db5e369698757301d30a7
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Thu Sep 30 15:15:39 2010 -0400

    staging: brcm80211: fix checkpatch error 'assignment in if condition'
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Acked-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a618cc28336b8dd1244dc28a251ccc4eff60a726
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Thu Sep 30 15:15:38 2010 -0400

    staging: brcm80211: fix checkpatch error 'assignment in if condition'
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Acked-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a1b04b0b33d2d5d2ecbc7c67845619bee493461e
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Thu Sep 30 15:15:37 2010 -0400

    staging: brcm80211: fix checkpatch error 'assignment in if condition'
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Acked-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 57c096b897fe59e106452500afbbe0e0f1f8e149
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Thu Sep 30 15:15:36 2010 -0400

    staging: brcm80211: fix checkpatch error 'assignment in if condition'
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Acked-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit c74c95cd1f6e4b59ecd75c0584b8b5589e7b60a3
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Thu Sep 30 15:15:35 2010 -0400

    staging: brcm80211: fix checkpatch errors 'assignment in if condition'
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Acked-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit eb7f37b3d56839fc0c3b631146f8b3be96b71879
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Thu Sep 30 15:15:34 2010 -0400

    staging: brcm80211: fix checkpatch error 'assignment in if condition'
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Acked-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit b229fad289ad36a5875c7e4f9a8e736b27d8bef4
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Thu Sep 30 15:15:33 2010 -0400

    staging: brcm80211: fix checkpatch error 'assignment in if condition'
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Acked-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 6f0c5bcdff5eec67a8fd5688e604ea1317fd26c8
Author: Brett Rudley <brudley@broadcom.com>
Date:   Wed Sep 29 17:11:11 2010 -0700

    staging: brcm80211: Fix debug section mismatch warning
    
    wl_remove() is now called from places other than the .remove field of struct pci_driver so
    do not annotate wl_remove() with __devexit.  This removes the debug section mismatch warning
    introduced by the previous nonexistant firmware patch.
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 84b9fac24ba168ebe5531a820d3ed63f2f3a8935
Author: Nohee Ko <noheek@broadcom.com>
Date:   Wed Sep 29 15:56:49 2010 -0700

    staging: brcm80211: fix #ifdef BRCM_FULLMAC mess
    
    This patch fixes "#ifdef BRCM_FULLMAC" mess which shows
    in siutils.c/hndpmu.c.
    All unnecessary #ifdefs were erased.
    Also as a part of this work, bcmutils.c was also modified.
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 07610433d980d91a96a9675253a95b1b6c1331ca
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Wed Sep 29 14:50:49 2010 -0700

    staging: brcm80211: Remove unneeded compile flags.
    
    This removes compile flags that are completely unnecessary when building the
    brcmfmac driver.
    
    Also sorts the options to make it a bit easier to look at them.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 8727a644289c77f988398f1136380f72a3df3fbb
Author: Brett Rudley <brudley@broadcom.com>
Date:   Wed Sep 29 11:42:47 2010 -0700

    staging: brcm80211: cleanup headers
    
    Trim down bcmip.h to only whats needed, purge the rest.
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit f61efd4723cc51289ff300e929f77a247a1aca30
Author: Brett Rudley <brudley@broadcom.com>
Date:   Wed Sep 29 11:41:56 2010 -0700

    staging: brcm80211: cleanup headers
    
    Purge unused and extraneous header, brcm80211/include/proto/802.11e.h
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 9e56568af114db4f87f5ce556d954388a516d9e0
Author: Brett Rudley <brudley@broadcom.com>
Date:   Tue Sep 28 17:35:39 2010 -0700

    staging: brcm80211: delete unused/obsolete code
    
    Delete unused attempt to debug through /proc.
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 683b505b934b677e5dc61d8363625d3ca67f48bd
Author: Brett Rudley <brudley@broadcom.com>
Date:   Tue Sep 28 11:34:44 2010 -0700

    staging: brcm80211: handle missing firmware better
    
    Handle non-extistent firmware more gracefully.
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a06b1414a4d1850244827dc61382f44525151e92
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Sep 29 18:07:31 2010 -0700

    Staging: brcm80211: remove Module.symvers file from the tree
    
    This shouldn't have been in the tree, it's generated by the build, so
    remove it.
    
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 6afd1198d111ccff4c91be96d8c631afc29325e7
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Sun Sep 26 13:19:44 2010 -0700

    staging: brcm80211: Make compiling of brcm80211.ko and brcmfmac.ko mutually exclusive.
    
    Temporary fix until utils get cleaned up.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 76a3ccabf25bc3a52c3377bfdfc3ecc16499180b
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Sun Sep 26 13:18:38 2010 -0700

    staging: brcm80211: Fix compile issue when BRCM80211_PCI is not set.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit efd89a2204d4086de48673ff7e4d5f537e32e0a5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Sep 23 16:36:06 2010 -0700

    Staging: brcm80211: remove driver specific -W options
    
    A single driver shouldn't be overriding the kernel-wide -W options.
    This removes them from the Makefile.
    
    Bonus is that the code at least now will build on a 64bit platform.
    Problem is that both drivers can't be built at the same time right now
    or bad things happen when linking.
    
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Cc: jason <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 449c6741b69cb745214f1b62e188852f28c79332
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Sep 23 16:28:53 2010 -0700

    Staging: brcm80211: clean up makefile cflag lines
    
    Change to use the proper ccflags-y option, as well as splitting the
    options out one-per-line so that we can see what is needed to be cleaned
    up and removed over time.
    
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Cc: jason <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit cf2b448852abd47cee21007b8313fbf962bf3c9a
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Mon Sep 20 22:33:12 2010 -0700

    staging: brcm80211: add fullmac driver
    
    This patch to the existing bcm80211 directory in the staging tree adds fullmac
    driver support for the BCM4329 SDIO chip from Broadcom.  Configuration of the
    mac80211 driver or the fullmac driver can be done through menuconfig.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 48c51a8cf484c8d569f97050bbac493c5bc79c2f
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Wed Sep 15 12:47:18 2010 +0300

    staging: brcm80211: use string native library
    
    Signed-off-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 3fb4e3d1ffc4f3ba0188ed326a22dc50bf424df6
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Wed Sep 15 12:47:17 2010 +0300

    staging: brcm80211: use native ctype library
    
    Signed-off-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 5fee254098c11a52ce04e1efdc8c090caf592bfd
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:51 2010 -0400

    staging: brcm80211: fix remaining checkpatch errors.
    
    Remaining errors are due to the use of typedefs.  They should dissappear
    once the typedefs get cleaned up.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 92dfc7d18a123fcf22beaf23036ba02a13416e3e
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:50 2010 -0400

    staging: brcm80211: fix "ERROR: trailing whitespace."
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit fd64bcc48bd1542ca361e99b6487b54ad10dc4b8
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:49 2010 -0400

    staging: brcm80211: fix "ERROR: spaces required around that ..."
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 2ae3b7ea9f8e7472d26ec317ce498466b0864871
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:48 2010 -0400

    staging: brcm80211: fix "ERROR: spaces prohibited around that ':' ..."
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a0e5ccd340ccb2cc9c87771609bafa1e2491770b
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:47 2010 -0400

    staging: brcm80211: fix "ERROR: space required before that ..."
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 914d69d6bc5758b57f46a33699d794a364db88b9
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:46 2010 -0400

    staging: brcm80211: fix "ERROR: space required after that ..."
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 0eeca2f48d5a28cc2458891294a98e46f4547c4b
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:45 2010 -0400

    staging: brcm80211: fix "ERROR: space required after that close brace"
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 5ebee113b66e9dfc07aa1ca45978c3a5c6bc970d
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:44 2010 -0400

    staging: brcm80211: fix "ERROR: space prohibited before ...close square bracket"
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 29c4275adbe15e95db54ce04a3137a6ff40c890c
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:43 2010 -0400

    staging: brcm80211: fix "ERROR: space prohibited after that ..."
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 198bd4d69dddb3fe78fdc251983bb49502b3b35e
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:42 2010 -0400

    staging: brcm80211: fix "ERROR: need consistent spacing around '*'"
    
    This patch fixes the real errors.  The rest are caused by typedefs
    which will be fixed in a later patch.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 39dcff3f45048df1c8bd3e3ba033e7b62328db3f
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:41 2010 -0400

    staging: brcm80211: fix 'ERROR: "(foo*)" should be "(foo *)"'
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
[bwh: Fix context for Debian's 2.6.32]

commit c5fe41c339180dea243443391d08f620fbf147c3
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:40 2010 -0400

    staging: brcm80211: fix "ERROR: Macros w/ mult. statements ... do - while loop"
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 0d706ef4f2f17541900978b0c1cf629321f56298
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:39 2010 -0400

    staging: brcm80211: fix "ERROR: Macros w/ complex values ... parenthesis"
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 7e85c72969b17eed698c3e23674f424bf345aceb
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:38 2010 -0400

    staging: brcm80211: fix "ERROR: do not initialise statics to 0 or NULL"
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit e4e4d21fa303f71a8289c3dd822a02cf91603502
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:37 2010 -0400

    staging: brcm80211: fix "ERROR: do not initialise globals to 0 or NULL"
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 9b6562b1c302704cdefd97f2c340b695bf481d44
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:36 2010 -0400

    staging: brcm80211: fix "ERROR: while should follow close brace '}'"
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit e5c4536fa4643ba15c06373f87e7a7e3080b8045
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:35 2010 -0400

    staging: brcm80211: fix "ERROR: that open brace { ... prev line"
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 621458221781e3e943c56e1978614604cee3beaf
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:34 2010 -0400

    staging: brcm80211: fix "ERROR: trailing statements should be on next line"
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ca8c1e5990926406708d99fe1ce2a6f5e12f9033
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:33 2010 -0400

    staging: brcm80211: fix "ERROR: do not use assignment in if condition"
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 90ea22962c5160812c601a115fb7b80c60d49fad
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:32 2010 -0400

    staging: brcm80211: fix "ERROR: return is not a function, paren..."
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a2627bc06580ffe1115b24a1dcce52924f157955
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:31 2010 -0400

    staging: brcm80211: fix "ERROR: open brace '{' following function dec..."
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 7cc4a4c02954afcd00abe5af81a4254d33a36e14
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:30 2010 -0400

    staging: brcm80211: fix 'ERROR: "foo * bar" should be "foo *bar"'
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 29f6465fc8d9a3bdee8378ed1d82c8ff8364e65e
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Sat Sep 11 09:44:09 2010 -0700

    staging: brcm80211: Fix URLs for firmware files.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 8dab24ce3e90219794a9ac28d79d22e528920b06
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Mon Sep 13 11:40:27 2010 +0300

    staging: brcm80211: use '%pM' format to print MAC address
    
    Signed-off-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Cc: linux-wireless@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit d30dc9a2f2f0a80ee1b11d3565ccd3ae83a26df4
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Thu Sep 9 11:53:33 2010 -0700

    staging: brcm80211: Add contact info to TODO list.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
diff --git a/drivers/staging/brcm80211/Kconfig b/drivers/staging/brcm80211/Kconfig
index 6b74685..57d2d1b 100644
--- a/drivers/staging/brcm80211/Kconfig
+++ b/drivers/staging/brcm80211/Kconfig
@@ -1,14 +1,33 @@
 menuconfig BRCM80211
-	tristate "Broadcom 802.11 WLAN driver for bcm43xx chips"
-	depends on PCI && WLAN
-	select WIRELESS_EXT
-	select WEXT_PRIV
-	default N
+	tristate "Broadcom IEEE802.11n WLAN drivers"
+	depends on WLAN
+
+choice
+	prompt "Broadcom IEEE802.11n driver style"
+	depends on BRCM80211
 	help
-	  If built as a module, it will be called brcm80211.ko.
+	Select the appropriate driver style from the list below.
 
 config BRCM80211_PCI
-	bool "Broadcom 802.11 WLAN NIC driver"
-	depends on BRCM80211
-	default y
+	bool "Broadcom IEEE802.11n PCIe SoftMAC WLAN driver"
+	depends on PCI
+	depends on BRCM80211 && MAC80211
+	select FW_LOADER
+	---help---
+	  This module adds support for PCIe wireless adapters based on Broadcom
+	  IEEE802.11n SoftMAC chipsets.  If you choose to build a module, it'll
+	  be called brcm80211.ko.
 
+config BRCMFMAC
+	bool "Broadcom IEEE802.11n embedded FullMAC WLAN driver"
+	depends on MMC
+	depends on BRCM80211 && CFG80211
+	select FW_LOADER
+	select WIRELESS_EXT
+	select WEXT_PRIV
+	---help---
+	  This module adds support for embedded wireless adapters based on
+	  Broadcom IEEE802.11n FullMAC chipsets.  This driver uses the kernel's
+	  wireless extensions subsystem.  If you choose to build a module,
+	  it'll be called brcmfmac.ko.
+endchoice
diff --git a/drivers/staging/brcm80211/Makefile b/drivers/staging/brcm80211/Makefile
index 05a4103..1953ebe 100644
--- a/drivers/staging/brcm80211/Makefile
+++ b/drivers/staging/brcm80211/Makefile
@@ -15,7 +15,19 @@
 # OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 # CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-EXTRA_CFLAGS := -DBCMDBG -DWLC_HIGH -DSTA -DWME -DWL11N -DDBAND -DBCMDMA32 -DBCMNVRAMR -Idrivers/staging/brcm80211/sys -Idrivers/staging/brcm80211/phy -Idrivers/staging/brcm80211/util -Idrivers/staging/brcm80211/include -Wall -Wstrict-prototypes -Werror -Wmissing-prototypes
+ccflags-y :=					\
+	-DBCMDBG				\
+	-DWLC_HIGH				\
+	-DSTA					\
+	-DWME					\
+	-DWL11N					\
+	-DDBAND					\
+	-DBCMDMA32				\
+	-DBCMNVRAMR				\
+	-Idrivers/staging/brcm80211/sys		\
+	-Idrivers/staging/brcm80211/phy		\
+	-Idrivers/staging/brcm80211/util	\
+	-Idrivers/staging/brcm80211/include
 
 PCI_CFLAGS := -DWLC_LOW
 
@@ -26,7 +38,6 @@ BRCM80211_OFILES := \
 	util/bcmsrom.o \
 	util/bcmutils.o \
 	util/bcmwifi.o \
-	util/bcmwpa.o \
 	util/hndpmu.o \
 	util/linux_osl.o \
 	sys/wlc_alloc.o \
@@ -55,11 +66,11 @@ PCIFILES := \
 
 MODULEPFX := brcm80211
 
-obj-m	+= $(MODULEPFX).o
-
 # PCI driver
 ifeq ($(CONFIG_BRCM80211_PCI),y)
-EXTRA_CFLAGS += $(PCI_CFLAGS)
+obj-m	+= $(MODULEPFX).o
+ccflags-y += $(PCI_CFLAGS)
 $(MODULEPFX)-objs	= $(BRCM80211_OFILES) $(PCIFILES)
 endif
 
+obj-$(CONFIG_BRCMFMAC)    += brcmfmac/
diff --git a/drivers/staging/brcm80211/Module.symvers b/drivers/staging/brcm80211/Module.symvers
deleted file mode 100644
index e69de29..0000000
diff --git a/drivers/staging/brcm80211/README b/drivers/staging/brcm80211/README
index 97fa01c..c3ba9bb 100644
--- a/drivers/staging/brcm80211/README
+++ b/drivers/staging/brcm80211/README
@@ -40,8 +40,8 @@ Firmware installation
 Firmware is available from the Linux firmware repository at:
 
 	git://git.kernel.org/pub/scm/linux/kernel/git/dwmw2/linux-firmware.git
-	http://git.kernel.org/pub/scm/linux/kernel/git/dwmw2/linux-firmware.git
-	https://git.kernel.org/pub/scm/linux/kernel/git/dwmw2/linux-firmware.git
+	http://git.kernel.org/?p=linux/kernel/git/dwmw2/linux-firmware.git
+	https://git.kernel.org/?p=linux/kernel/git/dwmw2/linux-firmware.git
 
 For all chips, copy brcm/bcm43xx-0-610-809-0.fw and
 brcm/bcm43xx_hdr-0-610-809-0.fw to /lib/firmware/brcm (or wherever firmware is
diff --git a/drivers/staging/brcm80211/TODO b/drivers/staging/brcm80211/TODO
index 5870bca..8803d30 100644
--- a/drivers/staging/brcm80211/TODO
+++ b/drivers/staging/brcm80211/TODO
@@ -32,6 +32,8 @@ Other
 =====
 - wlc_mac80211.[ch], wl_mac80211.[ch] and linux_osl.c all need to be refactored
     and combined.
+- Merge files that are partially duplicated between the softmac and fullmac
+  drivers
 - Replace driver's proprietary ssb interface with generic kernel ssb module
   (only used when compiling for SDIO).
 - PCI and SDIO support are currently #ifdef'ed exclusive of each other, which
@@ -39,3 +41,9 @@ Other
   handling of different interfaces so that a single binary driver can be built.
 - Add support for new chips (obviously an ongoing item).
 
+Contact
+=====
+Brett Rudley <brudley@broadcom.com>
+Henry Ptasinski <henryp@broadcom.com>
+Nohee Ko <noheek@broadcom.com>
+
diff --git a/drivers/staging/brcm80211/brcmfmac/Kconfig b/drivers/staging/brcm80211/brcmfmac/Kconfig
new file mode 100644
index 0000000..e9f3037
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/Kconfig
@@ -0,0 +1,15 @@
+menuconfig BRCMFMAC
+	tristate "Broadcom fullmac wireless cards support"
+	depends on MMC
+	depends on CFG80211
+	select FW_LOADER
+	select WIRELESS_EXT
+	select WEXT_PRIV
+	---help---
+	  This module adds support for wireless adapters based on
+	  Broadcom fullmac chipsets.
+	  This driver uses the kernel's wireless extensions subsystem.
+	  If you choose to build a module, it'll be called brcmfmac.ko. Say M if
+	  unsure.
+
+
diff --git a/drivers/staging/brcm80211/brcmfmac/Makefile b/drivers/staging/brcm80211/brcmfmac/Makefile
new file mode 100644
index 0000000..76f2d8b
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/Makefile
@@ -0,0 +1,47 @@
+#
+# Makefile fragment for Broadcom 802.11n Networking Device Driver
+#
+# Copyright (c) 2010 Broadcom Corporation
+#
+# Permission to use, copy, modify, and/or distribute this software for any
+# purpose with or without fee is hereby granted, provided that the above
+# copyright notice and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+# SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+ccflags-y :=			\
+	-DARP_OFFLOAD_SUPPORT	\
+	-DBCMDBG		\
+	-DBCMLXSDMMC		\
+	-DBCMPLATFORM_BUS	\
+	-DBCMSDIO		\
+	-DBDC			\
+	-DBRCM_FULLMAC		\
+	-DDHD_DEBUG		\
+	-DDHD_FIRSTREAD=64	\
+	-DDHD_SCHED		\
+	-DDHD_SDALIGN=64	\
+	-DEMBEDDED_PLATFORM	\
+	-DMAX_HDR_READ=64	\
+	-DMMC_SDIO_ABORT	\
+	-DPKT_FILTER_SUPPORT	\
+	-DSHOW_EVENTS		\
+	-DTOE			\
+	-Idrivers/staging/brcm80211/brcmfmac		\
+	-Idrivers/staging/brcm80211/include		\
+	-Idrivers/staging/brcm80211/util
+
+DHDOFILES = dhd_linux.o ../util/linux_osl.o ../util/bcmutils.o dhd_common.o dhd_custom_gpio.o	\
+	wl_iw.o wl_cfg80211.o ../util/siutils.o ../util/sbutils.o ../util/aiutils.o ../util/hndpmu.o ../util/bcmwifi.o dhd_sdio.o	\
+	dhd_linux_sched.o dhd_cdc.o bcmsdh_sdmmc.o bcmsdh.o bcmsdh_linux.o	\
+	bcmsdh_sdmmc_linux.o
+
+obj-m += brcmfmac.o
+brcmfmac-objs += $(DHDOFILES)
+
diff --git a/drivers/staging/brcm80211/brcmfmac/README b/drivers/staging/brcm80211/brcmfmac/README
new file mode 100644
index 0000000..43601fa
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/README
@@ -0,0 +1,36 @@
+Broadcom fullmac driver
+
+This is production driver.
+
+What's here
+===========
+- Completely open source host driver, no binary object files
+- Features Broadcom's OneDriver architecture (single source base for
+  supported chips and architectures)
+- On-chip firmware loaded using standard request_firmware()
+- Support for BCM4329(SDIO)
+
+What's done
+==========
+- Integration with cfg80211 stack
+- Most of Mac functionality is performed in dongle
+- A-MPDU single stream rates
+- BCM4329:	Dualband, Single stream, 20MHz channels
+
+Firmware installation
+======================
+Firmware is available from the Linux firmware repository at:
+
+	git://git.kernel.org/pub/scm/linux/kernel/git/dwmw2/linux-firmware.git
+	http://git.kernel.org/?p=linux/kernel/git/dwmw2/linux-firmware.git
+	https://git.kernel.org/?p=linux/kernel/git/dwmw2/linux-firmware.git
+
+For 4329 chip, copy brcm/bcm4329-fullmac-4-218-248-5.bin and
+bcm4329-fullmac-4-218-248-5.txt to /lib/firmware/brcm
+
+Contact Info:
+=============
+Brett Rudley	brudley@broadcom.com
+Henry Ptasinski henryp@broadcom.com
+Nohee Ko	noheek@broadcom.com
+
diff --git a/drivers/staging/brcm80211/brcmfmac/bcmsdh.c b/drivers/staging/brcm80211/brcmfmac/bcmsdh.c
new file mode 100644
index 0000000..4c613da
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh.c
@@ -0,0 +1,632 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+/* ****************** BCMSDH Interface Functions *************************** */
+
+#include <linux/types.h>
+#include <bcmdefs.h>
+#include <bcmdevs.h>
+#include <bcmendian.h>
+#include <bcmutils.h>
+#include <hndsoc.h>
+#include <siutils.h>
+#include <osl.h>
+
+#include <bcmsdh.h>		/* BRCM API for SDIO
+			 clients (such as wl, dhd) */
+#include <bcmsdbus.h>		/* common SDIO/controller interface */
+#include <sbsdio.h>		/* BRCM sdio device core */
+
+#include <sdio.h>		/* sdio spec */
+
+#define SDIOH_API_ACCESS_RETRY_LIMIT	2
+const uint bcmsdh_msglevel = BCMSDH_ERROR_VAL;
+
+struct bcmsdh_info {
+	bool init_success;	/* underlying driver successfully attached */
+	void *sdioh;		/* handler for sdioh */
+	u32 vendevid;	/* Target Vendor and Device ID on SD bus */
+	osl_t *osh;
+	bool regfail;		/* Save status of last
+				 reg_read/reg_write call */
+	u32 sbwad;		/* Save backplane window address */
+};
+/* local copy of bcm sd handler */
+bcmsdh_info_t *l_bcmsdh;
+
+#if defined(OOB_INTR_ONLY) && defined(HW_OOB)
+extern int sdioh_enable_hw_oob_intr(void *sdioh, bool enable);
+
+void bcmsdh_enable_hw_oob_intr(bcmsdh_info_t *sdh, bool enable)
+{
+	sdioh_enable_hw_oob_intr(sdh->sdioh, enable);
+}
+#endif
+
+bcmsdh_info_t *bcmsdh_attach(osl_t *osh, void *cfghdl, void **regsva, uint irq)
+{
+	bcmsdh_info_t *bcmsdh;
+
+	bcmsdh = kzalloc(sizeof(bcmsdh_info_t), GFP_ATOMIC);
+	if (bcmsdh == NULL) {
+		BCMSDH_ERROR(("bcmsdh_attach: out of memory"));
+		return NULL;
+	}
+
+	/* save the handler locally */
+	l_bcmsdh = bcmsdh;
+
+	bcmsdh->sdioh = sdioh_attach(osh, cfghdl, irq);
+	if (!bcmsdh->sdioh) {
+		bcmsdh_detach(osh, bcmsdh);
+		return NULL;
+	}
+
+	bcmsdh->osh = osh;
+	bcmsdh->init_success = true;
+
+	*regsva = (u32 *) SI_ENUM_BASE;
+
+	/* Report the BAR, to fix if needed */
+	bcmsdh->sbwad = SI_ENUM_BASE;
+	return bcmsdh;
+}
+
+int bcmsdh_detach(osl_t *osh, void *sdh)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+
+	if (bcmsdh != NULL) {
+		if (bcmsdh->sdioh) {
+			sdioh_detach(osh, bcmsdh->sdioh);
+			bcmsdh->sdioh = NULL;
+		}
+		kfree(bcmsdh);
+	}
+
+	l_bcmsdh = NULL;
+	return 0;
+}
+
+int
+bcmsdh_iovar_op(void *sdh, const char *name,
+		void *params, int plen, void *arg, int len, bool set)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	return sdioh_iovar_op(bcmsdh->sdioh, name, params, plen, arg, len, set);
+}
+
+bool bcmsdh_intr_query(void *sdh)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	SDIOH_API_RC status;
+	bool on;
+
+	ASSERT(bcmsdh);
+	status = sdioh_interrupt_query(bcmsdh->sdioh, &on);
+	if (SDIOH_API_SUCCESS(status))
+		return false;
+	else
+		return on;
+}
+
+int bcmsdh_intr_enable(void *sdh)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	SDIOH_API_RC status;
+	ASSERT(bcmsdh);
+
+	status = sdioh_interrupt_set(bcmsdh->sdioh, true);
+	return SDIOH_API_SUCCESS(status) ? 0 : BCME_ERROR;
+}
+
+int bcmsdh_intr_disable(void *sdh)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	SDIOH_API_RC status;
+	ASSERT(bcmsdh);
+
+	status = sdioh_interrupt_set(bcmsdh->sdioh, false);
+	return SDIOH_API_SUCCESS(status) ? 0 : BCME_ERROR;
+}
+
+int bcmsdh_intr_reg(void *sdh, bcmsdh_cb_fn_t fn, void *argh)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	SDIOH_API_RC status;
+	ASSERT(bcmsdh);
+
+	status = sdioh_interrupt_register(bcmsdh->sdioh, fn, argh);
+	return SDIOH_API_SUCCESS(status) ? 0 : BCME_ERROR;
+}
+
+int bcmsdh_intr_dereg(void *sdh)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	SDIOH_API_RC status;
+	ASSERT(bcmsdh);
+
+	status = sdioh_interrupt_deregister(bcmsdh->sdioh);
+	return SDIOH_API_SUCCESS(status) ? 0 : BCME_ERROR;
+}
+
+#if defined(DHD_DEBUG)
+bool bcmsdh_intr_pending(void *sdh)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+
+	ASSERT(sdh);
+	return sdioh_interrupt_pending(bcmsdh->sdioh);
+}
+#endif
+
+int bcmsdh_devremove_reg(void *sdh, bcmsdh_cb_fn_t fn, void *argh)
+{
+	ASSERT(sdh);
+
+	/* don't support yet */
+	return BCME_UNSUPPORTED;
+}
+
+u8 bcmsdh_cfg_read(void *sdh, uint fnc_num, u32 addr, int *err)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	SDIOH_API_RC status;
+#ifdef SDIOH_API_ACCESS_RETRY_LIMIT
+	s32 retry = 0;
+#endif
+	u8 data = 0;
+
+	if (!bcmsdh)
+		bcmsdh = l_bcmsdh;
+
+	ASSERT(bcmsdh->init_success);
+
+#ifdef SDIOH_API_ACCESS_RETRY_LIMIT
+	do {
+		if (retry)	/* wait for 1 ms till bus get settled down */
+			udelay(1000);
+#endif
+		status =
+		    sdioh_cfg_read(bcmsdh->sdioh, fnc_num, addr,
+				   (u8 *) &data);
+#ifdef SDIOH_API_ACCESS_RETRY_LIMIT
+	} while (!SDIOH_API_SUCCESS(status)
+		 && (retry++ < SDIOH_API_ACCESS_RETRY_LIMIT));
+#endif
+	if (err)
+		*err = (SDIOH_API_SUCCESS(status) ? 0 : BCME_SDIO_ERROR);
+
+	BCMSDH_INFO(("%s:fun = %d, addr = 0x%x, u8data = 0x%x\n",
+		     __func__, fnc_num, addr, data));
+
+	return data;
+}
+
+void
+bcmsdh_cfg_write(void *sdh, uint fnc_num, u32 addr, u8 data, int *err)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	SDIOH_API_RC status;
+#ifdef SDIOH_API_ACCESS_RETRY_LIMIT
+	s32 retry = 0;
+#endif
+
+	if (!bcmsdh)
+		bcmsdh = l_bcmsdh;
+
+	ASSERT(bcmsdh->init_success);
+
+#ifdef SDIOH_API_ACCESS_RETRY_LIMIT
+	do {
+		if (retry)	/* wait for 1 ms till bus get settled down */
+			udelay(1000);
+#endif
+		status =
+		    sdioh_cfg_write(bcmsdh->sdioh, fnc_num, addr,
+				    (u8 *) &data);
+#ifdef SDIOH_API_ACCESS_RETRY_LIMIT
+	} while (!SDIOH_API_SUCCESS(status)
+		 && (retry++ < SDIOH_API_ACCESS_RETRY_LIMIT));
+#endif
+	if (err)
+		*err = SDIOH_API_SUCCESS(status) ? 0 : BCME_SDIO_ERROR;
+
+	BCMSDH_INFO(("%s:fun = %d, addr = 0x%x, u8data = 0x%x\n",
+		     __func__, fnc_num, addr, data));
+}
+
+u32 bcmsdh_cfg_read_word(void *sdh, uint fnc_num, u32 addr, int *err)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	SDIOH_API_RC status;
+	u32 data = 0;
+
+	if (!bcmsdh)
+		bcmsdh = l_bcmsdh;
+
+	ASSERT(bcmsdh->init_success);
+
+	status =
+	    sdioh_request_word(bcmsdh->sdioh, SDIOH_CMD_TYPE_NORMAL, SDIOH_READ,
+			       fnc_num, addr, &data, 4);
+
+	if (err)
+		*err = (SDIOH_API_SUCCESS(status) ? 0 : BCME_SDIO_ERROR);
+
+	BCMSDH_INFO(("%s:fun = %d, addr = 0x%x, u32data = 0x%x\n",
+		     __func__, fnc_num, addr, data));
+
+	return data;
+}
+
+void
+bcmsdh_cfg_write_word(void *sdh, uint fnc_num, u32 addr, u32 data,
+		      int *err)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	SDIOH_API_RC status;
+
+	if (!bcmsdh)
+		bcmsdh = l_bcmsdh;
+
+	ASSERT(bcmsdh->init_success);
+
+	status =
+	    sdioh_request_word(bcmsdh->sdioh, SDIOH_CMD_TYPE_NORMAL,
+			       SDIOH_WRITE, fnc_num, addr, &data, 4);
+
+	if (err)
+		*err = (SDIOH_API_SUCCESS(status) ? 0 : BCME_SDIO_ERROR);
+
+	BCMSDH_INFO(("%s:fun = %d, addr = 0x%x, u32data = 0x%x\n",
+		     __func__, fnc_num, addr, data));
+}
+
+int bcmsdh_cis_read(void *sdh, uint func, u8 * cis, uint length)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	SDIOH_API_RC status;
+
+	u8 *tmp_buf, *tmp_ptr;
+	u8 *ptr;
+	bool ascii = func & ~0xf;
+	func &= 0x7;
+
+	if (!bcmsdh)
+		bcmsdh = l_bcmsdh;
+
+	ASSERT(bcmsdh->init_success);
+	ASSERT(cis);
+	ASSERT(length <= SBSDIO_CIS_SIZE_LIMIT);
+
+	status = sdioh_cis_read(bcmsdh->sdioh, func, cis, length);
+
+	if (ascii) {
+		/* Move binary bits to tmp and format them
+			 into the provided buffer. */
+		tmp_buf = kmalloc(length, GFP_ATOMIC);
+		if (tmp_buf == NULL) {
+			BCMSDH_ERROR(("%s: out of memory\n", __func__));
+			return BCME_NOMEM;
+		}
+		bcopy(cis, tmp_buf, length);
+		for (tmp_ptr = tmp_buf, ptr = cis; ptr < (cis + length - 4);
+		     tmp_ptr++) {
+			ptr += sprintf((char *)ptr, "%.2x ", *tmp_ptr & 0xff);
+			if ((((tmp_ptr - tmp_buf) + 1) & 0xf) == 0)
+				ptr += sprintf((char *)ptr, "\n");
+		}
+		kfree(tmp_buf);
+	}
+
+	return SDIOH_API_SUCCESS(status) ? 0 : BCME_ERROR;
+}
+
+static int bcmsdhsdio_set_sbaddr_window(void *sdh, u32 address)
+{
+	int err = 0;
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	bcmsdh_cfg_write(bcmsdh, SDIO_FUNC_1, SBSDIO_FUNC1_SBADDRLOW,
+			 (address >> 8) & SBSDIO_SBADDRLOW_MASK, &err);
+	if (!err)
+		bcmsdh_cfg_write(bcmsdh, SDIO_FUNC_1, SBSDIO_FUNC1_SBADDRMID,
+				 (address >> 16) & SBSDIO_SBADDRMID_MASK, &err);
+	if (!err)
+		bcmsdh_cfg_write(bcmsdh, SDIO_FUNC_1, SBSDIO_FUNC1_SBADDRHIGH,
+				 (address >> 24) & SBSDIO_SBADDRHIGH_MASK,
+				 &err);
+
+	return err;
+}
+
+u32 bcmsdh_reg_read(void *sdh, u32 addr, uint size)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	SDIOH_API_RC status;
+	u32 word = 0;
+	uint bar0 = addr & ~SBSDIO_SB_OFT_ADDR_MASK;
+
+	BCMSDH_INFO(("%s:fun = 1, addr = 0x%x, ", __func__, addr));
+
+	if (!bcmsdh)
+		bcmsdh = l_bcmsdh;
+
+	ASSERT(bcmsdh->init_success);
+
+	if (bar0 != bcmsdh->sbwad) {
+		if (bcmsdhsdio_set_sbaddr_window(bcmsdh, bar0))
+			return 0xFFFFFFFF;
+
+		bcmsdh->sbwad = bar0;
+	}
+
+	addr &= SBSDIO_SB_OFT_ADDR_MASK;
+	if (size == 4)
+		addr |= SBSDIO_SB_ACCESS_2_4B_FLAG;
+
+	status = sdioh_request_word(bcmsdh->sdioh, SDIOH_CMD_TYPE_NORMAL,
+				    SDIOH_READ, SDIO_FUNC_1, addr, &word, size);
+
+	bcmsdh->regfail = !(SDIOH_API_SUCCESS(status));
+
+	BCMSDH_INFO(("u32data = 0x%x\n", word));
+
+	/* if ok, return appropriately masked word */
+	if (SDIOH_API_SUCCESS(status)) {
+		switch (size) {
+		case sizeof(u8):
+			return word & 0xff;
+		case sizeof(u16):
+			return word & 0xffff;
+		case sizeof(u32):
+			return word;
+		default:
+			bcmsdh->regfail = true;
+
+		}
+	}
+
+	/* otherwise, bad sdio access or invalid size */
+	BCMSDH_ERROR(("%s: error reading addr 0x%04x size %d\n", __func__,
+		      addr, size));
+	return 0xFFFFFFFF;
+}
+
+u32 bcmsdh_reg_write(void *sdh, u32 addr, uint size, u32 data)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	SDIOH_API_RC status;
+	uint bar0 = addr & ~SBSDIO_SB_OFT_ADDR_MASK;
+	int err = 0;
+
+	BCMSDH_INFO(("%s:fun = 1, addr = 0x%x, uint%ddata = 0x%x\n",
+		     __func__, addr, size * 8, data));
+
+	if (!bcmsdh)
+		bcmsdh = l_bcmsdh;
+
+	ASSERT(bcmsdh->init_success);
+
+	if (bar0 != bcmsdh->sbwad) {
+		err = bcmsdhsdio_set_sbaddr_window(bcmsdh, bar0);
+		if (err)
+			return err;
+
+		bcmsdh->sbwad = bar0;
+	}
+
+	addr &= SBSDIO_SB_OFT_ADDR_MASK;
+	if (size == 4)
+		addr |= SBSDIO_SB_ACCESS_2_4B_FLAG;
+	status =
+	    sdioh_request_word(bcmsdh->sdioh, SDIOH_CMD_TYPE_NORMAL,
+			       SDIOH_WRITE, SDIO_FUNC_1, addr, &data, size);
+	bcmsdh->regfail = !(SDIOH_API_SUCCESS(status));
+
+	if (SDIOH_API_SUCCESS(status))
+		return 0;
+
+	BCMSDH_ERROR(("%s: error writing 0x%08x to addr 0x%04x size %d\n",
+		      __func__, data, addr, size));
+	return 0xFFFFFFFF;
+}
+
+bool bcmsdh_regfail(void *sdh)
+{
+	return ((bcmsdh_info_t *) sdh)->regfail;
+}
+
+int
+bcmsdh_recv_buf(void *sdh, u32 addr, uint fn, uint flags,
+		u8 *buf, uint nbytes, void *pkt,
+		bcmsdh_cmplt_fn_t complete, void *handle)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	SDIOH_API_RC status;
+	uint incr_fix;
+	uint width;
+	uint bar0 = addr & ~SBSDIO_SB_OFT_ADDR_MASK;
+	int err = 0;
+
+	ASSERT(bcmsdh);
+	ASSERT(bcmsdh->init_success);
+
+	BCMSDH_INFO(("%s:fun = %d, addr = 0x%x, size = %d\n",
+		     __func__, fn, addr, nbytes));
+
+	/* Async not implemented yet */
+	ASSERT(!(flags & SDIO_REQ_ASYNC));
+	if (flags & SDIO_REQ_ASYNC)
+		return BCME_UNSUPPORTED;
+
+	if (bar0 != bcmsdh->sbwad) {
+		err = bcmsdhsdio_set_sbaddr_window(bcmsdh, bar0);
+		if (err)
+			return err;
+
+		bcmsdh->sbwad = bar0;
+	}
+
+	addr &= SBSDIO_SB_OFT_ADDR_MASK;
+
+	incr_fix = (flags & SDIO_REQ_FIXED) ? SDIOH_DATA_FIX : SDIOH_DATA_INC;
+	width = (flags & SDIO_REQ_4BYTE) ? 4 : 2;
+	if (width == 4)
+		addr |= SBSDIO_SB_ACCESS_2_4B_FLAG;
+
+	status = sdioh_request_buffer(bcmsdh->sdioh, SDIOH_DATA_PIO, incr_fix,
+				      SDIOH_READ, fn, addr, width, nbytes, buf,
+				      pkt);
+
+	return SDIOH_API_SUCCESS(status) ? 0 : BCME_SDIO_ERROR;
+}
+
+int
+bcmsdh_send_buf(void *sdh, u32 addr, uint fn, uint flags,
+		u8 *buf, uint nbytes, void *pkt,
+		bcmsdh_cmplt_fn_t complete, void *handle)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	SDIOH_API_RC status;
+	uint incr_fix;
+	uint width;
+	uint bar0 = addr & ~SBSDIO_SB_OFT_ADDR_MASK;
+	int err = 0;
+
+	ASSERT(bcmsdh);
+	ASSERT(bcmsdh->init_success);
+
+	BCMSDH_INFO(("%s:fun = %d, addr = 0x%x, size = %d\n",
+		     __func__, fn, addr, nbytes));
+
+	/* Async not implemented yet */
+	ASSERT(!(flags & SDIO_REQ_ASYNC));
+	if (flags & SDIO_REQ_ASYNC)
+		return BCME_UNSUPPORTED;
+
+	if (bar0 != bcmsdh->sbwad) {
+		err = bcmsdhsdio_set_sbaddr_window(bcmsdh, bar0);
+		if (err)
+			return err;
+
+		bcmsdh->sbwad = bar0;
+	}
+
+	addr &= SBSDIO_SB_OFT_ADDR_MASK;
+
+	incr_fix = (flags & SDIO_REQ_FIXED) ? SDIOH_DATA_FIX : SDIOH_DATA_INC;
+	width = (flags & SDIO_REQ_4BYTE) ? 4 : 2;
+	if (width == 4)
+		addr |= SBSDIO_SB_ACCESS_2_4B_FLAG;
+
+	status = sdioh_request_buffer(bcmsdh->sdioh, SDIOH_DATA_PIO, incr_fix,
+				      SDIOH_WRITE, fn, addr, width, nbytes, buf,
+				      pkt);
+
+	return SDIOH_API_SUCCESS(status) ? 0 : BCME_ERROR;
+}
+
+int bcmsdh_rwdata(void *sdh, uint rw, u32 addr, u8 *buf, uint nbytes)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	SDIOH_API_RC status;
+
+	ASSERT(bcmsdh);
+	ASSERT(bcmsdh->init_success);
+	ASSERT((addr & SBSDIO_SBWINDOW_MASK) == 0);
+
+	addr &= SBSDIO_SB_OFT_ADDR_MASK;
+	addr |= SBSDIO_SB_ACCESS_2_4B_FLAG;
+
+	status =
+	    sdioh_request_buffer(bcmsdh->sdioh, SDIOH_DATA_PIO, SDIOH_DATA_INC,
+				 (rw ? SDIOH_WRITE : SDIOH_READ), SDIO_FUNC_1,
+				 addr, 4, nbytes, buf, NULL);
+
+	return SDIOH_API_SUCCESS(status) ? 0 : BCME_ERROR;
+}
+
+int bcmsdh_abort(void *sdh, uint fn)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+
+	return sdioh_abort(bcmsdh->sdioh, fn);
+}
+
+int bcmsdh_start(void *sdh, int stage)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+
+	return sdioh_start(bcmsdh->sdioh, stage);
+}
+
+int bcmsdh_stop(void *sdh)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+
+	return sdioh_stop(bcmsdh->sdioh);
+}
+
+int bcmsdh_query_device(void *sdh)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+	bcmsdh->vendevid = (VENDOR_BROADCOM << 16) | 0;
+	return bcmsdh->vendevid;
+}
+
+uint bcmsdh_query_iofnum(void *sdh)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+
+	if (!bcmsdh)
+		bcmsdh = l_bcmsdh;
+
+	return sdioh_query_iofnum(bcmsdh->sdioh);
+}
+
+int bcmsdh_reset(bcmsdh_info_t *sdh)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+
+	return sdioh_sdio_reset(bcmsdh->sdioh);
+}
+
+void *bcmsdh_get_sdioh(bcmsdh_info_t *sdh)
+{
+	ASSERT(sdh);
+	return sdh->sdioh;
+}
+
+/* Function to pass device-status bits to DHD. */
+u32 bcmsdh_get_dstatus(void *sdh)
+{
+	return 0;
+}
+
+u32 bcmsdh_cur_sbwad(void *sdh)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
+
+	if (!bcmsdh)
+		bcmsdh = l_bcmsdh;
+
+	return bcmsdh->sbwad;
+}
+
+void bcmsdh_chipinfo(void *sdh, u32 chip, u32 chiprev)
+{
+	return;
+}
diff --git a/drivers/staging/brcm80211/brcmfmac/bcmsdh_linux.c b/drivers/staging/brcm80211/brcmfmac/bcmsdh_linux.c
new file mode 100644
index 0000000..9028cd0
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh_linux.c
@@ -0,0 +1,658 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/**
+ * @file bcmsdh_linux.c
+ */
+
+#define __UNDEF_NO_VERSION__
+
+#include <linuxver.h>
+
+#include <linux/pci.h>
+#include <linux/completion.h>
+
+#include <osl.h>
+#include <pcicfg.h>
+#include <bcmdefs.h>
+#include <bcmdevs.h>
+
+#if defined(OOB_INTR_ONLY)
+#include <linux/irq.h>
+extern void dhdsdio_isr(void *args);
+#include <bcmutils.h>
+#include <dngl_stats.h>
+#include <dhd.h>
+#endif				/* defined(OOB_INTR_ONLY) */
+#if defined(CONFIG_MACH_SANDGATE2G) || defined(CONFIG_MACH_LOGICPD_PXA270)
+#if !defined(BCMPLATFORM_BUS)
+#define BCMPLATFORM_BUS
+#endif				/* !defined(BCMPLATFORM_BUS) */
+
+#include <linux/platform_device.h>
+#endif				/* CONFIG_MACH_SANDGATE2G */
+
+/**
+ * SDIO Host Controller info
+ */
+typedef struct bcmsdh_hc bcmsdh_hc_t;
+
+struct bcmsdh_hc {
+	bcmsdh_hc_t *next;
+#ifdef BCMPLATFORM_BUS
+	struct device *dev;	/* platform device handle */
+#else
+	struct pci_dev *dev;	/* pci device handle */
+#endif				/* BCMPLATFORM_BUS */
+	osl_t *osh;
+	void *regs;		/* SDIO Host Controller address */
+	bcmsdh_info_t *sdh;	/* SDIO Host Controller handle */
+	void *ch;
+	unsigned int oob_irq;
+	unsigned long oob_flags;	/* OOB Host specifiction
+					as edge and etc */
+	bool oob_irq_registered;
+#if defined(OOB_INTR_ONLY)
+	spinlock_t irq_lock;
+#endif
+};
+static bcmsdh_hc_t *sdhcinfo;
+
+/* driver info, initialized when bcmsdh_register is called */
+static bcmsdh_driver_t drvinfo = { NULL, NULL };
+
+/* debugging macros */
+#define SDLX_MSG(x)
+
+/**
+ * Checks to see if vendor and device IDs match a supported SDIO Host Controller.
+ */
+bool bcmsdh_chipmatch(u16 vendor, u16 device)
+{
+	/* Add other vendors and devices as required */
+
+#ifdef BCMSDIOH_STD
+	/* Check for Arasan host controller */
+	if (vendor == VENDOR_SI_IMAGE)
+		return true;
+
+	/* Check for BRCM 27XX Standard host controller */
+	if (device == BCM27XX_SDIOH_ID && vendor == VENDOR_BROADCOM)
+		return true;
+
+	/* Check for BRCM Standard host controller */
+	if (device == SDIOH_FPGA_ID && vendor == VENDOR_BROADCOM)
+		return true;
+
+	/* Check for TI PCIxx21 Standard host controller */
+	if (device == PCIXX21_SDIOH_ID && vendor == VENDOR_TI)
+		return true;
+
+	if (device == PCIXX21_SDIOH0_ID && vendor == VENDOR_TI)
+		return true;
+
+	/* Ricoh R5C822 Standard SDIO Host */
+	if (device == R5C822_SDIOH_ID && vendor == VENDOR_RICOH)
+		return true;
+
+	/* JMicron Standard SDIO Host */
+	if (device == JMICRON_SDIOH_ID && vendor == VENDOR_JMICRON)
+		return true;
+#endif				/* BCMSDIOH_STD */
+#ifdef BCMSDIOH_SPI
+	/* This is the PciSpiHost. */
+	if (device == SPIH_FPGA_ID && vendor == VENDOR_BROADCOM) {
+		printf("Found PCI SPI Host Controller\n");
+		return true;
+	}
+#endif				/* BCMSDIOH_SPI */
+
+	return false;
+}
+
+#if defined(BCMPLATFORM_BUS)
+#if defined(BCMLXSDMMC)
+/* forward declarations */
+int bcmsdh_probe(struct device *dev);
+EXPORT_SYMBOL(bcmsdh_probe);
+
+int bcmsdh_remove(struct device *dev);
+EXPORT_SYMBOL(bcmsdh_remove);
+
+#else
+/* forward declarations */
+static int __devinit bcmsdh_probe(struct device *dev);
+static int __devexit bcmsdh_remove(struct device *dev);
+#endif				/* BCMLXSDMMC */
+
+#ifndef BCMLXSDMMC
+static struct device_driver bcmsdh_driver = {
+	.name = "pxa2xx-mci",
+	.bus = &platform_bus_type,
+	.probe = bcmsdh_probe,
+	.remove = bcmsdh_remove,
+	.suspend = NULL,
+	.resume = NULL,
+};
+#endif				/* BCMLXSDMMC */
+
+#ifndef BCMLXSDMMC
+static
+#endif				/* BCMLXSDMMC */
+int bcmsdh_probe(struct device *dev)
+{
+	osl_t *osh = NULL;
+	bcmsdh_hc_t *sdhc = NULL;
+	unsigned long regs = 0;
+	bcmsdh_info_t *sdh = NULL;
+#if !defined(BCMLXSDMMC) && defined(BCMPLATFORM_BUS)
+	struct platform_device *pdev;
+	struct resource *r;
+#endif				/* BCMLXSDMMC */
+	int irq = 0;
+	u32 vendevid;
+	unsigned long irq_flags = 0;
+
+#if !defined(BCMLXSDMMC) && defined(BCMPLATFORM_BUS)
+	pdev = to_platform_device(dev);
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_get_irq(pdev, 0);
+	if (!r || irq == NO_IRQ)
+		return -ENXIO;
+#endif				/* BCMLXSDMMC */
+
+#if defined(OOB_INTR_ONLY)
+#ifdef HW_OOB
+	irq_flags =
+	    IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL |
+	    IORESOURCE_IRQ_SHAREABLE;
+#else
+	irq_flags = IRQF_TRIGGER_FALLING;
+#endif				/* HW_OOB */
+	irq = dhd_customer_oob_irq_map(&irq_flags);
+	if (irq < 0) {
+		SDLX_MSG(("%s: Host irq is not defined\n", __func__));
+		return 1;
+	}
+#endif				/* defined(OOB_INTR_ONLY) */
+	/* allocate SDIO Host Controller state info */
+	osh = osl_attach(dev, PCI_BUS, false);
+	if (!osh) {
+		SDLX_MSG(("%s: osl_attach failed\n", __func__));
+		goto err;
+	}
+	sdhc = kzalloc(sizeof(bcmsdh_hc_t), GFP_ATOMIC);
+	if (!sdhc) {
+		SDLX_MSG(("%s: out of memory\n", __func__));
+		goto err;
+	}
+	sdhc->osh = osh;
+
+	sdhc->dev = (void *)dev;
+
+#ifdef BCMLXSDMMC
+	sdh = bcmsdh_attach(osh, (void *)0, (void **)&regs, irq);
+	if (!sdh) {
+		SDLX_MSG(("%s: bcmsdh_attach failed\n", __func__));
+		goto err;
+	}
+#else
+	sdh = bcmsdh_attach(osh, (void *)r->start, (void **)&regs, irq);
+	if (!sdh) {
+		SDLX_MSG(("%s: bcmsdh_attach failed\n", __func__));
+		goto err;
+	}
+#endif				/* BCMLXSDMMC */
+	sdhc->sdh = sdh;
+	sdhc->oob_irq = irq;
+	sdhc->oob_flags = irq_flags;
+	sdhc->oob_irq_registered = false;	/* to make sure.. */
+#if defined(OOB_INTR_ONLY)
+	spin_lock_init(&sdhc->irq_lock);
+#endif
+
+	/* chain SDIO Host Controller info together */
+	sdhc->next = sdhcinfo;
+	sdhcinfo = sdhc;
+	/* Read the vendor/device ID from the CIS */
+	vendevid = bcmsdh_query_device(sdh);
+
+	/* try to attach to the target device */
+	sdhc->ch = drvinfo.attach((vendevid >> 16), (vendevid & 0xFFFF),
+				0, 0, 0, 0, (void *)regs, NULL, sdh);
+	if (!sdhc->ch) {
+		SDLX_MSG(("%s: device attach failed\n", __func__));
+		goto err;
+	}
+
+	return 0;
+
+	/* error handling */
+err:
+	if (sdhc) {
+		if (sdhc->sdh)
+			bcmsdh_detach(sdhc->osh, sdhc->sdh);
+		kfree(sdhc);
+	}
+	if (osh)
+		osl_detach(osh);
+	return -ENODEV;
+}
+
+#ifndef BCMLXSDMMC
+static
+#endif				/* BCMLXSDMMC */
+int bcmsdh_remove(struct device *dev)
+{
+	bcmsdh_hc_t *sdhc, *prev;
+	osl_t *osh;
+
+	sdhc = sdhcinfo;
+	drvinfo.detach(sdhc->ch);
+	bcmsdh_detach(sdhc->osh, sdhc->sdh);
+	/* find the SDIO Host Controller state for this pdev
+		 and take it out from the list */
+	for (sdhc = sdhcinfo, prev = NULL; sdhc; sdhc = sdhc->next) {
+		if (sdhc->dev == (void *)dev) {
+			if (prev)
+				prev->next = sdhc->next;
+			else
+				sdhcinfo = NULL;
+			break;
+		}
+		prev = sdhc;
+	}
+	if (!sdhc) {
+		SDLX_MSG(("%s: failed\n", __func__));
+		return 0;
+	}
+
+	/* release SDIO Host Controller info */
+	osh = sdhc->osh;
+	kfree(sdhc);
+	osl_detach(osh);
+
+#if !defined(BCMLXSDMMC)
+	dev_set_drvdata(dev, NULL);
+#endif				/* !defined(BCMLXSDMMC) */
+
+	return 0;
+}
+
+#else				/* BCMPLATFORM_BUS */
+
+#if !defined(BCMLXSDMMC)
+/* forward declarations for PCI probe and remove functions. */
+static int __devinit bcmsdh_pci_probe(struct pci_dev *pdev,
+				      const struct pci_device_id *ent);
+static void __devexit bcmsdh_pci_remove(struct pci_dev *pdev);
+
+/**
+ * pci id table
+ */
+static struct pci_device_id bcmsdh_pci_devid[] __devinitdata = {
+{
+	.vendor = PCI_ANY_ID,
+	.device = PCI_ANY_ID,
+	.subvendor = PCI_ANY_ID,
+	.subdevice = PCI_ANY_ID,
+	.class = 0,
+	.class_mask = 0,
+	.driver_data = 0,
+},
+{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, bcmsdh_pci_devid);
+
+/**
+ * SDIO Host Controller pci driver info
+ */
+static struct pci_driver bcmsdh_pci_driver = {
+	.node = {},
+	.name = "bcmsdh",
+	.id_table = bcmsdh_pci_devid,
+	.probe = bcmsdh_pci_probe,
+	.remove = bcmsdh_pci_remove,
+	.suspend = NULL,
+	.resume = NULL,
+};
+
+extern uint sd_pci_slot;	/* Force detection to a particular PCI */
+				/* slot only . Allows for having multiple */
+				/* WL devices at once in a PC */
+				/* Only one instance of dhd will be */
+				/* usable at a time */
+				/* Upper word is bus number, */
+				/* lower word is slot number */
+				/* Default value of 0xFFFFffff turns this */
+				/* off */
+module_param(sd_pci_slot, uint, 0);
+
+/**
+ * Detect supported SDIO Host Controller and attach if found.
+ *
+ * Determine if the device described by pdev is a supported SDIO Host
+ * Controller.  If so, attach to it and attach to the target device.
+ */
+static int __devinit
+bcmsdh_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	osl_t *osh = NULL;
+	bcmsdh_hc_t *sdhc = NULL;
+	unsigned long regs;
+	bcmsdh_info_t *sdh = NULL;
+	int rc;
+
+	if (sd_pci_slot != 0xFFFFffff) {
+		if (pdev->bus->number != (sd_pci_slot >> 16) ||
+		    PCI_SLOT(pdev->devfn) != (sd_pci_slot & 0xffff)) {
+			SDLX_MSG(("%s: %s: bus %X, slot %X, vend %X, dev %X\n",
+				  __func__,
+				  bcmsdh_chipmatch(pdev->vendor, pdev->device) ?
+				  "Found compatible SDIOHC" :
+				  "Probing unknown device",
+				  pdev->bus->number, PCI_SLOT(pdev->devfn),
+				  pdev->vendor, pdev->device));
+			return -ENODEV;
+		}
+		SDLX_MSG(("%s: %s: bus %X, slot %X, vendor %X, device %X "
+			"(good PCI location)\n", __func__,
+			bcmsdh_chipmatch(pdev->vendor, pdev->device) ?
+			"Using compatible SDIOHC" : "WARNING, forced use "
+			"of unkown device",
+		pdev->bus->number, PCI_SLOT(pdev->devfn), pdev->vendor,
+		pdev->device));
+	}
+
+	if ((pdev->vendor == VENDOR_TI)
+	    && ((pdev->device == PCIXX21_FLASHMEDIA_ID)
+		|| (pdev->device == PCIXX21_FLASHMEDIA0_ID))) {
+		u32 config_reg;
+
+		SDLX_MSG(("%s: Disabling TI FlashMedia Controller.\n",
+			  __func__));
+		osh = osl_attach(pdev, PCI_BUS, false);
+		if (!osh) {
+			SDLX_MSG(("%s: osl_attach failed\n", __func__));
+			goto err;
+		}
+
+		config_reg = OSL_PCI_READ_CONFIG(osh, 0x4c, 4);
+
+		/*
+		 * Set MMC_SD_DIS bit in FlashMedia Controller.
+		 * Disbling the SD/MMC Controller in the FlashMedia Controller
+		 * allows the Standard SD Host Controller to take over control
+		 * of the SD Slot.
+		 */
+		config_reg |= 0x02;
+		OSL_PCI_WRITE_CONFIG(osh, 0x4c, 4, config_reg);
+		osl_detach(osh);
+	}
+	/* match this pci device with what we support */
+	/* we can't solely rely on this to believe it is
+		our SDIO Host Controller! */
+	if (!bcmsdh_chipmatch(pdev->vendor, pdev->device))
+		return -ENODEV;
+
+	/* this is a pci device we might support */
+	SDLX_MSG(("%s: Found possible SDIO Host Controller: "
+		"bus %d slot %d func %d irq %d\n", __func__,
+		pdev->bus->number, PCI_SLOT(pdev->devfn),
+		PCI_FUNC(pdev->devfn), pdev->irq));
+
+	/* use bcmsdh_query_device() to get the vendor ID of the target device
+	 * so it will eventually appear in the Broadcom string on the console
+	 */
+
+	/* allocate SDIO Host Controller state info */
+	osh = osl_attach(pdev, PCI_BUS, false);
+	if (!osh) {
+		SDLX_MSG(("%s: osl_attach failed\n", __func__));
+		goto err;
+	}
+	sdhc = kzalloc(sizeof(bcmsdh_hc_t), GFP_ATOMIC);
+	if (!sdhc) {
+		SDLX_MSG(("%s: out of memory\n", __func__));
+		goto err;
+	}
+	sdhc->osh = osh;
+
+	sdhc->dev = pdev;
+
+	/* map to address where host can access */
+	pci_set_master(pdev);
+	rc = pci_enable_device(pdev);
+	if (rc) {
+		SDLX_MSG(("%s: Cannot enable PCI device\n", __func__));
+		goto err;
+	}
+	sdh = bcmsdh_attach(osh, (void *)(unsigned long)pci_resource_start(pdev, 0),
+			(void **)&regs, pdev->irq);
+	if (!sdh) {
+		SDLX_MSG(("%s: bcmsdh_attach failed\n", __func__));
+		goto err;
+	}
+
+	sdhc->sdh = sdh;
+
+	/* try to attach to the target device */
+	sdhc->ch = drvinfo.attach(VENDOR_BROADCOM, /* pdev->vendor, */
+				bcmsdh_query_device(sdh) & 0xFFFF, 0, 0, 0, 0,
+				(void *)regs, NULL, sdh);
+	if (!sdhc->ch) {
+		SDLX_MSG(("%s: device attach failed\n", __func__));
+		goto err;
+	}
+
+	/* chain SDIO Host Controller info together */
+	sdhc->next = sdhcinfo;
+	sdhcinfo = sdhc;
+
+	return 0;
+
+	/* error handling */
+err:
+	if (sdhc->sdh)
+		bcmsdh_detach(sdhc->osh, sdhc->sdh);
+	if (sdhc)
+		kfree(sdhc);
+	if (osh)
+		osl_detach(osh);
+	return -ENODEV;
+}
+
+/**
+ * Detach from target devices and SDIO Host Controller
+ */
+static void __devexit bcmsdh_pci_remove(struct pci_dev *pdev)
+{
+	bcmsdh_hc_t *sdhc, *prev;
+	osl_t *osh;
+
+	/* find the SDIO Host Controller state for this
+		 pdev and take it out from the list */
+	for (sdhc = sdhcinfo, prev = NULL; sdhc; sdhc = sdhc->next) {
+		if (sdhc->dev == pdev) {
+			if (prev)
+				prev->next = sdhc->next;
+			else
+				sdhcinfo = NULL;
+			break;
+		}
+		prev = sdhc;
+	}
+	if (!sdhc)
+		return;
+
+	drvinfo.detach(sdhc->ch);
+
+	bcmsdh_detach(sdhc->osh, sdhc->sdh);
+
+	/* release SDIO Host Controller info */
+	osh = sdhc->osh;
+	kfree(sdhc);
+	osl_detach(osh);
+}
+#endif				/* BCMLXSDMMC */
+#endif				/* BCMPLATFORM_BUS */
+
+extern int sdio_function_init(void);
+
+int bcmsdh_register(bcmsdh_driver_t *driver)
+{
+	int error = 0;
+
+	drvinfo = *driver;
+
+#if defined(BCMPLATFORM_BUS)
+#if defined(BCMLXSDMMC)
+	SDLX_MSG(("Linux Kernel SDIO/MMC Driver\n"));
+	error = sdio_function_init();
+#else
+	SDLX_MSG(("Intel PXA270 SDIO Driver\n"));
+	error = driver_register(&bcmsdh_driver);
+#endif				/* defined(BCMLXSDMMC) */
+	return error;
+#endif				/* defined(BCMPLATFORM_BUS) */
+
+#if !defined(BCMPLATFORM_BUS) && !defined(BCMLXSDMMC)
+	error = pci_register_driver(&bcmsdh_pci_driver);
+	if (!error)
+		return 0;
+
+	SDLX_MSG(("%s: pci_register_driver failed 0x%x\n", __func__, error));
+#endif				/* BCMPLATFORM_BUS */
+
+	return error;
+}
+
+extern void sdio_function_cleanup(void);
+
+void bcmsdh_unregister(void)
+{
+#if defined(BCMPLATFORM_BUS) && !defined(BCMLXSDMMC)
+		driver_unregister(&bcmsdh_driver);
+#endif
+#if defined(BCMLXSDMMC)
+	sdio_function_cleanup();
+#endif				/* BCMLXSDMMC */
+#if !defined(BCMPLATFORM_BUS) && !defined(BCMLXSDMMC)
+	pci_unregister_driver(&bcmsdh_pci_driver);
+#endif				/* BCMPLATFORM_BUS */
+}
+
+#if defined(OOB_INTR_ONLY)
+void bcmsdh_oob_intr_set(bool enable)
+{
+	static bool curstate = 1;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sdhcinfo->irq_lock, flags);
+	if (curstate != enable) {
+		if (enable)
+			enable_irq(sdhcinfo->oob_irq);
+		else
+			disable_irq_nosync(sdhcinfo->oob_irq);
+		curstate = enable;
+	}
+	spin_unlock_irqrestore(&sdhcinfo->irq_lock, flags);
+}
+
+static irqreturn_t wlan_oob_irq(int irq, void *dev_id)
+{
+	dhd_pub_t *dhdp;
+
+	dhdp = (dhd_pub_t *) dev_get_drvdata(sdhcinfo->dev);
+
+	bcmsdh_oob_intr_set(0);
+
+	if (dhdp == NULL) {
+		SDLX_MSG(("Out of band GPIO interrupt fired way too early\n"));
+		return IRQ_HANDLED;
+	}
+
+	WAKE_LOCK_TIMEOUT(dhdp, WAKE_LOCK_TMOUT, 25);
+
+	dhdsdio_isr((void *)dhdp->bus);
+
+	return IRQ_HANDLED;
+}
+
+int bcmsdh_register_oob_intr(void *dhdp)
+{
+	int error = 0;
+
+	SDLX_MSG(("%s Enter\n", __func__));
+
+	sdhcinfo->oob_flags =
+	    IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL |
+	    IORESOURCE_IRQ_SHAREABLE;
+	dev_set_drvdata(sdhcinfo->dev, dhdp);
+
+	if (!sdhcinfo->oob_irq_registered) {
+		SDLX_MSG(("%s IRQ=%d Type=%X\n", __func__,
+			  (int)sdhcinfo->oob_irq, (int)sdhcinfo->oob_flags));
+		/* Refer to customer Host IRQ docs about
+			 proper irqflags definition */
+		error =
+		    request_irq(sdhcinfo->oob_irq, wlan_oob_irq,
+				sdhcinfo->oob_flags, "bcmsdh_sdmmc", NULL);
+		if (error)
+			return -ENODEV;
+
+		set_irq_wake(sdhcinfo->oob_irq, 1);
+		sdhcinfo->oob_irq_registered = true;
+	}
+
+	return 0;
+}
+
+void bcmsdh_unregister_oob_intr(void)
+{
+	SDLX_MSG(("%s: Enter\n", __func__));
+
+	set_irq_wake(sdhcinfo->oob_irq, 0);
+	disable_irq(sdhcinfo->oob_irq);	/* just in case.. */
+	free_irq(sdhcinfo->oob_irq, NULL);
+	sdhcinfo->oob_irq_registered = false;
+}
+#endif				/* defined(OOB_INTR_ONLY) */
+/* Module parameters specific to each host-controller driver */
+
+extern uint sd_msglevel;	/* Debug message level */
+module_param(sd_msglevel, uint, 0);
+
+extern uint sd_power;		/* 0 = SD Power OFF,
+					 1 = SD Power ON. */
+module_param(sd_power, uint, 0);
+
+extern uint sd_clock;		/* SD Clock Control, 0 = SD Clock OFF,
+				 1 = SD Clock ON */
+module_param(sd_clock, uint, 0);
+
+extern uint sd_divisor;		/* Divisor (-1 means external clock) */
+module_param(sd_divisor, uint, 0);
+
+extern uint sd_sdmode;		/* Default is SD4, 0=SPI, 1=SD1, 2=SD4 */
+module_param(sd_sdmode, uint, 0);
+
+extern uint sd_hiok;		/* Ok to use hi-speed mode */
+module_param(sd_hiok, uint, 0);
+
+extern uint sd_f2_blocksize;
+module_param(sd_f2_blocksize, int, 0);
diff --git a/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c b/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c
new file mode 100644
index 0000000..f6c9c45
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c
@@ -0,0 +1,1238 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linux/types.h>
+#include <bcmdefs.h>
+#include <bcmdevs.h>
+#include <bcmendian.h>
+#include <bcmutils.h>
+#include <osl.h>
+#include <sdio.h>		/* SDIO Device and Protocol Specs */
+#include <sdioh.h>		/* SDIO Host Controller Specification */
+#include <bcmsdbus.h>		/* bcmsdh to/from specific controller APIs */
+#include <sdiovar.h>		/* ioctl/iovars */
+
+#include <linux/mmc/core.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+
+#include <dngl_stats.h>
+#include <dhd.h>
+
+#if defined(CONFIG_PM_SLEEP)
+#include <linux/suspend.h>
+extern volatile bool dhd_mmc_suspend;
+#endif
+#include "bcmsdh_sdmmc.h"
+
+extern int sdio_function_init(void);
+extern void sdio_function_cleanup(void);
+
+#if !defined(OOB_INTR_ONLY)
+static void IRQHandler(struct sdio_func *func);
+static void IRQHandlerF2(struct sdio_func *func);
+#endif				/* !defined(OOB_INTR_ONLY) */
+static int sdioh_sdmmc_get_cisaddr(sdioh_info_t *sd, u32 regaddr);
+extern int sdio_reset_comm(struct mmc_card *card);
+
+extern PBCMSDH_SDMMC_INSTANCE gInstance;
+
+uint sd_sdmode = SDIOH_MODE_SD4;	/* Use SD4 mode by default */
+uint sd_f2_blocksize = 512;	/* Default blocksize */
+
+uint sd_divisor = 2;		/* Default 48MHz/2 = 24MHz */
+
+uint sd_power = 1;		/* Default to SD Slot powered ON */
+uint sd_clock = 1;		/* Default to SD Clock turned ON */
+uint sd_hiok = false;		/* Don't use hi-speed mode by default */
+uint sd_msglevel = 0x01;
+uint sd_use_dma = true;
+DHD_PM_RESUME_WAIT_INIT(sdioh_request_byte_wait);
+DHD_PM_RESUME_WAIT_INIT(sdioh_request_word_wait);
+DHD_PM_RESUME_WAIT_INIT(sdioh_request_packet_wait);
+DHD_PM_RESUME_WAIT_INIT(sdioh_request_buffer_wait);
+
+#define DMA_ALIGN_MASK	0x03
+
+int sdioh_sdmmc_card_regread(sdioh_info_t *sd, int func, u32 regaddr,
+			     int regsize, u32 *data);
+
+static int sdioh_sdmmc_card_enablefuncs(sdioh_info_t *sd)
+{
+	int err_ret;
+	u32 fbraddr;
+	u8 func;
+
+	sd_trace(("%s\n", __func__));
+
+	/* Get the Card's common CIS address */
+	sd->com_cis_ptr = sdioh_sdmmc_get_cisaddr(sd, SDIOD_CCCR_CISPTR_0);
+	sd->func_cis_ptr[0] = sd->com_cis_ptr;
+	sd_info(("%s: Card's Common CIS Ptr = 0x%x\n", __func__,
+		 sd->com_cis_ptr));
+
+	/* Get the Card's function CIS (for each function) */
+	for (fbraddr = SDIOD_FBR_STARTADDR, func = 1;
+	     func <= sd->num_funcs; func++, fbraddr += SDIOD_FBR_SIZE) {
+		sd->func_cis_ptr[func] =
+		    sdioh_sdmmc_get_cisaddr(sd, SDIOD_FBR_CISPTR_0 + fbraddr);
+		sd_info(("%s: Function %d CIS Ptr = 0x%x\n", __func__, func,
+			 sd->func_cis_ptr[func]));
+	}
+
+	sd->func_cis_ptr[0] = sd->com_cis_ptr;
+	sd_info(("%s: Card's Common CIS Ptr = 0x%x\n", __func__,
+		 sd->com_cis_ptr));
+
+	/* Enable Function 1 */
+	sdio_claim_host(gInstance->func[1]);
+	err_ret = sdio_enable_func(gInstance->func[1]);
+	sdio_release_host(gInstance->func[1]);
+	if (err_ret) {
+		sd_err(("bcmsdh_sdmmc: Failed to enable F1 Err: 0x%08x",
+			err_ret));
+	}
+
+	return false;
+}
+
+/*
+ *	Public entry points & extern's
+ */
+extern sdioh_info_t *sdioh_attach(osl_t *osh, void *bar0, uint irq)
+{
+	sdioh_info_t *sd;
+	int err_ret;
+
+	sd_trace(("%s\n", __func__));
+
+	if (gInstance == NULL) {
+		sd_err(("%s: SDIO Device not present\n", __func__));
+		return NULL;
+	}
+
+	sd = kzalloc(sizeof(sdioh_info_t), GFP_ATOMIC);
+	if (sd == NULL) {
+		sd_err(("sdioh_attach: out of memory\n"));
+		return NULL;
+	}
+	sd->osh = osh;
+	if (sdioh_sdmmc_osinit(sd) != 0) {
+		sd_err(("%s:sdioh_sdmmc_osinit() failed\n", __func__));
+		kfree(sd);
+		return NULL;
+	}
+
+	sd->num_funcs = 2;
+	sd->sd_blockmode = true;
+	sd->use_client_ints = true;
+	sd->client_block_size[0] = 64;
+
+	gInstance->sd = sd;
+
+	/* Claim host controller */
+	sdio_claim_host(gInstance->func[1]);
+
+	sd->client_block_size[1] = 64;
+	err_ret = sdio_set_block_size(gInstance->func[1], 64);
+	if (err_ret)
+		sd_err(("bcmsdh_sdmmc: Failed to set F1 blocksize\n"));
+
+	/* Release host controller F1 */
+	sdio_release_host(gInstance->func[1]);
+
+	if (gInstance->func[2]) {
+		/* Claim host controller F2 */
+		sdio_claim_host(gInstance->func[2]);
+
+		sd->client_block_size[2] = sd_f2_blocksize;
+		err_ret =
+		    sdio_set_block_size(gInstance->func[2], sd_f2_blocksize);
+		if (err_ret)
+			sd_err(("bcmsdh_sdmmc: Failed to set F2 blocksize "
+				"to %d\n", sd_f2_blocksize));
+
+		/* Release host controller F2 */
+		sdio_release_host(gInstance->func[2]);
+	}
+
+	sdioh_sdmmc_card_enablefuncs(sd);
+
+	sd_trace(("%s: Done\n", __func__));
+	return sd;
+}
+
+extern SDIOH_API_RC sdioh_detach(osl_t *osh, sdioh_info_t *sd)
+{
+	sd_trace(("%s\n", __func__));
+
+	if (sd) {
+
+		/* Disable Function 2 */
+		sdio_claim_host(gInstance->func[2]);
+		sdio_disable_func(gInstance->func[2]);
+		sdio_release_host(gInstance->func[2]);
+
+		/* Disable Function 1 */
+		sdio_claim_host(gInstance->func[1]);
+		sdio_disable_func(gInstance->func[1]);
+		sdio_release_host(gInstance->func[1]);
+
+		/* deregister irq */
+		sdioh_sdmmc_osfree(sd);
+
+		kfree(sd);
+	}
+	return SDIOH_API_RC_SUCCESS;
+}
+
+#if defined(OOB_INTR_ONLY) && defined(HW_OOB)
+
+extern SDIOH_API_RC sdioh_enable_func_intr(void)
+{
+	u8 reg;
+	int err;
+
+	if (gInstance->func[0]) {
+		sdio_claim_host(gInstance->func[0]);
+
+		reg = sdio_readb(gInstance->func[0], SDIOD_CCCR_INTEN, &err);
+		if (err) {
+			sd_err(("%s: error for read SDIO_CCCR_IENx : 0x%x\n",
+				__func__, err));
+			sdio_release_host(gInstance->func[0]);
+			return SDIOH_API_RC_FAIL;
+		}
+
+		/* Enable F1 and F2 interrupts, set master enable */
+		reg |=
+		    (INTR_CTL_FUNC1_EN | INTR_CTL_FUNC2_EN |
+		     INTR_CTL_MASTER_EN);
+
+		sdio_writeb(gInstance->func[0], reg, SDIOD_CCCR_INTEN, &err);
+		sdio_release_host(gInstance->func[0]);
+
+		if (err) {
+			sd_err(("%s: error for write SDIO_CCCR_IENx : 0x%x\n",
+				__func__, err));
+			return SDIOH_API_RC_FAIL;
+		}
+	}
+
+	return SDIOH_API_RC_SUCCESS;
+}
+
+extern SDIOH_API_RC sdioh_disable_func_intr(void)
+{
+	u8 reg;
+	int err;
+
+	if (gInstance->func[0]) {
+		sdio_claim_host(gInstance->func[0]);
+		reg = sdio_readb(gInstance->func[0], SDIOD_CCCR_INTEN, &err);
+		if (err) {
+			sd_err(("%s: error for read SDIO_CCCR_IENx : 0x%x\n",
+				__func__, err));
+			sdio_release_host(gInstance->func[0]);
+			return SDIOH_API_RC_FAIL;
+		}
+
+		reg &= ~(INTR_CTL_FUNC1_EN | INTR_CTL_FUNC2_EN);
+		/* Disable master interrupt with the last function interrupt */
+		if (!(reg & 0xFE))
+			reg = 0;
+		sdio_writeb(gInstance->func[0], reg, SDIOD_CCCR_INTEN, &err);
+
+		sdio_release_host(gInstance->func[0]);
+		if (err) {
+			sd_err(("%s: error for write SDIO_CCCR_IENx : 0x%x\n",
+				__func__, err));
+			return SDIOH_API_RC_FAIL;
+		}
+	}
+	return SDIOH_API_RC_SUCCESS;
+}
+#endif				/* defined(OOB_INTR_ONLY) && defined(HW_OOB) */
+
+/* Configure callback to client when we recieve client interrupt */
+extern SDIOH_API_RC
+sdioh_interrupt_register(sdioh_info_t *sd, sdioh_cb_fn_t fn, void *argh)
+{
+	sd_trace(("%s: Entering\n", __func__));
+	if (fn == NULL) {
+		sd_err(("%s: interrupt handler is NULL, not registering\n",
+			__func__));
+		return SDIOH_API_RC_FAIL;
+	}
+#if !defined(OOB_INTR_ONLY)
+	sd->intr_handler = fn;
+	sd->intr_handler_arg = argh;
+	sd->intr_handler_valid = true;
+
+	/* register and unmask irq */
+	if (gInstance->func[2]) {
+		sdio_claim_host(gInstance->func[2]);
+		sdio_claim_irq(gInstance->func[2], IRQHandlerF2);
+		sdio_release_host(gInstance->func[2]);
+	}
+
+	if (gInstance->func[1]) {
+		sdio_claim_host(gInstance->func[1]);
+		sdio_claim_irq(gInstance->func[1], IRQHandler);
+		sdio_release_host(gInstance->func[1]);
+	}
+#elif defined(HW_OOB)
+	sdioh_enable_func_intr();
+#endif				/* defined(OOB_INTR_ONLY) */
+	return SDIOH_API_RC_SUCCESS;
+}
+
+extern SDIOH_API_RC sdioh_interrupt_deregister(sdioh_info_t *sd)
+{
+	sd_trace(("%s: Entering\n", __func__));
+
+#if !defined(OOB_INTR_ONLY)
+	if (gInstance->func[1]) {
+		/* register and unmask irq */
+		sdio_claim_host(gInstance->func[1]);
+		sdio_release_irq(gInstance->func[1]);
+		sdio_release_host(gInstance->func[1]);
+	}
+
+	if (gInstance->func[2]) {
+		/* Claim host controller F2 */
+		sdio_claim_host(gInstance->func[2]);
+		sdio_release_irq(gInstance->func[2]);
+		/* Release host controller F2 */
+		sdio_release_host(gInstance->func[2]);
+	}
+
+	sd->intr_handler_valid = false;
+	sd->intr_handler = NULL;
+	sd->intr_handler_arg = NULL;
+#elif defined(HW_OOB)
+	sdioh_disable_func_intr();
+#endif				/*  !defined(OOB_INTR_ONLY) */
+	return SDIOH_API_RC_SUCCESS;
+}
+
+extern SDIOH_API_RC sdioh_interrupt_query(sdioh_info_t *sd, bool *onoff)
+{
+	sd_trace(("%s: Entering\n", __func__));
+	*onoff = sd->client_intr_enabled;
+	return SDIOH_API_RC_SUCCESS;
+}
+
+#if defined(DHD_DEBUG)
+extern bool sdioh_interrupt_pending(sdioh_info_t *sd)
+{
+	return 0;
+}
+#endif
+
+uint sdioh_query_iofnum(sdioh_info_t *sd)
+{
+	return sd->num_funcs;
+}
+
+/* IOVar table */
+enum {
+	IOV_MSGLEVEL = 1,
+	IOV_BLOCKMODE,
+	IOV_BLOCKSIZE,
+	IOV_DMA,
+	IOV_USEINTS,
+	IOV_NUMINTS,
+	IOV_NUMLOCALINTS,
+	IOV_HOSTREG,
+	IOV_DEVREG,
+	IOV_DIVISOR,
+	IOV_SDMODE,
+	IOV_HISPEED,
+	IOV_HCIREGS,
+	IOV_POWER,
+	IOV_CLOCK,
+	IOV_RXCHAIN
+};
+
+const bcm_iovar_t sdioh_iovars[] = {
+	{"sd_msglevel", IOV_MSGLEVEL, 0, IOVT_UINT32, 0},
+	{"sd_blockmode", IOV_BLOCKMODE, 0, IOVT_BOOL, 0},
+	{"sd_blocksize", IOV_BLOCKSIZE, 0, IOVT_UINT32, 0},/* ((fn << 16) |
+								 size) */
+	{"sd_dma", IOV_DMA, 0, IOVT_BOOL, 0},
+	{"sd_ints", IOV_USEINTS, 0, IOVT_BOOL, 0},
+	{"sd_numints", IOV_NUMINTS, 0, IOVT_UINT32, 0},
+	{"sd_numlocalints", IOV_NUMLOCALINTS, 0, IOVT_UINT32, 0},
+	{"sd_hostreg", IOV_HOSTREG, 0, IOVT_BUFFER, sizeof(sdreg_t)}
+	,
+	{"sd_devreg", IOV_DEVREG, 0, IOVT_BUFFER, sizeof(sdreg_t)}
+	,
+	{"sd_divisor", IOV_DIVISOR, 0, IOVT_UINT32, 0}
+	,
+	{"sd_power", IOV_POWER, 0, IOVT_UINT32, 0}
+	,
+	{"sd_clock", IOV_CLOCK, 0, IOVT_UINT32, 0}
+	,
+	{"sd_mode", IOV_SDMODE, 0, IOVT_UINT32, 100}
+	,
+	{"sd_highspeed", IOV_HISPEED, 0, IOVT_UINT32, 0}
+	,
+	{"sd_rxchain", IOV_RXCHAIN, 0, IOVT_BOOL, 0}
+	,
+	{NULL, 0, 0, 0, 0}
+};
+
+int
+sdioh_iovar_op(sdioh_info_t *si, const char *name,
+	       void *params, int plen, void *arg, int len, bool set)
+{
+	const bcm_iovar_t *vi = NULL;
+	int bcmerror = 0;
+	int val_size;
+	s32 int_val = 0;
+	bool bool_val;
+	u32 actionid;
+
+	ASSERT(name);
+	ASSERT(len >= 0);
+
+	/* Get must have return space; Set does not take qualifiers */
+	ASSERT(set || (arg && len));
+	ASSERT(!set || (!params && !plen));
+
+	sd_trace(("%s: Enter (%s %s)\n", __func__, (set ? "set" : "get"),
+		  name));
+
+	vi = bcm_iovar_lookup(sdioh_iovars, name);
+	if (vi == NULL) {
+		bcmerror = BCME_UNSUPPORTED;
+		goto exit;
+	}
+
+	bcmerror = bcm_iovar_lencheck(vi, arg, len, set);
+	if (bcmerror != 0)
+		goto exit;
+
+	/* Set up params so get and set can share the convenience variables */
+	if (params == NULL) {
+		params = arg;
+		plen = len;
+	}
+
+	if (vi->type == IOVT_VOID)
+		val_size = 0;
+	else if (vi->type == IOVT_BUFFER)
+		val_size = len;
+	else
+		val_size = sizeof(int);
+
+	if (plen >= (int)sizeof(int_val))
+		bcopy(params, &int_val, sizeof(int_val));
+
+	bool_val = (int_val != 0) ? true : false;
+
+	actionid = set ? IOV_SVAL(vi->varid) : IOV_GVAL(vi->varid);
+	switch (actionid) {
+	case IOV_GVAL(IOV_MSGLEVEL):
+		int_val = (s32) sd_msglevel;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_MSGLEVEL):
+		sd_msglevel = int_val;
+		break;
+
+	case IOV_GVAL(IOV_BLOCKMODE):
+		int_val = (s32) si->sd_blockmode;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_BLOCKMODE):
+		si->sd_blockmode = (bool) int_val;
+		/* Haven't figured out how to make non-block mode with DMA */
+		break;
+
+	case IOV_GVAL(IOV_BLOCKSIZE):
+		if ((u32) int_val > si->num_funcs) {
+			bcmerror = BCME_BADARG;
+			break;
+		}
+		int_val = (s32) si->client_block_size[int_val];
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_BLOCKSIZE):
+		{
+			uint func = ((u32) int_val >> 16);
+			uint blksize = (u16) int_val;
+			uint maxsize;
+
+			if (func > si->num_funcs) {
+				bcmerror = BCME_BADARG;
+				break;
+			}
+
+			switch (func) {
+			case 0:
+				maxsize = 32;
+				break;
+			case 1:
+				maxsize = BLOCK_SIZE_4318;
+				break;
+			case 2:
+				maxsize = BLOCK_SIZE_4328;
+				break;
+			default:
+				maxsize = 0;
+			}
+			if (blksize > maxsize) {
+				bcmerror = BCME_BADARG;
+				break;
+			}
+			if (!blksize)
+				blksize = maxsize;
+
+			/* Now set it */
+			si->client_block_size[func] = blksize;
+
+			break;
+		}
+
+	case IOV_GVAL(IOV_RXCHAIN):
+		int_val = false;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_GVAL(IOV_DMA):
+		int_val = (s32) si->sd_use_dma;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_DMA):
+		si->sd_use_dma = (bool) int_val;
+		break;
+
+	case IOV_GVAL(IOV_USEINTS):
+		int_val = (s32) si->use_client_ints;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_USEINTS):
+		si->use_client_ints = (bool) int_val;
+		if (si->use_client_ints)
+			si->intmask |= CLIENT_INTR;
+		else
+			si->intmask &= ~CLIENT_INTR;
+
+		break;
+
+	case IOV_GVAL(IOV_DIVISOR):
+		int_val = (u32) sd_divisor;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_DIVISOR):
+		sd_divisor = int_val;
+		break;
+
+	case IOV_GVAL(IOV_POWER):
+		int_val = (u32) sd_power;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_POWER):
+		sd_power = int_val;
+		break;
+
+	case IOV_GVAL(IOV_CLOCK):
+		int_val = (u32) sd_clock;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_CLOCK):
+		sd_clock = int_val;
+		break;
+
+	case IOV_GVAL(IOV_SDMODE):
+		int_val = (u32) sd_sdmode;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_SDMODE):
+		sd_sdmode = int_val;
+		break;
+
+	case IOV_GVAL(IOV_HISPEED):
+		int_val = (u32) sd_hiok;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_HISPEED):
+		sd_hiok = int_val;
+		break;
+
+	case IOV_GVAL(IOV_NUMINTS):
+		int_val = (s32) si->intrcount;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_GVAL(IOV_NUMLOCALINTS):
+		int_val = (s32) 0;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_GVAL(IOV_HOSTREG):
+		{
+			sdreg_t *sd_ptr = (sdreg_t *) params;
+
+			if (sd_ptr->offset < SD_SysAddr
+			    || sd_ptr->offset > SD_MaxCurCap) {
+				sd_err(("%s: bad offset 0x%x\n", __func__,
+					sd_ptr->offset));
+				bcmerror = BCME_BADARG;
+				break;
+			}
+
+			sd_trace(("%s: rreg%d at offset %d\n", __func__,
+				  (sd_ptr->offset & 1) ? 8
+				  : ((sd_ptr->offset & 2) ? 16 : 32),
+				  sd_ptr->offset));
+			if (sd_ptr->offset & 1)
+				int_val = 8;	/* sdioh_sdmmc_rreg8(si,
+						 sd_ptr->offset); */
+			else if (sd_ptr->offset & 2)
+				int_val = 16;	/* sdioh_sdmmc_rreg16(si,
+						 sd_ptr->offset); */
+			else
+				int_val = 32;	/* sdioh_sdmmc_rreg(si,
+						 sd_ptr->offset); */
+
+			bcopy(&int_val, arg, sizeof(int_val));
+			break;
+		}
+
+	case IOV_SVAL(IOV_HOSTREG):
+		{
+			sdreg_t *sd_ptr = (sdreg_t *) params;
+
+			if (sd_ptr->offset < SD_SysAddr
+			    || sd_ptr->offset > SD_MaxCurCap) {
+				sd_err(("%s: bad offset 0x%x\n", __func__,
+					sd_ptr->offset));
+				bcmerror = BCME_BADARG;
+				break;
+			}
+
+			sd_trace(("%s: wreg%d value 0x%08x at offset %d\n",
+				  __func__, sd_ptr->value,
+				  (sd_ptr->offset & 1) ? 8
+				  : ((sd_ptr->offset & 2) ? 16 : 32),
+				  sd_ptr->offset));
+			break;
+		}
+
+	case IOV_GVAL(IOV_DEVREG):
+		{
+			sdreg_t *sd_ptr = (sdreg_t *) params;
+			u8 data = 0;
+
+			if (sdioh_cfg_read
+			    (si, sd_ptr->func, sd_ptr->offset, &data)) {
+				bcmerror = BCME_SDIO_ERROR;
+				break;
+			}
+
+			int_val = (int)data;
+			bcopy(&int_val, arg, sizeof(int_val));
+			break;
+		}
+
+	case IOV_SVAL(IOV_DEVREG):
+		{
+			sdreg_t *sd_ptr = (sdreg_t *) params;
+			u8 data = (u8) sd_ptr->value;
+
+			if (sdioh_cfg_write
+			    (si, sd_ptr->func, sd_ptr->offset, &data)) {
+				bcmerror = BCME_SDIO_ERROR;
+				break;
+			}
+			break;
+		}
+
+	default:
+		bcmerror = BCME_UNSUPPORTED;
+		break;
+	}
+exit:
+
+	return bcmerror;
+}
+
+#if defined(OOB_INTR_ONLY) && defined(HW_OOB)
+
+SDIOH_API_RC sdioh_enable_hw_oob_intr(sdioh_info_t *sd, bool enable)
+{
+	SDIOH_API_RC status;
+	u8 data;
+
+	if (enable)
+		data = 3;	/* enable hw oob interrupt */
+	else
+		data = 4;	/* disable hw oob interrupt */
+	data |= 4;		/* Active HIGH */
+
+	status = sdioh_request_byte(sd, SDIOH_WRITE, 0, 0xf2, &data);
+	return status;
+}
+#endif				/* defined(OOB_INTR_ONLY) && defined(HW_OOB) */
+
+extern SDIOH_API_RC
+sdioh_cfg_read(sdioh_info_t *sd, uint fnc_num, u32 addr, u8 *data)
+{
+	SDIOH_API_RC status;
+	/* No lock needed since sdioh_request_byte does locking */
+	status = sdioh_request_byte(sd, SDIOH_READ, fnc_num, addr, data);
+	return status;
+}
+
+extern SDIOH_API_RC
+sdioh_cfg_write(sdioh_info_t *sd, uint fnc_num, u32 addr, u8 *data)
+{
+	/* No lock needed since sdioh_request_byte does locking */
+	SDIOH_API_RC status;
+	status = sdioh_request_byte(sd, SDIOH_WRITE, fnc_num, addr, data);
+	return status;
+}
+
+static int sdioh_sdmmc_get_cisaddr(sdioh_info_t *sd, u32 regaddr)
+{
+	/* read 24 bits and return valid 17 bit addr */
+	int i;
+	u32 scratch, regdata;
+	u8 *ptr = (u8 *)&scratch;
+	for (i = 0; i < 3; i++) {
+		if ((sdioh_sdmmc_card_regread(sd, 0, regaddr, 1, &regdata)) !=
+		    SUCCESS)
+			sd_err(("%s: Can't read!\n", __func__));
+
+		*ptr++ = (u8) regdata;
+		regaddr++;
+	}
+
+	/* Only the lower 17-bits are valid */
+	scratch = ltoh32(scratch);
+	scratch &= 0x0001FFFF;
+	return scratch;
+}
+
+extern SDIOH_API_RC
+sdioh_cis_read(sdioh_info_t *sd, uint func, u8 *cisd, u32 length)
+{
+	u32 count;
+	int offset;
+	u32 foo;
+	u8 *cis = cisd;
+
+	sd_trace(("%s: Func = %d\n", __func__, func));
+
+	if (!sd->func_cis_ptr[func]) {
+		bzero(cis, length);
+		sd_err(("%s: no func_cis_ptr[%d]\n", __func__, func));
+		return SDIOH_API_RC_FAIL;
+	}
+
+	sd_err(("%s: func_cis_ptr[%d]=0x%04x\n", __func__, func,
+		sd->func_cis_ptr[func]));
+
+	for (count = 0; count < length; count++) {
+		offset = sd->func_cis_ptr[func] + count;
+		if (sdioh_sdmmc_card_regread(sd, 0, offset, 1, &foo) < 0) {
+			sd_err(("%s: regread failed: Can't read CIS\n",
+				__func__));
+			return SDIOH_API_RC_FAIL;
+		}
+
+		*cis = (u8) (foo & 0xff);
+		cis++;
+	}
+
+	return SDIOH_API_RC_SUCCESS;
+}
+
+extern SDIOH_API_RC
+sdioh_request_byte(sdioh_info_t *sd, uint rw, uint func, uint regaddr,
+		   u8 *byte)
+{
+	int err_ret;
+
+	sd_info(("%s: rw=%d, func=%d, addr=0x%05x\n", __func__, rw, func,
+		 regaddr));
+
+	DHD_PM_RESUME_WAIT(sdioh_request_byte_wait);
+	DHD_PM_RESUME_RETURN_ERROR(SDIOH_API_RC_FAIL);
+	if (rw) {		/* CMD52 Write */
+		if (func == 0) {
+			/* Can only directly write to some F0 registers.
+			 * Handle F2 enable
+			 * as a special case.
+			 */
+			if (regaddr == SDIOD_CCCR_IOEN) {
+				if (gInstance->func[2]) {
+					sdio_claim_host(gInstance->func[2]);
+					if (*byte & SDIO_FUNC_ENABLE_2) {
+						/* Enable Function 2 */
+						err_ret =
+						    sdio_enable_func
+						    (gInstance->func[2]);
+						if (err_ret)
+							sd_err(("bcmsdh_sdmmc: enable F2 failed:%d",
+								 err_ret));
+					} else {
+						/* Disable Function 2 */
+						err_ret =
+						    sdio_disable_func
+						    (gInstance->func[2]);
+						if (err_ret)
+							sd_err(("bcmsdh_sdmmc: Disab F2 failed:%d",
+								 err_ret));
+					}
+					sdio_release_host(gInstance->func[2]);
+				}
+			}
+#if defined(MMC_SDIO_ABORT)
+			/* to allow abort command through F1 */
+			else if (regaddr == SDIOD_CCCR_IOABORT) {
+				sdio_claim_host(gInstance->func[func]);
+				/*
+				 * this sdio_f0_writeb() can be replaced
+				 * with another api
+				 * depending upon MMC driver change.
+				 * As of this time, this is temporaray one
+				 */
+				sdio_writeb(gInstance->func[func], *byte,
+					    regaddr, &err_ret);
+				sdio_release_host(gInstance->func[func]);
+			}
+#endif				/* MMC_SDIO_ABORT */
+			else if (regaddr < 0xF0) {
+				sd_err(("bcmsdh_sdmmc: F0 Wr:0x%02x: write "
+					"disallowed\n", regaddr));
+			} else {
+				/* Claim host controller, perform F0 write,
+				 and release */
+				sdio_claim_host(gInstance->func[func]);
+				sdio_f0_writeb(gInstance->func[func], *byte,
+					       regaddr, &err_ret);
+				sdio_release_host(gInstance->func[func]);
+			}
+		} else {
+			/* Claim host controller, perform Fn write,
+			 and release */
+			sdio_claim_host(gInstance->func[func]);
+			sdio_writeb(gInstance->func[func], *byte, regaddr,
+				    &err_ret);
+			sdio_release_host(gInstance->func[func]);
+		}
+	} else {		/* CMD52 Read */
+		/* Claim host controller, perform Fn read, and release */
+		sdio_claim_host(gInstance->func[func]);
+
+		if (func == 0) {
+			*byte =
+			    sdio_f0_readb(gInstance->func[func], regaddr,
+					  &err_ret);
+		} else {
+			*byte =
+			    sdio_readb(gInstance->func[func], regaddr,
+				       &err_ret);
+		}
+
+		sdio_release_host(gInstance->func[func]);
+	}
+
+	if (err_ret)
+		sd_err(("bcmsdh_sdmmc: Failed to %s byte F%d:@0x%05x=%02x, "
+			"Err: %d\n", rw ? "Write" : "Read", func, regaddr,
+			*byte, err_ret));
+
+	return ((err_ret == 0) ? SDIOH_API_RC_SUCCESS : SDIOH_API_RC_FAIL);
+}
+
+extern SDIOH_API_RC
+sdioh_request_word(sdioh_info_t *sd, uint cmd_type, uint rw, uint func,
+		   uint addr, u32 *word, uint nbytes)
+{
+	int err_ret = SDIOH_API_RC_FAIL;
+
+	if (func == 0) {
+		sd_err(("%s: Only CMD52 allowed to F0.\n", __func__));
+		return SDIOH_API_RC_FAIL;
+	}
+
+	sd_info(("%s: cmd_type=%d, rw=%d, func=%d, addr=0x%05x, nbytes=%d\n",
+		 __func__, cmd_type, rw, func, addr, nbytes));
+
+	DHD_PM_RESUME_WAIT(sdioh_request_word_wait);
+	DHD_PM_RESUME_RETURN_ERROR(SDIOH_API_RC_FAIL);
+	/* Claim host controller */
+	sdio_claim_host(gInstance->func[func]);
+
+	if (rw) {		/* CMD52 Write */
+		if (nbytes == 4) {
+			sdio_writel(gInstance->func[func], *word, addr,
+				    &err_ret);
+		} else if (nbytes == 2) {
+			sdio_writew(gInstance->func[func], (*word & 0xFFFF),
+				    addr, &err_ret);
+		} else {
+			sd_err(("%s: Invalid nbytes: %d\n", __func__, nbytes));
+		}
+	} else {		/* CMD52 Read */
+		if (nbytes == 4) {
+			*word =
+			    sdio_readl(gInstance->func[func], addr, &err_ret);
+		} else if (nbytes == 2) {
+			*word =
+			    sdio_readw(gInstance->func[func], addr,
+				       &err_ret) & 0xFFFF;
+		} else {
+			sd_err(("%s: Invalid nbytes: %d\n", __func__, nbytes));
+		}
+	}
+
+	/* Release host controller */
+	sdio_release_host(gInstance->func[func]);
+
+	if (err_ret) {
+		sd_err(("bcmsdh_sdmmc: Failed to %s word, Err: 0x%08x",
+			rw ? "Write" : "Read", err_ret));
+	}
+
+	return ((err_ret == 0) ? SDIOH_API_RC_SUCCESS : SDIOH_API_RC_FAIL);
+}
+
+static SDIOH_API_RC
+sdioh_request_packet(sdioh_info_t *sd, uint fix_inc, uint write, uint func,
+		     uint addr, void *pkt)
+{
+	bool fifo = (fix_inc == SDIOH_DATA_FIX);
+	u32 SGCount = 0;
+	int err_ret = 0;
+
+	void *pnext;
+
+	sd_trace(("%s: Enter\n", __func__));
+
+	ASSERT(pkt);
+	DHD_PM_RESUME_WAIT(sdioh_request_packet_wait);
+	DHD_PM_RESUME_RETURN_ERROR(SDIOH_API_RC_FAIL);
+
+	/* Claim host controller */
+	sdio_claim_host(gInstance->func[func]);
+	for (pnext = pkt; pnext; pnext = PKTNEXT(pnext)) {
+		uint pkt_len = PKTLEN(pnext);
+		pkt_len += 3;
+		pkt_len &= 0xFFFFFFFC;
+
+#ifdef CONFIG_MMC_MSM7X00A
+		if ((pkt_len % 64) == 32) {
+			sd_trace(("%s: Rounding up TX packet +=32\n",
+				  __func__));
+			pkt_len += 32;
+		}
+#endif				/* CONFIG_MMC_MSM7X00A */
+		/* Make sure the packet is aligned properly.
+		 * If it isn't, then this
+		 * is the fault of sdioh_request_buffer() which
+		 * is supposed to give
+		 * us something we can work with.
+		 */
+		ASSERT(((u32) (PKTDATA(pkt)) & DMA_ALIGN_MASK) == 0);
+
+		if ((write) && (!fifo)) {
+			err_ret = sdio_memcpy_toio(gInstance->func[func], addr,
+						   ((u8 *) PKTDATA(pnext)),
+						   pkt_len);
+		} else if (write) {
+			err_ret = sdio_memcpy_toio(gInstance->func[func], addr,
+						   ((u8 *) PKTDATA(pnext)),
+						   pkt_len);
+		} else if (fifo) {
+			err_ret = sdio_readsb(gInstance->func[func],
+					      ((u8 *) PKTDATA(pnext)),
+					      addr, pkt_len);
+		} else {
+			err_ret = sdio_memcpy_fromio(gInstance->func[func],
+						     ((u8 *) PKTDATA(pnext)),
+						     addr, pkt_len);
+		}
+
+		if (err_ret) {
+			sd_err(("%s: %s FAILED %p[%d], addr=0x%05x, pkt_len=%d,"
+				 "ERR=0x%08x\n", __func__,
+				 (write) ? "TX" : "RX",
+				 pnext, SGCount, addr, pkt_len, err_ret));
+		} else {
+			sd_trace(("%s: %s xfr'd %p[%d], addr=0x%05x, len=%d\n",
+				  __func__,
+				  (write) ? "TX" : "RX",
+				  pnext, SGCount, addr, pkt_len));
+		}
+
+		if (!fifo)
+			addr += pkt_len;
+		SGCount++;
+
+	}
+
+	/* Release host controller */
+	sdio_release_host(gInstance->func[func]);
+
+	sd_trace(("%s: Exit\n", __func__));
+	return ((err_ret == 0) ? SDIOH_API_RC_SUCCESS : SDIOH_API_RC_FAIL);
+}
+
+/*
+ * This function takes a buffer or packet, and fixes everything up
+ * so that in the
+ * end, a DMA-able packet is created.
+ *
+ * A buffer does not have an associated packet pointer,
+ * and may or may not be aligned.
+ * A packet may consist of a single packet, or a packet chain.
+ * If it is a packet chain,
+ * then all the packets in the chain must be properly aligned.
+ * If the packet data is not
+ * aligned, then there may only be one packet, and in this case,
+ * it is copied to a new
+ * aligned packet.
+ *
+ */
+extern SDIOH_API_RC
+sdioh_request_buffer(sdioh_info_t *sd, uint pio_dma, uint fix_inc, uint write,
+		     uint func, uint addr, uint reg_width, uint buflen_u,
+		     u8 *buffer, void *pkt)
+{
+	SDIOH_API_RC Status;
+	void *mypkt = NULL;
+
+	sd_trace(("%s: Enter\n", __func__));
+
+	DHD_PM_RESUME_WAIT(sdioh_request_buffer_wait);
+	DHD_PM_RESUME_RETURN_ERROR(SDIOH_API_RC_FAIL);
+	/* Case 1: we don't have a packet. */
+	if (pkt == NULL) {
+		sd_data(("%s: Creating new %s Packet, len=%d\n",
+			 __func__, write ? "TX" : "RX", buflen_u));
+		mypkt = PKTGET(sd->osh, buflen_u, write ? true : false);
+		if (!mypkt) {
+			sd_err(("%s: PKTGET failed: len %d\n",
+				__func__, buflen_u));
+			return SDIOH_API_RC_FAIL;
+		}
+
+		/* For a write, copy the buffer data into the packet. */
+		if (write)
+			bcopy(buffer, PKTDATA(mypkt), buflen_u);
+
+		Status =
+		    sdioh_request_packet(sd, fix_inc, write, func, addr, mypkt);
+
+		/* For a read, copy the packet data back to the buffer. */
+		if (!write)
+			bcopy(PKTDATA(mypkt), buffer, buflen_u);
+
+		PKTFREE(sd->osh, mypkt, write ? true : false);
+	} else if (((u32) (PKTDATA(pkt)) & DMA_ALIGN_MASK) != 0) {
+		/* Case 2: We have a packet, but it is unaligned. */
+
+		/* In this case, we cannot have a chain. */
+		ASSERT(PKTNEXT(pkt) == NULL);
+
+		sd_data(("%s: Creating aligned %s Packet, len=%d\n",
+			 __func__, write ? "TX" : "RX", PKTLEN(pkt)));
+		mypkt = PKTGET(sd->osh, PKTLEN(pkt), write ? true : false);
+		if (!mypkt) {
+			sd_err(("%s: PKTGET failed: len %d\n",
+				__func__, PKTLEN(pkt)));
+			return SDIOH_API_RC_FAIL;
+		}
+
+		/* For a write, copy the buffer data into the packet. */
+		if (write)
+			bcopy(PKTDATA(pkt), PKTDATA(mypkt), PKTLEN(pkt));
+
+		Status =
+		    sdioh_request_packet(sd, fix_inc, write, func, addr, mypkt);
+
+		/* For a read, copy the packet data back to the buffer. */
+		if (!write)
+			bcopy(PKTDATA(mypkt), PKTDATA(pkt), PKTLEN(mypkt));
+
+		PKTFREE(sd->osh, mypkt, write ? true : false);
+	} else {		/* case 3: We have a packet and
+				 it is aligned. */
+		sd_data(("%s: Aligned %s Packet, direct DMA\n",
+			 __func__, write ? "Tx" : "Rx"));
+		Status =
+		    sdioh_request_packet(sd, fix_inc, write, func, addr, pkt);
+	}
+
+	return Status;
+}
+
+/* this function performs "abort" for both of host & device */
+extern int sdioh_abort(sdioh_info_t *sd, uint func)
+{
+#if defined(MMC_SDIO_ABORT)
+	char t_func = (char)func;
+#endif				/* defined(MMC_SDIO_ABORT) */
+	sd_trace(("%s: Enter\n", __func__));
+
+#if defined(MMC_SDIO_ABORT)
+	/* issue abort cmd52 command through F1 */
+	sdioh_request_byte(sd, SD_IO_OP_WRITE, SDIO_FUNC_0, SDIOD_CCCR_IOABORT,
+			   &t_func);
+#endif				/* defined(MMC_SDIO_ABORT) */
+
+	sd_trace(("%s: Exit\n", __func__));
+	return SDIOH_API_RC_SUCCESS;
+}
+
+/* Reset and re-initialize the device */
+int sdioh_sdio_reset(sdioh_info_t *si)
+{
+	sd_trace(("%s: Enter\n", __func__));
+	sd_trace(("%s: Exit\n", __func__));
+	return SDIOH_API_RC_SUCCESS;
+}
+
+/* Disable device interrupt */
+void sdioh_sdmmc_devintr_off(sdioh_info_t *sd)
+{
+	sd_trace(("%s: %d\n", __func__, sd->use_client_ints));
+	sd->intmask &= ~CLIENT_INTR;
+}
+
+/* Enable device interrupt */
+void sdioh_sdmmc_devintr_on(sdioh_info_t *sd)
+{
+	sd_trace(("%s: %d\n", __func__, sd->use_client_ints));
+	sd->intmask |= CLIENT_INTR;
+}
+
+/* Read client card reg */
+int
+sdioh_sdmmc_card_regread(sdioh_info_t *sd, int func, u32 regaddr,
+			 int regsize, u32 *data)
+{
+
+	if ((func == 0) || (regsize == 1)) {
+		u8 temp = 0;
+
+		sdioh_request_byte(sd, SDIOH_READ, func, regaddr, &temp);
+		*data = temp;
+		*data &= 0xff;
+		sd_data(("%s: byte read data=0x%02x\n", __func__, *data));
+	} else {
+		sdioh_request_word(sd, 0, SDIOH_READ, func, regaddr, data,
+				   regsize);
+		if (regsize == 2)
+			*data &= 0xffff;
+
+		sd_data(("%s: word read data=0x%08x\n", __func__, *data));
+	}
+
+	return SUCCESS;
+}
+
+#if !defined(OOB_INTR_ONLY)
+/* bcmsdh_sdmmc interrupt handler */
+static void IRQHandler(struct sdio_func *func)
+{
+	sdioh_info_t *sd;
+
+	sd_trace(("bcmsdh_sdmmc: ***IRQHandler\n"));
+	sd = gInstance->sd;
+
+	ASSERT(sd != NULL);
+	sdio_release_host(gInstance->func[0]);
+
+	if (sd->use_client_ints) {
+		sd->intrcount++;
+		ASSERT(sd->intr_handler);
+		ASSERT(sd->intr_handler_arg);
+		(sd->intr_handler) (sd->intr_handler_arg);
+	} else {
+		sd_err(("bcmsdh_sdmmc: ***IRQHandler\n"));
+
+		sd_err(("%s: Not ready for intr: enabled %d, handler %p\n",
+			__func__, sd->client_intr_enabled, sd->intr_handler));
+	}
+
+	sdio_claim_host(gInstance->func[0]);
+}
+
+/* bcmsdh_sdmmc interrupt handler for F2 (dummy handler) */
+static void IRQHandlerF2(struct sdio_func *func)
+{
+	sdioh_info_t *sd;
+
+	sd_trace(("bcmsdh_sdmmc: ***IRQHandlerF2\n"));
+
+	sd = gInstance->sd;
+
+	ASSERT(sd != NULL);
+}
+#endif				/* !defined(OOB_INTR_ONLY) */
+
+#ifdef NOTUSED
+/* Write client card reg */
+static int
+sdioh_sdmmc_card_regwrite(sdioh_info_t *sd, int func, u32 regaddr,
+			  int regsize, u32 data)
+{
+
+	if ((func == 0) || (regsize == 1)) {
+		u8 temp;
+
+		temp = data & 0xff;
+		sdioh_request_byte(sd, SDIOH_READ, func, regaddr, &temp);
+		sd_data(("%s: byte write data=0x%02x\n", __func__, data));
+	} else {
+		if (regsize == 2)
+			data &= 0xffff;
+
+		sdioh_request_word(sd, 0, SDIOH_READ, func, regaddr, &data,
+				   regsize);
+
+		sd_data(("%s: word write data=0x%08x\n", __func__, data));
+	}
+
+	return SUCCESS;
+}
+#endif				/* NOTUSED */
+
+int sdioh_start(sdioh_info_t *si, int stage)
+{
+	return 0;
+}
+
+int sdioh_stop(sdioh_info_t *si)
+{
+	return 0;
+}
diff --git a/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc_linux.c b/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc_linux.c
new file mode 100644
index 0000000..ae7b566
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc_linux.c
@@ -0,0 +1,231 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linux/types.h>
+#include <linux/sched.h>	/* request_irq() */
+#include <bcmdefs.h>
+#include <bcmutils.h>
+#include <sdio.h>		/* SDIO Specs */
+#include <bcmsdbus.h>		/* bcmsdh to/from specific controller APIs */
+#include <sdiovar.h>		/* to get msglevel bit values */
+
+#include <linux/mmc/core.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+
+#if !defined(SDIO_VENDOR_ID_BROADCOM)
+#define SDIO_VENDOR_ID_BROADCOM		0x02d0
+#endif				/* !defined(SDIO_VENDOR_ID_BROADCOM) */
+
+#define SDIO_DEVICE_ID_BROADCOM_DEFAULT	0x0000
+
+#if !defined(SDIO_DEVICE_ID_BROADCOM_4325_SDGWB)
+#define SDIO_DEVICE_ID_BROADCOM_4325_SDGWB	0x0492	/* BCM94325SDGWB */
+#endif		/* !defined(SDIO_DEVICE_ID_BROADCOM_4325_SDGWB) */
+#if !defined(SDIO_DEVICE_ID_BROADCOM_4325)
+#define SDIO_DEVICE_ID_BROADCOM_4325	0x0493
+#endif		/* !defined(SDIO_DEVICE_ID_BROADCOM_4325) */
+#if !defined(SDIO_DEVICE_ID_BROADCOM_4329)
+#define SDIO_DEVICE_ID_BROADCOM_4329	0x4329
+#endif		/* !defined(SDIO_DEVICE_ID_BROADCOM_4329) */
+#if !defined(SDIO_DEVICE_ID_BROADCOM_4319)
+#define SDIO_DEVICE_ID_BROADCOM_4319	0x4319
+#endif		/* !defined(SDIO_DEVICE_ID_BROADCOM_4329) */
+
+#include <bcmsdh_sdmmc.h>
+
+#include <dhd_dbg.h>
+#include <wl_cfg80211.h>
+
+extern void sdioh_sdmmc_devintr_off(sdioh_info_t *sd);
+extern void sdioh_sdmmc_devintr_on(sdioh_info_t *sd);
+
+int sdio_function_init(void);
+void sdio_function_cleanup(void);
+
+/* module param defaults */
+static int clockoverride;
+
+module_param(clockoverride, int, 0644);
+MODULE_PARM_DESC(clockoverride, "SDIO card clock override");
+
+PBCMSDH_SDMMC_INSTANCE gInstance;
+
+/* Maximum number of bcmsdh_sdmmc devices supported by driver */
+#define BCMSDH_SDMMC_MAX_DEVICES 1
+
+extern int bcmsdh_probe(struct device *dev);
+extern int bcmsdh_remove(struct device *dev);
+struct device sdmmc_dev;
+
+static int bcmsdh_sdmmc_probe(struct sdio_func *func,
+			      const struct sdio_device_id *id)
+{
+	int ret = 0;
+	static struct sdio_func sdio_func_0;
+	sd_trace(("bcmsdh_sdmmc: %s Enter\n", __func__));
+	sd_trace(("sdio_bcmsdh: func->class=%x\n", func->class));
+	sd_trace(("sdio_vendor: 0x%04x\n", func->vendor));
+	sd_trace(("sdio_device: 0x%04x\n", func->device));
+	sd_trace(("Function#: 0x%04x\n", func->num));
+
+	if (func->num == 1) {
+		sdio_func_0.num = 0;
+		sdio_func_0.card = func->card;
+		gInstance->func[0] = &sdio_func_0;
+		if (func->device == 0x4) {	/* 4318 */
+			gInstance->func[2] = NULL;
+			sd_trace(("NIC found, calling bcmsdh_probe...\n"));
+			ret = bcmsdh_probe(&sdmmc_dev);
+		}
+	}
+
+	gInstance->func[func->num] = func;
+
+	if (func->num == 2) {
+		wl_cfg80211_sdio_func(func);
+		sd_trace(("F2 found, calling bcmsdh_probe...\n"));
+		ret = bcmsdh_probe(&sdmmc_dev);
+	}
+
+	return ret;
+}
+
+static void bcmsdh_sdmmc_remove(struct sdio_func *func)
+{
+	sd_trace(("bcmsdh_sdmmc: %s Enter\n", __func__));
+	sd_info(("sdio_bcmsdh: func->class=%x\n", func->class));
+	sd_info(("sdio_vendor: 0x%04x\n", func->vendor));
+	sd_info(("sdio_device: 0x%04x\n", func->device));
+	sd_info(("Function#: 0x%04x\n", func->num));
+
+	if (func->num == 2) {
+		sd_trace(("F2 found, calling bcmsdh_remove...\n"));
+		bcmsdh_remove(&sdmmc_dev);
+	}
+}
+
+/* devices we support, null terminated */
+static const struct sdio_device_id bcmsdh_sdmmc_ids[] = {
+	{SDIO_DEVICE(SDIO_VENDOR_ID_BROADCOM, SDIO_DEVICE_ID_BROADCOM_DEFAULT)},
+	{SDIO_DEVICE
+	 (SDIO_VENDOR_ID_BROADCOM, SDIO_DEVICE_ID_BROADCOM_4325_SDGWB)},
+	{SDIO_DEVICE(SDIO_VENDOR_ID_BROADCOM, SDIO_DEVICE_ID_BROADCOM_4325)},
+	{SDIO_DEVICE(SDIO_VENDOR_ID_BROADCOM, SDIO_DEVICE_ID_BROADCOM_4329)},
+	{SDIO_DEVICE(SDIO_VENDOR_ID_BROADCOM, SDIO_DEVICE_ID_BROADCOM_4319)},
+	{ /* end: all zeroes */ },
+};
+
+MODULE_DEVICE_TABLE(sdio, bcmsdh_sdmmc_ids);
+
+static struct sdio_driver bcmsdh_sdmmc_driver = {
+	.probe = bcmsdh_sdmmc_probe,
+	.remove = bcmsdh_sdmmc_remove,
+	.name = "brcmfmac",
+	.id_table = bcmsdh_sdmmc_ids,
+};
+
+struct sdos_info {
+	sdioh_info_t *sd;
+	spinlock_t lock;
+};
+
+int sdioh_sdmmc_osinit(sdioh_info_t *sd)
+{
+	struct sdos_info *sdos;
+
+	sdos = kmalloc(sizeof(struct sdos_info), GFP_ATOMIC);
+	sd->sdos_info = (void *)sdos;
+	if (sdos == NULL)
+		return BCME_NOMEM;
+
+	sdos->sd = sd;
+	spin_lock_init(&sdos->lock);
+	return BCME_OK;
+}
+
+void sdioh_sdmmc_osfree(sdioh_info_t *sd)
+{
+	struct sdos_info *sdos;
+	ASSERT(sd && sd->sdos_info);
+
+	sdos = (struct sdos_info *)sd->sdos_info;
+	kfree(sdos);
+}
+
+/* Interrupt enable/disable */
+SDIOH_API_RC sdioh_interrupt_set(sdioh_info_t *sd, bool enable)
+{
+	unsigned long flags;
+	struct sdos_info *sdos;
+
+	sd_trace(("%s: %s\n", __func__, enable ? "Enabling" : "Disabling"));
+
+	sdos = (struct sdos_info *)sd->sdos_info;
+	ASSERT(sdos);
+
+#if !defined(OOB_INTR_ONLY)
+	if (enable && !(sd->intr_handler && sd->intr_handler_arg)) {
+		sd_err(("%s: no handler registered, will not enable\n",
+			__func__));
+		return SDIOH_API_RC_FAIL;
+	}
+#endif				/* !defined(OOB_INTR_ONLY) */
+
+	/* Ensure atomicity for enable/disable calls */
+	spin_lock_irqsave(&sdos->lock, flags);
+
+	sd->client_intr_enabled = enable;
+	if (enable)
+		sdioh_sdmmc_devintr_on(sd);
+	else
+		sdioh_sdmmc_devintr_off(sd);
+
+	spin_unlock_irqrestore(&sdos->lock, flags);
+
+	return SDIOH_API_RC_SUCCESS;
+}
+
+/*
+ * module init
+*/
+int sdio_function_init(void)
+{
+	int error = 0;
+	sd_trace(("bcmsdh_sdmmc: %s Enter\n", __func__));
+
+	gInstance = kzalloc(sizeof(BCMSDH_SDMMC_INSTANCE), GFP_KERNEL);
+	if (!gInstance)
+		return -ENOMEM;
+
+	bzero(&sdmmc_dev, sizeof(sdmmc_dev));
+	error = sdio_register_driver(&bcmsdh_sdmmc_driver);
+
+	return error;
+}
+
+/*
+ * module cleanup
+*/
+extern int bcmsdh_remove(struct device *dev);
+void sdio_function_cleanup(void)
+{
+	sd_trace(("%s Enter\n", __func__));
+
+	sdio_unregister_driver(&bcmsdh_sdmmc_driver);
+
+	kfree(gInstance);
+}
diff --git a/drivers/staging/brcm80211/brcmfmac/dhd.h b/drivers/staging/brcm80211/brcmfmac/dhd.h
new file mode 100644
index 0000000..57d06b2
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/dhd.h
@@ -0,0 +1,468 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/****************
+ * Common types *
+ */
+
+#ifndef _dhd_h_
+#define _dhd_h_
+
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/random.h>
+#include <linux/spinlock.h>
+#include <linux/ethtool.h>
+#include <asm/uaccess.h>
+#include <asm/unaligned.h>
+#if defined(CONFIG_HAS_WAKELOCK)
+#include <linux/wakelock.h>
+#endif			/* defined (CONFIG_HAS_WAKELOCK) */
+/* The kernel threading is sdio-specific */
+
+#include <wlioctl.h>
+
+/* Forward decls */
+struct dhd_bus;
+struct dhd_prot;
+struct dhd_info;
+
+/* The level of bus communication with the dongle */
+enum dhd_bus_state {
+	DHD_BUS_DOWN,		/* Not ready for frame transfers */
+	DHD_BUS_LOAD,		/* Download access only (CPU reset) */
+	DHD_BUS_DATA		/* Ready for frame transfers */
+};
+
+enum dhd_bus_wake_state {
+	WAKE_LOCK_OFF,
+	WAKE_LOCK_PRIV,
+	WAKE_LOCK_DPC,
+	WAKE_LOCK_IOCTL,
+	WAKE_LOCK_DOWNLOAD,
+	WAKE_LOCK_TMOUT,
+	WAKE_LOCK_WATCHDOG,
+	WAKE_LOCK_LINK_DOWN_TMOUT,
+	WAKE_LOCK_PNO_FIND_TMOUT,
+	WAKE_LOCK_SOFTAP_SET,
+	WAKE_LOCK_SOFTAP_STOP,
+	WAKE_LOCK_SOFTAP_START,
+	WAKE_LOCK_MAX
+};
+enum dhd_prealloc_index {
+	DHD_PREALLOC_PROT = 0,
+	DHD_PREALLOC_RXBUF,
+	DHD_PREALLOC_DATABUF,
+	DHD_PREALLOC_OSL_BUF
+};
+
+/* Common structure for module and instance linkage */
+typedef struct dhd_pub {
+	/* Linkage ponters */
+	osl_t *osh;		/* OSL handle */
+	struct dhd_bus *bus;	/* Bus module handle */
+	struct dhd_prot *prot;	/* Protocol module handle */
+	struct dhd_info *info;	/* Info module handle */
+
+	/* Internal dhd items */
+	bool up;		/* Driver up/down (to OS) */
+	bool txoff;		/* Transmit flow-controlled */
+	bool dongle_reset;	/* true = DEVRESET put dongle into reset */
+	enum dhd_bus_state busstate;
+	uint hdrlen;		/* Total DHD header length (proto + bus) */
+	uint maxctl;		/* Max size rxctl request from proto to bus */
+	uint rxsz;		/* Rx buffer size bus module should use */
+	u8 wme_dp;		/* wme discard priority */
+
+	/* Dongle media info */
+	bool iswl;		/* Dongle-resident driver is wl */
+	unsigned long drv_version;	/* Version of dongle-resident driver */
+	struct ether_addr mac;	/* MAC address obtained from dongle */
+	dngl_stats_t dstats;	/* Stats for dongle-based data */
+
+	/* Additional stats for the bus level */
+	unsigned long tx_packets;	/* Data packets sent to dongle */
+	unsigned long tx_multicast;	/* Multicast data packets sent to dongle */
+	unsigned long tx_errors;	/* Errors in sending data to dongle */
+	unsigned long tx_ctlpkts;	/* Control packets sent to dongle */
+	unsigned long tx_ctlerrs;	/* Errors sending control frames to dongle */
+	unsigned long rx_packets;	/* Packets sent up the network interface */
+	unsigned long rx_multicast;	/* Multicast packets sent up the network
+					 interface */
+	unsigned long rx_errors;	/* Errors processing rx data packets */
+	unsigned long rx_ctlpkts;	/* Control frames processed from dongle */
+	unsigned long rx_ctlerrs;	/* Errors in processing rx control frames */
+	unsigned long rx_dropped;	/* Packets dropped locally (no memory) */
+	unsigned long rx_flushed;	/* Packets flushed due to
+				unscheduled sendup thread */
+	unsigned long wd_dpc_sched;	/* Number of times dhd dpc scheduled by
+					 watchdog timer */
+
+	unsigned long rx_readahead_cnt;	/* Number of packets where header read-ahead
+					 was used. */
+	unsigned long tx_realloc;	/* Number of tx packets we had to realloc for
+					 headroom */
+	unsigned long fc_packets;	/* Number of flow control pkts recvd */
+
+	/* Last error return */
+	int bcmerror;
+	uint tickcnt;
+
+	/* Last error from dongle */
+	int dongle_error;
+
+	/* Suspend disable flag  flag */
+	int suspend_disable_flag;	/* "1" to disable all extra powersaving
+					 during suspend */
+	int in_suspend;		/* flag set to 1 when early suspend called */
+#ifdef PNO_SUPPORT
+	int pno_enable;		/* pno status : "1" is pno enable */
+#endif				/* PNO_SUPPORT */
+	int dtim_skip;		/* dtim skip , default 0 means wake each dtim */
+
+	/* Pkt filter defination */
+	char *pktfilter[100];
+	int pktfilter_count;
+
+	u8 country_code[WLC_CNTRY_BUF_SZ];
+	char eventmask[WL_EVENTING_MASK_LEN];
+
+#if defined(CONFIG_HAS_WAKELOCK)
+	struct wake_lock wakelock[WAKE_LOCK_MAX];
+#endif		/*  defined (CONFIG_HAS_WAKELOCK) */
+} dhd_pub_t;
+
+#if defined(CONFIG_PM_SLEEP)
+
+#define DHD_PM_RESUME_WAIT_INIT(a) DECLARE_WAIT_QUEUE_HEAD(a);
+#define _DHD_PM_RESUME_WAIT(a, b) do {\
+			int retry = 0; \
+			while (dhd_mmc_suspend && retry++ != b) { \
+				wait_event_timeout(a, false, HZ/100); \
+			} \
+		}	while (0)
+#define DHD_PM_RESUME_WAIT(a)	_DHD_PM_RESUME_WAIT(a, 30)
+#define DHD_PM_RESUME_WAIT_FOREVER(a)	_DHD_PM_RESUME_WAIT(a, ~0)
+#define DHD_PM_RESUME_RETURN_ERROR(a)	\
+	do { if (dhd_mmc_suspend) return a; } while (0)
+#define DHD_PM_RESUME_RETURN	do { if (dhd_mmc_suspend) return; } while (0)
+
+#define DHD_SPINWAIT_SLEEP_INIT(a) DECLARE_WAIT_QUEUE_HEAD(a);
+#define SPINWAIT_SLEEP(a, exp, us) do { \
+		uint countdown = (us) + 9999; \
+		while ((exp) && (countdown >= 10000)) { \
+			wait_event_timeout(a, false, HZ/100); \
+			countdown -= 10000; \
+		} \
+	} while (0)
+
+#else
+
+#define DHD_PM_RESUME_WAIT_INIT(a)
+#define DHD_PM_RESUME_WAIT(a)
+#define DHD_PM_RESUME_WAIT_FOREVER(a)
+#define DHD_PM_RESUME_RETURN_ERROR(a)
+#define DHD_PM_RESUME_RETURN
+
+#define DHD_SPINWAIT_SLEEP_INIT(a)
+#define SPINWAIT_SLEEP(a, exp, us)  do { \
+		uint countdown = (us) + 9; \
+		while ((exp) && (countdown >= 10)) { \
+			udelay(10);  \
+			countdown -= 10;  \
+		} \
+	} while (0)
+
+#endif	/* defined(CONFIG_PM_SLEEP) */
+#define DHD_IF_VIF	0x01	/* Virtual IF (Hidden from user) */
+
+static inline void MUTEX_LOCK_INIT(dhd_pub_t *dhdp)
+{
+}
+
+static inline void MUTEX_LOCK(dhd_pub_t *dhdp)
+{
+}
+
+static inline void MUTEX_UNLOCK(dhd_pub_t *dhdp)
+{
+}
+
+static inline void MUTEX_LOCK_SOFTAP_SET_INIT(dhd_pub_t *dhdp)
+{
+}
+
+static inline void MUTEX_LOCK_SOFTAP_SET(dhd_pub_t *dhdp)
+{
+}
+
+static inline void MUTEX_UNLOCK_SOFTAP_SET(dhd_pub_t *dhdp)
+{
+}
+
+static inline void MUTEX_LOCK_WL_SCAN_SET_INIT(void)
+{
+}
+
+static inline void MUTEX_LOCK_WL_SCAN_SET(void)
+{
+}
+
+static inline void MUTEX_UNLOCK_WL_SCAN_SET(void)
+{
+}
+
+static inline void WAKE_LOCK_INIT(dhd_pub_t *dhdp, int index, char *y)
+{
+#if defined(CONFIG_HAS_WAKELOCK)
+	wake_lock_init(&dhdp->wakelock[index], WAKE_LOCK_SUSPEND, y);
+#endif	/* defined (CONFIG_HAS_WAKELOCK) */
+}
+
+static inline void WAKE_LOCK(dhd_pub_t *dhdp, int index)
+{
+#if defined(CONFIG_HAS_WAKELOCK)
+	wake_lock(&dhdp->wakelock[index]);
+#endif	/* defined (CONFIG_HAS_WAKELOCK) */
+}
+
+static inline void WAKE_UNLOCK(dhd_pub_t *dhdp, int index)
+{
+#if defined(CONFIG_HAS_WAKELOCK)
+	wake_unlock(&dhdp->wakelock[index]);
+#endif	/* defined (CONFIG_HAS_WAKELOCK) */
+}
+
+static inline void WAKE_LOCK_TIMEOUT(dhd_pub_t *dhdp, int index, long time)
+{
+#if defined(CONFIG_HAS_WAKELOCK)
+	wake_lock_timeout(&dhdp->wakelock[index], time);
+#endif	/* defined (CONFIG_HAS_WAKELOCK) */
+}
+
+static inline void WAKE_LOCK_DESTROY(dhd_pub_t *dhdp, int index)
+{
+#if defined(CONFIG_HAS_WAKELOCK)
+	wake_lock_destroy(&dhdp->wakelock[index]);
+#endif /* defined (CONFIG_HAS_WAKELOCK) */
+}
+
+typedef struct dhd_if_event {
+	u8 ifidx;
+	u8 action;
+	u8 flags;
+	u8 bssidx;
+} dhd_if_event_t;
+
+/*
+ * Exported from dhd OS modules (dhd_linux/dhd_ndis)
+ */
+
+/* To allow osl_attach/detach calls from os-independent modules */
+osl_t *dhd_osl_attach(void *pdev, uint bustype);
+void dhd_osl_detach(osl_t *osh);
+
+/* Indication from bus module regarding presence/insertion of dongle.
+ * Return dhd_pub_t pointer, used as handle to OS module in later calls.
+ * Returned structure should have bus and prot pointers filled in.
+ * bus_hdrlen specifies required headroom for bus module header.
+ */
+extern dhd_pub_t *dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen);
+extern int dhd_net_attach(dhd_pub_t *dhdp, int idx);
+
+/* Indication from bus module regarding removal/absence of dongle */
+extern void dhd_detach(dhd_pub_t *dhdp);
+
+/* Indication from bus module to change flow-control state */
+extern void dhd_txflowcontrol(dhd_pub_t *dhdp, int ifidx, bool on);
+
+extern bool dhd_prec_enq(dhd_pub_t *dhdp, struct pktq *q, void *pkt, int prec);
+
+/* Receive frame for delivery to OS.  Callee disposes of rxp. */
+extern void dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *rxp, int numpkt);
+
+/* Return pointer to interface name */
+extern char *dhd_ifname(dhd_pub_t *dhdp, int idx);
+
+/* Request scheduling of the bus dpc */
+extern void dhd_sched_dpc(dhd_pub_t *dhdp);
+
+/* Notify tx completion */
+extern void dhd_txcomplete(dhd_pub_t *dhdp, void *txp, bool success);
+
+/* Query ioctl */
+extern int dhdcdc_query_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf,
+			      uint len);
+
+/* OS independent layer functions */
+extern int dhd_os_proto_block(dhd_pub_t *pub);
+extern int dhd_os_proto_unblock(dhd_pub_t *pub);
+extern int dhd_os_ioctl_resp_wait(dhd_pub_t *pub, uint *condition,
+				  bool *pending);
+extern int dhd_os_ioctl_resp_wake(dhd_pub_t *pub);
+extern unsigned int dhd_os_get_ioctl_resp_timeout(void);
+extern void dhd_os_set_ioctl_resp_timeout(unsigned int timeout_msec);
+extern void *dhd_os_open_image(char *filename);
+extern int dhd_os_get_image_block(char *buf, int len, void *image);
+extern void dhd_os_close_image(void *image);
+extern void dhd_os_wd_timer(void *bus, uint wdtick);
+extern void dhd_os_sdlock(dhd_pub_t *pub);
+extern void dhd_os_sdunlock(dhd_pub_t *pub);
+extern void dhd_os_sdlock_txq(dhd_pub_t *pub);
+extern void dhd_os_sdunlock_txq(dhd_pub_t *pub);
+extern void dhd_os_sdlock_rxq(dhd_pub_t *pub);
+extern void dhd_os_sdunlock_rxq(dhd_pub_t *pub);
+extern void dhd_os_sdlock_sndup_rxq(dhd_pub_t *pub);
+extern void dhd_customer_gpio_wlan_ctrl(int onoff);
+extern int dhd_custom_get_mac_address(unsigned char *buf);
+extern void dhd_os_sdunlock_sndup_rxq(dhd_pub_t *pub);
+extern void dhd_os_sdlock_eventq(dhd_pub_t *pub);
+extern void dhd_os_sdunlock_eventq(dhd_pub_t *pub);
+#ifdef DHD_DEBUG
+extern int write_to_file(dhd_pub_t *dhd, u8 *buf, int size);
+#endif				/* DHD_DEBUG */
+#if defined(OOB_INTR_ONLY)
+extern int dhd_customer_oob_irq_map(unsigned long *irq_flags_ptr);
+#endif				/* defined(OOB_INTR_ONLY) */
+extern void dhd_os_sdtxlock(dhd_pub_t *pub);
+extern void dhd_os_sdtxunlock(dhd_pub_t *pub);
+
+int setScheduler(struct task_struct *p, int policy, struct sched_param *param);
+
+typedef struct {
+	u32 limit;		/* Expiration time (usec) */
+	u32 increment;	/* Current expiration increment (usec) */
+	u32 elapsed;		/* Current elapsed time (usec) */
+	u32 tick;		/* O/S tick time (usec) */
+} dhd_timeout_t;
+
+extern void dhd_timeout_start(dhd_timeout_t *tmo, uint usec);
+extern int dhd_timeout_expired(dhd_timeout_t *tmo);
+
+extern int dhd_ifname2idx(struct dhd_info *dhd, char *name);
+extern u8 *dhd_bssidx2bssid(dhd_pub_t *dhd, int idx);
+extern int wl_host_event(struct dhd_info *dhd, int *idx, void *pktdata,
+			 wl_event_msg_t *, void **data_ptr);
+extern void wl_event_to_host_order(wl_event_msg_t *evt);
+
+extern void dhd_common_init(void);
+
+extern int dhd_add_if(struct dhd_info *dhd, int ifidx, void *handle,
+		      char *name, u8 *mac_addr, u32 flags, u8 bssidx);
+extern void dhd_del_if(struct dhd_info *dhd, int ifidx);
+
+extern void dhd_vif_add(struct dhd_info *dhd, int ifidx, char *name);
+extern void dhd_vif_del(struct dhd_info *dhd, int ifidx);
+
+extern void dhd_event(struct dhd_info *dhd, char *evpkt, int evlen, int ifidx);
+extern void dhd_vif_sendup(struct dhd_info *dhd, int ifidx, unsigned char * cp,
+			   int len);
+
+/* Send packet to dongle via data channel */
+extern int dhd_sendpkt(dhd_pub_t *dhdp, int ifidx, void *pkt);
+
+/* Send event to host */
+extern void dhd_sendup_event(dhd_pub_t *dhdp, wl_event_msg_t *event,
+			     void *data);
+extern int dhd_bus_devreset(dhd_pub_t *dhdp, u8 flag);
+extern uint dhd_bus_status(dhd_pub_t *dhdp);
+extern int dhd_bus_start(dhd_pub_t *dhdp);
+
+extern void print_buf(void *pbuf, int len, int bytes_per_line);
+
+typedef enum cust_gpio_modes {
+	WLAN_RESET_ON,
+	WLAN_RESET_OFF,
+	WLAN_POWER_ON,
+	WLAN_POWER_OFF
+} cust_gpio_modes_t;
+/*
+ * Insmod parameters for debug/test
+ */
+
+/* Watchdog timer interval */
+extern uint dhd_watchdog_ms;
+
+#if defined(DHD_DEBUG)
+/* Console output poll interval */
+extern uint dhd_console_ms;
+#endif				/* defined(DHD_DEBUG) */
+
+/* Use interrupts */
+extern uint dhd_intr;
+
+/* Use polling */
+extern uint dhd_poll;
+
+/* ARP offload agent mode */
+extern uint dhd_arp_mode;
+
+/* ARP offload enable */
+extern uint dhd_arp_enable;
+
+/* Pkt filte enable control */
+extern uint dhd_pkt_filter_enable;
+
+/*  Pkt filter init setup */
+extern uint dhd_pkt_filter_init;
+
+/* Pkt filter mode control */
+extern uint dhd_master_mode;
+
+/* Roaming mode control */
+extern uint dhd_roam;
+
+/* Roaming mode control */
+extern uint dhd_radio_up;
+
+/* Initial idletime ticks (may be -1 for immediate idle, 0 for no idle) */
+extern int dhd_idletime;
+#define DHD_IDLETIME_TICKS 1
+
+/* SDIO Drive Strength */
+extern uint dhd_sdiod_drive_strength;
+
+/* Override to force tx queueing all the time */
+extern uint dhd_force_tx_queueing;
+
+#ifdef SDTEST
+/* Echo packet generator (SDIO), pkts/s */
+extern uint dhd_pktgen;
+
+/* Echo packet len (0 => sawtooth, max 1800) */
+extern uint dhd_pktgen_len;
+#define MAX_PKTGEN_LEN 1800
+#endif
+
+/* optionally set by a module_param_string() */
+#define MOD_PARAM_PATHLEN	2048
+extern char fw_path[MOD_PARAM_PATHLEN];
+extern char nv_path[MOD_PARAM_PATHLEN];
+
+/* For supporting multiple interfaces */
+#define DHD_MAX_IFS	16
+#define DHD_DEL_IF	-0xe
+#define DHD_BAD_IF	-0xf
+
+extern void dhd_wait_for_event(dhd_pub_t *dhd, bool * lockvar);
+extern void dhd_wait_event_wakeup(dhd_pub_t *dhd);
+
+#endif				/* _dhd_h_ */
diff --git a/drivers/staging/brcm80211/brcmfmac/dhd_bus.h b/drivers/staging/brcm80211/brcmfmac/dhd_bus.h
new file mode 100644
index 0000000..3b39c99
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_bus.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _dhd_bus_h_
+#define _dhd_bus_h_
+
+/*
+ * Exported from dhd bus module (dhd_usb, dhd_sdio)
+ */
+
+/* Indicate (dis)interest in finding dongles. */
+extern int dhd_bus_register(void);
+extern void dhd_bus_unregister(void);
+
+/* Download firmware image and nvram image */
+extern bool dhd_bus_download_firmware(struct dhd_bus *bus, osl_t * osh,
+				      char *fw_path, char *nv_path);
+
+/* Stop bus module: clear pending frames, disable data flow */
+extern void dhd_bus_stop(struct dhd_bus *bus, bool enforce_mutex);
+
+/* Initialize bus module: prepare for communication w/dongle */
+extern int dhd_bus_init(dhd_pub_t *dhdp, bool enforce_mutex);
+
+/* Send a data frame to the dongle.  Callee disposes of txp. */
+extern int dhd_bus_txdata(struct dhd_bus *bus, void *txp);
+
+/* Send/receive a control message to/from the dongle.
+ * Expects caller to enforce a single outstanding transaction.
+ */
+extern int dhd_bus_txctl(struct dhd_bus *bus, unsigned char *msg, uint msglen);
+extern int dhd_bus_rxctl(struct dhd_bus *bus, unsigned char *msg, uint msglen);
+
+/* Watchdog timer function */
+extern bool dhd_bus_watchdog(dhd_pub_t *dhd);
+
+#ifdef DHD_DEBUG
+/* Device console input function */
+extern int dhd_bus_console_in(dhd_pub_t *dhd, unsigned char *msg, uint msglen);
+#endif				/* DHD_DEBUG */
+
+/* Deferred processing for the bus, return true requests reschedule */
+extern bool dhd_bus_dpc(struct dhd_bus *bus);
+extern void dhd_bus_isr(bool *InterruptRecognized,
+			bool *QueueMiniportHandleInterrupt, void *arg);
+
+/* Check for and handle local prot-specific iovar commands */
+extern int dhd_bus_iovar_op(dhd_pub_t *dhdp, const char *name,
+			    void *params, int plen, void *arg, int len,
+			    bool set);
+
+/* Add bus dump output to a buffer */
+extern void dhd_bus_dump(dhd_pub_t *dhdp, struct bcmstrbuf *strbuf);
+
+/* Clear any bus counters */
+extern void dhd_bus_clearcounts(dhd_pub_t *dhdp);
+
+/* return the dongle chipid */
+extern uint dhd_bus_chip(struct dhd_bus *bus);
+
+/* Set user-specified nvram parameters. */
+extern void dhd_bus_set_nvram_params(struct dhd_bus *bus,
+				     const char *nvram_params);
+
+extern void *dhd_bus_pub(struct dhd_bus *bus);
+extern void *dhd_bus_txq(struct dhd_bus *bus);
+extern uint dhd_bus_hdrlen(struct dhd_bus *bus);
+
+#endif				/* _dhd_bus_h_ */
diff --git a/drivers/staging/brcm80211/brcmfmac/dhd_cdc.c b/drivers/staging/brcm80211/brcmfmac/dhd_cdc.c
new file mode 100644
index 0000000..bcbaac9
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_cdc.c
@@ -0,0 +1,487 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/types.h>
+#include <bcmdefs.h>
+#include <osl.h>
+
+#include <bcmutils.h>
+#include <bcmcdc.h>
+#include <bcmendian.h>
+
+#include <dngl_stats.h>
+#include <dhd.h>
+#include <dhd_proto.h>
+#include <dhd_bus.h>
+#include <dhd_dbg.h>
+#ifdef CUSTOMER_HW2
+int wifi_get_mac_addr(unsigned char *buf);
+#endif
+
+extern int dhd_preinit_ioctls(dhd_pub_t *dhd);
+
+/* Packet alignment for most efficient SDIO (can change based on platform) */
+#ifndef DHD_SDALIGN
+#define DHD_SDALIGN	32
+#endif
+#if !ISPOWEROF2(DHD_SDALIGN)
+#error DHD_SDALIGN is not a power of 2!
+#endif
+
+#define RETRIES 2	/* # of retries to retrieve matching ioctl response */
+#define BUS_HEADER_LEN	(16+DHD_SDALIGN) /* Must be atleast SDPCM_RESERVE
+					 * defined in dhd_sdio.c
+					 * (amount of header tha might be added)
+					 * plus any space that might be needed
+					 * for alignment padding.
+					 */
+#define ROUND_UP_MARGIN	2048	/* Biggest SDIO block size possible for
+				 * round off at the end of buffer
+				 */
+
+typedef struct dhd_prot {
+	u16 reqid;
+	u8 pending;
+	u32 lastcmd;
+	u8 bus_header[BUS_HEADER_LEN];
+	cdc_ioctl_t msg;
+	unsigned char buf[WLC_IOCTL_MAXLEN + ROUND_UP_MARGIN];
+} dhd_prot_t;
+
+static int dhdcdc_msg(dhd_pub_t *dhd)
+{
+	dhd_prot_t *prot = dhd->prot;
+	int len = ltoh32(prot->msg.len) + sizeof(cdc_ioctl_t);
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	/* NOTE : cdc->msg.len holds the desired length of the buffer to be
+	 *        returned. Only up to CDC_MAX_MSG_SIZE of this buffer area
+	 *        is actually sent to the dongle
+	 */
+	if (len > CDC_MAX_MSG_SIZE)
+		len = CDC_MAX_MSG_SIZE;
+
+	/* Send request */
+	return dhd_bus_txctl(dhd->bus, (unsigned char *)&prot->msg, len);
+}
+
+static int dhdcdc_cmplt(dhd_pub_t *dhd, u32 id, u32 len)
+{
+	int ret;
+	dhd_prot_t *prot = dhd->prot;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	do {
+		ret =
+		    dhd_bus_rxctl(dhd->bus, (unsigned char *)&prot->msg,
+				  len + sizeof(cdc_ioctl_t));
+		if (ret < 0)
+			break;
+	} while (CDC_IOC_ID(ltoh32(prot->msg.flags)) != id);
+
+	return ret;
+}
+
+int
+dhdcdc_query_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf, uint len)
+{
+	dhd_prot_t *prot = dhd->prot;
+	cdc_ioctl_t *msg = &prot->msg;
+	void *info;
+	int ret = 0, retries = 0;
+	u32 id, flags = 0;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+	DHD_CTL(("%s: cmd %d len %d\n", __func__, cmd, len));
+
+	/* Respond "bcmerror" and "bcmerrorstr" with local cache */
+	if (cmd == WLC_GET_VAR && buf) {
+		if (!strcmp((char *)buf, "bcmerrorstr")) {
+			strncpy((char *)buf, bcmerrorstr(dhd->dongle_error),
+				BCME_STRLEN);
+			goto done;
+		} else if (!strcmp((char *)buf, "bcmerror")) {
+			*(int *)buf = dhd->dongle_error;
+			goto done;
+		}
+	}
+
+	memset(msg, 0, sizeof(cdc_ioctl_t));
+
+	msg->cmd = htol32(cmd);
+	msg->len = htol32(len);
+	msg->flags = (++prot->reqid << CDCF_IOC_ID_SHIFT);
+	CDC_SET_IF_IDX(msg, ifidx);
+	msg->flags = htol32(msg->flags);
+
+	if (buf)
+		memcpy(prot->buf, buf, len);
+
+	ret = dhdcdc_msg(dhd);
+	if (ret < 0) {
+		DHD_ERROR(("dhdcdc_query_ioctl: dhdcdc_msg failed w/status "
+			"%d\n", ret));
+		goto done;
+	}
+
+retry:
+	/* wait for interrupt and get first fragment */
+	ret = dhdcdc_cmplt(dhd, prot->reqid, len);
+	if (ret < 0)
+		goto done;
+
+	flags = ltoh32(msg->flags);
+	id = (flags & CDCF_IOC_ID_MASK) >> CDCF_IOC_ID_SHIFT;
+
+	if ((id < prot->reqid) && (++retries < RETRIES))
+		goto retry;
+	if (id != prot->reqid) {
+		DHD_ERROR(("%s: %s: unexpected request id %d (expected %d)\n",
+			   dhd_ifname(dhd, ifidx), __func__, id, prot->reqid));
+		ret = -EINVAL;
+		goto done;
+	}
+
+	/* Check info buffer */
+	info = (void *)&msg[1];
+
+	/* Copy info buffer */
+	if (buf) {
+		if (ret < (int)len)
+			len = ret;
+		memcpy(buf, info, len);
+	}
+
+	/* Check the ERROR flag */
+	if (flags & CDCF_IOC_ERROR) {
+		ret = ltoh32(msg->status);
+		/* Cache error from dongle */
+		dhd->dongle_error = ret;
+	}
+
+done:
+	return ret;
+}
+
+int dhdcdc_set_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf, uint len)
+{
+	dhd_prot_t *prot = dhd->prot;
+	cdc_ioctl_t *msg = &prot->msg;
+	int ret = 0;
+	u32 flags, id;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+	DHD_CTL(("%s: cmd %d len %d\n", __func__, cmd, len));
+
+	memset(msg, 0, sizeof(cdc_ioctl_t));
+
+	msg->cmd = htol32(cmd);
+	msg->len = htol32(len);
+	msg->flags = (++prot->reqid << CDCF_IOC_ID_SHIFT) | CDCF_IOC_SET;
+	CDC_SET_IF_IDX(msg, ifidx);
+	msg->flags = htol32(msg->flags);
+
+	if (buf)
+		memcpy(prot->buf, buf, len);
+
+	ret = dhdcdc_msg(dhd);
+	if (ret < 0)
+		goto done;
+
+	ret = dhdcdc_cmplt(dhd, prot->reqid, len);
+	if (ret < 0)
+		goto done;
+
+	flags = ltoh32(msg->flags);
+	id = (flags & CDCF_IOC_ID_MASK) >> CDCF_IOC_ID_SHIFT;
+
+	if (id != prot->reqid) {
+		DHD_ERROR(("%s: %s: unexpected request id %d (expected %d)\n",
+			   dhd_ifname(dhd, ifidx), __func__, id, prot->reqid));
+		ret = -EINVAL;
+		goto done;
+	}
+
+	/* Check the ERROR flag */
+	if (flags & CDCF_IOC_ERROR) {
+		ret = ltoh32(msg->status);
+		/* Cache error from dongle */
+		dhd->dongle_error = ret;
+	}
+
+done:
+	return ret;
+}
+
+extern int dhd_bus_interface(struct dhd_bus *bus, uint arg, void *arg2);
+int
+dhd_prot_ioctl(dhd_pub_t *dhd, int ifidx, wl_ioctl_t *ioc, void *buf, int len)
+{
+	dhd_prot_t *prot = dhd->prot;
+	int ret = -1;
+
+	if (dhd->busstate == DHD_BUS_DOWN) {
+		DHD_ERROR(("%s : bus is down. we have nothing to do\n",
+			   __func__));
+		return ret;
+	}
+	dhd_os_proto_block(dhd);
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	ASSERT(len <= WLC_IOCTL_MAXLEN);
+
+	if (len > WLC_IOCTL_MAXLEN)
+		goto done;
+
+	if (prot->pending == true) {
+		DHD_TRACE(("CDC packet is pending!!!! cmd=0x%x (%lu) "
+			"lastcmd=0x%x (%lu)\n",
+			ioc->cmd, (unsigned long)ioc->cmd, prot->lastcmd,
+			(unsigned long)prot->lastcmd));
+		if ((ioc->cmd == WLC_SET_VAR) || (ioc->cmd == WLC_GET_VAR)) {
+			DHD_TRACE(("iovar cmd=%s\n", (char *)buf));
+		}
+		goto done;
+	}
+
+	prot->pending = true;
+	prot->lastcmd = ioc->cmd;
+	if (ioc->set)
+		ret = dhdcdc_set_ioctl(dhd, ifidx, ioc->cmd, buf, len);
+	else {
+		ret = dhdcdc_query_ioctl(dhd, ifidx, ioc->cmd, buf, len);
+		if (ret > 0)
+			ioc->used = ret - sizeof(cdc_ioctl_t);
+	}
+
+	/* Too many programs assume ioctl() returns 0 on success */
+	if (ret >= 0)
+		ret = 0;
+	else {
+		cdc_ioctl_t *msg = &prot->msg;
+		ioc->needed = ltoh32(msg->len);	/* len == needed when set/query
+						 fails from dongle */
+	}
+
+	/* Intercept the wme_dp ioctl here */
+	if ((!ret) && (ioc->cmd == WLC_SET_VAR) && (!strcmp(buf, "wme_dp"))) {
+		int slen, val = 0;
+
+		slen = strlen("wme_dp") + 1;
+		if (len >= (int)(slen + sizeof(int)))
+			bcopy(((char *)buf + slen), &val, sizeof(int));
+		dhd->wme_dp = (u8) ltoh32(val);
+	}
+
+	prot->pending = false;
+
+done:
+	dhd_os_proto_unblock(dhd);
+
+	return ret;
+}
+
+int
+dhd_prot_iovar_op(dhd_pub_t *dhdp, const char *name,
+		  void *params, int plen, void *arg, int len, bool set)
+{
+	return BCME_UNSUPPORTED;
+}
+
+void dhd_prot_dump(dhd_pub_t *dhdp, struct bcmstrbuf *strbuf)
+{
+	bcm_bprintf(strbuf, "Protocol CDC: reqid %d\n", dhdp->prot->reqid);
+}
+
+void dhd_prot_hdrpush(dhd_pub_t *dhd, int ifidx, void *pktbuf)
+{
+#ifdef BDC
+	struct bdc_header *h;
+#endif				/* BDC */
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+#ifdef BDC
+	/* Push BDC header used to convey priority for buses that don't */
+
+	PKTPUSH(pktbuf, BDC_HEADER_LEN);
+
+	h = (struct bdc_header *)PKTDATA(pktbuf);
+
+	h->flags = (BDC_PROTO_VER << BDC_FLAG_VER_SHIFT);
+	if (PKTSUMNEEDED(pktbuf))
+		h->flags |= BDC_FLAG_SUM_NEEDED;
+
+	h->priority = (PKTPRIO(pktbuf) & BDC_PRIORITY_MASK);
+	h->flags2 = 0;
+	h->rssi = 0;
+#endif				/* BDC */
+	BDC_SET_IF_IDX(h, ifidx);
+}
+
+bool dhd_proto_fcinfo(dhd_pub_t *dhd, void *pktbuf, u8 * fcbits)
+{
+#ifdef BDC
+	struct bdc_header *h;
+
+	if (PKTLEN(pktbuf) < BDC_HEADER_LEN) {
+		DHD_ERROR(("%s: rx data too short (%d < %d)\n",
+			   __func__, PKTLEN(pktbuf), BDC_HEADER_LEN));
+		return BCME_ERROR;
+	}
+
+	h = (struct bdc_header *)PKTDATA(pktbuf);
+
+	*fcbits = h->priority >> BDC_PRIORITY_FC_SHIFT;
+	if ((h->flags2 & BDC_FLAG2_FC_FLAG) == BDC_FLAG2_FC_FLAG)
+		return true;
+#endif
+	return false;
+}
+
+int dhd_prot_hdrpull(dhd_pub_t *dhd, int *ifidx, void *pktbuf)
+{
+#ifdef BDC
+	struct bdc_header *h;
+#endif
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+#ifdef BDC
+	/* Pop BDC header used to convey priority for buses that don't */
+
+	if (PKTLEN(pktbuf) < BDC_HEADER_LEN) {
+		DHD_ERROR(("%s: rx data too short (%d < %d)\n", __func__,
+			   PKTLEN(pktbuf), BDC_HEADER_LEN));
+		return BCME_ERROR;
+	}
+
+	h = (struct bdc_header *)PKTDATA(pktbuf);
+
+	*ifidx = BDC_GET_IF_IDX(h);
+	if (*ifidx >= DHD_MAX_IFS) {
+		DHD_ERROR(("%s: rx data ifnum out of range (%d)\n",
+			   __func__, *ifidx));
+		return BCME_ERROR;
+	}
+
+	if (((h->flags & BDC_FLAG_VER_MASK) >> BDC_FLAG_VER_SHIFT) !=
+	    BDC_PROTO_VER) {
+		DHD_ERROR(("%s: non-BDC packet received, flags 0x%x\n",
+			   dhd_ifname(dhd, *ifidx), h->flags));
+		return BCME_ERROR;
+	}
+
+	if (h->flags & BDC_FLAG_SUM_GOOD) {
+		DHD_INFO(("%s: BDC packet received with good rx-csum, "
+			"flags 0x%x\n",
+			dhd_ifname(dhd, *ifidx), h->flags));
+		PKTSETSUMGOOD(pktbuf, true);
+	}
+
+	PKTSETPRIO(pktbuf, (h->priority & BDC_PRIORITY_MASK));
+
+	PKTPULL(pktbuf, BDC_HEADER_LEN);
+#endif				/* BDC */
+
+	return 0;
+}
+
+int dhd_prot_attach(dhd_pub_t *dhd)
+{
+	dhd_prot_t *cdc;
+
+	cdc = kzalloc(sizeof(dhd_prot_t), GFP_ATOMIC);
+	if (!cdc) {
+		DHD_ERROR(("%s: kmalloc failed\n", __func__));
+		goto fail;
+	}
+
+	/* ensure that the msg buf directly follows the cdc msg struct */
+	if ((unsigned long)(&cdc->msg + 1) != (unsigned long)cdc->buf) {
+		DHD_ERROR(("dhd_prot_t is not correctly defined\n"));
+		goto fail;
+	}
+
+	dhd->prot = cdc;
+#ifdef BDC
+	dhd->hdrlen += BDC_HEADER_LEN;
+#endif
+	dhd->maxctl = WLC_IOCTL_MAXLEN + sizeof(cdc_ioctl_t) + ROUND_UP_MARGIN;
+	return 0;
+
+fail:
+	if (cdc != NULL)
+		kfree(cdc);
+	return BCME_NOMEM;
+}
+
+/* ~NOTE~ What if another thread is waiting on the semaphore?  Holding it? */
+void dhd_prot_detach(dhd_pub_t *dhd)
+{
+	kfree(dhd->prot);
+	dhd->prot = NULL;
+}
+
+void dhd_prot_dstats(dhd_pub_t *dhd)
+{
+	/* No stats from dongle added yet, copy bus stats */
+	dhd->dstats.tx_packets = dhd->tx_packets;
+	dhd->dstats.tx_errors = dhd->tx_errors;
+	dhd->dstats.rx_packets = dhd->rx_packets;
+	dhd->dstats.rx_errors = dhd->rx_errors;
+	dhd->dstats.rx_dropped = dhd->rx_dropped;
+	dhd->dstats.multicast = dhd->rx_multicast;
+	return;
+}
+
+int dhd_prot_init(dhd_pub_t *dhd)
+{
+	int ret = 0;
+	char buf[128];
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	dhd_os_proto_block(dhd);
+
+	/* Get the device MAC address */
+	strcpy(buf, "cur_etheraddr");
+	ret = dhdcdc_query_ioctl(dhd, 0, WLC_GET_VAR, buf, sizeof(buf));
+	if (ret < 0) {
+		dhd_os_proto_unblock(dhd);
+		return ret;
+	}
+	memcpy(dhd->mac.octet, buf, ETHER_ADDR_LEN);
+
+	dhd_os_proto_unblock(dhd);
+
+#ifdef EMBEDDED_PLATFORM
+	ret = dhd_preinit_ioctls(dhd);
+#endif				/* EMBEDDED_PLATFORM */
+
+	/* Always assumes wl for now */
+	dhd->iswl = true;
+
+	return ret;
+}
+
+void dhd_prot_stop(dhd_pub_t *dhd)
+{
+	/* Nothing to do for CDC */
+}
diff --git a/drivers/staging/brcm80211/brcmfmac/dhd_common.c b/drivers/staging/brcm80211/brcmfmac/dhd_common.c
new file mode 100644
index 0000000..703188f
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_common.c
@@ -0,0 +1,1910 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <bcmendian.h>
+#include <dngl_stats.h>
+#include <dhd.h>
+#include <dhd_bus.h>
+#include <dhd_proto.h>
+#include <dhd_dbg.h>
+#include <msgtrace.h>
+#include <wlioctl.h>
+
+int dhd_msg_level;
+char fw_path[MOD_PARAM_PATHLEN];
+char nv_path[MOD_PARAM_PATHLEN];
+
+/* Last connection success/failure status */
+u32 dhd_conn_event;
+u32 dhd_conn_status;
+u32 dhd_conn_reason;
+
+#define htod32(i) i
+#define htod16(i) i
+#define dtoh32(i) i
+#define dtoh16(i) i
+
+extern int dhdcdc_set_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf,
+			    uint len);
+extern void dhd_ind_scan_confirm(void *h, bool status);
+extern int dhd_wl_ioctl(dhd_pub_t *dhd, uint cmd, char *buf, uint buflen);
+void dhd_iscan_lock(void);
+void dhd_iscan_unlock(void);
+
+/* Packet alignment for most efficient SDIO (can change based on platform) */
+#ifndef DHD_SDALIGN
+#define DHD_SDALIGN	32
+#endif
+#if !ISPOWEROF2(DHD_SDALIGN)
+#error DHD_SDALIGN is not a power of 2!
+#endif
+
+#ifdef DHD_DEBUG
+#define EPI_VERSION_STR         "4.218.248.5"
+const char dhd_version[] =
+"Dongle Host Driver, version " EPI_VERSION_STR "\nCompiled on " __DATE__
+" at " __TIME__;
+#else
+const char dhd_version[] = "Dongle Host Driver, version " EPI_VERSION_STR;
+#endif
+
+void dhd_set_timer(void *bus, uint wdtick);
+
+/* IOVar table */
+enum {
+	IOV_VERSION = 1,
+	IOV_MSGLEVEL,
+	IOV_BCMERRORSTR,
+	IOV_BCMERROR,
+	IOV_WDTICK,
+	IOV_DUMP,
+#ifdef DHD_DEBUG
+	IOV_CONS,
+	IOV_DCONSOLE_POLL,
+#endif
+	IOV_CLEARCOUNTS,
+	IOV_LOGDUMP,
+	IOV_LOGCAL,
+	IOV_LOGSTAMP,
+	IOV_GPIOOB,
+	IOV_IOCTLTIMEOUT,
+	IOV_LAST
+};
+
+const bcm_iovar_t dhd_iovars[] = {
+	{"version", IOV_VERSION, 0, IOVT_BUFFER, sizeof(dhd_version)}
+	,
+#ifdef DHD_DEBUG
+	{"msglevel", IOV_MSGLEVEL, 0, IOVT_UINT32, 0}
+	,
+#endif				/* DHD_DEBUG */
+	{"bcmerrorstr", IOV_BCMERRORSTR, 0, IOVT_BUFFER, BCME_STRLEN}
+	,
+	{"bcmerror", IOV_BCMERROR, 0, IOVT_INT8, 0}
+	,
+	{"wdtick", IOV_WDTICK, 0, IOVT_UINT32, 0}
+	,
+	{"dump", IOV_DUMP, 0, IOVT_BUFFER, DHD_IOCTL_MAXLEN}
+	,
+#ifdef DHD_DEBUG
+	{"dconpoll", IOV_DCONSOLE_POLL, 0, IOVT_UINT32, 0}
+	,
+	{"cons", IOV_CONS, 0, IOVT_BUFFER, 0}
+	,
+#endif
+	{"clearcounts", IOV_CLEARCOUNTS, 0, IOVT_VOID, 0}
+	,
+	{"gpioob", IOV_GPIOOB, 0, IOVT_UINT32, 0}
+	,
+	{"ioctl_timeout", IOV_IOCTLTIMEOUT, 0, IOVT_UINT32, 0}
+	,
+	{NULL, 0, 0, 0, 0}
+};
+
+void dhd_common_init(void)
+{
+	/* Init global variables at run-time, not as part of the declaration.
+	 * This is required to support init/de-init of the driver.
+	 * Initialization
+	 * of globals as part of the declaration results in non-deterministic
+	 * behaviour since the value of the globals may be different on the
+	 * first time that the driver is initialized vs subsequent
+	 * initializations.
+	 */
+	dhd_msg_level = DHD_ERROR_VAL;
+#ifdef CONFIG_BCM4329_FW_PATH
+	strncpy(fw_path, CONFIG_BCM4329_FW_PATH, MOD_PARAM_PATHLEN - 1);
+#else
+	fw_path[0] = '\0';
+#endif
+#ifdef CONFIG_BCM4329_NVRAM_PATH
+	strncpy(nv_path, CONFIG_BCM4329_NVRAM_PATH, MOD_PARAM_PATHLEN - 1);
+#else
+	nv_path[0] = '\0';
+#endif
+}
+
+static int dhd_dump(dhd_pub_t *dhdp, char *buf, int buflen)
+{
+	struct bcmstrbuf b;
+	struct bcmstrbuf *strbuf = &b;
+
+	bcm_binit(strbuf, buf, buflen);
+
+	/* Base DHD info */
+	bcm_bprintf(strbuf, "%s\n", dhd_version);
+	bcm_bprintf(strbuf, "\n");
+	bcm_bprintf(strbuf, "pub.up %d pub.txoff %d pub.busstate %d\n",
+		    dhdp->up, dhdp->txoff, dhdp->busstate);
+	bcm_bprintf(strbuf, "pub.hdrlen %d pub.maxctl %d pub.rxsz %d\n",
+		    dhdp->hdrlen, dhdp->maxctl, dhdp->rxsz);
+	bcm_bprintf(strbuf, "pub.iswl %d pub.drv_version %ld pub.mac %pM\n",
+		    dhdp->iswl, dhdp->drv_version, &dhdp->mac);
+	bcm_bprintf(strbuf, "pub.bcmerror %d tickcnt %d\n", dhdp->bcmerror,
+		    dhdp->tickcnt);
+
+	bcm_bprintf(strbuf, "dongle stats:\n");
+	bcm_bprintf(strbuf,
+		    "tx_packets %ld tx_bytes %ld tx_errors %ld tx_dropped %ld\n",
+		    dhdp->dstats.tx_packets, dhdp->dstats.tx_bytes,
+		    dhdp->dstats.tx_errors, dhdp->dstats.tx_dropped);
+	bcm_bprintf(strbuf,
+		    "rx_packets %ld rx_bytes %ld rx_errors %ld rx_dropped %ld\n",
+		    dhdp->dstats.rx_packets, dhdp->dstats.rx_bytes,
+		    dhdp->dstats.rx_errors, dhdp->dstats.rx_dropped);
+	bcm_bprintf(strbuf, "multicast %ld\n", dhdp->dstats.multicast);
+
+	bcm_bprintf(strbuf, "bus stats:\n");
+	bcm_bprintf(strbuf, "tx_packets %ld tx_multicast %ld tx_errors %ld\n",
+		    dhdp->tx_packets, dhdp->tx_multicast, dhdp->tx_errors);
+	bcm_bprintf(strbuf, "tx_ctlpkts %ld tx_ctlerrs %ld\n",
+		    dhdp->tx_ctlpkts, dhdp->tx_ctlerrs);
+	bcm_bprintf(strbuf, "rx_packets %ld rx_multicast %ld rx_errors %ld\n",
+		    dhdp->rx_packets, dhdp->rx_multicast, dhdp->rx_errors);
+	bcm_bprintf(strbuf,
+		    "rx_ctlpkts %ld rx_ctlerrs %ld rx_dropped %ld rx_flushed %ld\n",
+		    dhdp->rx_ctlpkts, dhdp->rx_ctlerrs, dhdp->rx_dropped,
+		    dhdp->rx_flushed);
+	bcm_bprintf(strbuf,
+		    "rx_readahead_cnt %ld tx_realloc %ld fc_packets %ld\n",
+		    dhdp->rx_readahead_cnt, dhdp->tx_realloc, dhdp->fc_packets);
+	bcm_bprintf(strbuf, "wd_dpc_sched %ld\n", dhdp->wd_dpc_sched);
+	bcm_bprintf(strbuf, "\n");
+
+	/* Add any prot info */
+	dhd_prot_dump(dhdp, strbuf);
+	bcm_bprintf(strbuf, "\n");
+
+	/* Add any bus info */
+	dhd_bus_dump(dhdp, strbuf);
+
+	return !strbuf->size ? BCME_BUFTOOSHORT : 0;
+}
+
+static int
+dhd_doiovar(dhd_pub_t *dhd_pub, const bcm_iovar_t *vi, u32 actionid,
+	    const char *name, void *params, int plen, void *arg, int len,
+	    int val_size)
+{
+	int bcmerror = 0;
+	s32 int_val = 0;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	bcmerror = bcm_iovar_lencheck(vi, arg, len, IOV_ISSET(actionid));
+	if (bcmerror != 0)
+		goto exit;
+
+	if (plen >= (int)sizeof(int_val))
+		bcopy(params, &int_val, sizeof(int_val));
+
+	switch (actionid) {
+	case IOV_GVAL(IOV_VERSION):
+		/* Need to have checked buffer length */
+		strncpy((char *)arg, dhd_version, len);
+		break;
+
+	case IOV_GVAL(IOV_MSGLEVEL):
+		int_val = (s32) dhd_msg_level;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_MSGLEVEL):
+		dhd_msg_level = int_val;
+		break;
+
+	case IOV_GVAL(IOV_BCMERRORSTR):
+		strncpy((char *)arg, bcmerrorstr(dhd_pub->bcmerror),
+			BCME_STRLEN);
+		((char *)arg)[BCME_STRLEN - 1] = 0x00;
+		break;
+
+	case IOV_GVAL(IOV_BCMERROR):
+		int_val = (s32) dhd_pub->bcmerror;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_GVAL(IOV_WDTICK):
+		int_val = (s32) dhd_watchdog_ms;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_WDTICK):
+		if (!dhd_pub->up) {
+			bcmerror = BCME_NOTUP;
+			break;
+		}
+		dhd_os_wd_timer(dhd_pub, (uint) int_val);
+		break;
+
+	case IOV_GVAL(IOV_DUMP):
+		bcmerror = dhd_dump(dhd_pub, arg, len);
+		break;
+
+#ifdef DHD_DEBUG
+	case IOV_GVAL(IOV_DCONSOLE_POLL):
+		int_val = (s32) dhd_console_ms;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_DCONSOLE_POLL):
+		dhd_console_ms = (uint) int_val;
+		break;
+
+	case IOV_SVAL(IOV_CONS):
+		if (len > 0)
+			bcmerror = dhd_bus_console_in(dhd_pub, arg, len - 1);
+		break;
+#endif
+
+	case IOV_SVAL(IOV_CLEARCOUNTS):
+		dhd_pub->tx_packets = dhd_pub->rx_packets = 0;
+		dhd_pub->tx_errors = dhd_pub->rx_errors = 0;
+		dhd_pub->tx_ctlpkts = dhd_pub->rx_ctlpkts = 0;
+		dhd_pub->tx_ctlerrs = dhd_pub->rx_ctlerrs = 0;
+		dhd_pub->rx_dropped = 0;
+		dhd_pub->rx_readahead_cnt = 0;
+		dhd_pub->tx_realloc = 0;
+		dhd_pub->wd_dpc_sched = 0;
+		memset(&dhd_pub->dstats, 0, sizeof(dhd_pub->dstats));
+		dhd_bus_clearcounts(dhd_pub);
+		break;
+
+	case IOV_GVAL(IOV_IOCTLTIMEOUT):{
+			int_val = (s32) dhd_os_get_ioctl_resp_timeout();
+			bcopy(&int_val, arg, sizeof(int_val));
+			break;
+		}
+
+	case IOV_SVAL(IOV_IOCTLTIMEOUT):{
+			if (int_val <= 0)
+				bcmerror = BCME_BADARG;
+			else
+				dhd_os_set_ioctl_resp_timeout((unsigned int)
+							      int_val);
+			break;
+		}
+
+	default:
+		bcmerror = BCME_UNSUPPORTED;
+		break;
+	}
+
+exit:
+	return bcmerror;
+}
+
+/* Store the status of a connection attempt for later retrieval by an iovar */
+void dhd_store_conn_status(u32 event, u32 status, u32 reason)
+{
+	/* Do not overwrite a WLC_E_PRUNE with a WLC_E_SET_SSID
+	 * because an encryption/rsn mismatch results in both events, and
+	 * the important information is in the WLC_E_PRUNE.
+	 */
+	if (!(event == WLC_E_SET_SSID && status == WLC_E_STATUS_FAIL &&
+	      dhd_conn_event == WLC_E_PRUNE)) {
+		dhd_conn_event = event;
+		dhd_conn_status = status;
+		dhd_conn_reason = reason;
+	}
+}
+
+bool dhd_prec_enq(dhd_pub_t *dhdp, struct pktq *q, void *pkt, int prec)
+{
+	void *p;
+	int eprec = -1;		/* precedence to evict from */
+	bool discard_oldest;
+
+	/* Fast case, precedence queue is not full and we are also not
+	 * exceeding total queue length
+	 */
+	if (!pktq_pfull(q, prec) && !pktq_full(q)) {
+		pktq_penq(q, prec, pkt);
+		return true;
+	}
+
+	/* Determine precedence from which to evict packet, if any */
+	if (pktq_pfull(q, prec))
+		eprec = prec;
+	else if (pktq_full(q)) {
+		p = pktq_peek_tail(q, &eprec);
+		ASSERT(p);
+		if (eprec > prec)
+			return false;
+	}
+
+	/* Evict if needed */
+	if (eprec >= 0) {
+		/* Detect queueing to unconfigured precedence */
+		ASSERT(!pktq_pempty(q, eprec));
+		discard_oldest = AC_BITMAP_TST(dhdp->wme_dp, eprec);
+		if (eprec == prec && !discard_oldest)
+			return false;	/* refuse newer (incoming) packet */
+		/* Evict packet according to discard policy */
+		p = discard_oldest ? pktq_pdeq(q, eprec) : pktq_pdeq_tail(q,
+						  eprec);
+		if (p == NULL) {
+			DHD_ERROR(("%s: pktq_penq() failed, oldest %d.",
+				   __func__, discard_oldest));
+			ASSERT(p);
+		}
+
+		PKTFREE(dhdp->osh, p, true);
+	}
+
+	/* Enqueue */
+	p = pktq_penq(q, prec, pkt);
+	if (p == NULL) {
+		DHD_ERROR(("%s: pktq_penq() failed.", __func__));
+		ASSERT(p);
+	}
+
+	return true;
+}
+
+static int
+dhd_iovar_op(dhd_pub_t *dhd_pub, const char *name,
+	     void *params, int plen, void *arg, int len, bool set)
+{
+	int bcmerror = 0;
+	int val_size;
+	const bcm_iovar_t *vi = NULL;
+	u32 actionid;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	ASSERT(name);
+	ASSERT(len >= 0);
+
+	/* Get MUST have return space */
+	ASSERT(set || (arg && len));
+
+	/* Set does NOT take qualifiers */
+	ASSERT(!set || (!params && !plen));
+
+	vi = bcm_iovar_lookup(dhd_iovars, name);
+	if (vi == NULL) {
+		bcmerror = BCME_UNSUPPORTED;
+		goto exit;
+	}
+
+	DHD_CTL(("%s: %s %s, len %d plen %d\n", __func__,
+		 name, (set ? "set" : "get"), len, plen));
+
+	/* set up 'params' pointer in case this is a set command so that
+	 * the convenience int and bool code can be common to set and get
+	 */
+	if (params == NULL) {
+		params = arg;
+		plen = len;
+	}
+
+	if (vi->type == IOVT_VOID)
+		val_size = 0;
+	else if (vi->type == IOVT_BUFFER)
+		val_size = len;
+	else
+		/* all other types are integer sized */
+		val_size = sizeof(int);
+
+	actionid = set ? IOV_SVAL(vi->varid) : IOV_GVAL(vi->varid);
+	bcmerror =
+	    dhd_doiovar(dhd_pub, vi, actionid, name, params, plen, arg, len,
+			val_size);
+
+exit:
+	return bcmerror;
+}
+
+int dhd_ioctl(dhd_pub_t *dhd_pub, dhd_ioctl_t *ioc, void *buf, uint buflen)
+{
+	int bcmerror = 0;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	if (!buf)
+		return BCME_BADARG;
+
+	switch (ioc->cmd) {
+	case DHD_GET_MAGIC:
+		if (buflen < sizeof(int))
+			bcmerror = BCME_BUFTOOSHORT;
+		else
+			*(int *)buf = DHD_IOCTL_MAGIC;
+		break;
+
+	case DHD_GET_VERSION:
+		if (buflen < sizeof(int))
+			bcmerror = -BCME_BUFTOOSHORT;
+		else
+			*(int *)buf = DHD_IOCTL_VERSION;
+		break;
+
+	case DHD_GET_VAR:
+	case DHD_SET_VAR:{
+			char *arg;
+			uint arglen;
+
+			/* scan past the name to any arguments */
+			for (arg = buf, arglen = buflen; *arg && arglen;
+			     arg++, arglen--)
+				;
+
+			if (*arg) {
+				bcmerror = BCME_BUFTOOSHORT;
+				break;
+			}
+
+			/* account for the NUL terminator */
+			arg++, arglen--;
+
+			/* call with the appropriate arguments */
+			if (ioc->cmd == DHD_GET_VAR)
+				bcmerror =
+				    dhd_iovar_op(dhd_pub, buf, arg, arglen, buf,
+						 buflen, IOV_GET);
+			else
+				bcmerror =
+				    dhd_iovar_op(dhd_pub, buf, NULL, 0, arg,
+						 arglen, IOV_SET);
+			if (bcmerror != BCME_UNSUPPORTED)
+				break;
+
+			/* not in generic table, try protocol module */
+			if (ioc->cmd == DHD_GET_VAR)
+				bcmerror = dhd_prot_iovar_op(dhd_pub, buf, arg,
+							     arglen, buf,
+							     buflen, IOV_GET);
+			else
+				bcmerror = dhd_prot_iovar_op(dhd_pub, buf,
+							     NULL, 0, arg,
+							     arglen, IOV_SET);
+			if (bcmerror != BCME_UNSUPPORTED)
+				break;
+
+			/* if still not found, try bus module */
+			if (ioc->cmd == DHD_GET_VAR)
+				bcmerror = dhd_bus_iovar_op(dhd_pub, buf,
+							    arg, arglen, buf,
+							    buflen, IOV_GET);
+			else
+				bcmerror = dhd_bus_iovar_op(dhd_pub, buf,
+							    NULL, 0, arg,
+							    arglen, IOV_SET);
+
+			break;
+		}
+
+	default:
+		bcmerror = BCME_UNSUPPORTED;
+	}
+
+	return bcmerror;
+}
+
+#ifdef SHOW_EVENTS
+static void wl_show_host_event(wl_event_msg_t *event, void *event_data)
+{
+	uint i, status, reason;
+	bool group = false, flush_txq = false, link = false;
+	char *auth_str, *event_name;
+	unsigned char *buf;
+	char err_msg[256], eabuf[ETHER_ADDR_STR_LEN];
+	static struct {
+		uint event;
+		char *event_name;
+	} event_names[] = {
+		{
+		WLC_E_SET_SSID, "SET_SSID"}, {
+		WLC_E_JOIN, "JOIN"}, {
+		WLC_E_START, "START"}, {
+		WLC_E_AUTH, "AUTH"}, {
+		WLC_E_AUTH_IND, "AUTH_IND"}, {
+		WLC_E_DEAUTH, "DEAUTH"}, {
+		WLC_E_DEAUTH_IND, "DEAUTH_IND"}, {
+		WLC_E_ASSOC, "ASSOC"}, {
+		WLC_E_ASSOC_IND, "ASSOC_IND"}, {
+		WLC_E_REASSOC, "REASSOC"}, {
+		WLC_E_REASSOC_IND, "REASSOC_IND"}, {
+		WLC_E_DISASSOC, "DISASSOC"}, {
+		WLC_E_DISASSOC_IND, "DISASSOC_IND"}, {
+		WLC_E_QUIET_START, "START_QUIET"}, {
+		WLC_E_QUIET_END, "END_QUIET"}, {
+		WLC_E_BEACON_RX, "BEACON_RX"}, {
+		WLC_E_LINK, "LINK"}, {
+		WLC_E_MIC_ERROR, "MIC_ERROR"}, {
+		WLC_E_NDIS_LINK, "NDIS_LINK"}, {
+		WLC_E_ROAM, "ROAM"}, {
+		WLC_E_TXFAIL, "TXFAIL"}, {
+		WLC_E_PMKID_CACHE, "PMKID_CACHE"}, {
+		WLC_E_RETROGRADE_TSF, "RETROGRADE_TSF"}, {
+		WLC_E_PRUNE, "PRUNE"}, {
+		WLC_E_AUTOAUTH, "AUTOAUTH"}, {
+		WLC_E_EAPOL_MSG, "EAPOL_MSG"}, {
+		WLC_E_SCAN_COMPLETE, "SCAN_COMPLETE"}, {
+		WLC_E_ADDTS_IND, "ADDTS_IND"}, {
+		WLC_E_DELTS_IND, "DELTS_IND"}, {
+		WLC_E_BCNSENT_IND, "BCNSENT_IND"}, {
+		WLC_E_BCNRX_MSG, "BCNRX_MSG"}, {
+		WLC_E_BCNLOST_MSG, "BCNLOST_MSG"}, {
+		WLC_E_ROAM_PREP, "ROAM_PREP"}, {
+		WLC_E_PFN_NET_FOUND, "PNO_NET_FOUND"}, {
+		WLC_E_PFN_NET_LOST, "PNO_NET_LOST"}, {
+		WLC_E_RESET_COMPLETE, "RESET_COMPLETE"}, {
+		WLC_E_JOIN_START, "JOIN_START"}, {
+		WLC_E_ROAM_START, "ROAM_START"}, {
+		WLC_E_ASSOC_START, "ASSOC_START"}, {
+		WLC_E_IBSS_ASSOC, "IBSS_ASSOC"}, {
+		WLC_E_RADIO, "RADIO"}, {
+		WLC_E_PSM_WATCHDOG, "PSM_WATCHDOG"}, {
+		WLC_E_PROBREQ_MSG, "PROBREQ_MSG"}, {
+		WLC_E_SCAN_CONFIRM_IND, "SCAN_CONFIRM_IND"}, {
+		WLC_E_PSK_SUP, "PSK_SUP"}, {
+		WLC_E_COUNTRY_CODE_CHANGED, "COUNTRY_CODE_CHANGED"}, {
+		WLC_E_EXCEEDED_MEDIUM_TIME, "EXCEEDED_MEDIUM_TIME"}, {
+		WLC_E_ICV_ERROR, "ICV_ERROR"}, {
+		WLC_E_UNICAST_DECODE_ERROR, "UNICAST_DECODE_ERROR"}, {
+		WLC_E_MULTICAST_DECODE_ERROR, "MULTICAST_DECODE_ERROR"}, {
+		WLC_E_TRACE, "TRACE"}, {
+		WLC_E_ACTION_FRAME, "ACTION FRAME"}, {
+		WLC_E_ACTION_FRAME_COMPLETE, "ACTION FRAME TX COMPLETE"}, {
+		WLC_E_IF, "IF"}, {
+		WLC_E_RSSI, "RSSI"}, {
+		WLC_E_PFN_SCAN_COMPLETE, "SCAN_COMPLETE"}
+	};
+	uint event_type, flags, auth_type, datalen;
+	event_type = ntoh32(event->event_type);
+	flags = ntoh16(event->flags);
+	status = ntoh32(event->status);
+	reason = ntoh32(event->reason);
+	auth_type = ntoh32(event->auth_type);
+	datalen = ntoh32(event->datalen);
+	/* debug dump of event messages */
+	sprintf(eabuf, "%pM", event->addr.octet);
+
+	event_name = "UNKNOWN";
+	for (i = 0; i < ARRAY_SIZE(event_names); i++) {
+		if (event_names[i].event == event_type)
+			event_name = event_names[i].event_name;
+	}
+
+	DHD_EVENT(("EVENT: %s, event ID = %d\n", event_name, event_type));
+
+	if (flags & WLC_EVENT_MSG_LINK)
+		link = true;
+	if (flags & WLC_EVENT_MSG_GROUP)
+		group = true;
+	if (flags & WLC_EVENT_MSG_FLUSHTXQ)
+		flush_txq = true;
+
+	switch (event_type) {
+	case WLC_E_START:
+	case WLC_E_DEAUTH:
+	case WLC_E_DISASSOC:
+		DHD_EVENT(("MACEVENT: %s, MAC %s\n", event_name, eabuf));
+		break;
+
+	case WLC_E_ASSOC_IND:
+	case WLC_E_REASSOC_IND:
+		DHD_EVENT(("MACEVENT: %s, MAC %s\n", event_name, eabuf));
+		break;
+
+	case WLC_E_ASSOC:
+	case WLC_E_REASSOC:
+		if (status == WLC_E_STATUS_SUCCESS) {
+			DHD_EVENT(("MACEVENT: %s, MAC %s, SUCCESS\n",
+				   event_name, eabuf));
+		} else if (status == WLC_E_STATUS_TIMEOUT) {
+			DHD_EVENT(("MACEVENT: %s, MAC %s, TIMEOUT\n",
+				   event_name, eabuf));
+		} else if (status == WLC_E_STATUS_FAIL) {
+			DHD_EVENT(("MACEVENT: %s, MAC %s, FAILURE, reason %d\n",
+				   event_name, eabuf, (int)reason));
+		} else {
+			DHD_EVENT(("MACEVENT: %s, MAC %s, unexpected status "
+				"%d\n", event_name, eabuf, (int)status));
+		}
+		break;
+
+	case WLC_E_DEAUTH_IND:
+	case WLC_E_DISASSOC_IND:
+		DHD_EVENT(("MACEVENT: %s, MAC %s, reason %d\n", event_name,
+			   eabuf, (int)reason));
+		break;
+
+	case WLC_E_AUTH:
+	case WLC_E_AUTH_IND:
+		if (auth_type == DOT11_OPEN_SYSTEM)
+			auth_str = "Open System";
+		else if (auth_type == DOT11_SHARED_KEY)
+			auth_str = "Shared Key";
+		else {
+			sprintf(err_msg, "AUTH unknown: %d", (int)auth_type);
+			auth_str = err_msg;
+		}
+		if (event_type == WLC_E_AUTH_IND) {
+			DHD_EVENT(("MACEVENT: %s, MAC %s, %s\n", event_name,
+				   eabuf, auth_str));
+		} else if (status == WLC_E_STATUS_SUCCESS) {
+			DHD_EVENT(("MACEVENT: %s, MAC %s, %s, SUCCESS\n",
+				   event_name, eabuf, auth_str));
+		} else if (status == WLC_E_STATUS_TIMEOUT) {
+			DHD_EVENT(("MACEVENT: %s, MAC %s, %s, TIMEOUT\n",
+				   event_name, eabuf, auth_str));
+		} else if (status == WLC_E_STATUS_FAIL) {
+			DHD_EVENT(("MACEVENT: %s, MAC %s, %s, FAILURE, "
+				"reason %d\n",
+				event_name, eabuf, auth_str, (int)reason));
+		}
+
+		break;
+
+	case WLC_E_JOIN:
+	case WLC_E_ROAM:
+	case WLC_E_SET_SSID:
+		if (status == WLC_E_STATUS_SUCCESS) {
+			DHD_EVENT(("MACEVENT: %s, MAC %s\n", event_name,
+				   eabuf));
+		} else if (status == WLC_E_STATUS_FAIL) {
+			DHD_EVENT(("MACEVENT: %s, failed\n", event_name));
+		} else if (status == WLC_E_STATUS_NO_NETWORKS) {
+			DHD_EVENT(("MACEVENT: %s, no networks found\n",
+				   event_name));
+		} else {
+			DHD_EVENT(("MACEVENT: %s, unexpected status %d\n",
+				   event_name, (int)status));
+		}
+		break;
+
+	case WLC_E_BEACON_RX:
+		if (status == WLC_E_STATUS_SUCCESS) {
+			DHD_EVENT(("MACEVENT: %s, SUCCESS\n", event_name));
+		} else if (status == WLC_E_STATUS_FAIL) {
+			DHD_EVENT(("MACEVENT: %s, FAIL\n", event_name));
+		} else {
+			DHD_EVENT(("MACEVENT: %s, status %d\n", event_name,
+				   status));
+		}
+		break;
+
+	case WLC_E_LINK:
+		DHD_EVENT(("MACEVENT: %s %s\n", event_name,
+			   link ? "UP" : "DOWN"));
+		break;
+
+	case WLC_E_MIC_ERROR:
+		DHD_EVENT(("MACEVENT: %s, MAC %s, Group %d, Flush %d\n",
+			   event_name, eabuf, group, flush_txq));
+		break;
+
+	case WLC_E_ICV_ERROR:
+	case WLC_E_UNICAST_DECODE_ERROR:
+	case WLC_E_MULTICAST_DECODE_ERROR:
+		DHD_EVENT(("MACEVENT: %s, MAC %s\n", event_name, eabuf));
+		break;
+
+	case WLC_E_TXFAIL:
+		DHD_EVENT(("MACEVENT: %s, RA %s\n", event_name, eabuf));
+		break;
+
+	case WLC_E_SCAN_COMPLETE:
+	case WLC_E_PMKID_CACHE:
+		DHD_EVENT(("MACEVENT: %s\n", event_name));
+		break;
+
+	case WLC_E_PFN_NET_FOUND:
+	case WLC_E_PFN_NET_LOST:
+	case WLC_E_PFN_SCAN_COMPLETE:
+		DHD_EVENT(("PNOEVENT: %s\n", event_name));
+		break;
+
+	case WLC_E_PSK_SUP:
+	case WLC_E_PRUNE:
+		DHD_EVENT(("MACEVENT: %s, status %d, reason %d\n",
+			   event_name, (int)status, (int)reason));
+		break;
+
+	case WLC_E_TRACE:
+		{
+			static u32 seqnum_prev;
+			msgtrace_hdr_t hdr;
+			u32 nblost;
+			char *s, *p;
+
+			buf = (unsigned char *) event_data;
+			memcpy(&hdr, buf, MSGTRACE_HDRLEN);
+
+			if (hdr.version != MSGTRACE_VERSION) {
+				printf
+				    ("\nMACEVENT: %s [unsupported version --> "
+				     "dhd version:%d dongle version:%d]\n",
+				     event_name, MSGTRACE_VERSION, hdr.version);
+				/* Reset datalen to avoid display below */
+				datalen = 0;
+				break;
+			}
+
+			/* There are 2 bytes available at the end of data */
+			buf[MSGTRACE_HDRLEN + ntoh16(hdr.len)] = '\0';
+
+			if (ntoh32(hdr.discarded_bytes)
+			    || ntoh32(hdr.discarded_printf)) {
+				printf
+				    ("\nWLC_E_TRACE: [Discarded traces in dongle -->"
+				     "discarded_bytes %d discarded_printf %d]\n",
+				     ntoh32(hdr.discarded_bytes),
+				     ntoh32(hdr.discarded_printf));
+			}
+
+			nblost = ntoh32(hdr.seqnum) - seqnum_prev - 1;
+			if (nblost > 0) {
+				printf
+				    ("\nWLC_E_TRACE: [Event lost --> seqnum %d nblost %d\n",
+				     ntoh32(hdr.seqnum), nblost);
+			}
+			seqnum_prev = ntoh32(hdr.seqnum);
+
+			/* Display the trace buffer. Advance from \n to \n to
+			 * avoid display big
+			 * printf (issue with Linux printk )
+			 */
+			p = (char *)&buf[MSGTRACE_HDRLEN];
+			while ((s = strstr(p, "\n")) != NULL) {
+				*s = '\0';
+				printf("%s\n", p);
+				p = s + 1;
+			}
+			printf("%s\n", p);
+
+			/* Reset datalen to avoid display below */
+			datalen = 0;
+		}
+		break;
+
+	case WLC_E_RSSI:
+		DHD_EVENT(("MACEVENT: %s %d\n", event_name,
+			   ntoh32(*((int *)event_data))));
+		break;
+
+	default:
+		DHD_EVENT(("MACEVENT: %s %d, MAC %s, status %d, reason %d, "
+			"auth %d\n", event_name, event_type, eabuf,
+			(int)status, (int)reason, (int)auth_type));
+		break;
+	}
+
+	/* show any appended data */
+	if (datalen) {
+		buf = (unsigned char *) event_data;
+		DHD_EVENT((" data (%d) : ", datalen));
+		for (i = 0; i < datalen; i++)
+			DHD_EVENT((" 0x%02x ", *buf++));
+		DHD_EVENT(("\n"));
+	}
+}
+#endif				/* SHOW_EVENTS */
+
+int
+wl_host_event(struct dhd_info *dhd, int *ifidx, void *pktdata,
+	      wl_event_msg_t *event, void **data_ptr)
+{
+	/* check whether packet is a BRCM event pkt */
+	bcm_event_t *pvt_data = (bcm_event_t *) pktdata;
+	char *event_data;
+	u32 type, status;
+	u16 flags;
+	int evlen;
+
+	if (bcmp(BRCM_OUI, &pvt_data->bcm_hdr.oui[0], DOT11_OUI_LEN)) {
+		DHD_ERROR(("%s: mismatched OUI, bailing\n", __func__));
+		return BCME_ERROR;
+	}
+
+	/* BRCM event pkt may be unaligned - use xxx_ua to load user_subtype. */
+	if (ntoh16_ua((void *)&pvt_data->bcm_hdr.usr_subtype) !=
+	    BCMILCP_BCM_SUBTYPE_EVENT) {
+		DHD_ERROR(("%s: mismatched subtype, bailing\n", __func__));
+		return BCME_ERROR;
+	}
+
+	*data_ptr = &pvt_data[1];
+	event_data = *data_ptr;
+
+	/* memcpy since BRCM event pkt may be unaligned. */
+	memcpy(event, &pvt_data->event, sizeof(wl_event_msg_t));
+
+	type = ntoh32_ua((void *)&event->event_type);
+	flags = ntoh16_ua((void *)&event->flags);
+	status = ntoh32_ua((void *)&event->status);
+	evlen = ntoh32_ua((void *)&event->datalen) + sizeof(bcm_event_t);
+
+	switch (type) {
+	case WLC_E_IF:
+		{
+			dhd_if_event_t *ifevent = (dhd_if_event_t *) event_data;
+			DHD_TRACE(("%s: if event\n", __func__));
+
+			if (ifevent->ifidx > 0 &&
+				 ifevent->ifidx < DHD_MAX_IFS) {
+				if (ifevent->action == WLC_E_IF_ADD)
+					dhd_add_if(dhd, ifevent->ifidx,
+						   NULL, event->ifname,
+						   pvt_data->eth.ether_dhost,
+						   ifevent->flags,
+						   ifevent->bssidx);
+				else
+					dhd_del_if(dhd, ifevent->ifidx);
+			} else {
+				DHD_ERROR(("%s: Invalid ifidx %d for %s\n",
+					   __func__, ifevent->ifidx,
+					   event->ifname));
+			}
+		}
+		/* send up the if event: btamp user needs it */
+		*ifidx = dhd_ifname2idx(dhd, event->ifname);
+		/* push up to external supp/auth */
+		dhd_event(dhd, (char *)pvt_data, evlen, *ifidx);
+		break;
+
+#ifdef P2P
+	case WLC_E_NDIS_LINK:
+		break;
+#endif
+		/* fall through */
+		/* These are what external supplicant/authenticator wants */
+	case WLC_E_LINK:
+	case WLC_E_ASSOC_IND:
+	case WLC_E_REASSOC_IND:
+	case WLC_E_DISASSOC_IND:
+	case WLC_E_MIC_ERROR:
+	default:
+		/* Fall through: this should get _everything_  */
+
+		*ifidx = dhd_ifname2idx(dhd, event->ifname);
+		/* push up to external supp/auth */
+		dhd_event(dhd, (char *)pvt_data, evlen, *ifidx);
+		DHD_TRACE(("%s: MAC event %d, flags %x, status %x\n",
+			   __func__, type, flags, status));
+
+		/* put it back to WLC_E_NDIS_LINK */
+		if (type == WLC_E_NDIS_LINK) {
+			u32 temp;
+
+			temp = ntoh32_ua((void *)&event->event_type);
+			DHD_TRACE(("Converted to WLC_E_LINK type %d\n", temp));
+
+			temp = ntoh32(WLC_E_NDIS_LINK);
+			memcpy((void *)(&pvt_data->event.event_type), &temp,
+			       sizeof(pvt_data->event.event_type));
+		}
+		break;
+	}
+
+#ifdef SHOW_EVENTS
+	wl_show_host_event(event, event_data);
+#endif				/* SHOW_EVENTS */
+
+	return BCME_OK;
+}
+
+void wl_event_to_host_order(wl_event_msg_t *evt)
+{
+	/* Event struct members passed from dongle to host are stored
+	 * in network
+	 * byte order. Convert all members to host-order.
+	 */
+	evt->event_type = ntoh32(evt->event_type);
+	evt->flags = ntoh16(evt->flags);
+	evt->status = ntoh32(evt->status);
+	evt->reason = ntoh32(evt->reason);
+	evt->auth_type = ntoh32(evt->auth_type);
+	evt->datalen = ntoh32(evt->datalen);
+	evt->version = ntoh16(evt->version);
+}
+
+void print_buf(void *pbuf, int len, int bytes_per_line)
+{
+	int i, j = 0;
+	unsigned char *buf = pbuf;
+
+	if (bytes_per_line == 0)
+		bytes_per_line = len;
+
+	for (i = 0; i < len; i++) {
+		printf("%2.2x", *buf++);
+		j++;
+		if (j == bytes_per_line) {
+			printf("\n");
+			j = 0;
+		} else {
+			printf(":");
+		}
+	}
+	printf("\n");
+}
+
+/* Convert user's input in hex pattern to byte-size mask */
+static int wl_pattern_atoh(char *src, char *dst)
+{
+	int i;
+	if (strncmp(src, "0x", 2) != 0 && strncmp(src, "0X", 2) != 0) {
+		DHD_ERROR(("Mask invalid format. Needs to start with 0x\n"));
+		return -1;
+	}
+	src = src + 2;		/* Skip past 0x */
+	if (strlen(src) % 2 != 0) {
+		DHD_ERROR(("Mask invalid format. Length must be even.\n"));
+		return -1;
+	}
+	for (i = 0; *src != '\0'; i++) {
+		char num[3];
+		strncpy(num, src, 2);
+		num[2] = '\0';
+		dst[i] = (u8) simple_strtoul(num, NULL, 16);
+		src += 2;
+	}
+	return i;
+}
+
+void
+dhd_pktfilter_offload_enable(dhd_pub_t *dhd, char *arg, int enable,
+			     int master_mode)
+{
+	char *argv[8];
+	int i = 0;
+	const char *str;
+	int buf_len;
+	int str_len;
+	char *arg_save = 0, *arg_org = 0;
+	int rc;
+	char buf[128];
+	wl_pkt_filter_enable_t enable_parm;
+	wl_pkt_filter_enable_t *pkt_filterp;
+
+	arg_save = kmalloc(strlen(arg) + 1, GFP_ATOMIC);
+	if (!arg_save) {
+		DHD_ERROR(("%s: kmalloc failed\n", __func__));
+		goto fail;
+	}
+	arg_org = arg_save;
+	memcpy(arg_save, arg, strlen(arg) + 1);
+
+	argv[i] = strsep(&arg_save, " ");
+
+	i = 0;
+	if (NULL == argv[i]) {
+		DHD_ERROR(("No args provided\n"));
+		goto fail;
+	}
+
+	str = "pkt_filter_enable";
+	str_len = strlen(str);
+	strncpy(buf, str, str_len);
+	buf[str_len] = '\0';
+	buf_len = str_len + 1;
+
+	pkt_filterp = (wl_pkt_filter_enable_t *) (buf + str_len + 1);
+
+	/* Parse packet filter id. */
+	enable_parm.id = htod32(simple_strtoul(argv[i], NULL, 0));
+
+	/* Parse enable/disable value. */
+	enable_parm.enable = htod32(enable);
+
+	buf_len += sizeof(enable_parm);
+	memcpy((char *)pkt_filterp, &enable_parm, sizeof(enable_parm));
+
+	/* Enable/disable the specified filter. */
+	rc = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, buf, buf_len);
+	rc = rc >= 0 ? 0 : rc;
+	if (rc)
+		DHD_TRACE(("%s: failed to add pktfilter %s, retcode = %d\n",
+			   __func__, arg, rc));
+	else
+		DHD_TRACE(("%s: successfully added pktfilter %s\n",
+			   __func__, arg));
+
+	/* Contorl the master mode */
+	bcm_mkiovar("pkt_filter_mode", (char *)&master_mode, 4, buf,
+		    sizeof(buf));
+	rc = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, buf, sizeof(buf));
+	rc = rc >= 0 ? 0 : rc;
+	if (rc)
+		DHD_TRACE(("%s: failed to add pktfilter %s, retcode = %d\n",
+			   __func__, arg, rc));
+
+fail:
+	if (arg_org)
+		kfree(arg_org);
+}
+
+void dhd_pktfilter_offload_set(dhd_pub_t *dhd, char *arg)
+{
+	const char *str;
+	wl_pkt_filter_t pkt_filter;
+	wl_pkt_filter_t *pkt_filterp;
+	int buf_len;
+	int str_len;
+	int rc;
+	u32 mask_size;
+	u32 pattern_size;
+	char *argv[8], *buf = 0;
+	int i = 0;
+	char *arg_save = 0, *arg_org = 0;
+#define BUF_SIZE		2048
+
+	arg_save = kmalloc(strlen(arg) + 1, GFP_ATOMIC);
+	if (!arg_save) {
+		DHD_ERROR(("%s: kmalloc failed\n", __func__));
+		goto fail;
+	}
+
+	arg_org = arg_save;
+
+	buf = kmalloc(BUF_SIZE, GFP_ATOMIC);
+	if (!buf) {
+		DHD_ERROR(("%s: kmalloc failed\n", __func__));
+		goto fail;
+	}
+
+	memcpy(arg_save, arg, strlen(arg) + 1);
+
+	if (strlen(arg) > BUF_SIZE) {
+		DHD_ERROR(("Not enough buffer %d < %d\n", (int)strlen(arg),
+			   (int)sizeof(buf)));
+		goto fail;
+	}
+
+	argv[i] = strsep(&arg_save, " ");
+	while (argv[i++])
+		argv[i] = strsep(&arg_save, " ");
+
+	i = 0;
+	if (NULL == argv[i]) {
+		DHD_ERROR(("No args provided\n"));
+		goto fail;
+	}
+
+	str = "pkt_filter_add";
+	str_len = strlen(str);
+	strncpy(buf, str, str_len);
+	buf[str_len] = '\0';
+	buf_len = str_len + 1;
+
+	pkt_filterp = (wl_pkt_filter_t *) (buf + str_len + 1);
+
+	/* Parse packet filter id. */
+	pkt_filter.id = htod32(simple_strtoul(argv[i], NULL, 0));
+
+	if (NULL == argv[++i]) {
+		DHD_ERROR(("Polarity not provided\n"));
+		goto fail;
+	}
+
+	/* Parse filter polarity. */
+	pkt_filter.negate_match = htod32(simple_strtoul(argv[i], NULL, 0));
+
+	if (NULL == argv[++i]) {
+		DHD_ERROR(("Filter type not provided\n"));
+		goto fail;
+	}
+
+	/* Parse filter type. */
+	pkt_filter.type = htod32(simple_strtoul(argv[i], NULL, 0));
+
+	if (NULL == argv[++i]) {
+		DHD_ERROR(("Offset not provided\n"));
+		goto fail;
+	}
+
+	/* Parse pattern filter offset. */
+	pkt_filter.u.pattern.offset = htod32(simple_strtoul(argv[i], NULL, 0));
+
+	if (NULL == argv[++i]) {
+		DHD_ERROR(("Bitmask not provided\n"));
+		goto fail;
+	}
+
+	/* Parse pattern filter mask. */
+	mask_size =
+	    htod32(wl_pattern_atoh
+		   (argv[i], (char *)pkt_filterp->u.pattern.mask_and_pattern));
+
+	if (NULL == argv[++i]) {
+		DHD_ERROR(("Pattern not provided\n"));
+		goto fail;
+	}
+
+	/* Parse pattern filter pattern. */
+	pattern_size =
+	    htod32(wl_pattern_atoh(argv[i],
+				   (char *)&pkt_filterp->u.pattern.
+				   mask_and_pattern[mask_size]));
+
+	if (mask_size != pattern_size) {
+		DHD_ERROR(("Mask and pattern not the same size\n"));
+		goto fail;
+	}
+
+	pkt_filter.u.pattern.size_bytes = mask_size;
+	buf_len += WL_PKT_FILTER_FIXED_LEN;
+	buf_len += (WL_PKT_FILTER_PATTERN_FIXED_LEN + 2 * mask_size);
+
+	/* Keep-alive attributes are set in local
+	 * variable (keep_alive_pkt), and
+	 ** then memcpy'ed into buffer (keep_alive_pktp) since there is no
+	 ** guarantee that the buffer is properly aligned.
+	 */
+	memcpy((char *)pkt_filterp,
+	       &pkt_filter,
+	       WL_PKT_FILTER_FIXED_LEN + WL_PKT_FILTER_PATTERN_FIXED_LEN);
+
+	rc = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, buf, buf_len);
+	rc = rc >= 0 ? 0 : rc;
+
+	if (rc)
+		DHD_TRACE(("%s: failed to add pktfilter %s, retcode = %d\n",
+			   __func__, arg, rc));
+	else
+		DHD_TRACE(("%s: successfully added pktfilter %s\n",
+			   __func__, arg));
+
+fail:
+	if (arg_org)
+		kfree(arg_org);
+
+	if (buf)
+		kfree(buf);
+}
+
+void dhd_arp_offload_set(dhd_pub_t *dhd, int arp_mode)
+{
+	char iovbuf[32];
+	int retcode;
+
+	bcm_mkiovar("arp_ol", (char *)&arp_mode, 4, iovbuf, sizeof(iovbuf));
+	retcode = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+	retcode = retcode >= 0 ? 0 : retcode;
+	if (retcode)
+		DHD_TRACE(("%s: failed to set ARP offload mode to 0x%x, "
+			"retcode = %d\n", __func__, arp_mode, retcode));
+	else
+		DHD_TRACE(("%s: successfully set ARP offload mode to 0x%x\n",
+			   __func__, arp_mode));
+}
+
+void dhd_arp_offload_enable(dhd_pub_t *dhd, int arp_enable)
+{
+	char iovbuf[32];
+	int retcode;
+
+	bcm_mkiovar("arpoe", (char *)&arp_enable, 4, iovbuf, sizeof(iovbuf));
+	retcode = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+	retcode = retcode >= 0 ? 0 : retcode;
+	if (retcode)
+		DHD_TRACE(("%s: failed to enabe ARP offload to %d, "
+			"retcode = %d\n", __func__, arp_enable, retcode));
+	else
+		DHD_TRACE(("%s: successfully enabed ARP offload to %d\n",
+			   __func__, arp_enable));
+}
+
+int dhd_preinit_ioctls(dhd_pub_t *dhd)
+{
+	char iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for
+				 "event_msgs" + '\0' + bitvec  */
+	uint up = 0;
+	char buf[128], *ptr;
+	uint power_mode = PM_FAST;
+	u32 dongle_align = DHD_SDALIGN;
+	u32 glom = 0;
+	uint bcn_timeout = 3;
+	int scan_assoc_time = 40;
+	int scan_unassoc_time = 40;
+#ifdef GET_CUSTOM_MAC_ENABLE
+	int ret = 0;
+	struct ether_addr ea_addr;
+#endif				/* GET_CUSTOM_MAC_ENABLE */
+
+	dhd_os_proto_block(dhd);
+
+#ifdef GET_CUSTOM_MAC_ENABLE
+	/* Read MAC address from external customer place
+	 ** NOTE that default mac address has to be present in
+	 ** otp or nvram file to bring up
+	 ** firmware but unique per board mac address maybe provided by
+	 ** customer code
+	 */
+	ret = dhd_custom_get_mac_address(ea_addr.octet);
+	if (!ret) {
+		bcm_mkiovar("cur_etheraddr", (void *)&ea_addr, ETHER_ADDR_LEN,
+			    buf, sizeof(buf));
+		ret = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, buf, sizeof(buf));
+		if (ret < 0) {
+			DHD_ERROR(("%s: can't set MAC address , error=%d\n",
+				   __func__, ret));
+		} else
+			memcpy(dhd->mac.octet, (void *)&ea_addr,
+			       ETHER_ADDR_LEN);
+	}
+#endif				/* GET_CUSTOM_MAC_ENABLE */
+
+	/* Set Country code */
+	if (dhd->country_code[0] != 0) {
+		if (dhdcdc_set_ioctl(dhd, 0, WLC_SET_COUNTRY,
+				     dhd->country_code,
+				     sizeof(dhd->country_code)) < 0) {
+			DHD_ERROR(("%s: country code setting failed\n",
+				   __func__));
+		}
+	}
+
+	/* query for 'ver' to get version info from firmware */
+	memset(buf, 0, sizeof(buf));
+	ptr = buf;
+	bcm_mkiovar("ver", 0, 0, buf, sizeof(buf));
+	dhdcdc_query_ioctl(dhd, 0, WLC_GET_VAR, buf, sizeof(buf));
+	strsep(&ptr, "\n");
+	/* Print fw version info */
+	DHD_ERROR(("Firmware version = %s\n", buf));
+
+	/* Set PowerSave mode */
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_PM, (char *)&power_mode,
+			 sizeof(power_mode));
+
+	/* Match Host and Dongle rx alignment */
+	bcm_mkiovar("bus:txglomalign", (char *)&dongle_align, 4, iovbuf,
+		    sizeof(iovbuf));
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+
+	/* disable glom option per default */
+	bcm_mkiovar("bus:txglom", (char *)&glom, 4, iovbuf, sizeof(iovbuf));
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+
+	/* Setup timeout if Beacons are lost and roam is off to report
+		 link down */
+	bcm_mkiovar("bcn_timeout", (char *)&bcn_timeout, 4, iovbuf,
+		    sizeof(iovbuf));
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+
+	/* Enable/Disable build-in roaming to allowed ext supplicant to take
+		 of romaing */
+	bcm_mkiovar("roam_off", (char *)&dhd_roam, 4, iovbuf, sizeof(iovbuf));
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+
+	/* Force STA UP */
+	if (dhd_radio_up)
+		dhdcdc_set_ioctl(dhd, 0, WLC_UP, (char *)&up, sizeof(up));
+
+	/* Setup event_msgs */
+	bcm_mkiovar("event_msgs", dhd->eventmask, WL_EVENTING_MASK_LEN, iovbuf,
+		    sizeof(iovbuf));
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_SCAN_CHANNEL_TIME,
+			 (char *)&scan_assoc_time, sizeof(scan_assoc_time));
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_SCAN_UNASSOC_TIME,
+			 (char *)&scan_unassoc_time, sizeof(scan_unassoc_time));
+
+#ifdef ARP_OFFLOAD_SUPPORT
+	/* Set and enable ARP offload feature */
+	if (dhd_arp_enable)
+		dhd_arp_offload_set(dhd, dhd_arp_mode);
+	dhd_arp_offload_enable(dhd, dhd_arp_enable);
+#endif				/* ARP_OFFLOAD_SUPPORT */
+
+#ifdef PKT_FILTER_SUPPORT
+	{
+		int i;
+		/* Set up pkt filter */
+		if (dhd_pkt_filter_enable) {
+			for (i = 0; i < dhd->pktfilter_count; i++) {
+				dhd_pktfilter_offload_set(dhd,
+							  dhd->pktfilter[i]);
+				dhd_pktfilter_offload_enable(dhd,
+				     dhd->pktfilter[i],
+				     dhd_pkt_filter_init,
+				     dhd_master_mode);
+			}
+		}
+	}
+#endif				/* PKT_FILTER_SUPPORT */
+
+	dhd_os_proto_unblock(dhd);
+
+	return 0;
+}
+
+#ifdef SIMPLE_ISCAN
+uint iscan_thread_id;
+iscan_buf_t *iscan_chain;
+
+iscan_buf_t *dhd_iscan_allocate_buf(dhd_pub_t *dhd, iscan_buf_t **iscanbuf)
+{
+	iscan_buf_t *iscanbuf_alloc = 0;
+	iscan_buf_t *iscanbuf_head;
+
+	dhd_iscan_lock();
+
+	iscanbuf_alloc = kmalloc(sizeof(iscan_buf_t), GFP_ATOMIC);
+	if (iscanbuf_alloc == NULL)
+		goto fail;
+
+	iscanbuf_alloc->next = NULL;
+	iscanbuf_head = *iscanbuf;
+
+	DHD_ISCAN(("%s: addr of allocated node = 0x%X"
+		   "addr of iscanbuf_head = 0x%X dhd = 0x%X\n",
+		   __func__, iscanbuf_alloc, iscanbuf_head, dhd));
+
+	if (iscanbuf_head == NULL) {
+		*iscanbuf = iscanbuf_alloc;
+		DHD_ISCAN(("%s: Head is allocated\n", __func__));
+		goto fail;
+	}
+
+	while (iscanbuf_head->next)
+		iscanbuf_head = iscanbuf_head->next;
+
+	iscanbuf_head->next = iscanbuf_alloc;
+
+fail:
+	dhd_iscan_unlock();
+	return iscanbuf_alloc;
+}
+
+void dhd_iscan_free_buf(void *dhdp, iscan_buf_t *iscan_delete)
+{
+	iscan_buf_t *iscanbuf_free = 0;
+	iscan_buf_t *iscanbuf_prv = 0;
+	iscan_buf_t *iscanbuf_cur = iscan_chain;
+	dhd_pub_t *dhd = dhd_bus_pub(dhdp);
+
+	dhd_iscan_lock();
+	/* If iscan_delete is null then delete the entire
+	 * chain or else delete specific one provided
+	 */
+	if (!iscan_delete) {
+		while (iscanbuf_cur) {
+			iscanbuf_free = iscanbuf_cur;
+			iscanbuf_cur = iscanbuf_cur->next;
+			iscanbuf_free->next = 0;
+			kfree(iscanbuf_free);
+		}
+		iscan_chain = 0;
+	} else {
+		while (iscanbuf_cur) {
+			if (iscanbuf_cur == iscan_delete)
+				break;
+			iscanbuf_prv = iscanbuf_cur;
+			iscanbuf_cur = iscanbuf_cur->next;
+		}
+		if (iscanbuf_prv)
+			iscanbuf_prv->next = iscan_delete->next;
+
+		iscan_delete->next = 0;
+		kfree(iscan_delete);
+
+		if (!iscanbuf_prv)
+			iscan_chain = 0;
+	}
+	dhd_iscan_unlock();
+}
+
+iscan_buf_t *dhd_iscan_result_buf(void)
+{
+	return iscan_chain;
+}
+
+/*
+* print scan cache
+* print partial iscan_skip list differently
+*/
+int dhd_iscan_print_cache(iscan_buf_t *iscan_skip)
+{
+	int i = 0, l = 0;
+	iscan_buf_t *iscan_cur;
+	wl_iscan_results_t *list;
+	wl_scan_results_t *results;
+	wl_bss_info_t UNALIGNED *bi;
+
+	dhd_iscan_lock();
+
+	iscan_cur = dhd_iscan_result_buf();
+
+	while (iscan_cur) {
+		list = (wl_iscan_results_t *)iscan_cur->iscan_buf;
+		if (!list)
+			break;
+
+		results = (wl_scan_results_t *)&list->results;
+		if (!results)
+			break;
+
+		if (results->version != WL_BSS_INFO_VERSION) {
+			DHD_ISCAN(("%s: results->version %d != "
+				"WL_BSS_INFO_VERSION\n",
+				__func__, results->version));
+			goto done;
+		}
+
+		bi = results->bss_info;
+		for (i = 0; i < results->count; i++) {
+			if (!bi)
+				break;
+
+			DHD_ISCAN(("%s[%2.2d:%2.2d] %X:%X:%X:%X:%X:%X\n",
+				   iscan_cur != iscan_skip ? "BSS" : "bss", l,
+				   i, bi->BSSID.octet[0], bi->BSSID.octet[1],
+				   bi->BSSID.octet[2], bi->BSSID.octet[3],
+				   bi->BSSID.octet[4], bi->BSSID.octet[5]));
+
+			bi = (wl_bss_info_t *)((unsigned long)bi +
+						dtoh32(bi->length));
+		}
+		iscan_cur = iscan_cur->next;
+		l++;
+	}
+
+done:
+	dhd_iscan_unlock();
+	return 0;
+}
+
+/*
+* delete disappeared AP from specific scan cache but skip partial
+* list in iscan_skip
+*/
+int dhd_iscan_delete_bss(void *dhdp, void *addr, iscan_buf_t *iscan_skip)
+{
+	int i = 0, j = 0, l = 0;
+	iscan_buf_t *iscan_cur;
+	wl_iscan_results_t *list;
+	wl_scan_results_t *results;
+	wl_bss_info_t UNALIGNED *bi, *bi_new, *bi_next;
+
+	unsigned char *s_addr = addr;
+
+	dhd_iscan_lock();
+	DHD_ISCAN(("%s: BSS to remove %X:%X:%X:%X:%X:%X\n",
+		   __func__, s_addr[0], s_addr[1], s_addr[2],
+		   s_addr[3], s_addr[4], s_addr[5]));
+
+	iscan_cur = dhd_iscan_result_buf();
+
+	while (iscan_cur) {
+		if (iscan_cur != iscan_skip) {
+			list = (wl_iscan_results_t *)iscan_cur->iscan_buf;
+			if (!list)
+				break;
+
+			results = (wl_scan_results_t *)&list->results;
+			if (!results)
+				break;
+
+			if (results->version != WL_BSS_INFO_VERSION) {
+				DHD_ERROR(("%s: results->version %d != "
+					"WL_BSS_INFO_VERSION\n",
+					__func__, results->version));
+				goto done;
+			}
+
+			bi = results->bss_info;
+			for (i = 0; i < results->count; i++) {
+				if (!bi)
+					break;
+
+				if (!memcmp
+				    (bi->BSSID.octet, addr, ETHER_ADDR_LEN)) {
+					DHD_ISCAN(("%s: Del BSS[%2.2d:%2.2d] "
+					"%X:%X:%X:%X:%X:%X\n",
+					__func__, l, i, bi->BSSID.octet[0],
+					bi->BSSID.octet[1], bi->BSSID.octet[2],
+					bi->BSSID.octet[3], bi->BSSID.octet[4],
+					bi->BSSID.octet[5]));
+
+					bi_new = bi;
+					bi = (wl_bss_info_t *)((unsigned long)bi +
+								dtoh32
+								(bi->length));
+/*
+			if(bi && bi_new) {
+				bcopy(bi, bi_new, results->buflen -
+				dtoh32(bi_new->length));
+				results->buflen -= dtoh32(bi_new->length);
+			}
+*/
+					results->buflen -=
+					    dtoh32(bi_new->length);
+					results->count--;
+
+					for (j = i; j < results->count; j++) {
+						if (bi && bi_new) {
+							DHD_ISCAN(("%s: Moved up BSS[%2.2d:%2.2d]" "%X:%X:%X:%X:%X:%X\n",
+							__func__, l, j,
+							bi->BSSID.octet[0],
+							bi->BSSID.octet[1],
+							bi->BSSID.octet[2],
+							bi->BSSID.octet[3],
+							bi->BSSID.octet[4],
+							bi->BSSID.octet[5]));
+
+							bi_next =
+							    (wl_bss_info_t *)((unsigned long)bi +
+								 dtoh32
+								 (bi->length));
+							bcopy(bi, bi_new,
+							      dtoh32
+							      (bi->length));
+							bi_new =
+							    (wl_bss_info_t *)((unsigned long)bi_new +
+								 dtoh32
+								 (bi_new->
+								  length));
+							bi = bi_next;
+						}
+					}
+
+					if (results->count == 0) {
+						/* Prune now empty partial
+						scan list */
+						dhd_iscan_free_buf(dhdp,
+								   iscan_cur);
+						goto done;
+					}
+					break;
+				}
+				bi = (wl_bss_info_t *)((unsigned long)bi +
+							dtoh32(bi->length));
+			}
+		}
+		iscan_cur = iscan_cur->next;
+		l++;
+	}
+
+done:
+	dhd_iscan_unlock();
+	return 0;
+}
+
+int dhd_iscan_remove_duplicates(void *dhdp, iscan_buf_t *iscan_cur)
+{
+	int i = 0;
+	wl_iscan_results_t *list;
+	wl_scan_results_t *results;
+	wl_bss_info_t UNALIGNED *bi, *bi_new, *bi_next;
+
+	dhd_iscan_lock();
+
+	DHD_ISCAN(("%s: Scan cache before delete\n", __func__));
+	dhd_iscan_print_cache(iscan_cur);
+
+	if (!iscan_cur)
+		goto done;
+
+	list = (wl_iscan_results_t *)iscan_cur->iscan_buf;
+	if (!list)
+		goto done;
+
+	results = (wl_scan_results_t *)&list->results;
+	if (!results)
+		goto done;
+
+	if (results->version != WL_BSS_INFO_VERSION) {
+		DHD_ERROR(("%s: results->version %d != WL_BSS_INFO_VERSION\n",
+			   __func__, results->version));
+		goto done;
+	}
+
+	bi = results->bss_info;
+	for (i = 0; i < results->count; i++) {
+		if (!bi)
+			break;
+
+		DHD_ISCAN(("%s: Find dups for BSS[%2.2d] %X:%X:%X:%X:%X:%X\n",
+			   __func__, i, bi->BSSID.octet[0],
+			   bi->BSSID.octet[1], bi->BSSID.octet[2],
+			   bi->BSSID.octet[3], bi->BSSID.octet[4],
+			   bi->BSSID.octet[5]));
+
+		dhd_iscan_delete_bss(dhdp, bi->BSSID.octet, iscan_cur);
+
+		bi = (wl_bss_info_t *)((unsigned long)bi + dtoh32(bi->length));
+	}
+
+done:
+	DHD_ISCAN(("%s: Scan cache after delete\n", __func__));
+	dhd_iscan_print_cache(iscan_cur);
+	dhd_iscan_unlock();
+	return 0;
+}
+
+void dhd_iscan_ind_scan_confirm(void *dhdp, bool status)
+{
+
+	dhd_ind_scan_confirm(dhdp, status);
+}
+
+int dhd_iscan_request(void *dhdp, u16 action)
+{
+	int rc;
+	wl_iscan_params_t params;
+	dhd_pub_t *dhd = dhd_bus_pub(dhdp);
+	char buf[WLC_IOCTL_SMLEN];
+
+	memset(&params, 0, sizeof(wl_iscan_params_t));
+	memcpy(&params.params.bssid, &ether_bcast, ETHER_ADDR_LEN);
+
+	params.params.bss_type = DOT11_BSSTYPE_ANY;
+	params.params.scan_type = DOT11_SCANTYPE_ACTIVE;
+
+	params.params.nprobes = htod32(-1);
+	params.params.active_time = htod32(-1);
+	params.params.passive_time = htod32(-1);
+	params.params.home_time = htod32(-1);
+	params.params.channel_num = htod32(0);
+
+	params.version = htod32(ISCAN_REQ_VERSION);
+	params.action = htod16(action);
+	params.scan_duration = htod16(0);
+
+	bcm_mkiovar("iscan", (char *)&params, sizeof(wl_iscan_params_t), buf,
+		    WLC_IOCTL_SMLEN);
+	rc = dhd_wl_ioctl(dhdp, WLC_SET_VAR, buf, WLC_IOCTL_SMLEN);
+
+	return rc;
+}
+
+static int dhd_iscan_get_partial_result(void *dhdp, uint *scan_count)
+{
+	wl_iscan_results_t *list_buf;
+	wl_iscan_results_t list;
+	wl_scan_results_t *results;
+	iscan_buf_t *iscan_cur;
+	int status = -1;
+	dhd_pub_t *dhd = dhd_bus_pub(dhdp);
+	int rc;
+
+	iscan_cur = dhd_iscan_allocate_buf(dhd, &iscan_chain);
+	if (!iscan_cur) {
+		DHD_ERROR(("%s: Failed to allocate node\n", __func__));
+		dhd_iscan_free_buf(dhdp, 0);
+		dhd_iscan_request(dhdp, WL_SCAN_ACTION_ABORT);
+		goto fail;
+	}
+
+	dhd_iscan_lock();
+
+	memset(iscan_cur->iscan_buf, 0, WLC_IW_ISCAN_MAXLEN);
+	list_buf = (wl_iscan_results_t *) iscan_cur->iscan_buf;
+	results = &list_buf->results;
+	results->buflen = WL_ISCAN_RESULTS_FIXED_SIZE;
+	results->version = 0;
+	results->count = 0;
+
+	memset(&list, 0, sizeof(list));
+	list.results.buflen = htod32(WLC_IW_ISCAN_MAXLEN);
+	bcm_mkiovar("iscanresults", (char *)&list, WL_ISCAN_RESULTS_FIXED_SIZE,
+		    iscan_cur->iscan_buf, WLC_IW_ISCAN_MAXLEN);
+	rc = dhd_wl_ioctl(dhdp, WLC_GET_VAR, iscan_cur->iscan_buf,
+			  WLC_IW_ISCAN_MAXLEN);
+
+	results->buflen = dtoh32(results->buflen);
+	results->version = dtoh32(results->version);
+	*scan_count = results->count = dtoh32(results->count);
+	status = dtoh32(list_buf->status);
+
+	dhd_iscan_unlock();
+
+	if (!(*scan_count))
+		dhd_iscan_free_buf(dhdp, iscan_cur);
+	else
+		dhd_iscan_remove_duplicates(dhdp, iscan_cur);
+
+fail:
+	return status;
+}
+#endif				/* SIMPLE_ISCAN */
+
+#ifdef PNO_SUPPORT
+int dhd_pno_clean(dhd_pub_t *dhd)
+{
+	char iovbuf[128];
+	int pfn_enabled = 0;
+	int iov_len = 0;
+	int ret;
+
+	/* Disable pfn */
+	iov_len =
+	    bcm_mkiovar("pfn", (char *)&pfn_enabled, 4, iovbuf, sizeof(iovbuf));
+	ret = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+	if (ret >= 0) {
+		/* clear pfn */
+		iov_len = bcm_mkiovar("pfnclear", 0, 0, iovbuf, sizeof(iovbuf));
+		if (iov_len) {
+			ret = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf,
+					iov_len);
+			if (ret < 0) {
+				DHD_ERROR(("%s failed code %d\n", __func__,
+					   ret));
+			}
+		} else {
+			ret = -1;
+			DHD_ERROR(("%s failed code %d\n", __func__, iov_len));
+		}
+	} else
+		DHD_ERROR(("%s failed code %d\n", __func__, ret));
+
+	return ret;
+}
+
+int dhd_pno_enable(dhd_pub_t *dhd, int pfn_enabled)
+{
+	char iovbuf[128];
+	int ret = -1;
+
+	if ((!dhd) && ((pfn_enabled != 0) || (pfn_enabled != 1))) {
+		DHD_ERROR(("%s error exit\n", __func__));
+		return ret;
+	}
+
+	/* Enable/disable PNO */
+	ret = bcm_mkiovar("pfn", (char *)&pfn_enabled, 4, iovbuf,
+			sizeof(iovbuf));
+	if (ret > 0) {
+		ret = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf,
+				sizeof(iovbuf));
+		if (ret < 0) {
+			DHD_ERROR(("%s failed for error=%d\n", __func__, ret));
+			return ret;
+		} else {
+			dhd->pno_enable = pfn_enabled;
+			DHD_TRACE(("%s set pno as %d\n", __func__,
+				   dhd->pno_enable));
+		}
+	} else
+		DHD_ERROR(("%s failed err=%d\n", __func__, ret));
+
+	return ret;
+}
+
+/* Function to execute combined scan */
+int
+dhd_pno_set(dhd_pub_t *dhd, wlc_ssid_t *ssids_local, int nssid, unsigned char scan_fr)
+{
+	int err = -1;
+	char iovbuf[128];
+	int k, i;
+	wl_pfn_param_t pfn_param;
+	wl_pfn_t pfn_element;
+
+	DHD_TRACE(("%s nssid=%d nchan=%d\n", __func__, nssid, scan_fr));
+
+	if ((!dhd) && (!ssids_local)) {
+		DHD_ERROR(("%s error exit\n", __func__));
+		err = -1;
+	}
+
+	/* Check for broadcast ssid */
+	for (k = 0; k < nssid; k++) {
+		if (!ssids_local[k].SSID_len) {
+			DHD_ERROR(("%d: Broadcast SSID is ilegal for PNO "
+				"setting\n", k));
+			return err;
+		}
+	}
+/* #define  PNO_DUMP 1 */
+#ifdef PNO_DUMP
+	{
+		int j;
+		for (j = 0; j < nssid; j++) {
+			DHD_ERROR(("%d: scan  for  %s size =%d\n", j,
+				   ssids_local[j].SSID,
+				   ssids_local[j].SSID_len));
+		}
+	}
+#endif				/* PNO_DUMP */
+
+	/* clean up everything */
+	err = dhd_pno_clean(dhd);
+	if (err < 0) {
+		DHD_ERROR(("%s failed error=%d\n", __func__, err));
+		return err;
+	}
+	memset(&pfn_param, 0, sizeof(pfn_param));
+	memset(&pfn_element, 0, sizeof(pfn_element));
+
+	/* set pfn parameters */
+	pfn_param.version = htod32(PFN_VERSION);
+	pfn_param.flags = htod16((PFN_LIST_ORDER << SORT_CRITERIA_BIT));
+
+	/* set up pno scan fr */
+	if (scan_fr != 0)
+		pfn_param.scan_freq = htod32(scan_fr);
+
+	bcm_mkiovar("pfn_set", (char *)&pfn_param, sizeof(pfn_param), iovbuf,
+		    sizeof(iovbuf));
+	dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+
+	/* set all pfn ssid */
+	for (i = 0; i < nssid; i++) {
+
+		pfn_element.bss_type = htod32(DOT11_BSSTYPE_INFRASTRUCTURE);
+		pfn_element.auth = (DOT11_OPEN_SYSTEM);
+		pfn_element.wpa_auth = htod32(WPA_AUTH_PFN_ANY);
+		pfn_element.wsec = htod32(0);
+		pfn_element.infra = htod32(1);
+
+		memcpy((char *)pfn_element.ssid.SSID, ssids_local[i].SSID,
+		       ssids_local[i].SSID_len);
+		pfn_element.ssid.SSID_len = ssids_local[i].SSID_len;
+
+		err = bcm_mkiovar("pfn_add", (char *)&pfn_element,
+				sizeof(pfn_element), iovbuf, sizeof(iovbuf));
+		if (err > 0) {
+			err = dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf,
+					sizeof(iovbuf));
+			if (err < 0) {
+				DHD_ERROR(("%s failed for i=%d error=%d\n",
+					   __func__, i, err));
+				return err;
+			}
+		} else
+			DHD_ERROR(("%s failed err=%d\n", __func__, err));
+	}
+
+	/* Enable PNO */
+	/* dhd_pno_enable(dhd, 1); */
+	return err;
+}
+
+int dhd_pno_get_status(dhd_pub_t *dhd)
+{
+	int ret = -1;
+
+	if (!dhd)
+		return ret;
+	else
+		return dhd->pno_enable;
+}
+
+#endif				/* PNO_SUPPORT */
+
+/* Androd ComboSCAN support */
diff --git a/drivers/staging/brcm80211/brcmfmac/dhd_custom_gpio.c b/drivers/staging/brcm80211/brcmfmac/dhd_custom_gpio.c
new file mode 100644
index 0000000..f647034
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_custom_gpio.c
@@ -0,0 +1,160 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linuxver.h>
+#include <osl.h>
+#include <bcmutils.h>
+
+#include <dngl_stats.h>
+#include <dhd.h>
+
+#include <wlioctl.h>
+#include <wl_iw.h>
+
+#define WL_ERROR(x) printf x
+#define WL_TRACE(x)
+
+#ifdef CUSTOMER_HW
+extern void bcm_wlan_power_off(int);
+extern void bcm_wlan_power_on(int);
+#endif				/* CUSTOMER_HW */
+#ifdef CUSTOMER_HW2
+int wifi_set_carddetect(int on);
+int wifi_set_power(int on, unsigned long msec);
+int wifi_get_irq_number(unsigned long *irq_flags_ptr);
+#endif
+
+#if defined(OOB_INTR_ONLY)
+
+#if defined(BCMLXSDMMC)
+extern int sdioh_mmc_irq(int irq);
+#endif				/* (BCMLXSDMMC)  */
+
+#ifdef CUSTOMER_HW3
+#include <mach/gpio.h>
+#endif
+
+/* Customer specific Host GPIO defintion  */
+static int dhd_oob_gpio_num = -1;	/* GG 19 */
+
+module_param(dhd_oob_gpio_num, int, 0644);
+MODULE_PARM_DESC(dhd_oob_gpio_num, "DHD oob gpio number");
+
+int dhd_customer_oob_irq_map(unsigned long *irq_flags_ptr)
+{
+	int host_oob_irq = 0;
+
+#ifdef CUSTOMER_HW2
+	host_oob_irq = wifi_get_irq_number(irq_flags_ptr);
+
+#else				/* for NOT  CUSTOMER_HW2 */
+#if defined(CUSTOM_OOB_GPIO_NUM)
+	if (dhd_oob_gpio_num < 0)
+		dhd_oob_gpio_num = CUSTOM_OOB_GPIO_NUM;
+#endif
+
+	if (dhd_oob_gpio_num < 0) {
+		WL_ERROR(("%s: ERROR customer specific Host GPIO is NOT defined\n",
+			__func__));
+		return dhd_oob_gpio_num;
+	}
+
+	WL_ERROR(("%s: customer specific Host GPIO number is (%d)\n",
+		  __func__, dhd_oob_gpio_num));
+
+#if defined CUSTOMER_HW
+	host_oob_irq = MSM_GPIO_TO_INT(dhd_oob_gpio_num);
+#elif defined CUSTOMER_HW3
+	gpio_request(dhd_oob_gpio_num, "oob irq");
+	host_oob_irq = gpio_to_irq(dhd_oob_gpio_num);
+	gpio_direction_input(dhd_oob_gpio_num);
+#endif				/* CUSTOMER_HW */
+#endif				/* CUSTOMER_HW2 */
+
+	return host_oob_irq;
+}
+#endif				/* defined(OOB_INTR_ONLY) */
+
+/* Customer function to control hw specific wlan gpios */
+void dhd_customer_gpio_wlan_ctrl(int onoff)
+{
+	switch (onoff) {
+	case WLAN_RESET_OFF:
+		WL_TRACE(("%s: call customer specific GPIO to insert WLAN RESET\n",
+			__func__));
+#ifdef CUSTOMER_HW
+		bcm_wlan_power_off(2);
+#endif				/* CUSTOMER_HW */
+#ifdef CUSTOMER_HW2
+		wifi_set_power(0, 0);
+#endif
+		WL_ERROR(("=========== WLAN placed in RESET ========\n"));
+		break;
+
+	case WLAN_RESET_ON:
+		WL_TRACE(("%s: callc customer specific GPIO to remove WLAN RESET\n",
+			__func__));
+#ifdef CUSTOMER_HW
+		bcm_wlan_power_on(2);
+#endif				/* CUSTOMER_HW */
+#ifdef CUSTOMER_HW2
+		wifi_set_power(1, 0);
+#endif
+		WL_ERROR(("=========== WLAN going back to live  ========\n"));
+		break;
+
+	case WLAN_POWER_OFF:
+		WL_TRACE(("%s: call customer specific GPIO to turn off WL_REG_ON\n",
+			__func__));
+#ifdef CUSTOMER_HW
+		bcm_wlan_power_off(1);
+#endif				/* CUSTOMER_HW */
+		break;
+
+	case WLAN_POWER_ON:
+		WL_TRACE(("%s: call customer specific GPIO to turn on WL_REG_ON\n",
+			__func__));
+#ifdef CUSTOMER_HW
+		bcm_wlan_power_on(1);
+#endif				/* CUSTOMER_HW */
+		/* Lets customer power to get stable */
+		udelay(200);
+		break;
+	}
+}
+
+#ifdef GET_CUSTOM_MAC_ENABLE
+/* Function to get custom MAC address */
+int dhd_custom_get_mac_address(unsigned char *buf)
+{
+	WL_TRACE(("%s Enter\n", __func__));
+	if (!buf)
+		return -EINVAL;
+
+	/* Customer access to MAC address stored outside of DHD driver */
+
+#ifdef EXAMPLE_GET_MAC
+	/* EXAMPLE code */
+	{
+		struct ether_addr ea_example = {
+			{0x00, 0x11, 0x22, 0x33, 0x44, 0xFF} };
+		bcopy((char *)&ea_example, buf, sizeof(struct ether_addr));
+	}
+#endif				/* EXAMPLE_GET_MAC */
+
+	return 0;
+}
+#endif				/* GET_CUSTOM_MAC_ENABLE */
diff --git a/drivers/staging/brcm80211/brcmfmac/dhd_dbg.h b/drivers/staging/brcm80211/brcmfmac/dhd_dbg.h
new file mode 100644
index 0000000..cd2578a
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_dbg.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _dhd_dbg_
+#define _dhd_dbg_
+
+#if defined(DHD_DEBUG)
+
+#define DHD_ERROR(args)	       \
+	do {if ((dhd_msg_level & DHD_ERROR_VAL) && (net_ratelimit())) \
+		printf args; } while (0)
+#define DHD_TRACE(args)		do {if (dhd_msg_level & DHD_TRACE_VAL)	\
+					printf args; } while (0)
+#define DHD_INFO(args)		do {if (dhd_msg_level & DHD_INFO_VAL)	\
+					printf args; } while (0)
+#define DHD_DATA(args)		do {if (dhd_msg_level & DHD_DATA_VAL)	\
+					printf args; } while (0)
+#define DHD_CTL(args)		do {if (dhd_msg_level & DHD_CTL_VAL)	\
+					printf args; } while (0)
+#define DHD_TIMER(args)		do {if (dhd_msg_level & DHD_TIMER_VAL)	\
+					printf args; } while (0)
+#define DHD_HDRS(args)		do {if (dhd_msg_level & DHD_HDRS_VAL)	\
+					printf args; } while (0)
+#define DHD_BYTES(args)		do {if (dhd_msg_level & DHD_BYTES_VAL)	\
+					printf args; } while (0)
+#define DHD_INTR(args)		do {if (dhd_msg_level & DHD_INTR_VAL)	\
+					printf args; } while (0)
+#define DHD_GLOM(args)		do {if (dhd_msg_level & DHD_GLOM_VAL)	\
+					printf args; } while (0)
+#define DHD_EVENT(args)		do {if (dhd_msg_level & DHD_EVENT_VAL)	\
+					printf args; } while (0)
+#define DHD_BTA(args)		do {if (dhd_msg_level & DHD_BTA_VAL)	\
+					printf args; } while (0)
+#define DHD_ISCAN(args)		do {if (dhd_msg_level & DHD_ISCAN_VAL)	\
+					printf args; } while (0)
+
+#define DHD_ERROR_ON()		(dhd_msg_level & DHD_ERROR_VAL)
+#define DHD_TRACE_ON()		(dhd_msg_level & DHD_TRACE_VAL)
+#define DHD_INFO_ON()		(dhd_msg_level & DHD_INFO_VAL)
+#define DHD_DATA_ON()		(dhd_msg_level & DHD_DATA_VAL)
+#define DHD_CTL_ON()		(dhd_msg_level & DHD_CTL_VAL)
+#define DHD_TIMER_ON()		(dhd_msg_level & DHD_TIMER_VAL)
+#define DHD_HDRS_ON()		(dhd_msg_level & DHD_HDRS_VAL)
+#define DHD_BYTES_ON()		(dhd_msg_level & DHD_BYTES_VAL)
+#define DHD_INTR_ON()		(dhd_msg_level & DHD_INTR_VAL)
+#define DHD_GLOM_ON()		(dhd_msg_level & DHD_GLOM_VAL)
+#define DHD_EVENT_ON()		(dhd_msg_level & DHD_EVENT_VAL)
+#define DHD_BTA_ON()		(dhd_msg_level & DHD_BTA_VAL)
+#define DHD_ISCAN_ON()		(dhd_msg_level & DHD_ISCAN_VAL)
+
+#else	/* (defined BCMDBG) || (defined DHD_DEBUG) */
+
+#define DHD_ERROR(args)  do {if (net_ratelimit()) printf args; } while (0)
+#define DHD_TRACE(args)
+#define DHD_INFO(args)
+#define DHD_DATA(args)
+#define DHD_CTL(args)
+#define DHD_TIMER(args)
+#define DHD_HDRS(args)
+#define DHD_BYTES(args)
+#define DHD_INTR(args)
+#define DHD_GLOM(args)
+#define DHD_EVENT(args)
+#define DHD_BTA(args)
+#define DHD_ISCAN(args)
+
+#define DHD_ERROR_ON()		0
+#define DHD_TRACE_ON()		0
+#define DHD_INFO_ON()		0
+#define DHD_DATA_ON()		0
+#define DHD_CTL_ON()		0
+#define DHD_TIMER_ON()		0
+#define DHD_HDRS_ON()		0
+#define DHD_BYTES_ON()		0
+#define DHD_INTR_ON()		0
+#define DHD_GLOM_ON()		0
+#define DHD_EVENT_ON()		0
+#define DHD_BTA_ON()		0
+#define DHD_ISCAN_ON()		0
+#endif				/* defined(DHD_DEBUG) */
+
+#define DHD_LOG(args)
+
+#define DHD_NONE(args)
+extern int dhd_msg_level;
+
+/* Defines msg bits */
+#include <dhdioctl.h>
+
+#endif				/* _dhd_dbg_ */
diff --git a/drivers/staging/brcm80211/brcmfmac/dhd_linux.c b/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
new file mode 100644
index 0000000..bbbe7c5
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
@@ -0,0 +1,2929 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+#include <linux/platform_device.h>
+#endif
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/random.h>
+#include <linux/spinlock.h>
+#include <linux/ethtool.h>
+#include <linux/fcntl.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <bcmdefs.h>
+#include <linuxver.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <bcmendian.h>
+
+#include <proto/ethernet.h>
+#include <dngl_stats.h>
+#include <dhd.h>
+#include <dhd_bus.h>
+#include <dhd_proto.h>
+#include <dhd_dbg.h>
+
+#include <wl_cfg80211.h>
+
+#define EPI_VERSION_STR         "4.218.248.5"
+
+#if defined(CUSTOMER_HW2) && defined(CONFIG_WIFI_CONTROL_FUNC)
+#include <linux/wifi_tiwlan.h>
+
+struct semaphore wifi_control_sem;
+
+struct dhd_bus *g_bus;
+
+static struct wifi_platform_data *wifi_control_data;
+static struct resource *wifi_irqres;
+
+int wifi_get_irq_number(unsigned long *irq_flags_ptr)
+{
+	if (wifi_irqres) {
+		*irq_flags_ptr = wifi_irqres->flags & IRQF_TRIGGER_MASK;
+		return (int)wifi_irqres->start;
+	}
+#ifdef CUSTOM_OOB_GPIO_NUM
+	return CUSTOM_OOB_GPIO_NUM;
+#else
+	return -1;
+#endif
+}
+
+int wifi_set_carddetect(int on)
+{
+	printk(KERN_ERR "%s = %d\n", __func__, on);
+	if (wifi_control_data && wifi_control_data->set_carddetect)
+		wifi_control_data->set_carddetect(on);
+	return 0;
+}
+
+int wifi_set_power(int on, unsigned long msec)
+{
+	printk(KERN_ERR "%s = %d\n", __func__, on);
+	if (wifi_control_data && wifi_control_data->set_power)
+		wifi_control_data->set_power(on);
+	if (msec)
+		mdelay(msec);
+	return 0;
+}
+
+int wifi_set_reset(int on, unsigned long msec)
+{
+	printk(KERN_ERR "%s = %d\n", __func__, on);
+	if (wifi_control_data && wifi_control_data->set_reset)
+		wifi_control_data->set_reset(on);
+	if (msec)
+		mdelay(msec);
+	return 0;
+}
+
+static int wifi_probe(struct platform_device *pdev)
+{
+	struct wifi_platform_data *wifi_ctrl =
+	    (struct wifi_platform_data *)(pdev->dev.platform_data);
+
+	printk(KERN_ERR "## %s\n", __func__);
+	wifi_irqres =
+	    platform_get_resource_byname(pdev, IORESOURCE_IRQ,
+					 "bcm4329_wlan_irq");
+	wifi_control_data = wifi_ctrl;
+
+	wifi_set_power(1, 0);	/* Power On */
+	wifi_set_carddetect(1);	/* CardDetect (0->1) */
+
+	up(&wifi_control_sem);
+	return 0;
+}
+
+static int wifi_remove(struct platform_device *pdev)
+{
+	struct wifi_platform_data *wifi_ctrl =
+	    (struct wifi_platform_data *)(pdev->dev.platform_data);
+
+	printk(KERN_ERR "## %s\n", __func__);
+	wifi_control_data = wifi_ctrl;
+
+	wifi_set_carddetect(0);	/* CardDetect (1->0) */
+	wifi_set_power(0, 0);	/* Power Off */
+
+	up(&wifi_control_sem);
+	return 0;
+}
+
+static int wifi_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	DHD_TRACE(("##> %s\n", __func__));
+	return 0;
+}
+
+static int wifi_resume(struct platform_device *pdev)
+{
+	DHD_TRACE(("##> %s\n", __func__));
+	return 0;
+}
+
+static struct platform_driver wifi_device = {
+	.probe = wifi_probe,
+	.remove = wifi_remove,
+	.suspend = wifi_suspend,
+	.resume = wifi_resume,
+	.driver = {
+		   .name = "bcm4329_wlan",
+		   }
+};
+
+int wifi_add_dev(void)
+{
+	DHD_TRACE(("## Calling platform_driver_register\n"));
+	return platform_driver_register(&wifi_device);
+}
+
+void wifi_del_dev(void)
+{
+	DHD_TRACE(("## Unregister platform_driver_register\n"));
+	platform_driver_unregister(&wifi_device);
+}
+#endif	/* defined(CUSTOMER_HW2) && defined(CONFIG_WIFI_CONTROL_FUNC) */
+
+#if defined(CONFIG_PM_SLEEP)
+#include <linux/suspend.h>
+volatile bool dhd_mmc_suspend = false;
+DECLARE_WAIT_QUEUE_HEAD(dhd_dpc_wait);
+#endif	/*  defined(CONFIG_PM_SLEEP) */
+
+#if defined(OOB_INTR_ONLY)
+extern void dhd_enable_oob_intr(struct dhd_bus *bus, bool enable);
+#endif	/* defined(OOB_INTR_ONLY) */
+
+MODULE_AUTHOR("Broadcom Corporation");
+MODULE_DESCRIPTION("Broadcom 802.11n wireless LAN fullmac driver.");
+MODULE_SUPPORTED_DEVICE("Broadcom 802.11n WLAN fullmac cards");
+MODULE_LICENSE("Dual BSD/GPL");
+
+#define DRV_MODULE_NAME "brcmfmac"
+
+/* Linux wireless extension support */
+#if defined(CONFIG_WIRELESS_EXT)
+#include <wl_iw.h>
+extern wl_iw_extra_params_t g_wl_iw_params;
+#endif		/* defined(CONFIG_WIRELESS_EXT) */
+
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+extern int dhdcdc_set_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf,
+			    uint len);
+#endif		/* defined(CONFIG_HAS_EARLYSUSPEND) */
+
+#ifdef PKT_FILTER_SUPPORT
+extern void dhd_pktfilter_offload_set(dhd_pub_t *dhd, char *arg);
+extern void dhd_pktfilter_offload_enable(dhd_pub_t *dhd, char *arg, int enable,
+					 int master_mode);
+#endif
+
+/* Interface control information */
+typedef struct dhd_if {
+	struct dhd_info *info;	/* back pointer to dhd_info */
+	/* OS/stack specifics */
+	struct net_device *net;
+	struct net_device_stats stats;
+	int idx;		/* iface idx in dongle */
+	int state;		/* interface state */
+	uint subunit;		/* subunit */
+	u8 mac_addr[ETHER_ADDR_LEN];	/* assigned MAC address */
+	bool attached;		/* Delayed attachment when unset */
+	bool txflowcontrol;	/* Per interface flow control indicator */
+	char name[IFNAMSIZ];	/* linux interface name */
+} dhd_if_t;
+
+/* Local private structure (extension of pub) */
+typedef struct dhd_info {
+#if defined(CONFIG_WIRELESS_EXT)
+	wl_iw_t iw;		/* wireless extensions state (must be first) */
+#endif				/* defined(CONFIG_WIRELESS_EXT) */
+
+	dhd_pub_t pub;
+
+	/* OS/stack specifics */
+	dhd_if_t *iflist[DHD_MAX_IFS];
+
+	struct semaphore proto_sem;
+	wait_queue_head_t ioctl_resp_wait;
+	struct timer_list timer;
+	bool wd_timer_valid;
+	struct tasklet_struct tasklet;
+	spinlock_t sdlock;
+	spinlock_t txqlock;
+	/* Thread based operation */
+	bool threads_only;
+	struct semaphore sdsem;
+	struct task_struct *watchdog_tsk;
+	struct semaphore watchdog_sem;
+	struct task_struct *dpc_tsk;
+	struct semaphore dpc_sem;
+
+	/* Thread to issue ioctl for multicast */
+	struct task_struct *sysioc_tsk;
+	struct semaphore sysioc_sem;
+	bool set_multicast;
+	bool set_macaddress;
+	struct ether_addr macvalue;
+	wait_queue_head_t ctrl_wait;
+	atomic_t pend_8021x_cnt;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif				/* CONFIG_HAS_EARLYSUSPEND */
+} dhd_info_t;
+
+/* Definitions to provide path to the firmware and nvram
+ * example nvram_path[MOD_PARAM_PATHLEN]="/projects/wlan/nvram.txt"
+ */
+char firmware_path[MOD_PARAM_PATHLEN];
+char nvram_path[MOD_PARAM_PATHLEN];
+
+/* load firmware and/or nvram values from the filesystem */
+module_param_string(firmware_path, firmware_path, MOD_PARAM_PATHLEN, 0);
+module_param_string(nvram_path, nvram_path, MOD_PARAM_PATHLEN, 0);
+
+/* Error bits */
+module_param(dhd_msg_level, int, 0);
+
+/* Spawn a thread for system ioctls (set mac, set mcast) */
+uint dhd_sysioc = true;
+module_param(dhd_sysioc, uint, 0);
+
+/* Watchdog interval */
+uint dhd_watchdog_ms = 10;
+module_param(dhd_watchdog_ms, uint, 0);
+
+#ifdef DHD_DEBUG
+/* Console poll interval */
+uint dhd_console_ms;
+module_param(dhd_console_ms, uint, 0);
+#endif				/* DHD_DEBUG */
+
+/* ARP offload agent mode : Enable ARP Host Auto-Reply
+and ARP Peer Auto-Reply */
+uint dhd_arp_mode = 0xb;
+module_param(dhd_arp_mode, uint, 0);
+
+/* ARP offload enable */
+uint dhd_arp_enable = true;
+module_param(dhd_arp_enable, uint, 0);
+
+/* Global Pkt filter enable control */
+uint dhd_pkt_filter_enable = true;
+module_param(dhd_pkt_filter_enable, uint, 0);
+
+/*  Pkt filter init setup */
+uint dhd_pkt_filter_init;
+module_param(dhd_pkt_filter_init, uint, 0);
+
+/* Pkt filter mode control */
+uint dhd_master_mode = true;
+module_param(dhd_master_mode, uint, 1);
+
+/* Watchdog thread priority, -1 to use kernel timer */
+int dhd_watchdog_prio = 97;
+module_param(dhd_watchdog_prio, int, 0);
+
+/* DPC thread priority, -1 to use tasklet */
+int dhd_dpc_prio = 98;
+module_param(dhd_dpc_prio, int, 0);
+
+/* DPC thread priority, -1 to use tasklet */
+extern int dhd_dongle_memsize;
+module_param(dhd_dongle_memsize, int, 0);
+
+/* Contorl fw roaming */
+#ifdef CUSTOMER_HW2
+uint dhd_roam;
+#else
+uint dhd_roam = 1;
+#endif
+
+/* Control radio state */
+uint dhd_radio_up = 1;
+
+/* Network inteface name */
+char iface_name[IFNAMSIZ];
+module_param_string(iface_name, iface_name, IFNAMSIZ, 0);
+
+/* The following are specific to the SDIO dongle */
+
+/* IOCTL response timeout */
+int dhd_ioctl_timeout_msec = IOCTL_RESP_TIMEOUT;
+
+/* Idle timeout for backplane clock */
+int dhd_idletime = DHD_IDLETIME_TICKS;
+module_param(dhd_idletime, int, 0);
+
+/* Use polling */
+uint dhd_poll = false;
+module_param(dhd_poll, uint, 0);
+
+/* Use cfg80211 */
+uint dhd_cfg80211 = true;
+module_param(dhd_cfg80211, uint, 0);
+
+/* Use interrupts */
+uint dhd_intr = true;
+module_param(dhd_intr, uint, 0);
+
+/* SDIO Drive Strength (in milliamps) */
+uint dhd_sdiod_drive_strength = 6;
+module_param(dhd_sdiod_drive_strength, uint, 0);
+
+/* Tx/Rx bounds */
+extern uint dhd_txbound;
+extern uint dhd_rxbound;
+module_param(dhd_txbound, uint, 0);
+module_param(dhd_rxbound, uint, 0);
+
+/* Deferred transmits */
+extern uint dhd_deferred_tx;
+module_param(dhd_deferred_tx, uint, 0);
+
+#ifdef SDTEST
+/* Echo packet generator (pkts/s) */
+uint dhd_pktgen;
+module_param(dhd_pktgen, uint, 0);
+
+/* Echo packet len (0 => sawtooth, max 2040) */
+uint dhd_pktgen_len;
+module_param(dhd_pktgen_len, uint, 0);
+#endif
+
+#define FAVORITE_WIFI_CP	(!!dhd_cfg80211)
+#define IS_CFG80211_FAVORITE() FAVORITE_WIFI_CP
+#define DBG_CFG80211_GET() ((dhd_cfg80211 & WL_DBG_MASK) >> 1)
+#define NO_FW_REQ() (dhd_cfg80211 & 0x80)
+
+/* Version string to report */
+#ifdef DHD_DEBUG
+#define DHD_COMPILED "\nCompiled in " SRCBASE
+#else
+#define DHD_COMPILED
+#endif
+
+static char dhd_version[] = "Dongle Host Driver, version " EPI_VERSION_STR
+#ifdef DHD_DEBUG
+"\nCompiled in " " on " __DATE__ " at " __TIME__
+#endif
+;
+
+#if defined(CONFIG_WIRELESS_EXT)
+struct iw_statistics *dhd_get_wireless_stats(struct net_device *dev);
+#endif				/* defined(CONFIG_WIRELESS_EXT) */
+
+static void dhd_dpc(unsigned long data);
+/* forward decl */
+extern int dhd_wait_pend8021x(struct net_device *dev);
+
+#ifdef TOE
+#ifndef BDC
+#error TOE requires BDC
+#endif				/* !BDC */
+static int dhd_toe_get(dhd_info_t *dhd, int idx, u32 *toe_ol);
+static int dhd_toe_set(dhd_info_t *dhd, int idx, u32 toe_ol);
+#endif				/* TOE */
+
+static int dhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata,
+			     wl_event_msg_t *event_ptr, void **data_ptr);
+
+#if defined(CONFIG_PM_SLEEP)
+static int dhd_sleep_pm_callback(struct notifier_block *nfb,
+				 unsigned long action, void *ignored)
+{
+	switch (action) {
+	case PM_HIBERNATION_PREPARE:
+	case PM_SUSPEND_PREPARE:
+		dhd_mmc_suspend = true;
+		return NOTIFY_OK;
+	case PM_POST_HIBERNATION:
+	case PM_POST_SUSPEND:
+		dhd_mmc_suspend = false;
+		return NOTIFY_OK;
+	}
+	return 0;
+}
+
+static struct notifier_block dhd_sleep_pm_notifier = {
+	.notifier_call = dhd_sleep_pm_callback,
+	.priority = 0
+};
+
+extern int register_pm_notifier(struct notifier_block *nb);
+extern int unregister_pm_notifier(struct notifier_block *nb);
+#endif	/* defined(CONFIG_PM_SLEEP) */
+	/* && defined(DHD_GPL) */
+static void dhd_set_packet_filter(int value, dhd_pub_t *dhd)
+{
+#ifdef PKT_FILTER_SUPPORT
+	DHD_TRACE(("%s: %d\n", __func__, value));
+	/* 1 - Enable packet filter, only allow unicast packet to send up */
+	/* 0 - Disable packet filter */
+	if (dhd_pkt_filter_enable) {
+		int i;
+
+		for (i = 0; i < dhd->pktfilter_count; i++) {
+			dhd_pktfilter_offload_set(dhd, dhd->pktfilter[i]);
+			dhd_pktfilter_offload_enable(dhd, dhd->pktfilter[i],
+						     value, dhd_master_mode);
+		}
+	}
+#endif
+}
+
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+static int dhd_set_suspend(int value, dhd_pub_t *dhd)
+{
+	int power_mode = PM_MAX;
+	/* wl_pkt_filter_enable_t       enable_parm; */
+	char iovbuf[32];
+	int bcn_li_dtim = 3;
+#ifdef CUSTOMER_HW2
+	uint roamvar = 1;
+#endif				/* CUSTOMER_HW2 */
+
+	DHD_TRACE(("%s: enter, value = %d in_suspend=%d\n",
+		   __func__, value, dhd->in_suspend));
+
+	if (dhd && dhd->up) {
+		if (value && dhd->in_suspend) {
+
+			/* Kernel suspended */
+			DHD_TRACE(("%s: force extra Suspend setting\n",
+				   __func__));
+
+			dhdcdc_set_ioctl(dhd, 0, WLC_SET_PM,
+					 (char *)&power_mode,
+					 sizeof(power_mode));
+
+			/* Enable packet filter, only allow unicast
+				 packet to send up */
+			dhd_set_packet_filter(1, dhd);
+
+			/* if dtim skip setup as default force it
+			 * to wake each thrid dtim
+			 * for better power saving.
+			 * Note that side effect is chance to miss BC/MC
+			 * packet
+			 */
+			if ((dhd->dtim_skip == 0) || (dhd->dtim_skip == 1))
+				bcn_li_dtim = 3;
+			else
+				bcn_li_dtim = dhd->dtim_skip;
+			bcm_mkiovar("bcn_li_dtim", (char *)&bcn_li_dtim,
+				    4, iovbuf, sizeof(iovbuf));
+			dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf,
+					 sizeof(iovbuf));
+#ifdef CUSTOMER_HW2
+			/* Disable build-in roaming to allowed \
+			 * supplicant to take of romaing
+			 */
+			bcm_mkiovar("roam_off", (char *)&roamvar, 4,
+				    iovbuf, sizeof(iovbuf));
+			dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf,
+					 sizeof(iovbuf));
+#endif				/* CUSTOMER_HW2 */
+		} else {
+
+			/* Kernel resumed  */
+			DHD_TRACE(("%s: Remove extra suspend setting\n",
+				   __func__));
+
+			power_mode = PM_FAST;
+			dhdcdc_set_ioctl(dhd, 0, WLC_SET_PM,
+					 (char *)&power_mode,
+					 sizeof(power_mode));
+
+			/* disable pkt filter */
+			dhd_set_packet_filter(0, dhd);
+
+			/* restore pre-suspend setting for dtim_skip */
+			bcm_mkiovar("bcn_li_dtim", (char *)&dhd->dtim_skip,
+				    4, iovbuf, sizeof(iovbuf));
+
+			dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf,
+					 sizeof(iovbuf));
+#ifdef CUSTOMER_HW2
+			roamvar = 0;
+			bcm_mkiovar("roam_off", (char *)&roamvar, 4, iovbuf,
+				    sizeof(iovbuf));
+			dhdcdc_set_ioctl(dhd, 0, WLC_SET_VAR, iovbuf,
+					 sizeof(iovbuf));
+#endif				/* CUSTOMER_HW2 */
+		}
+	}
+
+	return 0;
+}
+
+static void dhd_suspend_resume_helper(struct dhd_info *dhd, int val)
+{
+	dhd_pub_t *dhdp = &dhd->pub;
+
+	dhd_os_proto_block(dhdp);
+	/* Set flag when early suspend was called */
+	dhdp->in_suspend = val;
+	if (!dhdp->suspend_disable_flag)
+		dhd_set_suspend(val, dhdp);
+	dhd_os_proto_unblock(dhdp);
+}
+
+static void dhd_early_suspend(struct early_suspend *h)
+{
+	struct dhd_info *dhd = container_of(h, struct dhd_info, early_suspend);
+
+	DHD_TRACE(("%s: enter\n", __func__));
+
+	if (dhd)
+		dhd_suspend_resume_helper(dhd, 1);
+
+}
+
+static void dhd_late_resume(struct early_suspend *h)
+{
+	struct dhd_info *dhd = container_of(h, struct dhd_info, early_suspend);
+
+	DHD_TRACE(("%s: enter\n", __func__));
+
+	if (dhd)
+		dhd_suspend_resume_helper(dhd, 0);
+}
+#endif				/* defined(CONFIG_HAS_EARLYSUSPEND) */
+
+/*
+ * Generalized timeout mechanism.  Uses spin sleep with exponential
+ * back-off until
+ * the sleep time reaches one jiffy, then switches over to task delay.  Usage:
+ *
+ *      dhd_timeout_start(&tmo, usec);
+ *      while (!dhd_timeout_expired(&tmo))
+ *              if (poll_something())
+ *                      break;
+ *      if (dhd_timeout_expired(&tmo))
+ *              fatal();
+ */
+
+void dhd_timeout_start(dhd_timeout_t *tmo, uint usec)
+{
+	tmo->limit = usec;
+	tmo->increment = 0;
+	tmo->elapsed = 0;
+	tmo->tick = 1000000 / HZ;
+}
+
+int dhd_timeout_expired(dhd_timeout_t *tmo)
+{
+	/* Does nothing the first call */
+	if (tmo->increment == 0) {
+		tmo->increment = 1;
+		return 0;
+	}
+
+	if (tmo->elapsed >= tmo->limit)
+		return 1;
+
+	/* Add the delay that's about to take place */
+	tmo->elapsed += tmo->increment;
+
+	if (tmo->increment < tmo->tick) {
+		udelay(tmo->increment);
+		tmo->increment *= 2;
+		if (tmo->increment > tmo->tick)
+			tmo->increment = tmo->tick;
+	} else {
+		wait_queue_head_t delay_wait;
+		DECLARE_WAITQUEUE(wait, current);
+		int pending;
+		init_waitqueue_head(&delay_wait);
+		add_wait_queue(&delay_wait, &wait);
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(1);
+		pending = signal_pending(current);
+		remove_wait_queue(&delay_wait, &wait);
+		set_current_state(TASK_RUNNING);
+		if (pending)
+			return 1;	/* Interrupted */
+	}
+
+	return 0;
+}
+
+static int dhd_net2idx(dhd_info_t *dhd, struct net_device *net)
+{
+	int i = 0;
+
+	ASSERT(dhd);
+	while (i < DHD_MAX_IFS) {
+		if (dhd->iflist[i] && (dhd->iflist[i]->net == net))
+			return i;
+		i++;
+	}
+
+	return DHD_BAD_IF;
+}
+
+int dhd_ifname2idx(dhd_info_t *dhd, char *name)
+{
+	int i = DHD_MAX_IFS;
+
+	ASSERT(dhd);
+
+	if (name == NULL || *name == '\0')
+		return 0;
+
+	while (--i > 0)
+		if (dhd->iflist[i]
+		    && !strncmp(dhd->iflist[i]->name, name, IFNAMSIZ))
+			break;
+
+	DHD_TRACE(("%s: return idx %d for \"%s\"\n", __func__, i, name));
+
+	return i;		/* default - the primary interface */
+}
+
+char *dhd_ifname(dhd_pub_t *dhdp, int ifidx)
+{
+	dhd_info_t *dhd = (dhd_info_t *) dhdp->info;
+
+	ASSERT(dhd);
+
+	if (ifidx < 0 || ifidx >= DHD_MAX_IFS) {
+		DHD_ERROR(("%s: ifidx %d out of range\n", __func__, ifidx));
+		return "<if_bad>";
+	}
+
+	if (dhd->iflist[ifidx] == NULL) {
+		DHD_ERROR(("%s: null i/f %d\n", __func__, ifidx));
+		return "<if_null>";
+	}
+
+	if (dhd->iflist[ifidx]->net)
+		return dhd->iflist[ifidx]->net->name;
+
+	return "<if_none>";
+}
+
+static void _dhd_set_multicast_list(dhd_info_t *dhd, int ifidx)
+{
+	struct net_device *dev;
+	struct netdev_hw_addr *ha;
+	u32 allmulti, cnt;
+
+	wl_ioctl_t ioc;
+	char *buf, *bufp;
+	uint buflen;
+	int ret;
+
+	ASSERT(dhd && dhd->iflist[ifidx]);
+	dev = dhd->iflist[ifidx]->net;
+	cnt = netdev_mc_count(dev);
+
+	/* Determine initial value of allmulti flag */
+	allmulti = (dev->flags & IFF_ALLMULTI) ? true : false;
+
+	/* Send down the multicast list first. */
+
+	buflen = sizeof("mcast_list") + sizeof(cnt) + (cnt * ETHER_ADDR_LEN);
+	bufp = buf = kmalloc(buflen, GFP_ATOMIC);
+	if (!bufp) {
+		DHD_ERROR(("%s: out of memory for mcast_list, cnt %d\n",
+			   dhd_ifname(&dhd->pub, ifidx), cnt));
+		return;
+	}
+
+	strcpy(bufp, "mcast_list");
+	bufp += strlen("mcast_list") + 1;
+
+	cnt = htol32(cnt);
+	memcpy(bufp, &cnt, sizeof(cnt));
+	bufp += sizeof(cnt);
+
+	netdev_for_each_mc_addr(ha, dev) {
+		if (!cnt)
+			break;
+		memcpy(bufp, ha->addr, ETHER_ADDR_LEN);
+		bufp += ETHER_ADDR_LEN;
+		cnt--;
+	}
+
+	memset(&ioc, 0, sizeof(ioc));
+	ioc.cmd = WLC_SET_VAR;
+	ioc.buf = buf;
+	ioc.len = buflen;
+	ioc.set = true;
+
+	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
+	if (ret < 0) {
+		DHD_ERROR(("%s: set mcast_list failed, cnt %d\n",
+			   dhd_ifname(&dhd->pub, ifidx), cnt));
+		allmulti = cnt ? true : allmulti;
+	}
+
+	kfree(buf);
+
+	/* Now send the allmulti setting.  This is based on the setting in the
+	 * net_device flags, but might be modified above to be turned on if we
+	 * were trying to set some addresses and dongle rejected it...
+	 */
+
+	buflen = sizeof("allmulti") + sizeof(allmulti);
+	buf = kmalloc(buflen, GFP_ATOMIC);
+	if (!buf) {
+		DHD_ERROR(("%s: out of memory for allmulti\n",
+			   dhd_ifname(&dhd->pub, ifidx)));
+		return;
+	}
+	allmulti = htol32(allmulti);
+
+	if (!bcm_mkiovar
+	    ("allmulti", (void *)&allmulti, sizeof(allmulti), buf, buflen)) {
+		DHD_ERROR(("%s: mkiovar failed for allmulti, datalen %d "
+			"buflen %u\n", dhd_ifname(&dhd->pub, ifidx),
+			(int)sizeof(allmulti), buflen));
+		kfree(buf);
+		return;
+	}
+
+	memset(&ioc, 0, sizeof(ioc));
+	ioc.cmd = WLC_SET_VAR;
+	ioc.buf = buf;
+	ioc.len = buflen;
+	ioc.set = true;
+
+	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
+	if (ret < 0) {
+		DHD_ERROR(("%s: set allmulti %d failed\n",
+			   dhd_ifname(&dhd->pub, ifidx), ltoh32(allmulti)));
+	}
+
+	kfree(buf);
+
+	/* Finally, pick up the PROMISC flag as well, like the NIC
+		 driver does */
+
+	allmulti = (dev->flags & IFF_PROMISC) ? true : false;
+	allmulti = htol32(allmulti);
+
+	memset(&ioc, 0, sizeof(ioc));
+	ioc.cmd = WLC_SET_PROMISC;
+	ioc.buf = &allmulti;
+	ioc.len = sizeof(allmulti);
+	ioc.set = true;
+
+	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
+	if (ret < 0) {
+		DHD_ERROR(("%s: set promisc %d failed\n",
+			   dhd_ifname(&dhd->pub, ifidx), ltoh32(allmulti)));
+	}
+}
+
+static int
+_dhd_set_mac_address(dhd_info_t *dhd, int ifidx, struct ether_addr *addr)
+{
+	char buf[32];
+	wl_ioctl_t ioc;
+	int ret;
+
+	DHD_TRACE(("%s enter\n", __func__));
+	if (!bcm_mkiovar
+	    ("cur_etheraddr", (char *)addr, ETHER_ADDR_LEN, buf, 32)) {
+		DHD_ERROR(("%s: mkiovar failed for cur_etheraddr\n",
+			   dhd_ifname(&dhd->pub, ifidx)));
+		return -1;
+	}
+	memset(&ioc, 0, sizeof(ioc));
+	ioc.cmd = WLC_SET_VAR;
+	ioc.buf = buf;
+	ioc.len = 32;
+	ioc.set = true;
+
+	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
+	if (ret < 0) {
+		DHD_ERROR(("%s: set cur_etheraddr failed\n",
+			   dhd_ifname(&dhd->pub, ifidx)));
+	} else {
+		memcpy(dhd->iflist[ifidx]->net->dev_addr, addr, ETHER_ADDR_LEN);
+	}
+
+	return ret;
+}
+
+#ifdef SOFTAP
+extern struct net_device *ap_net_dev;
+#endif
+
+static void dhd_op_if(dhd_if_t *ifp)
+{
+	dhd_info_t *dhd;
+	int ret = 0, err = 0;
+
+	ASSERT(ifp && ifp->info && ifp->idx);	/* Virtual interfaces only */
+
+	dhd = ifp->info;
+
+	DHD_TRACE(("%s: idx %d, state %d\n", __func__, ifp->idx, ifp->state));
+
+	switch (ifp->state) {
+	case WLC_E_IF_ADD:
+		/*
+		 * Delete the existing interface before overwriting it
+		 * in case we missed the WLC_E_IF_DEL event.
+		 */
+		if (ifp->net != NULL) {
+			DHD_ERROR(("%s: ERROR: netdev:%s already exists, "
+			"try free & unregister\n",
+			__func__, ifp->net->name));
+			netif_stop_queue(ifp->net);
+			unregister_netdev(ifp->net);
+			free_netdev(ifp->net);
+		}
+		/* Allocate etherdev, including space for private structure */
+		ifp->net = alloc_etherdev(sizeof(dhd));
+		if (!ifp->net) {
+			DHD_ERROR(("%s: OOM - alloc_etherdev\n", __func__));
+			ret = -ENOMEM;
+		}
+		if (ret == 0) {
+			strcpy(ifp->net->name, ifp->name);
+			memcpy(netdev_priv(ifp->net), &dhd, sizeof(dhd));
+			err = dhd_net_attach(&dhd->pub, ifp->idx);
+			if (err != 0) {
+				DHD_ERROR(("%s: dhd_net_attach failed, "
+					"err %d\n",
+					__func__, err));
+				ret = -EOPNOTSUPP;
+			} else {
+#ifdef SOFTAP
+				/* semaphore that the soft AP CODE
+					 waits on */
+				extern struct semaphore ap_eth_sema;
+
+				/* save ptr to wl0.1 netdev for use
+					 in wl_iw.c  */
+				ap_net_dev = ifp->net;
+				/* signal to the SOFTAP 'sleeper' thread,
+					 wl0.1 is ready */
+				up(&ap_eth_sema);
+#endif
+				DHD_TRACE(("\n ==== pid:%x, net_device for "
+					"if:%s created ===\n\n",
+					current->pid, ifp->net->name));
+				ifp->state = 0;
+			}
+		}
+		break;
+	case WLC_E_IF_DEL:
+		if (ifp->net != NULL) {
+			DHD_TRACE(("\n%s: got 'WLC_E_IF_DEL' state\n",
+				   __func__));
+			netif_stop_queue(ifp->net);
+			unregister_netdev(ifp->net);
+			ret = DHD_DEL_IF;	/* Make sure the free_netdev()
+							 is called */
+		}
+		break;
+	default:
+		DHD_ERROR(("%s: bad op %d\n", __func__, ifp->state));
+		ASSERT(!ifp->state);
+		break;
+	}
+
+	if (ret < 0) {
+		if (ifp->net)
+			free_netdev(ifp->net);
+
+		dhd->iflist[ifp->idx] = NULL;
+		kfree(ifp);
+#ifdef SOFTAP
+		if (ifp->net == ap_net_dev)
+			ap_net_dev = NULL;	/*  NULL  SOFTAP global
+							 wl0.1 as well */
+#endif				/*  SOFTAP */
+	}
+}
+
+static int _dhd_sysioc_thread(void *data)
+{
+	dhd_info_t *dhd = (dhd_info_t *) data;
+	int i;
+#ifdef SOFTAP
+	bool in_ap = false;
+#endif
+
+	allow_signal(SIGTERM);
+
+	while (down_interruptible(&dhd->sysioc_sem) == 0) {
+		if (kthread_should_stop())
+			break;
+		for (i = 0; i < DHD_MAX_IFS; i++) {
+			if (dhd->iflist[i]) {
+#ifdef SOFTAP
+				in_ap = (ap_net_dev != NULL);
+#endif				/* SOFTAP */
+				if (dhd->iflist[i]->state)
+					dhd_op_if(dhd->iflist[i]);
+#ifdef SOFTAP
+				if (dhd->iflist[i] == NULL) {
+					DHD_TRACE(("\n\n %s: interface %d "
+						"removed!\n", __func__, i));
+					continue;
+				}
+
+				if (in_ap && dhd->set_macaddress) {
+					DHD_TRACE(("attempt to set MAC for %s "
+						"in AP Mode," "blocked. \n",
+						dhd->iflist[i]->net->name));
+					dhd->set_macaddress = false;
+					continue;
+				}
+
+				if (in_ap && dhd->set_multicast) {
+					DHD_TRACE(("attempt to set MULTICAST list for %s" "in AP Mode, blocked. \n",
+						dhd->iflist[i]->net->name));
+					dhd->set_multicast = false;
+					continue;
+				}
+#endif				/* SOFTAP */
+				if (dhd->set_multicast) {
+					dhd->set_multicast = false;
+					_dhd_set_multicast_list(dhd, i);
+				}
+				if (dhd->set_macaddress) {
+					dhd->set_macaddress = false;
+					_dhd_set_mac_address(dhd, i,
+							     &dhd->macvalue);
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+static int dhd_set_mac_address(struct net_device *dev, void *addr)
+{
+	int ret = 0;
+
+	dhd_info_t *dhd = *(dhd_info_t **) netdev_priv(dev);
+	struct sockaddr *sa = (struct sockaddr *)addr;
+	int ifidx;
+
+	ifidx = dhd_net2idx(dhd, dev);
+	if (ifidx == DHD_BAD_IF)
+		return -1;
+
+	ASSERT(dhd->sysioc_tsk);
+	memcpy(&dhd->macvalue, sa->sa_data, ETHER_ADDR_LEN);
+	dhd->set_macaddress = true;
+	up(&dhd->sysioc_sem);
+
+	return ret;
+}
+
+static void dhd_set_multicast_list(struct net_device *dev)
+{
+	dhd_info_t *dhd = *(dhd_info_t **) netdev_priv(dev);
+	int ifidx;
+
+	ifidx = dhd_net2idx(dhd, dev);
+	if (ifidx == DHD_BAD_IF)
+		return;
+
+	ASSERT(dhd->sysioc_tsk);
+	dhd->set_multicast = true;
+	up(&dhd->sysioc_sem);
+}
+
+int dhd_sendpkt(dhd_pub_t *dhdp, int ifidx, void *pktbuf)
+{
+	int ret;
+	dhd_info_t *dhd = (dhd_info_t *) (dhdp->info);
+
+	/* Reject if down */
+	if (!dhdp->up || (dhdp->busstate == DHD_BUS_DOWN))
+		return -ENODEV;
+
+	/* Update multicast statistic */
+	if (PKTLEN(pktbuf) >= ETHER_ADDR_LEN) {
+		u8 *pktdata = (u8 *) PKTDATA(pktbuf);
+		struct ether_header *eh = (struct ether_header *)pktdata;
+
+		if (ETHER_ISMULTI(eh->ether_dhost))
+			dhdp->tx_multicast++;
+		if (ntoh16(eh->ether_type) == ETHER_TYPE_802_1X)
+			atomic_inc(&dhd->pend_8021x_cnt);
+	}
+
+	/* If the protocol uses a data header, apply it */
+	dhd_prot_hdrpush(dhdp, ifidx, pktbuf);
+
+	/* Use bus module to send data frame */
+#ifdef BCMDBUS
+	ret = dbus_send_pkt(dhdp->dbus, pktbuf, NULL /* pktinfo */);
+#else
+	WAKE_LOCK_TIMEOUT(dhdp, WAKE_LOCK_TMOUT, 25);
+	ret = dhd_bus_txdata(dhdp->bus, pktbuf);
+#endif				/* BCMDBUS */
+
+	return ret;
+}
+
+static int dhd_start_xmit(struct sk_buff *skb, struct net_device *net)
+{
+	int ret;
+	void *pktbuf;
+	dhd_info_t *dhd = *(dhd_info_t **) netdev_priv(net);
+	int ifidx;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	/* Reject if down */
+	if (!dhd->pub.up || (dhd->pub.busstate == DHD_BUS_DOWN)) {
+		DHD_ERROR(("%s: xmit rejected pub.up=%d busstate=%d\n",
+			   __func__, dhd->pub.up, dhd->pub.busstate));
+		netif_stop_queue(net);
+		return -ENODEV;
+	}
+
+	ifidx = dhd_net2idx(dhd, net);
+	if (ifidx == DHD_BAD_IF) {
+		DHD_ERROR(("%s: bad ifidx %d\n", __func__, ifidx));
+		netif_stop_queue(net);
+		return -ENODEV;
+	}
+
+	/* Make sure there's enough room for any header */
+	if (skb_headroom(skb) < dhd->pub.hdrlen) {
+		struct sk_buff *skb2;
+
+		DHD_INFO(("%s: insufficient headroom\n",
+			  dhd_ifname(&dhd->pub, ifidx)));
+		dhd->pub.tx_realloc++;
+		skb2 = skb_realloc_headroom(skb, dhd->pub.hdrlen);
+		dev_kfree_skb(skb);
+		skb = skb2;
+		if (skb == NULL) {
+			DHD_ERROR(("%s: skb_realloc_headroom failed\n",
+				   dhd_ifname(&dhd->pub, ifidx)));
+			ret = -ENOMEM;
+			goto done;
+		}
+	}
+
+	/* Convert to packet */
+	pktbuf = PKTFRMNATIVE(dhd->pub.osh, skb);
+	if (!pktbuf) {
+		DHD_ERROR(("%s: PKTFRMNATIVE failed\n",
+			   dhd_ifname(&dhd->pub, ifidx)));
+		dev_kfree_skb_any(skb);
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	ret = dhd_sendpkt(&dhd->pub, ifidx, pktbuf);
+
+done:
+	if (ret)
+		dhd->pub.dstats.tx_dropped++;
+	else
+		dhd->pub.tx_packets++;
+
+	/* Return ok: we always eat the packet */
+	return 0;
+}
+
+void dhd_txflowcontrol(dhd_pub_t *dhdp, int ifidx, bool state)
+{
+	struct net_device *net;
+	dhd_info_t *dhd = dhdp->info;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	dhdp->txoff = state;
+	ASSERT(dhd && dhd->iflist[ifidx]);
+	net = dhd->iflist[ifidx]->net;
+	if (state == ON)
+		netif_stop_queue(net);
+	else
+		netif_wake_queue(net);
+}
+
+void dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt)
+{
+	dhd_info_t *dhd = (dhd_info_t *) dhdp->info;
+	struct sk_buff *skb;
+	unsigned char *eth;
+	uint len;
+	void *data, *pnext, *save_pktbuf;
+	int i;
+	dhd_if_t *ifp;
+	wl_event_msg_t event;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	save_pktbuf = pktbuf;
+
+	for (i = 0; pktbuf && i < numpkt; i++, pktbuf = pnext) {
+
+		pnext = PKTNEXT(pktbuf);
+		PKTSETNEXT(pktbuf, NULL);
+
+		skb = PKTTONATIVE(dhdp->osh, pktbuf);
+
+		/* Get the protocol, maintain skb around eth_type_trans()
+		 * The main reason for this hack is for the limitation of
+		 * Linux 2.4 where 'eth_type_trans' uses the
+		 * 'net->hard_header_len'
+		 * to perform skb_pull inside vs ETH_HLEN. Since to avoid
+		 * coping of the packet coming from the network stack to add
+		 * BDC, Hardware header etc, during network interface
+		 * registration
+		 * we set the 'net->hard_header_len' to ETH_HLEN + extra space
+		 * required
+		 * for BDC, Hardware header etc. and not just the ETH_HLEN
+		 */
+		eth = skb->data;
+		len = skb->len;
+
+		ifp = dhd->iflist[ifidx];
+		if (ifp == NULL)
+			ifp = dhd->iflist[0];
+
+		ASSERT(ifp);
+		skb->dev = ifp->net;
+		skb->protocol = eth_type_trans(skb, skb->dev);
+
+		if (skb->pkt_type == PACKET_MULTICAST)
+			dhd->pub.rx_multicast++;
+
+		skb->data = eth;
+		skb->len = len;
+
+		/* Strip header, count, deliver upward */
+		skb_pull(skb, ETH_HLEN);
+
+		/* Process special event packets and then discard them */
+		if (ntoh16(skb->protocol) == ETHER_TYPE_BRCM)
+			dhd_wl_host_event(dhd, &ifidx,
+					  skb->mac_header,
+					  &event, &data);
+
+		ASSERT(ifidx < DHD_MAX_IFS && dhd->iflist[ifidx]);
+		if (dhd->iflist[ifidx] && !dhd->iflist[ifidx]->state)
+			ifp = dhd->iflist[ifidx];
+
+		if (ifp->net)
+			ifp->net->last_rx = jiffies;
+
+		dhdp->dstats.rx_bytes += skb->len;
+		dhdp->rx_packets++;	/* Local count */
+
+		if (in_interrupt()) {
+			netif_rx(skb);
+		} else {
+			/* If the receive is not processed inside an ISR,
+			 * the softirqd must be woken explicitly to service
+			 * the NET_RX_SOFTIRQ.  In 2.6 kernels, this is handled
+			 * by netif_rx_ni(), but in earlier kernels, we need
+			 * to do it manually.
+			 */
+			netif_rx_ni(skb);
+		}
+	}
+}
+
+void dhd_event(struct dhd_info *dhd, char *evpkt, int evlen, int ifidx)
+{
+	/* Linux version has nothing to do */
+	return;
+}
+
+void dhd_txcomplete(dhd_pub_t *dhdp, void *txp, bool success)
+{
+	uint ifidx;
+	dhd_info_t *dhd = (dhd_info_t *) (dhdp->info);
+	struct ether_header *eh;
+	u16 type;
+
+	dhd_prot_hdrpull(dhdp, &ifidx, txp);
+
+	eh = (struct ether_header *)PKTDATA(txp);
+	type = ntoh16(eh->ether_type);
+
+	if (type == ETHER_TYPE_802_1X)
+		atomic_dec(&dhd->pend_8021x_cnt);
+
+}
+
+static struct net_device_stats *dhd_get_stats(struct net_device *net)
+{
+	dhd_info_t *dhd = *(dhd_info_t **) netdev_priv(net);
+	dhd_if_t *ifp;
+	int ifidx;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	ifidx = dhd_net2idx(dhd, net);
+	if (ifidx == DHD_BAD_IF)
+		return NULL;
+
+	ifp = dhd->iflist[ifidx];
+	ASSERT(dhd && ifp);
+
+	if (dhd->pub.up) {
+		/* Use the protocol to get dongle stats */
+		dhd_prot_dstats(&dhd->pub);
+	}
+
+	/* Copy dongle stats to net device stats */
+	ifp->stats.rx_packets = dhd->pub.dstats.rx_packets;
+	ifp->stats.tx_packets = dhd->pub.dstats.tx_packets;
+	ifp->stats.rx_bytes = dhd->pub.dstats.rx_bytes;
+	ifp->stats.tx_bytes = dhd->pub.dstats.tx_bytes;
+	ifp->stats.rx_errors = dhd->pub.dstats.rx_errors;
+	ifp->stats.tx_errors = dhd->pub.dstats.tx_errors;
+	ifp->stats.rx_dropped = dhd->pub.dstats.rx_dropped;
+	ifp->stats.tx_dropped = dhd->pub.dstats.tx_dropped;
+	ifp->stats.multicast = dhd->pub.dstats.multicast;
+
+	return &ifp->stats;
+}
+
+static int dhd_watchdog_thread(void *data)
+{
+	dhd_info_t *dhd = (dhd_info_t *) data;
+	WAKE_LOCK_INIT(&dhd->pub, WAKE_LOCK_WATCHDOG, "dhd_watchdog_thread");
+
+	/* This thread doesn't need any user-level access,
+	 * so get rid of all our resources
+	 */
+#ifdef DHD_SCHED
+	if (dhd_watchdog_prio > 0) {
+		struct sched_param param;
+		param.sched_priority = (dhd_watchdog_prio < MAX_RT_PRIO) ?
+		    dhd_watchdog_prio : (MAX_RT_PRIO - 1);
+		setScheduler(current, SCHED_FIFO, &param);
+	}
+#endif				/* DHD_SCHED */
+
+	allow_signal(SIGTERM);
+	/* Run until signal received */
+	while (1) {
+		if (kthread_should_stop())
+			break;
+		if (down_interruptible(&dhd->watchdog_sem) == 0) {
+			if (dhd->pub.dongle_reset == false) {
+				WAKE_LOCK(&dhd->pub, WAKE_LOCK_WATCHDOG);
+				/* Call the bus module watchdog */
+				dhd_bus_watchdog(&dhd->pub);
+				WAKE_UNLOCK(&dhd->pub, WAKE_LOCK_WATCHDOG);
+			}
+			/* Count the tick for reference */
+			dhd->pub.tickcnt++;
+		} else
+			break;
+	}
+
+	WAKE_LOCK_DESTROY(&dhd->pub, WAKE_LOCK_WATCHDOG);
+	return 0;
+}
+
+static void dhd_watchdog(unsigned long data)
+{
+	dhd_info_t *dhd = (dhd_info_t *) data;
+
+	if (dhd->watchdog_tsk) {
+		up(&dhd->watchdog_sem);
+
+		/* Reschedule the watchdog */
+		if (dhd->wd_timer_valid) {
+			mod_timer(&dhd->timer,
+				  jiffies + dhd_watchdog_ms * HZ / 1000);
+		}
+		return;
+	}
+
+	/* Call the bus module watchdog */
+	dhd_bus_watchdog(&dhd->pub);
+
+	/* Count the tick for reference */
+	dhd->pub.tickcnt++;
+
+	/* Reschedule the watchdog */
+	if (dhd->wd_timer_valid)
+		mod_timer(&dhd->timer, jiffies + dhd_watchdog_ms * HZ / 1000);
+}
+
+static int dhd_dpc_thread(void *data)
+{
+	dhd_info_t *dhd = (dhd_info_t *) data;
+
+	WAKE_LOCK_INIT(&dhd->pub, WAKE_LOCK_DPC, "dhd_dpc_thread");
+	/* This thread doesn't need any user-level access,
+	 * so get rid of all our resources
+	 */
+#ifdef DHD_SCHED
+	if (dhd_dpc_prio > 0) {
+		struct sched_param param;
+		param.sched_priority =
+		    (dhd_dpc_prio <
+		     MAX_RT_PRIO) ? dhd_dpc_prio : (MAX_RT_PRIO - 1);
+		setScheduler(current, SCHED_FIFO, &param);
+	}
+#endif				/* DHD_SCHED */
+
+	allow_signal(SIGTERM);
+	/* Run until signal received */
+	while (1) {
+		if (kthread_should_stop())
+			break;
+		if (down_interruptible(&dhd->dpc_sem) == 0) {
+			/* Call bus dpc unless it indicated down
+				 (then clean stop) */
+			if (dhd->pub.busstate != DHD_BUS_DOWN) {
+				WAKE_LOCK(&dhd->pub, WAKE_LOCK_DPC);
+				if (dhd_bus_dpc(dhd->pub.bus)) {
+					up(&dhd->dpc_sem);
+					WAKE_LOCK_TIMEOUT(&dhd->pub,
+							  WAKE_LOCK_TMOUT, 25);
+				}
+				WAKE_UNLOCK(&dhd->pub, WAKE_LOCK_DPC);
+			} else {
+				dhd_bus_stop(dhd->pub.bus, true);
+			}
+		} else
+			break;
+	}
+
+	WAKE_LOCK_DESTROY(&dhd->pub, WAKE_LOCK_DPC);
+	return 0;
+}
+
+static void dhd_dpc(unsigned long data)
+{
+	dhd_info_t *dhd;
+
+	dhd = (dhd_info_t *) data;
+
+	/* Call bus dpc unless it indicated down (then clean stop) */
+	if (dhd->pub.busstate != DHD_BUS_DOWN) {
+		if (dhd_bus_dpc(dhd->pub.bus))
+			tasklet_schedule(&dhd->tasklet);
+	} else {
+		dhd_bus_stop(dhd->pub.bus, true);
+	}
+}
+
+void dhd_sched_dpc(dhd_pub_t *dhdp)
+{
+	dhd_info_t *dhd = (dhd_info_t *) dhdp->info;
+
+	if (dhd->dpc_tsk) {
+		up(&dhd->dpc_sem);
+		return;
+	}
+
+	tasklet_schedule(&dhd->tasklet);
+}
+
+#ifdef TOE
+/* Retrieve current toe component enables, which are kept
+	 as a bitmap in toe_ol iovar */
+static int dhd_toe_get(dhd_info_t *dhd, int ifidx, u32 *toe_ol)
+{
+	wl_ioctl_t ioc;
+	char buf[32];
+	int ret;
+
+	memset(&ioc, 0, sizeof(ioc));
+
+	ioc.cmd = WLC_GET_VAR;
+	ioc.buf = buf;
+	ioc.len = (uint) sizeof(buf);
+	ioc.set = false;
+
+	strcpy(buf, "toe_ol");
+	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
+	if (ret < 0) {
+		/* Check for older dongle image that doesn't support toe_ol */
+		if (ret == -EIO) {
+			DHD_ERROR(("%s: toe not supported by device\n",
+				   dhd_ifname(&dhd->pub, ifidx)));
+			return -EOPNOTSUPP;
+		}
+
+		DHD_INFO(("%s: could not get toe_ol: ret=%d\n",
+			  dhd_ifname(&dhd->pub, ifidx), ret));
+		return ret;
+	}
+
+	memcpy(toe_ol, buf, sizeof(u32));
+	return 0;
+}
+
+/* Set current toe component enables in toe_ol iovar,
+	 and set toe global enable iovar */
+static int dhd_toe_set(dhd_info_t *dhd, int ifidx, u32 toe_ol)
+{
+	wl_ioctl_t ioc;
+	char buf[32];
+	int toe, ret;
+
+	memset(&ioc, 0, sizeof(ioc));
+
+	ioc.cmd = WLC_SET_VAR;
+	ioc.buf = buf;
+	ioc.len = (uint) sizeof(buf);
+	ioc.set = true;
+
+	/* Set toe_ol as requested */
+
+	strcpy(buf, "toe_ol");
+	memcpy(&buf[sizeof("toe_ol")], &toe_ol, sizeof(u32));
+
+	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
+	if (ret < 0) {
+		DHD_ERROR(("%s: could not set toe_ol: ret=%d\n",
+			   dhd_ifname(&dhd->pub, ifidx), ret));
+		return ret;
+	}
+
+	/* Enable toe globally only if any components are enabled. */
+
+	toe = (toe_ol != 0);
+
+	strcpy(buf, "toe");
+	memcpy(&buf[sizeof("toe")], &toe, sizeof(u32));
+
+	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
+	if (ret < 0) {
+		DHD_ERROR(("%s: could not set toe: ret=%d\n",
+			   dhd_ifname(&dhd->pub, ifidx), ret));
+		return ret;
+	}
+
+	return 0;
+}
+#endif				/* TOE */
+
+static void dhd_ethtool_get_drvinfo(struct net_device *net,
+				    struct ethtool_drvinfo *info)
+{
+	dhd_info_t *dhd = *(dhd_info_t **) netdev_priv(net);
+
+	sprintf(info->driver, DRV_MODULE_NAME);
+	sprintf(info->version, "%lu", dhd->pub.drv_version);
+	sprintf(info->fw_version, "%s", wl_cfg80211_get_fwname());
+	sprintf(info->bus_info, "%s", dev_name(&wl_cfg80211_get_sdio_func()->dev));
+}
+
+struct ethtool_ops dhd_ethtool_ops = {
+	.get_drvinfo = dhd_ethtool_get_drvinfo
+};
+
+static int dhd_ethtool(dhd_info_t *dhd, void *uaddr)
+{
+	struct ethtool_drvinfo info;
+	char drvname[sizeof(info.driver)];
+	u32 cmd;
+#ifdef TOE
+	struct ethtool_value edata;
+	u32 toe_cmpnt, csum_dir;
+	int ret;
+#endif
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	/* all ethtool calls start with a cmd word */
+	if (copy_from_user(&cmd, uaddr, sizeof(u32)))
+		return -EFAULT;
+
+	switch (cmd) {
+	case ETHTOOL_GDRVINFO:
+		/* Copy out any request driver name */
+		if (copy_from_user(&info, uaddr, sizeof(info)))
+			return -EFAULT;
+		strncpy(drvname, info.driver, sizeof(info.driver));
+		drvname[sizeof(info.driver) - 1] = '\0';
+
+		/* clear struct for return */
+		memset(&info, 0, sizeof(info));
+		info.cmd = cmd;
+
+		/* if dhd requested, identify ourselves */
+		if (strcmp(drvname, "?dhd") == 0) {
+			sprintf(info.driver, "dhd");
+			strcpy(info.version, EPI_VERSION_STR);
+		}
+
+		/* otherwise, require dongle to be up */
+		else if (!dhd->pub.up) {
+			DHD_ERROR(("%s: dongle is not up\n", __func__));
+			return -ENODEV;
+		}
+
+		/* finally, report dongle driver type */
+		else if (dhd->pub.iswl)
+			sprintf(info.driver, "wl");
+		else
+			sprintf(info.driver, "xx");
+
+		sprintf(info.version, "%lu", dhd->pub.drv_version);
+		if (copy_to_user(uaddr, &info, sizeof(info)))
+			return -EFAULT;
+		DHD_CTL(("%s: given %*s, returning %s\n", __func__,
+			 (int)sizeof(drvname), drvname, info.driver));
+		break;
+
+#ifdef TOE
+		/* Get toe offload components from dongle */
+	case ETHTOOL_GRXCSUM:
+	case ETHTOOL_GTXCSUM:
+		ret = dhd_toe_get(dhd, 0, &toe_cmpnt);
+		if (ret < 0)
+			return ret;
+
+		csum_dir =
+		    (cmd == ETHTOOL_GTXCSUM) ? TOE_TX_CSUM_OL : TOE_RX_CSUM_OL;
+
+		edata.cmd = cmd;
+		edata.data = (toe_cmpnt & csum_dir) ? 1 : 0;
+
+		if (copy_to_user(uaddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		break;
+
+		/* Set toe offload components in dongle */
+	case ETHTOOL_SRXCSUM:
+	case ETHTOOL_STXCSUM:
+		if (copy_from_user(&edata, uaddr, sizeof(edata)))
+			return -EFAULT;
+
+		/* Read the current settings, update and write back */
+		ret = dhd_toe_get(dhd, 0, &toe_cmpnt);
+		if (ret < 0)
+			return ret;
+
+		csum_dir =
+		    (cmd == ETHTOOL_STXCSUM) ? TOE_TX_CSUM_OL : TOE_RX_CSUM_OL;
+
+		if (edata.data != 0)
+			toe_cmpnt |= csum_dir;
+		else
+			toe_cmpnt &= ~csum_dir;
+
+		ret = dhd_toe_set(dhd, 0, toe_cmpnt);
+		if (ret < 0)
+			return ret;
+
+		/* If setting TX checksum mode, tell Linux the new mode */
+		if (cmd == ETHTOOL_STXCSUM) {
+			if (edata.data)
+				dhd->iflist[0]->net->features |=
+				    NETIF_F_IP_CSUM;
+			else
+				dhd->iflist[0]->net->features &=
+				    ~NETIF_F_IP_CSUM;
+		}
+
+		break;
+#endif				/* TOE */
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int dhd_ioctl_entry(struct net_device *net, struct ifreq *ifr, int cmd)
+{
+	dhd_info_t *dhd = *(dhd_info_t **) netdev_priv(net);
+	dhd_ioctl_t ioc;
+	int bcmerror = 0;
+	int buflen = 0;
+	void *buf = NULL;
+	uint driver = 0;
+	int ifidx;
+	bool is_set_key_cmd;
+
+	ifidx = dhd_net2idx(dhd, net);
+	DHD_TRACE(("%s: ifidx %d, cmd 0x%04x\n", __func__, ifidx, cmd));
+
+	if (ifidx == DHD_BAD_IF)
+		return -1;
+
+#if defined(CONFIG_WIRELESS_EXT)
+	/* linux wireless extensions */
+	if ((cmd >= SIOCIWFIRST) && (cmd <= SIOCIWLAST)) {
+		/* may recurse, do NOT lock */
+		return wl_iw_ioctl(net, ifr, cmd);
+	}
+#endif				/* defined(CONFIG_WIRELESS_EXT) */
+
+	if (cmd == SIOCETHTOOL)
+		return dhd_ethtool(dhd, (void *)ifr->ifr_data);
+
+	if (cmd != SIOCDEVPRIVATE)
+		return -EOPNOTSUPP;
+
+	memset(&ioc, 0, sizeof(ioc));
+
+	/* Copy the ioc control structure part of ioctl request */
+	if (copy_from_user(&ioc, ifr->ifr_data, sizeof(wl_ioctl_t))) {
+		bcmerror = -BCME_BADADDR;
+		goto done;
+	}
+
+	/* Copy out any buffer passed */
+	if (ioc.buf) {
+		buflen = min_t(int, ioc.len, DHD_IOCTL_MAXLEN);
+		/* optimization for direct ioctl calls from kernel */
+		/*
+		   if (segment_eq(get_fs(), KERNEL_DS)) {
+		   buf = ioc.buf;
+		   } else {
+		 */
+		{
+			buf = kmalloc(buflen, GFP_ATOMIC);
+			if (!buf) {
+				bcmerror = -BCME_NOMEM;
+				goto done;
+			}
+			if (copy_from_user(buf, ioc.buf, buflen)) {
+				bcmerror = -BCME_BADADDR;
+				goto done;
+			}
+		}
+	}
+
+	/* To differentiate between wl and dhd read 4 more byes */
+	if ((copy_from_user(&driver, (char *)ifr->ifr_data + sizeof(wl_ioctl_t),
+			    sizeof(uint)) != 0)) {
+		bcmerror = -BCME_BADADDR;
+		goto done;
+	}
+
+	if (!capable(CAP_NET_ADMIN)) {
+		bcmerror = -BCME_EPERM;
+		goto done;
+	}
+
+	/* check for local dhd ioctl and handle it */
+	if (driver == DHD_IOCTL_MAGIC) {
+		bcmerror = dhd_ioctl((void *)&dhd->pub, &ioc, buf, buflen);
+		if (bcmerror)
+			dhd->pub.bcmerror = bcmerror;
+		goto done;
+	}
+
+	/* send to dongle (must be up, and wl) */
+	if ((dhd->pub.busstate != DHD_BUS_DATA)) {
+		DHD_ERROR(("%s DONGLE_DOWN,__func__\n", __func__));
+		bcmerror = BCME_DONGLE_DOWN;
+		goto done;
+	}
+
+	if (!dhd->pub.iswl) {
+		bcmerror = BCME_DONGLE_DOWN;
+		goto done;
+	}
+
+	/* Intercept WLC_SET_KEY IOCTL - serialize M4 send and set key IOCTL to
+	 * prevent M4 encryption.
+	 */
+	is_set_key_cmd = ((ioc.cmd == WLC_SET_KEY) ||
+			  ((ioc.cmd == WLC_SET_VAR) &&
+			   !(strncmp("wsec_key", ioc.buf, 9))) ||
+			  ((ioc.cmd == WLC_SET_VAR) &&
+			   !(strncmp("bsscfg:wsec_key", ioc.buf, 15))));
+	if (is_set_key_cmd)
+		dhd_wait_pend8021x(net);
+
+	WAKE_LOCK_INIT(&dhd->pub, WAKE_LOCK_IOCTL, "dhd_ioctl_entry");
+	WAKE_LOCK(&dhd->pub, WAKE_LOCK_IOCTL);
+
+	bcmerror =
+	    dhd_prot_ioctl(&dhd->pub, ifidx, (wl_ioctl_t *)&ioc, buf, buflen);
+
+	WAKE_UNLOCK(&dhd->pub, WAKE_LOCK_IOCTL);
+	WAKE_LOCK_DESTROY(&dhd->pub, WAKE_LOCK_IOCTL);
+done:
+	if (!bcmerror && buf && ioc.buf) {
+		if (copy_to_user(ioc.buf, buf, buflen))
+			bcmerror = -EFAULT;
+	}
+
+	if (buf)
+		kfree(buf);
+
+	return OSL_ERROR(bcmerror);
+}
+
+static int dhd_stop(struct net_device *net)
+{
+#if !defined(IGNORE_ETH0_DOWN)
+	dhd_info_t *dhd = *(dhd_info_t **) netdev_priv(net);
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+	if (IS_CFG80211_FAVORITE()) {
+		wl_cfg80211_down();
+	}
+	if (dhd->pub.up == 0)
+		return 0;
+
+	/* Set state and stop OS transmissions */
+	dhd->pub.up = 0;
+	netif_stop_queue(net);
+#else
+	DHD_ERROR(("BYPASS %s:due to BRCM compilation : under investigation\n",
+		__func__));
+#endif				/* !defined(IGNORE_ETH0_DOWN) */
+
+	return 0;
+}
+
+static int dhd_open(struct net_device *net)
+{
+	dhd_info_t *dhd = *(dhd_info_t **) netdev_priv(net);
+#ifdef TOE
+	u32 toe_ol;
+#endif
+	int ifidx = dhd_net2idx(dhd, net);
+	s32 ret = 0;
+
+	DHD_TRACE(("%s: ifidx %d\n", __func__, ifidx));
+
+	if (ifidx == 0) {	/* do it only for primary eth0 */
+
+		/* try to bring up bus */
+		ret = dhd_bus_start(&dhd->pub);
+		if (ret != 0) {
+			DHD_ERROR(("%s: failed with code %d\n", __func__, ret));
+			return -1;
+		}
+		atomic_set(&dhd->pend_8021x_cnt, 0);
+
+		memcpy(net->dev_addr, dhd->pub.mac.octet, ETHER_ADDR_LEN);
+
+#ifdef TOE
+		/* Get current TOE mode from dongle */
+		if (dhd_toe_get(dhd, ifidx, &toe_ol) >= 0
+		    && (toe_ol & TOE_TX_CSUM_OL) != 0)
+			dhd->iflist[ifidx]->net->features |= NETIF_F_IP_CSUM;
+		else
+			dhd->iflist[ifidx]->net->features &= ~NETIF_F_IP_CSUM;
+#endif
+	}
+	/* Allow transmit calls */
+	netif_start_queue(net);
+	dhd->pub.up = 1;
+	if (IS_CFG80211_FAVORITE()) {
+		if (unlikely(wl_cfg80211_up())) {
+			DHD_ERROR(("%s: failed to bring up cfg80211\n",
+				   __func__));
+			return -1;
+		}
+	}
+
+	return ret;
+}
+
+osl_t *dhd_osl_attach(void *pdev, uint bustype)
+{
+	return osl_attach(pdev, bustype, true);
+}
+
+void dhd_osl_detach(osl_t *osh)
+{
+	osl_detach(osh);
+}
+
+int
+dhd_add_if(dhd_info_t *dhd, int ifidx, void *handle, char *name,
+	   u8 *mac_addr, u32 flags, u8 bssidx)
+{
+	dhd_if_t *ifp;
+
+	DHD_TRACE(("%s: idx %d, handle->%p\n", __func__, ifidx, handle));
+
+	ASSERT(dhd && (ifidx < DHD_MAX_IFS));
+
+	ifp = dhd->iflist[ifidx];
+	if (!ifp && !(ifp = kmalloc(sizeof(dhd_if_t), GFP_ATOMIC))) {
+		DHD_ERROR(("%s: OOM - dhd_if_t\n", __func__));
+		return -ENOMEM;
+	}
+
+	memset(ifp, 0, sizeof(dhd_if_t));
+	ifp->info = dhd;
+	dhd->iflist[ifidx] = ifp;
+	strlcpy(ifp->name, name, IFNAMSIZ);
+	if (mac_addr != NULL)
+		memcpy(&ifp->mac_addr, mac_addr, ETHER_ADDR_LEN);
+
+	if (handle == NULL) {
+		ifp->state = WLC_E_IF_ADD;
+		ifp->idx = ifidx;
+		ASSERT(dhd->sysioc_tsk);
+		up(&dhd->sysioc_sem);
+	} else
+		ifp->net = (struct net_device *)handle;
+
+	return 0;
+}
+
+void dhd_del_if(dhd_info_t *dhd, int ifidx)
+{
+	dhd_if_t *ifp;
+
+	DHD_TRACE(("%s: idx %d\n", __func__, ifidx));
+
+	ASSERT(dhd && ifidx && (ifidx < DHD_MAX_IFS));
+	ifp = dhd->iflist[ifidx];
+	if (!ifp) {
+		DHD_ERROR(("%s: Null interface\n", __func__));
+		return;
+	}
+
+	ifp->state = WLC_E_IF_DEL;
+	ifp->idx = ifidx;
+	ASSERT(dhd->sysioc_tsk);
+	up(&dhd->sysioc_sem);
+}
+
+dhd_pub_t *dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
+{
+	dhd_info_t *dhd = NULL;
+	struct net_device *net;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+	/* updates firmware nvram path if it was provided as module
+		 paramters */
+	if ((firmware_path != NULL) && (firmware_path[0] != '\0'))
+		strcpy(fw_path, firmware_path);
+	if ((nvram_path != NULL) && (nvram_path[0] != '\0'))
+		strcpy(nv_path, nvram_path);
+
+	/* Allocate etherdev, including space for private structure */
+	net = alloc_etherdev(sizeof(dhd));
+	if (!net) {
+		DHD_ERROR(("%s: OOM - alloc_etherdev\n", __func__));
+		goto fail;
+	}
+
+	/* Allocate primary dhd_info */
+	dhd = kmalloc(sizeof(dhd_info_t), GFP_ATOMIC);
+	if (!dhd) {
+		DHD_ERROR(("%s: OOM - alloc dhd_info\n", __func__));
+		goto fail;
+	}
+
+	memset(dhd, 0, sizeof(dhd_info_t));
+
+	/*
+	 * Save the dhd_info into the priv
+	 */
+	memcpy(netdev_priv(net), &dhd, sizeof(dhd));
+	dhd->pub.osh = osh;
+
+	/* Set network interface name if it was provided as module parameter */
+	if (iface_name[0]) {
+		int len;
+		char ch;
+		strncpy(net->name, iface_name, IFNAMSIZ);
+		net->name[IFNAMSIZ - 1] = 0;
+		len = strlen(net->name);
+		ch = net->name[len - 1];
+		if ((ch > '9' || ch < '0') && (len < IFNAMSIZ - 2))
+			strcat(net->name, "%d");
+	}
+
+	if (dhd_add_if(dhd, 0, (void *)net, net->name, NULL, 0, 0) ==
+	    DHD_BAD_IF)
+		goto fail;
+
+	net->netdev_ops = NULL;
+	sema_init(&dhd->proto_sem, 1);
+	/* Initialize other structure content */
+	init_waitqueue_head(&dhd->ioctl_resp_wait);
+	init_waitqueue_head(&dhd->ctrl_wait);
+
+	/* Initialize the spinlocks */
+	spin_lock_init(&dhd->sdlock);
+	spin_lock_init(&dhd->txqlock);
+
+	/* Link to info module */
+	dhd->pub.info = dhd;
+
+	/* Link to bus module */
+	dhd->pub.bus = bus;
+	dhd->pub.hdrlen = bus_hdrlen;
+
+	/* Attach and link in the protocol */
+	if (dhd_prot_attach(&dhd->pub) != 0) {
+		DHD_ERROR(("dhd_prot_attach failed\n"));
+		goto fail;
+	}
+#if defined(CONFIG_WIRELESS_EXT)
+	/* Attach and link in the iw */
+	if (wl_iw_attach(net, (void *)&dhd->pub) != 0) {
+		DHD_ERROR(("wl_iw_attach failed\n"));
+		goto fail;
+	}
+#endif	/* defined(CONFIG_WIRELESS_EXT) */
+
+	/* Attach and link in the cfg80211 */
+	if (IS_CFG80211_FAVORITE()) {
+		if (unlikely(wl_cfg80211_attach(net, &dhd->pub))) {
+			DHD_ERROR(("wl_cfg80211_attach failed\n"));
+			goto fail;
+		}
+		if (!NO_FW_REQ()) {
+			strcpy(fw_path, wl_cfg80211_get_fwname());
+			strcpy(nv_path, wl_cfg80211_get_nvramname());
+		}
+		wl_cfg80211_dbg_level(DBG_CFG80211_GET());
+	}
+
+	/* Set up the watchdog timer */
+	init_timer(&dhd->timer);
+	dhd->timer.data = (unsigned long) dhd;
+	dhd->timer.function = dhd_watchdog;
+
+	/* Initialize thread based operation and lock */
+	sema_init(&dhd->sdsem, 1);
+	if ((dhd_watchdog_prio >= 0) && (dhd_dpc_prio >= 0))
+		dhd->threads_only = true;
+	else
+		dhd->threads_only = false;
+
+	if (dhd_dpc_prio >= 0) {
+		/* Initialize watchdog thread */
+		sema_init(&dhd->watchdog_sem, 0);
+		dhd->watchdog_tsk = kthread_run(dhd_watchdog_thread, dhd,
+						"dhd_watchdog");
+		if (IS_ERR(dhd->watchdog_tsk)) {
+			printk(KERN_WARNING
+				"dhd_watchdog thread failed to start\n");
+			dhd->watchdog_tsk = NULL;
+		}
+	} else {
+		dhd->watchdog_tsk = NULL;
+	}
+
+	/* Set up the bottom half handler */
+	if (dhd_dpc_prio >= 0) {
+		/* Initialize DPC thread */
+		sema_init(&dhd->dpc_sem, 0);
+		dhd->dpc_tsk = kthread_run(dhd_dpc_thread, dhd, "dhd_dpc");
+		if (IS_ERR(dhd->dpc_tsk)) {
+			printk(KERN_WARNING
+				"dhd_dpc thread failed to start\n");
+			dhd->dpc_tsk = NULL;
+		}
+	} else {
+		tasklet_init(&dhd->tasklet, dhd_dpc, (unsigned long) dhd);
+		dhd->dpc_tsk = NULL;
+	}
+
+	if (dhd_sysioc) {
+		sema_init(&dhd->sysioc_sem, 0);
+		dhd->sysioc_tsk = kthread_run(_dhd_sysioc_thread, dhd,
+						"_dhd_sysioc");
+		if (IS_ERR(dhd->sysioc_tsk)) {
+			printk(KERN_WARNING
+				"_dhd_sysioc thread failed to start\n");
+			dhd->sysioc_tsk = NULL;
+		}
+	} else
+		dhd->sysioc_tsk = NULL;
+
+	/*
+	 * Save the dhd_info into the priv
+	 */
+	memcpy(netdev_priv(net), &dhd, sizeof(dhd));
+
+#if defined(CUSTOMER_HW2) && defined(CONFIG_WIFI_CONTROL_FUNC)
+	g_bus = bus;
+#endif
+#if defined(CONFIG_PM_SLEEP)
+	register_pm_notifier(&dhd_sleep_pm_notifier);
+#endif	/* defined(CONFIG_PM_SLEEP) */
+	/* && defined(DHD_GPL) */
+	/* Init lock suspend to prevent kernel going to suspend */
+	WAKE_LOCK_INIT(&dhd->pub, WAKE_LOCK_TMOUT, "dhd_wake_lock");
+	WAKE_LOCK_INIT(&dhd->pub, WAKE_LOCK_LINK_DOWN_TMOUT,
+		       "dhd_wake_lock_link_dw_event");
+	WAKE_LOCK_INIT(&dhd->pub, WAKE_LOCK_PNO_FIND_TMOUT,
+		       "dhd_wake_lock_link_pno_find_event");
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	dhd->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 20;
+	dhd->early_suspend.suspend = dhd_early_suspend;
+	dhd->early_suspend.resume = dhd_late_resume;
+	register_early_suspend(&dhd->early_suspend);
+#endif
+
+	return &dhd->pub;
+
+fail:
+	if (net)
+		free_netdev(net);
+	if (dhd)
+		dhd_detach(&dhd->pub);
+
+	return NULL;
+}
+
+int dhd_bus_start(dhd_pub_t *dhdp)
+{
+	int ret = -1;
+	dhd_info_t *dhd = (dhd_info_t *) dhdp->info;
+#ifdef EMBEDDED_PLATFORM
+	char iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
+						 '\0' + bitvec  */
+#endif				/* EMBEDDED_PLATFORM */
+
+	ASSERT(dhd);
+
+	DHD_TRACE(("%s:\n", __func__));
+
+	/* try to download image and nvram to the dongle */
+	if (dhd->pub.busstate == DHD_BUS_DOWN) {
+		WAKE_LOCK_INIT(dhdp, WAKE_LOCK_DOWNLOAD, "dhd_bus_start");
+		WAKE_LOCK(dhdp, WAKE_LOCK_DOWNLOAD);
+		if (!(dhd_bus_download_firmware(dhd->pub.bus, dhd->pub.osh,
+						fw_path, nv_path))) {
+			DHD_ERROR(("%s: dhdsdio_probe_download failed. "
+				"firmware = %s nvram = %s\n",
+				__func__, fw_path, nv_path));
+			WAKE_UNLOCK(dhdp, WAKE_LOCK_DOWNLOAD);
+			WAKE_LOCK_DESTROY(dhdp, WAKE_LOCK_DOWNLOAD);
+			return -1;
+		}
+
+		WAKE_UNLOCK(dhdp, WAKE_LOCK_DOWNLOAD);
+		WAKE_LOCK_DESTROY(dhdp, WAKE_LOCK_DOWNLOAD);
+	}
+
+	/* Start the watchdog timer */
+	dhd->pub.tickcnt = 0;
+	dhd_os_wd_timer(&dhd->pub, dhd_watchdog_ms);
+
+	/* Bring up the bus */
+	ret = dhd_bus_init(&dhd->pub, true);
+	if (ret != 0) {
+		DHD_ERROR(("%s, dhd_bus_init failed %d\n", __func__, ret));
+		return ret;
+	}
+#if defined(OOB_INTR_ONLY)
+	/* Host registration for OOB interrupt */
+	if (bcmsdh_register_oob_intr(dhdp)) {
+		del_timer_sync(&dhd->timer);
+		dhd->wd_timer_valid = false;
+		DHD_ERROR(("%s Host failed to resgister for OOB\n", __func__));
+		return -ENODEV;
+	}
+
+	/* Enable oob at firmware */
+	dhd_enable_oob_intr(dhd->pub.bus, true);
+#endif				/* defined(OOB_INTR_ONLY) */
+
+	/* If bus is not ready, can't come up */
+	if (dhd->pub.busstate != DHD_BUS_DATA) {
+		del_timer_sync(&dhd->timer);
+		dhd->wd_timer_valid = false;
+		DHD_ERROR(("%s failed bus is not ready\n", __func__));
+		return -ENODEV;
+	}
+#ifdef EMBEDDED_PLATFORM
+	bcm_mkiovar("event_msgs", dhdp->eventmask, WL_EVENTING_MASK_LEN, iovbuf,
+		    sizeof(iovbuf));
+	dhdcdc_query_ioctl(dhdp, 0, WLC_GET_VAR, iovbuf, sizeof(iovbuf));
+	bcopy(iovbuf, dhdp->eventmask, WL_EVENTING_MASK_LEN);
+
+	setbit(dhdp->eventmask, WLC_E_SET_SSID);
+	setbit(dhdp->eventmask, WLC_E_PRUNE);
+	setbit(dhdp->eventmask, WLC_E_AUTH);
+	setbit(dhdp->eventmask, WLC_E_REASSOC);
+	setbit(dhdp->eventmask, WLC_E_REASSOC_IND);
+	setbit(dhdp->eventmask, WLC_E_DEAUTH_IND);
+	setbit(dhdp->eventmask, WLC_E_DISASSOC_IND);
+	setbit(dhdp->eventmask, WLC_E_DISASSOC);
+	setbit(dhdp->eventmask, WLC_E_JOIN);
+	setbit(dhdp->eventmask, WLC_E_ASSOC_IND);
+	setbit(dhdp->eventmask, WLC_E_PSK_SUP);
+	setbit(dhdp->eventmask, WLC_E_LINK);
+	setbit(dhdp->eventmask, WLC_E_NDIS_LINK);
+	setbit(dhdp->eventmask, WLC_E_MIC_ERROR);
+	setbit(dhdp->eventmask, WLC_E_PMKID_CACHE);
+	setbit(dhdp->eventmask, WLC_E_TXFAIL);
+	setbit(dhdp->eventmask, WLC_E_JOIN_START);
+	setbit(dhdp->eventmask, WLC_E_SCAN_COMPLETE);
+#ifdef PNO_SUPPORT
+	setbit(dhdp->eventmask, WLC_E_PFN_NET_FOUND);
+#endif				/* PNO_SUPPORT */
+
+/* enable dongle roaming event */
+
+	dhdp->pktfilter_count = 1;
+	/* Setup filter to allow only unicast */
+	dhdp->pktfilter[0] = "100 0 0 0 0x01 0x00";
+#endif				/* EMBEDDED_PLATFORM */
+
+	/* Bus is ready, do any protocol initialization */
+	ret = dhd_prot_init(&dhd->pub);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+int
+dhd_iovar(dhd_pub_t *pub, int ifidx, char *name, char *cmd_buf, uint cmd_len,
+	  int set)
+{
+	char buf[strlen(name) + 1 + cmd_len];
+	int len = sizeof(buf);
+	wl_ioctl_t ioc;
+	int ret;
+
+	len = bcm_mkiovar(name, cmd_buf, cmd_len, buf, len);
+
+	memset(&ioc, 0, sizeof(ioc));
+
+	ioc.cmd = set ? WLC_SET_VAR : WLC_GET_VAR;
+	ioc.buf = buf;
+	ioc.len = len;
+	ioc.set = set;
+
+	ret = dhd_prot_ioctl(pub, ifidx, &ioc, ioc.buf, ioc.len);
+	if (!set && ret >= 0)
+		memcpy(cmd_buf, buf, cmd_len);
+
+	return ret;
+}
+
+static struct net_device_ops dhd_ops_pri = {
+	.ndo_open = dhd_open,
+	.ndo_stop = dhd_stop,
+	.ndo_get_stats = dhd_get_stats,
+	.ndo_do_ioctl = dhd_ioctl_entry,
+	.ndo_start_xmit = dhd_start_xmit,
+	.ndo_set_mac_address = dhd_set_mac_address,
+	.ndo_set_multicast_list = dhd_set_multicast_list
+};
+
+static struct net_device_ops dhd_ops_virt = {
+	.ndo_get_stats = dhd_get_stats,
+	.ndo_do_ioctl = dhd_ioctl_entry,
+	.ndo_start_xmit = dhd_start_xmit,
+	.ndo_set_mac_address = dhd_set_mac_address,
+	.ndo_set_multicast_list = dhd_set_multicast_list
+};
+
+int dhd_net_attach(dhd_pub_t *dhdp, int ifidx)
+{
+	dhd_info_t *dhd = (dhd_info_t *) dhdp->info;
+	struct net_device *net;
+	u8 temp_addr[ETHER_ADDR_LEN] = {
+		0x00, 0x90, 0x4c, 0x11, 0x22, 0x33};
+
+	DHD_TRACE(("%s: ifidx %d\n", __func__, ifidx));
+
+	ASSERT(dhd && dhd->iflist[ifidx]);
+
+	net = dhd->iflist[ifidx]->net;
+	ASSERT(net);
+
+	ASSERT(!net->netdev_ops);
+	net->netdev_ops = &dhd_ops_virt;
+
+	net->netdev_ops = &dhd_ops_pri;
+
+	/*
+	 * We have to use the primary MAC for virtual interfaces
+	 */
+	if (ifidx != 0) {
+		/* for virtual interfaces use the primary MAC  */
+		memcpy(temp_addr, dhd->pub.mac.octet, ETHER_ADDR_LEN);
+
+	}
+
+	if (ifidx == 1) {
+		DHD_TRACE(("%s ACCESS POINT MAC: \n", __func__));
+		/*  ACCESSPOINT INTERFACE CASE */
+		temp_addr[0] |= 0X02;	/* set bit 2 ,
+			 - Locally Administered address  */
+
+	}
+	net->hard_header_len = ETH_HLEN + dhd->pub.hdrlen;
+	net->ethtool_ops = &dhd_ethtool_ops;
+
+#if defined(CONFIG_WIRELESS_EXT)
+	if (!IS_CFG80211_FAVORITE()) {
+#if WIRELESS_EXT < 19
+		net->get_wireless_stats = dhd_get_wireless_stats;
+#endif				/* WIRELESS_EXT < 19 */
+#if WIRELESS_EXT > 12
+		net->wireless_handlers =
+		    (struct iw_handler_def *)&wl_iw_handler_def;
+#endif				/* WIRELESS_EXT > 12 */
+	}
+#endif				/* defined(CONFIG_WIRELESS_EXT) */
+
+	dhd->pub.rxsz = net->mtu + net->hard_header_len + dhd->pub.hdrlen;
+
+	memcpy(net->dev_addr, temp_addr, ETHER_ADDR_LEN);
+
+	if (register_netdev(net) != 0) {
+		DHD_ERROR(("%s: couldn't register the net device\n",
+			__func__));
+		goto fail;
+	}
+
+	printf("%s: Broadcom Dongle Host Driver\n", net->name);
+
+	return 0;
+
+fail:
+	net->netdev_ops = NULL;
+	return BCME_ERROR;
+}
+
+void dhd_bus_detach(dhd_pub_t *dhdp)
+{
+	dhd_info_t *dhd;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	if (dhdp) {
+		dhd = (dhd_info_t *) dhdp->info;
+		if (dhd) {
+			/* Stop the protocol module */
+			dhd_prot_stop(&dhd->pub);
+
+			/* Stop the bus module */
+			dhd_bus_stop(dhd->pub.bus, true);
+#if defined(OOB_INTR_ONLY)
+			bcmsdh_unregister_oob_intr();
+#endif				/* defined(OOB_INTR_ONLY) */
+
+			/* Clear the watchdog timer */
+			del_timer_sync(&dhd->timer);
+			dhd->wd_timer_valid = false;
+		}
+	}
+}
+
+void dhd_detach(dhd_pub_t *dhdp)
+{
+	dhd_info_t *dhd;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	if (dhdp) {
+		dhd = (dhd_info_t *) dhdp->info;
+		if (dhd) {
+			dhd_if_t *ifp;
+			int i;
+
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+			if (dhd->early_suspend.suspend)
+				unregister_early_suspend(&dhd->early_suspend);
+#endif				/* defined(CONFIG_HAS_EARLYSUSPEND) */
+
+			for (i = 1; i < DHD_MAX_IFS; i++)
+				if (dhd->iflist[i])
+					dhd_del_if(dhd, i);
+
+			ifp = dhd->iflist[0];
+			ASSERT(ifp);
+			if (ifp->net->netdev_ops == &dhd_ops_pri) {
+				dhd_stop(ifp->net);
+				unregister_netdev(ifp->net);
+			}
+
+			if (dhd->watchdog_tsk) {
+				send_sig(SIGTERM, dhd->watchdog_tsk, 1);
+				kthread_stop(dhd->watchdog_tsk);
+				dhd->watchdog_tsk = NULL;
+			}
+
+			if (dhd->dpc_tsk) {
+				send_sig(SIGTERM, dhd->dpc_tsk, 1);
+				kthread_stop(dhd->dpc_tsk);
+				dhd->dpc_tsk = NULL;
+			} else
+				tasklet_kill(&dhd->tasklet);
+
+			if (dhd->sysioc_tsk) {
+				send_sig(SIGTERM, dhd->sysioc_tsk, 1);
+				kthread_stop(dhd->sysioc_tsk);
+				dhd->sysioc_tsk = NULL;
+			}
+
+			dhd_bus_detach(dhdp);
+
+			if (dhdp->prot)
+				dhd_prot_detach(dhdp);
+
+#if defined(CONFIG_WIRELESS_EXT)
+			wl_iw_detach();
+#endif				/* (CONFIG_WIRELESS_EXT) */
+
+			if (IS_CFG80211_FAVORITE())
+				wl_cfg80211_detach();
+
+#if defined(CONFIG_PM_SLEEP)
+			unregister_pm_notifier(&dhd_sleep_pm_notifier);
+#endif	/* defined(CONFIG_PM_SLEEP) */
+			/* && defined(DHD_GPL) */
+			WAKE_LOCK_DESTROY(dhdp, WAKE_LOCK_TMOUT);
+			WAKE_LOCK_DESTROY(dhdp, WAKE_LOCK_LINK_DOWN_TMOUT);
+			WAKE_LOCK_DESTROY(dhdp, WAKE_LOCK_PNO_FIND_TMOUT);
+			free_netdev(ifp->net);
+			kfree(ifp);
+			kfree(dhd);
+		}
+	}
+}
+
+static void __exit dhd_module_cleanup(void)
+{
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	dhd_bus_unregister();
+#if defined(CUSTOMER_HW2) && defined(CONFIG_WIFI_CONTROL_FUNC)
+	wifi_del_dev();
+#endif
+	/* Call customer gpio to turn off power with WL_REG_ON signal */
+	dhd_customer_gpio_wlan_ctrl(WLAN_POWER_OFF);
+}
+
+static int __init dhd_module_init(void)
+{
+	int error;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	/* Sanity check on the module parameters */
+	do {
+		/* Both watchdog and DPC as tasklets are ok */
+		if ((dhd_watchdog_prio < 0) && (dhd_dpc_prio < 0))
+			break;
+
+		/* If both watchdog and DPC are threads, TX must be deferred */
+		if ((dhd_watchdog_prio >= 0) && (dhd_dpc_prio >= 0)
+		    && dhd_deferred_tx)
+			break;
+
+		DHD_ERROR(("Invalid module parameters.\n"));
+		return -EINVAL;
+	} while (0);
+	/* Call customer gpio to turn on power with WL_REG_ON signal */
+	dhd_customer_gpio_wlan_ctrl(WLAN_POWER_ON);
+
+#if defined(CUSTOMER_HW2) && defined(CONFIG_WIFI_CONTROL_FUNC)
+	sema_init(&wifi_control_sem, 0);
+
+	error = wifi_add_dev();
+	if (error) {
+		DHD_ERROR(("%s: platform_driver_register failed\n", __func__));
+		goto faild;
+	}
+
+	/* Waiting callback after platform_driver_register is done or
+		 exit with error */
+	if (down_timeout(&wifi_control_sem, msecs_to_jiffies(1000)) != 0) {
+		printk(KERN_ERR "%s: platform_driver_register timeout\n",
+			__func__);
+		/* remove device */
+		wifi_del_dev();
+		goto faild;
+	}
+#endif	/* #if defined(CUSTOMER_HW2) && defined(CONFIG_WIFI_CONTROL_FUNC) */
+
+	error = dhd_bus_register();
+
+	if (!error)
+		printf("\n%s\n", dhd_version);
+	else {
+		DHD_ERROR(("%s: sdio_register_driver failed\n", __func__));
+		goto faild;
+	}
+	return error;
+
+faild:
+	/* turn off power and exit */
+	dhd_customer_gpio_wlan_ctrl(WLAN_POWER_OFF);
+	return -EINVAL;
+}
+
+module_init(dhd_module_init);
+module_exit(dhd_module_cleanup);
+
+/*
+ * OS specific functions required to implement DHD driver in OS independent way
+ */
+int dhd_os_proto_block(dhd_pub_t *pub)
+{
+	dhd_info_t *dhd = (dhd_info_t *) (pub->info);
+
+	if (dhd) {
+		down(&dhd->proto_sem);
+		return 1;
+	}
+	return 0;
+}
+
+int dhd_os_proto_unblock(dhd_pub_t *pub)
+{
+	dhd_info_t *dhd = (dhd_info_t *) (pub->info);
+
+	if (dhd) {
+		up(&dhd->proto_sem);
+		return 1;
+	}
+
+	return 0;
+}
+
+unsigned int dhd_os_get_ioctl_resp_timeout(void)
+{
+	return (unsigned int)dhd_ioctl_timeout_msec;
+}
+
+void dhd_os_set_ioctl_resp_timeout(unsigned int timeout_msec)
+{
+	dhd_ioctl_timeout_msec = (int)timeout_msec;
+}
+
+int dhd_os_ioctl_resp_wait(dhd_pub_t *pub, uint *condition, bool *pending)
+{
+	dhd_info_t *dhd = (dhd_info_t *) (pub->info);
+	DECLARE_WAITQUEUE(wait, current);
+	int timeout = dhd_ioctl_timeout_msec;
+
+	/* Convert timeout in millsecond to jiffies */
+	timeout = timeout * HZ / 1000;
+
+	/* Wait until control frame is available */
+	add_wait_queue(&dhd->ioctl_resp_wait, &wait);
+	set_current_state(TASK_INTERRUPTIBLE);
+
+	while (!(*condition) && (!signal_pending(current) && timeout))
+		timeout = schedule_timeout(timeout);
+
+	if (signal_pending(current))
+		*pending = true;
+
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&dhd->ioctl_resp_wait, &wait);
+
+	return timeout;
+}
+
+int dhd_os_ioctl_resp_wake(dhd_pub_t *pub)
+{
+	dhd_info_t *dhd = (dhd_info_t *) (pub->info);
+
+	if (waitqueue_active(&dhd->ioctl_resp_wait))
+		wake_up_interruptible(&dhd->ioctl_resp_wait);
+
+	return 0;
+}
+
+void dhd_os_wd_timer(void *bus, uint wdtick)
+{
+	dhd_pub_t *pub = bus;
+	static uint save_dhd_watchdog_ms;
+	dhd_info_t *dhd = (dhd_info_t *) pub->info;
+
+	/* don't start the wd until fw is loaded */
+	if (pub->busstate == DHD_BUS_DOWN)
+		return;
+
+	/* Totally stop the timer */
+	if (!wdtick && dhd->wd_timer_valid == true) {
+		del_timer_sync(&dhd->timer);
+		dhd->wd_timer_valid = false;
+		save_dhd_watchdog_ms = wdtick;
+		return;
+	}
+
+	if (wdtick) {
+		dhd_watchdog_ms = (uint) wdtick;
+
+		if (save_dhd_watchdog_ms != dhd_watchdog_ms) {
+
+			if (dhd->wd_timer_valid == true)
+				/* Stop timer and restart at new value */
+				del_timer_sync(&dhd->timer);
+
+			/* Create timer again when watchdog period is
+			   dynamically changed or in the first instance
+			 */
+			dhd->timer.expires =
+			    jiffies + dhd_watchdog_ms * HZ / 1000;
+			add_timer(&dhd->timer);
+
+		} else {
+			/* Re arm the timer, at last watchdog period */
+			mod_timer(&dhd->timer,
+				  jiffies + dhd_watchdog_ms * HZ / 1000);
+		}
+
+		dhd->wd_timer_valid = true;
+		save_dhd_watchdog_ms = wdtick;
+	}
+}
+
+void *dhd_os_open_image(char *filename)
+{
+	struct file *fp;
+
+	if (IS_CFG80211_FAVORITE() && !NO_FW_REQ())
+		return wl_cfg80211_request_fw(filename);
+
+	fp = filp_open(filename, O_RDONLY, 0);
+	/*
+	 * 2.6.11 (FC4) supports filp_open() but later revs don't?
+	 * Alternative:
+	 * fp = open_namei(AT_FDCWD, filename, O_RD, 0);
+	 * ???
+	 */
+	if (IS_ERR(fp))
+		fp = NULL;
+
+	return fp;
+}
+
+int dhd_os_get_image_block(char *buf, int len, void *image)
+{
+	struct file *fp = (struct file *)image;
+	int rdlen;
+
+	if (IS_CFG80211_FAVORITE() && !NO_FW_REQ())
+		return wl_cfg80211_read_fw(buf, len);
+
+	if (!image)
+		return 0;
+
+	rdlen = kernel_read(fp, fp->f_pos, buf, len);
+	if (rdlen > 0)
+		fp->f_pos += rdlen;
+
+	return rdlen;
+}
+
+void dhd_os_close_image(void *image)
+{
+	if (IS_CFG80211_FAVORITE() && !NO_FW_REQ())
+		return wl_cfg80211_release_fw();
+	if (image)
+		filp_close((struct file *)image, NULL);
+}
+
+void dhd_os_sdlock(dhd_pub_t *pub)
+{
+	dhd_info_t *dhd;
+
+	dhd = (dhd_info_t *) (pub->info);
+
+	if (dhd->threads_only)
+		down(&dhd->sdsem);
+	else
+		spin_lock_bh(&dhd->sdlock);
+}
+
+void dhd_os_sdunlock(dhd_pub_t *pub)
+{
+	dhd_info_t *dhd;
+
+	dhd = (dhd_info_t *) (pub->info);
+
+	if (dhd->threads_only)
+		up(&dhd->sdsem);
+	else
+		spin_unlock_bh(&dhd->sdlock);
+}
+
+void dhd_os_sdlock_txq(dhd_pub_t *pub)
+{
+	dhd_info_t *dhd;
+
+	dhd = (dhd_info_t *) (pub->info);
+	spin_lock_bh(&dhd->txqlock);
+}
+
+void dhd_os_sdunlock_txq(dhd_pub_t *pub)
+{
+	dhd_info_t *dhd;
+
+	dhd = (dhd_info_t *) (pub->info);
+	spin_unlock_bh(&dhd->txqlock);
+}
+
+void dhd_os_sdlock_rxq(dhd_pub_t *pub)
+{
+}
+
+void dhd_os_sdunlock_rxq(dhd_pub_t *pub)
+{
+}
+
+void dhd_os_sdtxlock(dhd_pub_t *pub)
+{
+	dhd_os_sdlock(pub);
+}
+
+void dhd_os_sdtxunlock(dhd_pub_t *pub)
+{
+	dhd_os_sdunlock(pub);
+}
+
+#if defined(CONFIG_WIRELESS_EXT)
+struct iw_statistics *dhd_get_wireless_stats(struct net_device *dev)
+{
+	int res = 0;
+	dhd_info_t *dhd = *(dhd_info_t **) netdev_priv(dev);
+
+	res = wl_iw_get_wireless_stats(dev, &dhd->iw.wstats);
+
+	if (res == 0)
+		return &dhd->iw.wstats;
+	else
+		return NULL;
+}
+#endif	/* defined(CONFIG_WIRELESS_EXT) */
+
+static int
+dhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata,
+		  wl_event_msg_t *event, void **data)
+{
+	int bcmerror = 0;
+
+	ASSERT(dhd != NULL);
+
+	bcmerror = wl_host_event(dhd, ifidx, pktdata, event, data);
+	if (bcmerror != BCME_OK)
+		return bcmerror;
+
+#if defined(CONFIG_WIRELESS_EXT)
+	if (!IS_CFG80211_FAVORITE()) {
+		if ((dhd->iflist[*ifidx] == NULL)
+		    || (dhd->iflist[*ifidx]->net == NULL)) {
+			DHD_ERROR(("%s Exit null pointer\n", __func__));
+			return bcmerror;
+		}
+
+		if (dhd->iflist[*ifidx]->net)
+			wl_iw_event(dhd->iflist[*ifidx]->net, event, *data);
+	}
+#endif				/* defined(CONFIG_WIRELESS_EXT)  */
+
+	if (IS_CFG80211_FAVORITE()) {
+		ASSERT(dhd->iflist[*ifidx] != NULL);
+		ASSERT(dhd->iflist[*ifidx]->net != NULL);
+		if (dhd->iflist[*ifidx]->net)
+			wl_cfg80211_event(dhd->iflist[*ifidx]->net, event,
+					  *data);
+	}
+
+	return bcmerror;
+}
+
+/* send up locally generated event */
+void dhd_sendup_event(dhd_pub_t *dhdp, wl_event_msg_t *event, void *data)
+{
+	switch (ntoh32(event->event_type)) {
+	default:
+		break;
+	}
+}
+
+void dhd_wait_for_event(dhd_pub_t *dhd, bool *lockvar)
+{
+	struct dhd_info *dhdinfo = dhd->info;
+	dhd_os_sdunlock(dhd);
+	wait_event_interruptible_timeout(dhdinfo->ctrl_wait,
+					 (*lockvar == false), HZ * 2);
+	dhd_os_sdlock(dhd);
+	return;
+}
+
+void dhd_wait_event_wakeup(dhd_pub_t *dhd)
+{
+	struct dhd_info *dhdinfo = dhd->info;
+	if (waitqueue_active(&dhdinfo->ctrl_wait))
+		wake_up_interruptible(&dhdinfo->ctrl_wait);
+	return;
+}
+
+int dhd_dev_reset(struct net_device *dev, u8 flag)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+
+	/* Turning off watchdog */
+	if (flag)
+		dhd_os_wd_timer(&dhd->pub, 0);
+
+	dhd_bus_devreset(&dhd->pub, flag);
+
+	/* Turning on watchdog back */
+	if (!flag)
+		dhd_os_wd_timer(&dhd->pub, dhd_watchdog_ms);
+	DHD_ERROR(("%s:  WLAN OFF DONE\n", __func__));
+
+	return 1;
+}
+
+int net_os_set_suspend_disable(struct net_device *dev, int val)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+	int ret = 0;
+
+	if (dhd) {
+		ret = dhd->pub.suspend_disable_flag;
+		dhd->pub.suspend_disable_flag = val;
+	}
+	return ret;
+}
+
+int net_os_set_suspend(struct net_device *dev, int val)
+{
+	int ret = 0;
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+
+	if (dhd) {
+		dhd_os_proto_block(&dhd->pub);
+		ret = dhd_set_suspend(val, &dhd->pub);
+		dhd_os_proto_unblock(&dhd->pub);
+	}
+#endif		/* defined(CONFIG_HAS_EARLYSUSPEND) */
+	return ret;
+}
+
+int net_os_set_dtim_skip(struct net_device *dev, int val)
+{
+	dhd_info_t *dhd = *(dhd_info_t **) netdev_priv(dev);
+
+	if (dhd)
+		dhd->pub.dtim_skip = val;
+
+	return 0;
+}
+
+int net_os_set_packet_filter(struct net_device *dev, int val)
+{
+	dhd_info_t *dhd = *(dhd_info_t **) netdev_priv(dev);
+	int ret = 0;
+
+	/* Packet filtering is set only if we still in early-suspend and
+	 * we need either to turn it ON or turn it OFF
+	 * We can always turn it OFF in case of early-suspend, but we turn it
+	 * back ON only if suspend_disable_flag was not set
+	 */
+	if (dhd && dhd->pub.up) {
+		dhd_os_proto_block(&dhd->pub);
+		if (dhd->pub.in_suspend) {
+			if (!val || (val && !dhd->pub.suspend_disable_flag))
+				dhd_set_packet_filter(val, &dhd->pub);
+		}
+		dhd_os_proto_unblock(&dhd->pub);
+	}
+	return ret;
+}
+
+void dhd_dev_init_ioctl(struct net_device *dev)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+
+	dhd_preinit_ioctls(&dhd->pub);
+}
+
+#ifdef PNO_SUPPORT
+/* Linux wrapper to call common dhd_pno_clean */
+int dhd_dev_pno_reset(struct net_device *dev)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+
+	return dhd_pno_clean(&dhd->pub);
+}
+
+/* Linux wrapper to call common dhd_pno_enable */
+int dhd_dev_pno_enable(struct net_device *dev, int pfn_enabled)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+
+	return dhd_pno_enable(&dhd->pub, pfn_enabled);
+}
+
+/* Linux wrapper to call common dhd_pno_set */
+int
+dhd_dev_pno_set(struct net_device *dev, wlc_ssid_t *ssids_local, int nssid,
+		unsigned char scan_fr)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+
+	return dhd_pno_set(&dhd->pub, ssids_local, nssid, scan_fr);
+}
+
+/* Linux wrapper to get  pno status */
+int dhd_dev_get_pno_status(struct net_device *dev)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+
+	return dhd_pno_get_status(&dhd->pub);
+}
+
+#endif				/* PNO_SUPPORT */
+
+static int dhd_get_pend_8021x_cnt(dhd_info_t *dhd)
+{
+	return atomic_read(&dhd->pend_8021x_cnt);
+}
+
+#define MAX_WAIT_FOR_8021X_TX	10
+
+int dhd_wait_pend8021x(struct net_device *dev)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+	int timeout = 10 * HZ / 1000;
+	int ntimes = MAX_WAIT_FOR_8021X_TX;
+	int pend = dhd_get_pend_8021x_cnt(dhd);
+
+	while (ntimes && pend) {
+		if (pend) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(timeout);
+			set_current_state(TASK_RUNNING);
+			ntimes--;
+		}
+		pend = dhd_get_pend_8021x_cnt(dhd);
+	}
+	return pend;
+}
+
+#ifdef DHD_DEBUG
+int write_to_file(dhd_pub_t *dhd, u8 *buf, int size)
+{
+	int ret = 0;
+	struct file *fp;
+	mm_segment_t old_fs;
+	loff_t pos = 0;
+
+	/* change to KERNEL_DS address limit */
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	/* open file to write */
+	fp = filp_open("/tmp/mem_dump", O_WRONLY | O_CREAT, 0640);
+	if (!fp) {
+		printf("%s: open file error\n", __func__);
+		ret = -1;
+		goto exit;
+	}
+
+	/* Write buf to file */
+	fp->f_op->write(fp, buf, size, &pos);
+
+exit:
+	/* free buf before return */
+	kfree(buf);
+	/* close file before return */
+	if (fp)
+		filp_close(fp, current->files);
+	/* restore previous address limit */
+	set_fs(old_fs);
+
+	return ret;
+}
+#endif				/* DHD_DEBUG */
diff --git a/drivers/staging/brcm80211/brcmfmac/dhd_linux_sched.c b/drivers/staging/brcm80211/brcmfmac/dhd_linux_sched.c
new file mode 100644
index 0000000..bf8df98
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_linux_sched.c
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linuxver.h>
+
+int setScheduler(struct task_struct *p, int policy, struct sched_param *param)
+{
+	int rc = 0;
+	rc = sched_setscheduler(p, policy, param);
+	return rc;
+}
diff --git a/drivers/staging/brcm80211/brcmfmac/dhd_proto.h b/drivers/staging/brcm80211/brcmfmac/dhd_proto.h
new file mode 100644
index 0000000..cc42fa4
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_proto.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _dhd_proto_h_
+#define _dhd_proto_h_
+
+#include <dhdioctl.h>
+#include <wlioctl.h>
+
+#ifndef IOCTL_RESP_TIMEOUT
+#define IOCTL_RESP_TIMEOUT  2000	/* In milli second */
+#endif
+
+#ifndef IOCTL_CHIP_ACTIVE_TIMEOUT
+#define IOCTL_CHIP_ACTIVE_TIMEOUT  10	/* In milli second */
+#endif
+
+/*
+ * Exported from the dhd protocol module (dhd_cdc, dhd_rndis)
+ */
+
+/* Linkage, sets prot link and updates hdrlen in pub */
+extern int dhd_prot_attach(dhd_pub_t *dhdp);
+
+/* Unlink, frees allocated protocol memory (including dhd_prot) */
+extern void dhd_prot_detach(dhd_pub_t *dhdp);
+
+/* Initialize protocol: sync w/dongle state.
+ * Sets dongle media info (iswl, drv_version, mac address).
+ */
+extern int dhd_prot_init(dhd_pub_t *dhdp);
+
+/* Stop protocol: sync w/dongle state. */
+extern void dhd_prot_stop(dhd_pub_t *dhdp);
+
+extern bool dhd_proto_fcinfo(dhd_pub_t *dhd, void *pktbuf, u8 *fcbits);
+
+/* Add any protocol-specific data header.
+ * Caller must reserve prot_hdrlen prepend space.
+ */
+extern void dhd_prot_hdrpush(dhd_pub_t *, int ifidx, void *txp);
+
+/* Remove any protocol-specific data header. */
+extern int dhd_prot_hdrpull(dhd_pub_t *, int *ifidx, void *rxp);
+
+/* Use protocol to issue ioctl to dongle */
+extern int dhd_prot_ioctl(dhd_pub_t *dhd, int ifidx, wl_ioctl_t *ioc,
+			  void *buf, int len);
+
+/* Check for and handle local prot-specific iovar commands */
+extern int dhd_prot_iovar_op(dhd_pub_t *dhdp, const char *name,
+			     void *params, int plen, void *arg, int len,
+			     bool set);
+
+/* Add prot dump output to a buffer */
+extern void dhd_prot_dump(dhd_pub_t *dhdp, struct bcmstrbuf *strbuf);
+
+/* Update local copy of dongle statistics */
+extern void dhd_prot_dstats(dhd_pub_t *dhdp);
+
+extern int dhd_ioctl(dhd_pub_t *dhd_pub, dhd_ioctl_t *ioc, void *buf,
+		     uint buflen);
+
+extern int dhd_preinit_ioctls(dhd_pub_t *dhd);
+
+/********************************
+ * For version-string expansion *
+ */
+#if defined(BDC)
+#define DHD_PROTOCOL "bdc"
+#elif defined(CDC)
+#define DHD_PROTOCOL "cdc"
+#elif defined(RNDIS)
+#define DHD_PROTOCOL "rndis"
+#else
+#define DHD_PROTOCOL "unknown"
+#endif				/* proto */
+
+#endif				/* _dhd_proto_h_ */
diff --git a/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c b/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
new file mode 100644
index 0000000..b2281d9
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
@@ -0,0 +1,6103 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/types.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmsdh.h>
+
+#ifdef BCMEMBEDIMAGE
+#include BCMEMBEDIMAGE
+#endif				/* BCMEMBEDIMAGE */
+
+#include <bcmdefs.h>
+#include <bcmutils.h>
+#include <bcmendian.h>
+#include <bcmdevs.h>
+
+#include <siutils.h>
+#include <hndpmu.h>
+#include <hndsoc.h>
+#ifdef DHD_DEBUG
+#include <hndrte_armtrap.h>
+#include <hndrte_cons.h>
+#endif				/* DHD_DEBUG */
+#include <sbchipc.h>
+#include <sbhnddma.h>
+
+#include <sdio.h>
+#include <sbsdio.h>
+#include <sbsdpcmdev.h>
+#include <bcmsdpcm.h>
+
+#include <proto/ethernet.h>
+#include <proto/802.1d.h>
+#include <proto/802.11.h>
+
+#include <dngl_stats.h>
+#include <dhd.h>
+#include <dhd_bus.h>
+#include <dhd_proto.h>
+#include <dhd_dbg.h>
+#include <dhdioctl.h>
+#include <sdiovar.h>
+#include <siutils_priv.h>
+
+#ifndef DHDSDIO_MEM_DUMP_FNAME
+#define DHDSDIO_MEM_DUMP_FNAME         "mem_dump"
+#endif
+
+#define QLEN		256	/* bulk rx and tx queue lengths */
+#define FCHI		(QLEN - 10)
+#define FCLOW		(FCHI / 2)
+#define PRIOMASK	7
+
+#define TXRETRIES	2	/* # of retries for tx frames */
+
+#if defined(CONFIG_MACH_SANDGATE2G)
+#define DHD_RXBOUND	250	/* Default for max rx frames in
+				 one scheduling */
+#else
+#define DHD_RXBOUND	50	/* Default for max rx frames in
+				 one scheduling */
+#endif				/* defined(CONFIG_MACH_SANDGATE2G) */
+
+#define DHD_TXBOUND	20	/* Default for max tx frames in
+				 one scheduling */
+
+#define DHD_TXMINMAX	1	/* Max tx frames if rx still pending */
+
+#define MEMBLOCK	2048	/* Block size used for downloading
+				 of dongle image */
+#define MAX_DATA_BUF	(32 * 1024)	/* Must be large enough to hold
+				 biggest possible glom */
+
+/* Packet alignment for most efficient SDIO (can change based on platform) */
+#ifndef DHD_SDALIGN
+#define DHD_SDALIGN	32
+#endif
+#if !ISPOWEROF2(DHD_SDALIGN)
+#error DHD_SDALIGN is not a power of 2!
+#endif
+
+#ifndef DHD_FIRSTREAD
+#define DHD_FIRSTREAD	32
+#endif
+#if !ISPOWEROF2(DHD_FIRSTREAD)
+#error DHD_FIRSTREAD is not a power of 2!
+#endif
+
+/* Total length of frame header for dongle protocol */
+#define SDPCM_HDRLEN	(SDPCM_FRAMETAG_LEN + SDPCM_SWHEADER_LEN)
+#ifdef SDTEST
+#define SDPCM_RESERVE	(SDPCM_HDRLEN + SDPCM_TEST_HDRLEN + DHD_SDALIGN)
+#else
+#define SDPCM_RESERVE	(SDPCM_HDRLEN + DHD_SDALIGN)
+#endif
+
+/* Space for header read, limit for data packets */
+#ifndef MAX_HDR_READ
+#define MAX_HDR_READ	32
+#endif
+#if !ISPOWEROF2(MAX_HDR_READ)
+#error MAX_HDR_READ is not a power of 2!
+#endif
+
+#define MAX_RX_DATASZ	2048
+
+/* Maximum milliseconds to wait for F2 to come up */
+#define DHD_WAIT_F2RDY	3000
+
+/* Bump up limit on waiting for HT to account for first startup;
+ * if the image is doing a CRC calculation before programming the PMU
+ * for HT availability, it could take a couple hundred ms more, so
+ * max out at a 1 second (1000000us).
+ */
+#if (PMU_MAX_TRANSITION_DLY <= 1000000)
+#undef PMU_MAX_TRANSITION_DLY
+#define PMU_MAX_TRANSITION_DLY 1000000
+#endif
+
+/* Value for ChipClockCSR during initial setup */
+#define DHD_INIT_CLKCTL1	(SBSDIO_FORCE_HW_CLKREQ_OFF |	\
+					SBSDIO_ALP_AVAIL_REQ)
+#define DHD_INIT_CLKCTL2	(SBSDIO_FORCE_HW_CLKREQ_OFF | SBSDIO_FORCE_ALP)
+
+/* Flags for SDH calls */
+#define F2SYNC	(SDIO_REQ_4BYTE | SDIO_REQ_FIXED)
+
+/* Packet free applicable unconditionally for sdio and sdspi.  Conditional if
+ * bufpool was present for gspi bus.
+ */
+#define PKTFREE2()		if ((bus->bus != SPI_BUS) || bus->usebufpool) \
+					PKTFREE(bus->dhd->osh, pkt, false);
+DHD_SPINWAIT_SLEEP_INIT(sdioh_spinwait_sleep);
+extern int dhdcdc_set_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf,
+			    uint len);
+
+#ifdef DHD_DEBUG
+/* Device console log buffer state */
+typedef struct dhd_console {
+	uint count;		/* Poll interval msec counter */
+	uint log_addr;		/* Log struct address (fixed) */
+	hndrte_log_t log;	/* Log struct (host copy) */
+	uint bufsize;		/* Size of log buffer */
+	u8 *buf;		/* Log buffer (host copy) */
+	uint last;		/* Last buffer read index */
+} dhd_console_t;
+#endif				/* DHD_DEBUG */
+
+/* Private data for SDIO bus interaction */
+typedef struct dhd_bus {
+	dhd_pub_t *dhd;
+
+	bcmsdh_info_t *sdh;	/* Handle for BCMSDH calls */
+	si_t *sih;		/* Handle for SI calls */
+	char *vars;		/* Variables (from CIS and/or other) */
+	uint varsz;		/* Size of variables buffer */
+	u32 sbaddr;		/* Current SB window pointer (-1, invalid) */
+
+	sdpcmd_regs_t *regs;	/* Registers for SDIO core */
+	uint sdpcmrev;		/* SDIO core revision */
+	uint armrev;		/* CPU core revision */
+	uint ramrev;		/* SOCRAM core revision */
+	u32 ramsize;		/* Size of RAM in SOCRAM (bytes) */
+	u32 orig_ramsize;	/* Size of RAM in SOCRAM (bytes) */
+
+	u32 bus;		/* gSPI or SDIO bus */
+	u32 hostintmask;	/* Copy of Host Interrupt Mask */
+	u32 intstatus;	/* Intstatus bits (events) pending */
+	bool dpc_sched;		/* Indicates DPC schedule (intrpt rcvd) */
+	bool fcstate;		/* State of dongle flow-control */
+
+	u16 cl_devid;	/* cached devid for dhdsdio_probe_attach() */
+	char *fw_path;		/* module_param: path to firmware image */
+	char *nv_path;		/* module_param: path to nvram vars file */
+	const char *nvram_params;	/* user specified nvram params. */
+
+	uint blocksize;		/* Block size of SDIO transfers */
+	uint roundup;		/* Max roundup limit */
+
+	struct pktq txq;	/* Queue length used for flow-control */
+	u8 flowcontrol;	/* per prio flow control bitmask */
+	u8 tx_seq;		/* Transmit sequence number (next) */
+	u8 tx_max;		/* Maximum transmit sequence allowed */
+
+	u8 hdrbuf[MAX_HDR_READ + DHD_SDALIGN];
+	u8 *rxhdr;		/* Header of current rx frame (in hdrbuf) */
+	u16 nextlen;		/* Next Read Len from last header */
+	u8 rx_seq;		/* Receive sequence number (expected) */
+	bool rxskip;		/* Skip receive (awaiting NAK ACK) */
+
+	void *glomd;		/* Packet containing glomming descriptor */
+	void *glom;		/* Packet chain for glommed superframe */
+	uint glomerr;		/* Glom packet read errors */
+
+	u8 *rxbuf;		/* Buffer for receiving control packets */
+	uint rxblen;		/* Allocated length of rxbuf */
+	u8 *rxctl;		/* Aligned pointer into rxbuf */
+	u8 *databuf;		/* Buffer for receiving big glom packet */
+	u8 *dataptr;		/* Aligned pointer into databuf */
+	uint rxlen;		/* Length of valid data in buffer */
+
+	u8 sdpcm_ver;	/* Bus protocol reported by dongle */
+
+	bool intr;		/* Use interrupts */
+	bool poll;		/* Use polling */
+	bool ipend;		/* Device interrupt is pending */
+	bool intdis;		/* Interrupts disabled by isr */
+	uint intrcount;		/* Count of device interrupt callbacks */
+	uint lastintrs;		/* Count as of last watchdog timer */
+	uint spurious;		/* Count of spurious interrupts */
+	uint pollrate;		/* Ticks between device polls */
+	uint polltick;		/* Tick counter */
+	uint pollcnt;		/* Count of active polls */
+
+#ifdef DHD_DEBUG
+	dhd_console_t console;	/* Console output polling support */
+	uint console_addr;	/* Console address from shared struct */
+#endif				/* DHD_DEBUG */
+
+	uint regfails;		/* Count of R_REG/W_REG failures */
+
+	uint clkstate;		/* State of sd and backplane clock(s) */
+	bool activity;		/* Activity flag for clock down */
+	s32 idletime;		/* Control for activity timeout */
+	s32 idlecount;	/* Activity timeout counter */
+	s32 idleclock;	/* How to set bus driver when idle */
+	s32 sd_divisor;	/* Speed control to bus driver */
+	s32 sd_mode;		/* Mode control to bus driver */
+	s32 sd_rxchain;	/* If bcmsdh api accepts PKT chains */
+	bool use_rxchain;	/* If dhd should use PKT chains */
+	bool sleeping;		/* Is SDIO bus sleeping? */
+	bool rxflow_mode;	/* Rx flow control mode */
+	bool rxflow;		/* Is rx flow control on */
+	uint prev_rxlim_hit;	/* Is prev rx limit exceeded
+					 (per dpc schedule) */
+	bool alp_only;		/* Don't use HT clock (ALP only) */
+/* Field to decide if rx of control frames happen in rxbuf or lb-pool */
+	bool usebufpool;
+
+#ifdef SDTEST
+	/* external loopback */
+	bool ext_loop;
+	u8 loopid;
+
+	/* pktgen configuration */
+	uint pktgen_freq;	/* Ticks between bursts */
+	uint pktgen_count;	/* Packets to send each burst */
+	uint pktgen_print;	/* Bursts between count displays */
+	uint pktgen_total;	/* Stop after this many */
+	uint pktgen_minlen;	/* Minimum packet data len */
+	uint pktgen_maxlen;	/* Maximum packet data len */
+	uint pktgen_mode;	/* Configured mode: tx, rx, or echo */
+	uint pktgen_stop;	/* Number of tx failures causing stop */
+
+	/* active pktgen fields */
+	uint pktgen_tick;	/* Tick counter for bursts */
+	uint pktgen_ptick;	/* Burst counter for printing */
+	uint pktgen_sent;	/* Number of test packets generated */
+	uint pktgen_rcvd;	/* Number of test packets received */
+	uint pktgen_fail;	/* Number of failed send attempts */
+	u16 pktgen_len;	/* Length of next packet to send */
+#endif				/* SDTEST */
+
+	/* Some additional counters */
+	uint tx_sderrs;		/* Count of tx attempts with sd errors */
+	uint fcqueued;		/* Tx packets that got queued */
+	uint rxrtx;		/* Count of rtx requests (NAK to dongle) */
+	uint rx_toolong;	/* Receive frames too long to receive */
+	uint rxc_errors;	/* SDIO errors when reading control frames */
+	uint rx_hdrfail;	/* SDIO errors on header reads */
+	uint rx_badhdr;		/* Bad received headers (roosync?) */
+	uint rx_badseq;		/* Mismatched rx sequence number */
+	uint fc_rcvd;		/* Number of flow-control events received */
+	uint fc_xoff;		/* Number which turned on flow-control */
+	uint fc_xon;		/* Number which turned off flow-control */
+	uint rxglomfail;	/* Failed deglom attempts */
+	uint rxglomframes;	/* Number of glom frames (superframes) */
+	uint rxglompkts;	/* Number of packets from glom frames */
+	uint f2rxhdrs;		/* Number of header reads */
+	uint f2rxdata;		/* Number of frame data reads */
+	uint f2txdata;		/* Number of f2 frame writes */
+	uint f1regdata;		/* Number of f1 register accesses */
+
+	u8 *ctrl_frame_buf;
+	u32 ctrl_frame_len;
+	bool ctrl_frame_stat;
+} dhd_bus_t;
+
+/* clkstate */
+#define CLK_NONE	0
+#define CLK_SDONLY	1
+#define CLK_PENDING	2	/* Not used yet */
+#define CLK_AVAIL	3
+
+#define DHD_NOPMU(dhd)	(false)
+
+#ifdef DHD_DEBUG
+static int qcount[NUMPRIO];
+static int tx_packets[NUMPRIO];
+#endif				/* DHD_DEBUG */
+
+/* Deferred transmit */
+const uint dhd_deferred_tx = 1;
+
+extern uint dhd_watchdog_ms;
+extern void dhd_os_wd_timer(void *bus, uint wdtick);
+
+/* Tx/Rx bounds */
+uint dhd_txbound;
+uint dhd_rxbound;
+uint dhd_txminmax;
+
+/* override the RAM size if possible */
+#define DONGLE_MIN_MEMSIZE (128 * 1024)
+int dhd_dongle_memsize;
+
+static bool dhd_doflow;
+static bool dhd_alignctl;
+
+static bool sd1idle;
+
+static bool retrydata;
+#define RETRYCHAN(chan) (((chan) == SDPCM_EVENT_CHANNEL) || retrydata)
+
+static const uint watermark = 8;
+static const uint firstread = DHD_FIRSTREAD;
+
+#define HDATLEN (firstread - (SDPCM_HDRLEN))
+
+/* Retry count for register access failures */
+static const uint retry_limit = 2;
+
+/* Force even SD lengths (some host controllers mess up on odd bytes) */
+static bool forcealign;
+
+#define ALIGNMENT  4
+
+#if defined(OOB_INTR_ONLY) && defined(HW_OOB)
+extern void bcmsdh_enable_hw_oob_intr(void *sdh, bool enable);
+#endif
+
+#if defined(OOB_INTR_ONLY) && defined(SDIO_ISR_THREAD)
+#error OOB_INTR_ONLY is NOT working with SDIO_ISR_THREAD
+#endif	/* defined(OOB_INTR_ONLY) && defined(SDIO_ISR_THREAD) */
+#define PKTALIGN(osh, p, len, align)					\
+	do {								\
+		uint datalign;						\
+		datalign = (unsigned long)PKTDATA((p));			\
+		datalign = roundup(datalign, (align)) - datalign;	\
+		ASSERT(datalign < (align));				\
+		ASSERT(PKTLEN((p)) >= ((len) + datalign));	\
+		if (datalign)						\
+			PKTPULL((p), datalign);			\
+		PKTSETLEN((p), (len));				\
+	} while (0)
+
+/* Limit on rounding up frames */
+static const uint max_roundup = 512;
+
+/* Try doing readahead */
+static bool dhd_readahead;
+
+/* To check if there's window offered */
+#define DATAOK(bus) \
+	(((u8)(bus->tx_max - bus->tx_seq) != 0) && \
+	(((u8)(bus->tx_max - bus->tx_seq) & 0x80) == 0))
+
+/* Macros to get register read/write status */
+/* NOTE: these assume a local dhdsdio_bus_t *bus! */
+#define R_SDREG(regvar, regaddr, retryvar) \
+do { \
+	retryvar = 0; \
+	do { \
+		regvar = R_REG(bus->dhd->osh, regaddr); \
+	} while (bcmsdh_regfail(bus->sdh) && (++retryvar <= retry_limit)); \
+	if (retryvar) { \
+		bus->regfails += (retryvar-1); \
+		if (retryvar > retry_limit) { \
+			DHD_ERROR(("%s: FAILED" #regvar "READ, LINE %d\n", \
+			__func__, __LINE__)); \
+			regvar = 0; \
+		} \
+	} \
+} while (0)
+
+#define W_SDREG(regval, regaddr, retryvar) \
+do { \
+	retryvar = 0; \
+	do { \
+		W_REG(bus->dhd->osh, regaddr, regval); \
+	} while (bcmsdh_regfail(bus->sdh) && (++retryvar <= retry_limit)); \
+	if (retryvar) { \
+		bus->regfails += (retryvar-1); \
+		if (retryvar > retry_limit) \
+			DHD_ERROR(("%s: FAILED REGISTER WRITE, LINE %d\n", \
+			__func__, __LINE__)); \
+	} \
+} while (0)
+
+#define DHD_BUS			SDIO_BUS
+
+#define PKT_AVAILABLE()		(intstatus & I_HMB_FRAME_IND)
+
+#define HOSTINTMASK		(I_HMB_SW_MASK | I_CHIPACTIVE)
+
+#define GSPI_PR55150_BAILOUT
+
+#ifdef SDTEST
+static void dhdsdio_testrcv(dhd_bus_t *bus, void *pkt, uint seq);
+static void dhdsdio_sdtest_set(dhd_bus_t *bus, bool start);
+#endif
+
+#ifdef DHD_DEBUG
+static int dhdsdio_checkdied(dhd_bus_t *bus, u8 *data, uint size);
+static int dhdsdio_mem_dump(dhd_bus_t *bus);
+#endif				/* DHD_DEBUG  */
+static int dhdsdio_download_state(dhd_bus_t *bus, bool enter);
+
+static void dhdsdio_release(dhd_bus_t *bus, osl_t *osh);
+static void dhdsdio_release_malloc(dhd_bus_t *bus, osl_t *osh);
+static void dhdsdio_disconnect(void *ptr);
+static bool dhdsdio_chipmatch(u16 chipid);
+static bool dhdsdio_probe_attach(dhd_bus_t *bus, osl_t *osh, void *sdh,
+				 void *regsva, u16 devid);
+static bool dhdsdio_probe_malloc(dhd_bus_t *bus, osl_t *osh, void *sdh);
+static bool dhdsdio_probe_init(dhd_bus_t *bus, osl_t *osh, void *sdh);
+static void dhdsdio_release_dongle(dhd_bus_t *bus, osl_t * osh);
+
+static uint process_nvram_vars(char *varbuf, uint len);
+
+static void dhd_dongle_setmemsize(struct dhd_bus *bus, int mem_size);
+static int dhd_bcmsdh_recv_buf(dhd_bus_t *bus, u32 addr, uint fn,
+			       uint flags, u8 *buf, uint nbytes, void *pkt,
+			       bcmsdh_cmplt_fn_t complete, void *handle);
+static int dhd_bcmsdh_send_buf(dhd_bus_t *bus, u32 addr, uint fn,
+			       uint flags, u8 *buf, uint nbytes, void *pkt,
+			       bcmsdh_cmplt_fn_t complete, void *handle);
+
+static bool dhdsdio_download_firmware(struct dhd_bus *bus, osl_t *osh,
+				      void *sdh);
+static int _dhdsdio_download_firmware(struct dhd_bus *bus);
+
+static int dhdsdio_download_code_file(struct dhd_bus *bus, char *image_path);
+static int dhdsdio_download_nvram(struct dhd_bus *bus);
+#ifdef BCMEMBEDIMAGE
+static int dhdsdio_download_code_array(struct dhd_bus *bus);
+#endif
+
+static void dhd_dongle_setmemsize(struct dhd_bus *bus, int mem_size)
+{
+	s32 min_size = DONGLE_MIN_MEMSIZE;
+	/* Restrict the memsize to user specified limit */
+	DHD_ERROR(("user: Restrict the dongle ram size to %d, min %d\n",
+		dhd_dongle_memsize, min_size));
+	if ((dhd_dongle_memsize > min_size) &&
+	    (dhd_dongle_memsize < (s32) bus->orig_ramsize))
+		bus->ramsize = dhd_dongle_memsize;
+}
+
+static int dhdsdio_set_siaddr_window(dhd_bus_t *bus, u32 address)
+{
+	int err = 0;
+	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SBADDRLOW,
+			 (address >> 8) & SBSDIO_SBADDRLOW_MASK, &err);
+	if (!err)
+		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SBADDRMID,
+				 (address >> 16) & SBSDIO_SBADDRMID_MASK, &err);
+	if (!err)
+		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SBADDRHIGH,
+				 (address >> 24) & SBSDIO_SBADDRHIGH_MASK,
+				 &err);
+	return err;
+}
+
+/* Turn backplane clock on or off */
+static int dhdsdio_htclk(dhd_bus_t *bus, bool on, bool pendok)
+{
+	int err;
+	u8 clkctl, clkreq, devctl;
+	bcmsdh_info_t *sdh;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+#if defined(OOB_INTR_ONLY)
+	pendok = false;
+#endif
+	clkctl = 0;
+	sdh = bus->sdh;
+
+	if (on) {
+		/* Request HT Avail */
+		clkreq =
+		    bus->alp_only ? SBSDIO_ALP_AVAIL_REQ : SBSDIO_HT_AVAIL_REQ;
+
+		if ((bus->sih->chip == BCM4329_CHIP_ID)
+		    && (bus->sih->chiprev == 0))
+			clkreq |= SBSDIO_FORCE_ALP;
+
+		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
+				 clkreq, &err);
+		if (err) {
+			DHD_ERROR(("%s: HT Avail request error: %d\n",
+				   __func__, err));
+			return BCME_ERROR;
+		}
+
+		if (pendok && ((bus->sih->buscoretype == PCMCIA_CORE_ID)
+			       && (bus->sih->buscorerev == 9))) {
+			u32 dummy, retries;
+			R_SDREG(dummy, &bus->regs->clockctlstatus, retries);
+		}
+
+		/* Check current status */
+		clkctl =
+		    bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
+				    &err);
+		if (err) {
+			DHD_ERROR(("%s: HT Avail read error: %d\n",
+				   __func__, err));
+			return BCME_ERROR;
+		}
+
+		/* Go to pending and await interrupt if appropriate */
+		if (!SBSDIO_CLKAV(clkctl, bus->alp_only) && pendok) {
+			/* Allow only clock-available interrupt */
+			devctl =
+			    bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL,
+					    &err);
+			if (err) {
+				DHD_ERROR(("%s: Devctl error setting CA: %d\n",
+					__func__, err));
+				return BCME_ERROR;
+			}
+
+			devctl |= SBSDIO_DEVCTL_CA_INT_ONLY;
+			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL,
+					 devctl, &err);
+			DHD_INFO(("CLKCTL: set PENDING\n"));
+			bus->clkstate = CLK_PENDING;
+
+			return BCME_OK;
+		} else if (bus->clkstate == CLK_PENDING) {
+			/* Cancel CA-only interrupt filter */
+			devctl =
+			    bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL,
+					    &err);
+			devctl &= ~SBSDIO_DEVCTL_CA_INT_ONLY;
+			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL,
+					 devctl, &err);
+		}
+
+		/* Otherwise, wait here (polling) for HT Avail */
+		if (!SBSDIO_CLKAV(clkctl, bus->alp_only)) {
+			SPINWAIT_SLEEP(sdioh_spinwait_sleep,
+				       ((clkctl =
+					 bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
+						 SBSDIO_FUNC1_CHIPCLKCSR,
+							 &err)),
+					!SBSDIO_CLKAV(clkctl, bus->alp_only)),
+				       PMU_MAX_TRANSITION_DLY);
+		}
+		if (err) {
+			DHD_ERROR(("%s: HT Avail request error: %d\n",
+				   __func__, err));
+			return BCME_ERROR;
+		}
+		if (!SBSDIO_CLKAV(clkctl, bus->alp_only)) {
+			DHD_ERROR(("%s: HT Avail timeout (%d): clkctl 0x%02x\n",
+				   __func__, PMU_MAX_TRANSITION_DLY, clkctl));
+			return BCME_ERROR;
+		}
+
+		/* Mark clock available */
+		bus->clkstate = CLK_AVAIL;
+		DHD_INFO(("CLKCTL: turned ON\n"));
+
+#if defined(DHD_DEBUG)
+		if (bus->alp_only == true) {
+#if !defined(BCMLXSDMMC)
+			if (!SBSDIO_ALPONLY(clkctl)) {
+				DHD_ERROR(("%s: HT Clock, when ALP Only\n",
+					   __func__));
+			}
+#endif				/* !defined(BCMLXSDMMC) */
+		} else {
+			if (SBSDIO_ALPONLY(clkctl)) {
+				DHD_ERROR(("%s: HT Clock should be on.\n",
+					   __func__));
+			}
+		}
+#endif				/* defined (DHD_DEBUG) */
+
+		bus->activity = true;
+	} else {
+		clkreq = 0;
+
+		if (bus->clkstate == CLK_PENDING) {
+			/* Cancel CA-only interrupt filter */
+			devctl =
+			    bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL,
+					    &err);
+			devctl &= ~SBSDIO_DEVCTL_CA_INT_ONLY;
+			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL,
+					 devctl, &err);
+		}
+
+		bus->clkstate = CLK_SDONLY;
+		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
+				 clkreq, &err);
+		DHD_INFO(("CLKCTL: turned OFF\n"));
+		if (err) {
+			DHD_ERROR(("%s: Failed access turning clock off: %d\n",
+				   __func__, err));
+			return BCME_ERROR;
+		}
+	}
+	return BCME_OK;
+}
+
+/* Change idle/active SD state */
+static int dhdsdio_sdclk(dhd_bus_t *bus, bool on)
+{
+	int err;
+	s32 iovalue;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	if (on) {
+		if (bus->idleclock == DHD_IDLE_STOP) {
+			/* Turn on clock and restore mode */
+			iovalue = 1;
+			err = bcmsdh_iovar_op(bus->sdh, "sd_clock", NULL, 0,
+					      &iovalue, sizeof(iovalue), true);
+			if (err) {
+				DHD_ERROR(("%s: error enabling sd_clock: %d\n",
+					   __func__, err));
+				return BCME_ERROR;
+			}
+
+			iovalue = bus->sd_mode;
+			err = bcmsdh_iovar_op(bus->sdh, "sd_mode", NULL, 0,
+					      &iovalue, sizeof(iovalue), true);
+			if (err) {
+				DHD_ERROR(("%s: error changing sd_mode: %d\n",
+					   __func__, err));
+				return BCME_ERROR;
+			}
+		} else if (bus->idleclock != DHD_IDLE_ACTIVE) {
+			/* Restore clock speed */
+			iovalue = bus->sd_divisor;
+			err = bcmsdh_iovar_op(bus->sdh, "sd_divisor", NULL, 0,
+					      &iovalue, sizeof(iovalue), true);
+			if (err) {
+				DHD_ERROR(("%s: error restoring sd_divisor: %d\n",
+					__func__, err));
+				return BCME_ERROR;
+			}
+		}
+		bus->clkstate = CLK_SDONLY;
+	} else {
+		/* Stop or slow the SD clock itself */
+		if ((bus->sd_divisor == -1) || (bus->sd_mode == -1)) {
+			DHD_TRACE(("%s: can't idle clock, divisor %d mode %d\n",
+				   __func__, bus->sd_divisor, bus->sd_mode));
+			return BCME_ERROR;
+		}
+		if (bus->idleclock == DHD_IDLE_STOP) {
+			if (sd1idle) {
+				/* Change to SD1 mode and turn off clock */
+				iovalue = 1;
+				err =
+				    bcmsdh_iovar_op(bus->sdh, "sd_mode", NULL,
+						    0, &iovalue,
+						    sizeof(iovalue), true);
+				if (err) {
+					DHD_ERROR(("%s: error changing sd_clock: %d\n",
+						__func__, err));
+					return BCME_ERROR;
+				}
+			}
+
+			iovalue = 0;
+			err = bcmsdh_iovar_op(bus->sdh, "sd_clock", NULL, 0,
+					      &iovalue, sizeof(iovalue), true);
+			if (err) {
+				DHD_ERROR(("%s: error disabling sd_clock: %d\n",
+					   __func__, err));
+				return BCME_ERROR;
+			}
+		} else if (bus->idleclock != DHD_IDLE_ACTIVE) {
+			/* Set divisor to idle value */
+			iovalue = bus->idleclock;
+			err = bcmsdh_iovar_op(bus->sdh, "sd_divisor", NULL, 0,
+					      &iovalue, sizeof(iovalue), true);
+			if (err) {
+				DHD_ERROR(("%s: error changing sd_divisor: %d\n",
+					__func__, err));
+				return BCME_ERROR;
+			}
+		}
+		bus->clkstate = CLK_NONE;
+	}
+
+	return BCME_OK;
+}
+
+/* Transition SD and backplane clock readiness */
+static int dhdsdio_clkctl(dhd_bus_t *bus, uint target, bool pendok)
+{
+#ifdef DHD_DEBUG
+	uint oldstate = bus->clkstate;
+#endif				/* DHD_DEBUG */
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	/* Early exit if we're already there */
+	if (bus->clkstate == target) {
+		if (target == CLK_AVAIL) {
+			dhd_os_wd_timer(bus->dhd, dhd_watchdog_ms);
+			bus->activity = true;
+		}
+		return BCME_OK;
+	}
+
+	switch (target) {
+	case CLK_AVAIL:
+		/* Make sure SD clock is available */
+		if (bus->clkstate == CLK_NONE)
+			dhdsdio_sdclk(bus, true);
+		/* Now request HT Avail on the backplane */
+		dhdsdio_htclk(bus, true, pendok);
+		dhd_os_wd_timer(bus->dhd, dhd_watchdog_ms);
+		bus->activity = true;
+		break;
+
+	case CLK_SDONLY:
+		/* Remove HT request, or bring up SD clock */
+		if (bus->clkstate == CLK_NONE)
+			dhdsdio_sdclk(bus, true);
+		else if (bus->clkstate == CLK_AVAIL)
+			dhdsdio_htclk(bus, false, false);
+		else
+			DHD_ERROR(("dhdsdio_clkctl: request for %d -> %d\n",
+				   bus->clkstate, target));
+		dhd_os_wd_timer(bus->dhd, dhd_watchdog_ms);
+		break;
+
+	case CLK_NONE:
+		/* Make sure to remove HT request */
+		if (bus->clkstate == CLK_AVAIL)
+			dhdsdio_htclk(bus, false, false);
+		/* Now remove the SD clock */
+		dhdsdio_sdclk(bus, false);
+		dhd_os_wd_timer(bus->dhd, 0);
+		break;
+	}
+#ifdef DHD_DEBUG
+	DHD_INFO(("dhdsdio_clkctl: %d -> %d\n", oldstate, bus->clkstate));
+#endif				/* DHD_DEBUG */
+
+	return BCME_OK;
+}
+
+int dhdsdio_bussleep(dhd_bus_t *bus, bool sleep)
+{
+	bcmsdh_info_t *sdh = bus->sdh;
+	sdpcmd_regs_t *regs = bus->regs;
+	uint retries = 0;
+
+	DHD_INFO(("dhdsdio_bussleep: request %s (currently %s)\n",
+		  (sleep ? "SLEEP" : "WAKE"),
+		  (bus->sleeping ? "SLEEP" : "WAKE")));
+
+	/* Done if we're already in the requested state */
+	if (sleep == bus->sleeping)
+		return BCME_OK;
+
+	/* Going to sleep: set the alarm and turn off the lights... */
+	if (sleep) {
+		/* Don't sleep if something is pending */
+		if (bus->dpc_sched || bus->rxskip || pktq_len(&bus->txq))
+			return BCME_BUSY;
+
+		/* Disable SDIO interrupts (no longer interested) */
+		bcmsdh_intr_disable(bus->sdh);
+
+		/* Make sure the controller has the bus up */
+		dhdsdio_clkctl(bus, CLK_AVAIL, false);
+
+		/* Tell device to start using OOB wakeup */
+		W_SDREG(SMB_USE_OOB, &regs->tosbmailbox, retries);
+		if (retries > retry_limit)
+			DHD_ERROR(("CANNOT SIGNAL CHIP, WILL NOT WAKE UP!!\n"));
+
+		/* Turn off our contribution to the HT clock request */
+		dhdsdio_clkctl(bus, CLK_SDONLY, false);
+
+		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
+				 SBSDIO_FORCE_HW_CLKREQ_OFF, NULL);
+
+		/* Isolate the bus */
+		if (bus->sih->chip != BCM4329_CHIP_ID
+		    && bus->sih->chip != BCM4319_CHIP_ID) {
+			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL,
+					 SBSDIO_DEVCTL_PADS_ISO, NULL);
+		}
+
+		/* Change state */
+		bus->sleeping = true;
+
+	} else {
+		/* Waking up: bus power up is ok, set local state */
+
+		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
+				 0, NULL);
+
+		/* Force pad isolation off if possible
+			 (in case power never toggled) */
+		if ((bus->sih->buscoretype == PCMCIA_CORE_ID)
+		    && (bus->sih->buscorerev >= 10))
+			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, 0,
+					 NULL);
+
+		/* Make sure the controller has the bus up */
+		dhdsdio_clkctl(bus, CLK_AVAIL, false);
+
+		/* Send misc interrupt to indicate OOB not needed */
+		W_SDREG(0, &regs->tosbmailboxdata, retries);
+		if (retries <= retry_limit)
+			W_SDREG(SMB_DEV_INT, &regs->tosbmailbox, retries);
+
+		if (retries > retry_limit)
+			DHD_ERROR(("CANNOT SIGNAL CHIP TO CLEAR OOB!!\n"));
+
+		/* Make sure we have SD bus access */
+		dhdsdio_clkctl(bus, CLK_SDONLY, false);
+
+		/* Change state */
+		bus->sleeping = false;
+
+		/* Enable interrupts again */
+		if (bus->intr && (bus->dhd->busstate == DHD_BUS_DATA)) {
+			bus->intdis = false;
+			bcmsdh_intr_enable(bus->sdh);
+		}
+	}
+
+	return BCME_OK;
+}
+
+#if defined(OOB_INTR_ONLY)
+void dhd_enable_oob_intr(struct dhd_bus *bus, bool enable)
+{
+#if defined(HW_OOB)
+	bcmsdh_enable_hw_oob_intr(bus->sdh, enable);
+#else
+	sdpcmd_regs_t *regs = bus->regs;
+	uint retries = 0;
+
+	dhdsdio_clkctl(bus, CLK_AVAIL, false);
+	if (enable == true) {
+
+		/* Tell device to start using OOB wakeup */
+		W_SDREG(SMB_USE_OOB, &regs->tosbmailbox, retries);
+		if (retries > retry_limit)
+			DHD_ERROR(("CANNOT SIGNAL CHIP, WILL NOT WAKE UP!!\n"));
+
+	} else {
+		/* Send misc interrupt to indicate OOB not needed */
+		W_SDREG(0, &regs->tosbmailboxdata, retries);
+		if (retries <= retry_limit)
+			W_SDREG(SMB_DEV_INT, &regs->tosbmailbox, retries);
+	}
+
+	/* Turn off our contribution to the HT clock request */
+	dhdsdio_clkctl(bus, CLK_SDONLY, false);
+#endif				/* !defined(HW_OOB) */
+}
+#endif				/* defined(OOB_INTR_ONLY) */
+
+#define BUS_WAKE(bus) \
+	do { \
+		if ((bus)->sleeping) \
+			dhdsdio_bussleep((bus), false); \
+	} while (0);
+
+/* Writes a HW/SW header into the packet and sends it. */
+/* Assumes: (a) header space already there, (b) caller holds lock */
+static int dhdsdio_txpkt(dhd_bus_t *bus, void *pkt, uint chan, bool free_pkt)
+{
+	int ret;
+	osl_t *osh;
+	u8 *frame;
+	u16 len, pad = 0;
+	u32 swheader;
+	uint retries = 0;
+	bcmsdh_info_t *sdh;
+	void *new;
+	int i;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	sdh = bus->sdh;
+	osh = bus->dhd->osh;
+
+	if (bus->dhd->dongle_reset) {
+		ret = BCME_NOTREADY;
+		goto done;
+	}
+
+	frame = (u8 *) PKTDATA(pkt);
+
+	/* Add alignment padding, allocate new packet if needed */
+	pad = ((unsigned long)frame % DHD_SDALIGN);
+	if (pad) {
+		if (PKTHEADROOM(pkt) < pad) {
+			DHD_INFO(("%s: insufficient headroom %d for %d pad\n",
+				  __func__, (int)PKTHEADROOM(pkt), pad));
+			bus->dhd->tx_realloc++;
+			new = PKTGET(osh, (PKTLEN(pkt) + DHD_SDALIGN), true);
+			if (!new) {
+				DHD_ERROR(("%s: couldn't allocate new %d-byte "
+					"packet\n",
+					__func__, PKTLEN(pkt) + DHD_SDALIGN));
+				ret = BCME_NOMEM;
+				goto done;
+			}
+
+			PKTALIGN(osh, new, PKTLEN(pkt), DHD_SDALIGN);
+			bcopy(PKTDATA(pkt), PKTDATA(new), PKTLEN(pkt));
+			if (free_pkt)
+				PKTFREE(osh, pkt, true);
+			/* free the pkt if canned one is not used */
+			free_pkt = true;
+			pkt = new;
+			frame = (u8 *) PKTDATA(pkt);
+			ASSERT(((unsigned long)frame % DHD_SDALIGN) == 0);
+			pad = 0;
+		} else {
+			PKTPUSH(pkt, pad);
+			frame = (u8 *) PKTDATA(pkt);
+
+			ASSERT((pad + SDPCM_HDRLEN) <= (int)PKTLEN(pkt));
+			bzero(frame, pad + SDPCM_HDRLEN);
+		}
+	}
+	ASSERT(pad < DHD_SDALIGN);
+
+	/* Hardware tag: 2 byte len followed by 2 byte ~len check (all LE) */
+	len = (u16) PKTLEN(pkt);
+	*(u16 *) frame = htol16(len);
+	*(((u16 *) frame) + 1) = htol16(~len);
+
+	/* Software tag: channel, sequence number, data offset */
+	swheader =
+	    ((chan << SDPCM_CHANNEL_SHIFT) & SDPCM_CHANNEL_MASK) | bus->tx_seq |
+	    (((pad +
+	       SDPCM_HDRLEN) << SDPCM_DOFFSET_SHIFT) & SDPCM_DOFFSET_MASK);
+	htol32_ua_store(swheader, frame + SDPCM_FRAMETAG_LEN);
+	htol32_ua_store(0, frame + SDPCM_FRAMETAG_LEN + sizeof(swheader));
+
+#ifdef DHD_DEBUG
+	tx_packets[PKTPRIO(pkt)]++;
+	if (DHD_BYTES_ON() &&
+	    (((DHD_CTL_ON() && (chan == SDPCM_CONTROL_CHANNEL)) ||
+	      (DHD_DATA_ON() && (chan != SDPCM_CONTROL_CHANNEL))))) {
+		prhex("Tx Frame", frame, len);
+	} else if (DHD_HDRS_ON()) {
+		prhex("TxHdr", frame, min_t(u16, len, 16));
+	}
+#endif
+
+	/* Raise len to next SDIO block to eliminate tail command */
+	if (bus->roundup && bus->blocksize && (len > bus->blocksize)) {
+		u16 pad = bus->blocksize - (len % bus->blocksize);
+		if ((pad <= bus->roundup) && (pad < bus->blocksize))
+#ifdef NOTUSED
+			if (pad <= PKTTAILROOM(pkt))
+#endif				/* NOTUSED */
+				len += pad;
+	} else if (len % DHD_SDALIGN) {
+		len += DHD_SDALIGN - (len % DHD_SDALIGN);
+	}
+
+	/* Some controllers have trouble with odd bytes -- round to even */
+	if (forcealign && (len & (ALIGNMENT - 1))) {
+#ifdef NOTUSED
+		if (PKTTAILROOM(pkt))
+#endif
+			len = roundup(len, ALIGNMENT);
+#ifdef NOTUSED
+		else
+			DHD_ERROR(("%s: sending unrounded %d-byte packet\n",
+				   __func__, len));
+#endif
+	}
+
+	do {
+		ret =
+		    dhd_bcmsdh_send_buf(bus, bcmsdh_cur_sbwad(sdh), SDIO_FUNC_2,
+					F2SYNC, frame, len, pkt, NULL, NULL);
+		bus->f2txdata++;
+		ASSERT(ret != BCME_PENDING);
+
+		if (ret < 0) {
+			/* On failure, abort the command
+			 and terminate the frame */
+			DHD_INFO(("%s: sdio error %d, abort command and "
+				"terminate frame.\n", __func__, ret));
+			bus->tx_sderrs++;
+
+			bcmsdh_abort(sdh, SDIO_FUNC_2);
+			bcmsdh_cfg_write(sdh, SDIO_FUNC_1,
+					 SBSDIO_FUNC1_FRAMECTRL, SFC_WF_TERM,
+					 NULL);
+			bus->f1regdata++;
+
+			for (i = 0; i < 3; i++) {
+				u8 hi, lo;
+				hi = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
+						     SBSDIO_FUNC1_WFRAMEBCHI,
+						     NULL);
+				lo = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
+						     SBSDIO_FUNC1_WFRAMEBCLO,
+						     NULL);
+				bus->f1regdata += 2;
+				if ((hi == 0) && (lo == 0))
+					break;
+			}
+
+		}
+		if (ret == 0)
+			bus->tx_seq = (bus->tx_seq + 1) % SDPCM_SEQUENCE_WRAP;
+
+	} while ((ret < 0) && retrydata && retries++ < TXRETRIES);
+
+done:
+	/* restore pkt buffer pointer before calling tx complete routine */
+	PKTPULL(pkt, SDPCM_HDRLEN + pad);
+	dhd_os_sdunlock(bus->dhd);
+	dhd_txcomplete(bus->dhd, pkt, ret != 0);
+	dhd_os_sdlock(bus->dhd);
+
+	if (free_pkt)
+		PKTFREE(osh, pkt, true);
+
+	return ret;
+}
+
+int dhd_bus_txdata(struct dhd_bus *bus, void *pkt)
+{
+	int ret = BCME_ERROR;
+	osl_t *osh;
+	uint datalen, prec;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	osh = bus->dhd->osh;
+	datalen = PKTLEN(pkt);
+
+#ifdef SDTEST
+	/* Push the test header if doing loopback */
+	if (bus->ext_loop) {
+		u8 *data;
+		PKTPUSH(pkt, SDPCM_TEST_HDRLEN);
+		data = PKTDATA(pkt);
+		*data++ = SDPCM_TEST_ECHOREQ;
+		*data++ = (u8) bus->loopid++;
+		*data++ = (datalen >> 0);
+		*data++ = (datalen >> 8);
+		datalen += SDPCM_TEST_HDRLEN;
+	}
+#endif				/* SDTEST */
+
+	/* Add space for the header */
+	PKTPUSH(pkt, SDPCM_HDRLEN);
+	ASSERT(IS_ALIGNED((unsigned long)PKTDATA(pkt), 2));
+
+	prec = PRIO2PREC((PKTPRIO(pkt) & PRIOMASK));
+
+	/* Check for existing queue, current flow-control,
+			 pending event, or pending clock */
+	if (dhd_deferred_tx || bus->fcstate || pktq_len(&bus->txq)
+	    || bus->dpc_sched || (!DATAOK(bus))
+	    || (bus->flowcontrol & NBITVAL(prec))
+	    || (bus->clkstate != CLK_AVAIL)) {
+		DHD_TRACE(("%s: deferring pktq len %d\n", __func__,
+			   pktq_len(&bus->txq)));
+		bus->fcqueued++;
+
+		/* Priority based enq */
+		dhd_os_sdlock_txq(bus->dhd);
+		if (dhd_prec_enq(bus->dhd, &bus->txq, pkt, prec) == false) {
+			PKTPULL(pkt, SDPCM_HDRLEN);
+			dhd_txcomplete(bus->dhd, pkt, false);
+			PKTFREE(osh, pkt, true);
+			DHD_ERROR(("%s: out of bus->txq !!!\n", __func__));
+			ret = BCME_NORESOURCE;
+		} else {
+			ret = BCME_OK;
+		}
+		dhd_os_sdunlock_txq(bus->dhd);
+
+		if ((pktq_len(&bus->txq) >= FCHI) && dhd_doflow)
+			dhd_txflowcontrol(bus->dhd, 0, ON);
+
+#ifdef DHD_DEBUG
+		if (pktq_plen(&bus->txq, prec) > qcount[prec])
+			qcount[prec] = pktq_plen(&bus->txq, prec);
+#endif
+		/* Schedule DPC if needed to send queued packet(s) */
+		if (dhd_deferred_tx && !bus->dpc_sched) {
+			bus->dpc_sched = true;
+			dhd_sched_dpc(bus->dhd);
+		}
+	} else {
+		/* Lock: we're about to use shared data/code (and SDIO) */
+		dhd_os_sdlock(bus->dhd);
+
+		/* Otherwise, send it now */
+		BUS_WAKE(bus);
+		/* Make sure back plane ht clk is on, no pending allowed */
+		dhdsdio_clkctl(bus, CLK_AVAIL, true);
+
+#ifndef SDTEST
+		DHD_TRACE(("%s: calling txpkt\n", __func__));
+		ret = dhdsdio_txpkt(bus, pkt, SDPCM_DATA_CHANNEL, true);
+#else
+		ret = dhdsdio_txpkt(bus, pkt,
+				    (bus->ext_loop ? SDPCM_TEST_CHANNEL :
+				     SDPCM_DATA_CHANNEL), true);
+#endif
+		if (ret)
+			bus->dhd->tx_errors++;
+		else
+			bus->dhd->dstats.tx_bytes += datalen;
+
+		if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
+			bus->activity = false;
+			dhdsdio_clkctl(bus, CLK_NONE, true);
+		}
+
+		dhd_os_sdunlock(bus->dhd);
+	}
+
+	return ret;
+}
+
+static uint dhdsdio_sendfromq(dhd_bus_t *bus, uint maxframes)
+{
+	void *pkt;
+	u32 intstatus = 0;
+	uint retries = 0;
+	int ret = 0, prec_out;
+	uint cnt = 0;
+	uint datalen;
+	u8 tx_prec_map;
+
+	dhd_pub_t *dhd = bus->dhd;
+	sdpcmd_regs_t *regs = bus->regs;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	tx_prec_map = ~bus->flowcontrol;
+
+	/* Send frames until the limit or some other event */
+	for (cnt = 0; (cnt < maxframes) && DATAOK(bus); cnt++) {
+		dhd_os_sdlock_txq(bus->dhd);
+		pkt = pktq_mdeq(&bus->txq, tx_prec_map, &prec_out);
+		if (pkt == NULL) {
+			dhd_os_sdunlock_txq(bus->dhd);
+			break;
+		}
+		dhd_os_sdunlock_txq(bus->dhd);
+		datalen = PKTLEN(pkt) - SDPCM_HDRLEN;
+
+#ifndef SDTEST
+		ret = dhdsdio_txpkt(bus, pkt, SDPCM_DATA_CHANNEL, true);
+#else
+		ret = dhdsdio_txpkt(bus, pkt,
+				    (bus->ext_loop ? SDPCM_TEST_CHANNEL :
+				     SDPCM_DATA_CHANNEL), true);
+#endif
+		if (ret)
+			bus->dhd->tx_errors++;
+		else
+			bus->dhd->dstats.tx_bytes += datalen;
+
+		/* In poll mode, need to check for other events */
+		if (!bus->intr && cnt) {
+			/* Check device status, signal pending interrupt */
+			R_SDREG(intstatus, &regs->intstatus, retries);
+			bus->f2txdata++;
+			if (bcmsdh_regfail(bus->sdh))
+				break;
+			if (intstatus & bus->hostintmask)
+				bus->ipend = true;
+		}
+	}
+
+	/* Deflow-control stack if needed */
+	if (dhd_doflow && dhd->up && (dhd->busstate == DHD_BUS_DATA) &&
+	    dhd->txoff && (pktq_len(&bus->txq) < FCLOW))
+		dhd_txflowcontrol(dhd, 0, OFF);
+
+	return cnt;
+}
+
+int dhd_bus_txctl(struct dhd_bus *bus, unsigned char *msg, uint msglen)
+{
+	u8 *frame;
+	u16 len;
+	u32 swheader;
+	uint retries = 0;
+	bcmsdh_info_t *sdh = bus->sdh;
+	u8 doff = 0;
+	int ret = -1;
+	int i;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	if (bus->dhd->dongle_reset)
+		return -EIO;
+
+	/* Back the pointer to make a room for bus header */
+	frame = msg - SDPCM_HDRLEN;
+	len = (msglen += SDPCM_HDRLEN);
+
+	/* Add alignment padding (optional for ctl frames) */
+	if (dhd_alignctl) {
+		doff = ((unsigned long)frame % DHD_SDALIGN);
+		if (doff) {
+			frame -= doff;
+			len += doff;
+			msglen += doff;
+			bzero(frame, doff + SDPCM_HDRLEN);
+		}
+		ASSERT(doff < DHD_SDALIGN);
+	}
+	doff += SDPCM_HDRLEN;
+
+	/* Round send length to next SDIO block */
+	if (bus->roundup && bus->blocksize && (len > bus->blocksize)) {
+		u16 pad = bus->blocksize - (len % bus->blocksize);
+		if ((pad <= bus->roundup) && (pad < bus->blocksize))
+			len += pad;
+	} else if (len % DHD_SDALIGN) {
+		len += DHD_SDALIGN - (len % DHD_SDALIGN);
+	}
+
+	/* Satisfy length-alignment requirements */
+	if (forcealign && (len & (ALIGNMENT - 1)))
+		len = roundup(len, ALIGNMENT);
+
+	ASSERT(IS_ALIGNED((unsigned long)frame, 2));
+
+	/* Need to lock here to protect txseq and SDIO tx calls */
+	dhd_os_sdlock(bus->dhd);
+
+	BUS_WAKE(bus);
+
+	/* Make sure backplane clock is on */
+	dhdsdio_clkctl(bus, CLK_AVAIL, false);
+
+	/* Hardware tag: 2 byte len followed by 2 byte ~len check (all LE) */
+	*(u16 *) frame = htol16((u16) msglen);
+	*(((u16 *) frame) + 1) = htol16(~msglen);
+
+	/* Software tag: channel, sequence number, data offset */
+	swheader =
+	    ((SDPCM_CONTROL_CHANNEL << SDPCM_CHANNEL_SHIFT) &
+	     SDPCM_CHANNEL_MASK)
+	    | bus->tx_seq | ((doff << SDPCM_DOFFSET_SHIFT) &
+			     SDPCM_DOFFSET_MASK);
+	htol32_ua_store(swheader, frame + SDPCM_FRAMETAG_LEN);
+	htol32_ua_store(0, frame + SDPCM_FRAMETAG_LEN + sizeof(swheader));
+
+	if (!DATAOK(bus)) {
+		DHD_INFO(("%s: No bus credit bus->tx_max %d, bus->tx_seq %d\n",
+			  __func__, bus->tx_max, bus->tx_seq));
+		bus->ctrl_frame_stat = true;
+		/* Send from dpc */
+		bus->ctrl_frame_buf = frame;
+		bus->ctrl_frame_len = len;
+
+		dhd_wait_for_event(bus->dhd, &bus->ctrl_frame_stat);
+
+		if (bus->ctrl_frame_stat == false) {
+			DHD_INFO(("%s: ctrl_frame_stat == false\n", __func__));
+			ret = 0;
+		} else {
+			DHD_INFO(("%s: ctrl_frame_stat == true\n", __func__));
+			ret = -1;
+		}
+	}
+
+	if (ret == -1) {
+#ifdef DHD_DEBUG
+		if (DHD_BYTES_ON() && DHD_CTL_ON())
+			prhex("Tx Frame", frame, len);
+		else if (DHD_HDRS_ON())
+			prhex("TxHdr", frame, min_t(u16, len, 16));
+#endif
+
+		do {
+			bus->ctrl_frame_stat = false;
+			ret =
+			    dhd_bcmsdh_send_buf(bus, bcmsdh_cur_sbwad(sdh),
+						SDIO_FUNC_2, F2SYNC, frame, len,
+						NULL, NULL, NULL);
+
+			ASSERT(ret != BCME_PENDING);
+
+			if (ret < 0) {
+				/* On failure, abort the command and
+				 terminate the frame */
+				DHD_INFO(("%s: sdio error %d, abort command and terminate frame.\n",
+					__func__, ret));
+				bus->tx_sderrs++;
+
+				bcmsdh_abort(sdh, SDIO_FUNC_2);
+
+				bcmsdh_cfg_write(sdh, SDIO_FUNC_1,
+						 SBSDIO_FUNC1_FRAMECTRL,
+						 SFC_WF_TERM, NULL);
+				bus->f1regdata++;
+
+				for (i = 0; i < 3; i++) {
+					u8 hi, lo;
+					hi = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
+					     SBSDIO_FUNC1_WFRAMEBCHI,
+					     NULL);
+					lo = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
+					     SBSDIO_FUNC1_WFRAMEBCLO,
+							     NULL);
+					bus->f1regdata += 2;
+					if ((hi == 0) && (lo == 0))
+						break;
+				}
+
+			}
+			if (ret == 0) {
+				bus->tx_seq =
+				    (bus->tx_seq + 1) % SDPCM_SEQUENCE_WRAP;
+			}
+		} while ((ret < 0) && retries++ < TXRETRIES);
+	}
+
+	if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
+		bus->activity = false;
+		dhdsdio_clkctl(bus, CLK_NONE, true);
+	}
+
+	dhd_os_sdunlock(bus->dhd);
+
+	if (ret)
+		bus->dhd->tx_ctlerrs++;
+	else
+		bus->dhd->tx_ctlpkts++;
+
+	return ret ? -EIO : 0;
+}
+
+int dhd_bus_rxctl(struct dhd_bus *bus, unsigned char *msg, uint msglen)
+{
+	int timeleft;
+	uint rxlen = 0;
+	bool pending;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	if (bus->dhd->dongle_reset)
+		return -EIO;
+
+	/* Wait until control frame is available */
+	timeleft = dhd_os_ioctl_resp_wait(bus->dhd, &bus->rxlen, &pending);
+
+	dhd_os_sdlock(bus->dhd);
+	rxlen = bus->rxlen;
+	bcopy(bus->rxctl, msg, min(msglen, rxlen));
+	bus->rxlen = 0;
+	dhd_os_sdunlock(bus->dhd);
+
+	if (rxlen) {
+		DHD_CTL(("%s: resumed on rxctl frame, got %d expected %d\n",
+			 __func__, rxlen, msglen));
+	} else if (timeleft == 0) {
+		DHD_ERROR(("%s: resumed on timeout\n", __func__));
+#ifdef DHD_DEBUG
+		dhd_os_sdlock(bus->dhd);
+		dhdsdio_checkdied(bus, NULL, 0);
+		dhd_os_sdunlock(bus->dhd);
+#endif				/* DHD_DEBUG */
+	} else if (pending == true) {
+		DHD_CTL(("%s: cancelled\n", __func__));
+		return -ERESTARTSYS;
+	} else {
+		DHD_CTL(("%s: resumed for unknown reason?\n", __func__));
+#ifdef DHD_DEBUG
+		dhd_os_sdlock(bus->dhd);
+		dhdsdio_checkdied(bus, NULL, 0);
+		dhd_os_sdunlock(bus->dhd);
+#endif				/* DHD_DEBUG */
+	}
+
+	if (rxlen)
+		bus->dhd->rx_ctlpkts++;
+	else
+		bus->dhd->rx_ctlerrs++;
+
+	return rxlen ? (int)rxlen : -ETIMEDOUT;
+}
+
+/* IOVar table */
+enum {
+	IOV_INTR = 1,
+	IOV_POLLRATE,
+	IOV_SDREG,
+	IOV_SBREG,
+	IOV_SDCIS,
+	IOV_MEMBYTES,
+	IOV_MEMSIZE,
+#ifdef DHD_DEBUG
+	IOV_CHECKDIED,
+#endif
+	IOV_DOWNLOAD,
+	IOV_FORCEEVEN,
+	IOV_SDIOD_DRIVE,
+	IOV_READAHEAD,
+	IOV_SDRXCHAIN,
+	IOV_ALIGNCTL,
+	IOV_SDALIGN,
+	IOV_DEVRESET,
+	IOV_CPU,
+#ifdef SDTEST
+	IOV_PKTGEN,
+	IOV_EXTLOOP,
+#endif				/* SDTEST */
+	IOV_SPROM,
+	IOV_TXBOUND,
+	IOV_RXBOUND,
+	IOV_TXMINMAX,
+	IOV_IDLETIME,
+	IOV_IDLECLOCK,
+	IOV_SD1IDLE,
+	IOV_SLEEP,
+	IOV_VARS
+};
+
+const bcm_iovar_t dhdsdio_iovars[] = {
+	{"intr", IOV_INTR, 0, IOVT_BOOL, 0},
+	{"sleep", IOV_SLEEP, 0, IOVT_BOOL, 0},
+	{"pollrate", IOV_POLLRATE, 0, IOVT_UINT32, 0},
+	{"idletime", IOV_IDLETIME, 0, IOVT_INT32, 0},
+	{"idleclock", IOV_IDLECLOCK, 0, IOVT_INT32, 0},
+	{"sd1idle", IOV_SD1IDLE, 0, IOVT_BOOL, 0},
+	{"membytes", IOV_MEMBYTES, 0, IOVT_BUFFER, 2 * sizeof(int)},
+	{"memsize", IOV_MEMSIZE, 0, IOVT_UINT32, 0},
+	{"download", IOV_DOWNLOAD, 0, IOVT_BOOL, 0},
+	{"vars", IOV_VARS, 0, IOVT_BUFFER, 0},
+	{"sdiod_drive", IOV_SDIOD_DRIVE, 0, IOVT_UINT32, 0},
+	{"readahead", IOV_READAHEAD, 0, IOVT_BOOL, 0},
+	{"sdrxchain", IOV_SDRXCHAIN, 0, IOVT_BOOL, 0},
+	{"alignctl", IOV_ALIGNCTL, 0, IOVT_BOOL, 0},
+	{"sdalign", IOV_SDALIGN, 0, IOVT_BOOL, 0},
+	{"devreset", IOV_DEVRESET, 0, IOVT_BOOL, 0},
+#ifdef DHD_DEBUG
+	{"sdreg", IOV_SDREG, 0, IOVT_BUFFER, sizeof(sdreg_t)}
+	,
+	{"sbreg", IOV_SBREG, 0, IOVT_BUFFER, sizeof(sdreg_t)}
+	,
+	{"sd_cis", IOV_SDCIS, 0, IOVT_BUFFER, DHD_IOCTL_MAXLEN}
+	,
+	{"forcealign", IOV_FORCEEVEN, 0, IOVT_BOOL, 0}
+	,
+	{"txbound", IOV_TXBOUND, 0, IOVT_UINT32, 0}
+	,
+	{"rxbound", IOV_RXBOUND, 0, IOVT_UINT32, 0}
+	,
+	{"txminmax", IOV_TXMINMAX, 0, IOVT_UINT32, 0}
+	,
+	{"cpu", IOV_CPU, 0, IOVT_BOOL, 0}
+	,
+#ifdef DHD_DEBUG
+	{"checkdied", IOV_CHECKDIED, 0, IOVT_BUFFER, 0}
+	,
+#endif				/* DHD_DEBUG  */
+#endif				/* DHD_DEBUG */
+#ifdef SDTEST
+	{"extloop", IOV_EXTLOOP, 0, IOVT_BOOL, 0}
+	,
+	{"pktgen", IOV_PKTGEN, 0, IOVT_BUFFER, sizeof(dhd_pktgen_t)}
+	,
+#endif				/* SDTEST */
+
+	{NULL, 0, 0, 0, 0}
+};
+
+static void
+dhd_dump_pct(struct bcmstrbuf *strbuf, char *desc, uint num, uint div)
+{
+	uint q1, q2;
+
+	if (!div) {
+		bcm_bprintf(strbuf, "%s N/A", desc);
+	} else {
+		q1 = num / div;
+		q2 = (100 * (num - (q1 * div))) / div;
+		bcm_bprintf(strbuf, "%s %d.%02d", desc, q1, q2);
+	}
+}
+
+void dhd_bus_dump(dhd_pub_t *dhdp, struct bcmstrbuf *strbuf)
+{
+	dhd_bus_t *bus = dhdp->bus;
+
+	bcm_bprintf(strbuf, "Bus SDIO structure:\n");
+	bcm_bprintf(strbuf,
+		    "hostintmask 0x%08x intstatus 0x%08x sdpcm_ver %d\n",
+		    bus->hostintmask, bus->intstatus, bus->sdpcm_ver);
+	bcm_bprintf(strbuf,
+		    "fcstate %d qlen %d tx_seq %d, max %d, rxskip %d rxlen %d rx_seq %d\n",
+		    bus->fcstate, pktq_len(&bus->txq), bus->tx_seq, bus->tx_max,
+		    bus->rxskip, bus->rxlen, bus->rx_seq);
+	bcm_bprintf(strbuf, "intr %d intrcount %d lastintrs %d spurious %d\n",
+		    bus->intr, bus->intrcount, bus->lastintrs, bus->spurious);
+	bcm_bprintf(strbuf, "pollrate %d pollcnt %d regfails %d\n",
+		    bus->pollrate, bus->pollcnt, bus->regfails);
+
+	bcm_bprintf(strbuf, "\nAdditional counters:\n");
+	bcm_bprintf(strbuf,
+		    "tx_sderrs %d fcqueued %d rxrtx %d rx_toolong %d rxc_errors %d\n",
+		    bus->tx_sderrs, bus->fcqueued, bus->rxrtx, bus->rx_toolong,
+		    bus->rxc_errors);
+	bcm_bprintf(strbuf, "rx_hdrfail %d badhdr %d badseq %d\n",
+		    bus->rx_hdrfail, bus->rx_badhdr, bus->rx_badseq);
+	bcm_bprintf(strbuf, "fc_rcvd %d, fc_xoff %d, fc_xon %d\n", bus->fc_rcvd,
+		    bus->fc_xoff, bus->fc_xon);
+	bcm_bprintf(strbuf, "rxglomfail %d, rxglomframes %d, rxglompkts %d\n",
+		    bus->rxglomfail, bus->rxglomframes, bus->rxglompkts);
+	bcm_bprintf(strbuf, "f2rx (hdrs/data) %d (%d/%d), f2tx %d f1regs %d\n",
+		    (bus->f2rxhdrs + bus->f2rxdata), bus->f2rxhdrs,
+		    bus->f2rxdata, bus->f2txdata, bus->f1regdata);
+	{
+		dhd_dump_pct(strbuf, "\nRx: pkts/f2rd", bus->dhd->rx_packets,
+			     (bus->f2rxhdrs + bus->f2rxdata));
+		dhd_dump_pct(strbuf, ", pkts/f1sd", bus->dhd->rx_packets,
+			     bus->f1regdata);
+		dhd_dump_pct(strbuf, ", pkts/sd", bus->dhd->rx_packets,
+			     (bus->f2rxhdrs + bus->f2rxdata + bus->f1regdata));
+		dhd_dump_pct(strbuf, ", pkts/int", bus->dhd->rx_packets,
+			     bus->intrcount);
+		bcm_bprintf(strbuf, "\n");
+
+		dhd_dump_pct(strbuf, "Rx: glom pct", (100 * bus->rxglompkts),
+			     bus->dhd->rx_packets);
+		dhd_dump_pct(strbuf, ", pkts/glom", bus->rxglompkts,
+			     bus->rxglomframes);
+		bcm_bprintf(strbuf, "\n");
+
+		dhd_dump_pct(strbuf, "Tx: pkts/f2wr", bus->dhd->tx_packets,
+			     bus->f2txdata);
+		dhd_dump_pct(strbuf, ", pkts/f1sd", bus->dhd->tx_packets,
+			     bus->f1regdata);
+		dhd_dump_pct(strbuf, ", pkts/sd", bus->dhd->tx_packets,
+			     (bus->f2txdata + bus->f1regdata));
+		dhd_dump_pct(strbuf, ", pkts/int", bus->dhd->tx_packets,
+			     bus->intrcount);
+		bcm_bprintf(strbuf, "\n");
+
+		dhd_dump_pct(strbuf, "Total: pkts/f2rw",
+			     (bus->dhd->tx_packets + bus->dhd->rx_packets),
+			     (bus->f2txdata + bus->f2rxhdrs + bus->f2rxdata));
+		dhd_dump_pct(strbuf, ", pkts/f1sd",
+			     (bus->dhd->tx_packets + bus->dhd->rx_packets),
+			     bus->f1regdata);
+		dhd_dump_pct(strbuf, ", pkts/sd",
+			     (bus->dhd->tx_packets + bus->dhd->rx_packets),
+			     (bus->f2txdata + bus->f2rxhdrs + bus->f2rxdata +
+			      bus->f1regdata));
+		dhd_dump_pct(strbuf, ", pkts/int",
+			     (bus->dhd->tx_packets + bus->dhd->rx_packets),
+			     bus->intrcount);
+		bcm_bprintf(strbuf, "\n\n");
+	}
+
+#ifdef SDTEST
+	if (bus->pktgen_count) {
+		bcm_bprintf(strbuf, "pktgen config and count:\n");
+		bcm_bprintf(strbuf,
+			    "freq %d count %d print %d total %d min %d len %d\n",
+			    bus->pktgen_freq, bus->pktgen_count,
+			    bus->pktgen_print, bus->pktgen_total,
+			    bus->pktgen_minlen, bus->pktgen_maxlen);
+		bcm_bprintf(strbuf, "send attempts %d rcvd %d fail %d\n",
+			    bus->pktgen_sent, bus->pktgen_rcvd,
+			    bus->pktgen_fail);
+	}
+#endif				/* SDTEST */
+#ifdef DHD_DEBUG
+	bcm_bprintf(strbuf, "dpc_sched %d host interrupt%spending\n",
+		    bus->dpc_sched,
+		    (bcmsdh_intr_pending(bus->sdh) ? " " : " not "));
+	bcm_bprintf(strbuf, "blocksize %d roundup %d\n", bus->blocksize,
+		    bus->roundup);
+#endif				/* DHD_DEBUG */
+	bcm_bprintf(strbuf,
+		    "clkstate %d activity %d idletime %d idlecount %d sleeping %d\n",
+		    bus->clkstate, bus->activity, bus->idletime, bus->idlecount,
+		    bus->sleeping);
+}
+
+void dhd_bus_clearcounts(dhd_pub_t *dhdp)
+{
+	dhd_bus_t *bus = (dhd_bus_t *) dhdp->bus;
+
+	bus->intrcount = bus->lastintrs = bus->spurious = bus->regfails = 0;
+	bus->rxrtx = bus->rx_toolong = bus->rxc_errors = 0;
+	bus->rx_hdrfail = bus->rx_badhdr = bus->rx_badseq = 0;
+	bus->tx_sderrs = bus->fc_rcvd = bus->fc_xoff = bus->fc_xon = 0;
+	bus->rxglomfail = bus->rxglomframes = bus->rxglompkts = 0;
+	bus->f2rxhdrs = bus->f2rxdata = bus->f2txdata = bus->f1regdata = 0;
+}
+
+#ifdef SDTEST
+static int dhdsdio_pktgen_get(dhd_bus_t *bus, u8 *arg)
+{
+	dhd_pktgen_t pktgen;
+
+	pktgen.version = DHD_PKTGEN_VERSION;
+	pktgen.freq = bus->pktgen_freq;
+	pktgen.count = bus->pktgen_count;
+	pktgen.print = bus->pktgen_print;
+	pktgen.total = bus->pktgen_total;
+	pktgen.minlen = bus->pktgen_minlen;
+	pktgen.maxlen = bus->pktgen_maxlen;
+	pktgen.numsent = bus->pktgen_sent;
+	pktgen.numrcvd = bus->pktgen_rcvd;
+	pktgen.numfail = bus->pktgen_fail;
+	pktgen.mode = bus->pktgen_mode;
+	pktgen.stop = bus->pktgen_stop;
+
+	bcopy(&pktgen, arg, sizeof(pktgen));
+
+	return 0;
+}
+
+static int dhdsdio_pktgen_set(dhd_bus_t *bus, u8 *arg)
+{
+	dhd_pktgen_t pktgen;
+	uint oldcnt, oldmode;
+
+	bcopy(arg, &pktgen, sizeof(pktgen));
+	if (pktgen.version != DHD_PKTGEN_VERSION)
+		return BCME_BADARG;
+
+	oldcnt = bus->pktgen_count;
+	oldmode = bus->pktgen_mode;
+
+	bus->pktgen_freq = pktgen.freq;
+	bus->pktgen_count = pktgen.count;
+	bus->pktgen_print = pktgen.print;
+	bus->pktgen_total = pktgen.total;
+	bus->pktgen_minlen = pktgen.minlen;
+	bus->pktgen_maxlen = pktgen.maxlen;
+	bus->pktgen_mode = pktgen.mode;
+	bus->pktgen_stop = pktgen.stop;
+
+	bus->pktgen_tick = bus->pktgen_ptick = 0;
+	bus->pktgen_len = max(bus->pktgen_len, bus->pktgen_minlen);
+	bus->pktgen_len = min(bus->pktgen_len, bus->pktgen_maxlen);
+
+	/* Clear counts for a new pktgen (mode change, or was stopped) */
+	if (bus->pktgen_count && (!oldcnt || oldmode != bus->pktgen_mode))
+		bus->pktgen_sent = bus->pktgen_rcvd = bus->pktgen_fail = 0;
+
+	return 0;
+}
+#endif				/* SDTEST */
+
+static int
+dhdsdio_membytes(dhd_bus_t *bus, bool write, u32 address, u8 *data,
+		 uint size)
+{
+	int bcmerror = 0;
+	u32 sdaddr;
+	uint dsize;
+
+	/* Determine initial transfer parameters */
+	sdaddr = address & SBSDIO_SB_OFT_ADDR_MASK;
+	if ((sdaddr + size) & SBSDIO_SBWINDOW_MASK)
+		dsize = (SBSDIO_SB_OFT_ADDR_LIMIT - sdaddr);
+	else
+		dsize = size;
+
+	/* Set the backplane window to include the start address */
+	bcmerror = dhdsdio_set_siaddr_window(bus, address);
+	if (bcmerror) {
+		DHD_ERROR(("%s: window change failed\n", __func__));
+		goto xfer_done;
+	}
+
+	/* Do the transfer(s) */
+	while (size) {
+		DHD_INFO(("%s: %s %d bytes at offset 0x%08x in window 0x%08x\n",
+			  __func__, (write ? "write" : "read"), dsize,
+			  sdaddr, (address & SBSDIO_SBWINDOW_MASK)));
+		bcmerror =
+		     bcmsdh_rwdata(bus->sdh, write, sdaddr, data, dsize);
+		if (bcmerror) {
+			DHD_ERROR(("%s: membytes transfer failed\n", __func__));
+			break;
+		}
+
+		/* Adjust for next transfer (if any) */
+		size -= dsize;
+		if (size) {
+			data += dsize;
+			address += dsize;
+			bcmerror = dhdsdio_set_siaddr_window(bus, address);
+			if (bcmerror) {
+				DHD_ERROR(("%s: window change failed\n",
+					   __func__));
+				break;
+			}
+			sdaddr = 0;
+			dsize = min_t(uint, SBSDIO_SB_OFT_ADDR_LIMIT, size);
+		}
+	}
+
+xfer_done:
+	/* Return the window to backplane enumeration space for core access */
+	if (dhdsdio_set_siaddr_window(bus, bcmsdh_cur_sbwad(bus->sdh))) {
+		DHD_ERROR(("%s: FAILED to set window back to 0x%x\n",
+			   __func__, bcmsdh_cur_sbwad(bus->sdh)));
+	}
+
+	return bcmerror;
+}
+
+#ifdef DHD_DEBUG
+static int dhdsdio_readshared(dhd_bus_t *bus, sdpcm_shared_t *sh)
+{
+	u32 addr;
+	int rv;
+
+	/* Read last word in memory to determine address of
+			 sdpcm_shared structure */
+	rv = dhdsdio_membytes(bus, false, bus->ramsize - 4, (u8 *)&addr, 4);
+	if (rv < 0)
+		return rv;
+
+	addr = ltoh32(addr);
+
+	DHD_INFO(("sdpcm_shared address 0x%08X\n", addr));
+
+	/*
+	 * Check if addr is valid.
+	 * NVRAM length at the end of memory should have been overwritten.
+	 */
+	if (addr == 0 || ((~addr >> 16) & 0xffff) == (addr & 0xffff)) {
+		DHD_ERROR(("%s: address (0x%08x) of sdpcm_shared invalid\n",
+			   __func__, addr));
+		return BCME_ERROR;
+	}
+
+	/* Read hndrte_shared structure */
+	rv = dhdsdio_membytes(bus, false, addr, (u8 *) sh,
+			      sizeof(sdpcm_shared_t));
+	if (rv < 0)
+		return rv;
+
+	/* Endianness */
+	sh->flags = ltoh32(sh->flags);
+	sh->trap_addr = ltoh32(sh->trap_addr);
+	sh->assert_exp_addr = ltoh32(sh->assert_exp_addr);
+	sh->assert_file_addr = ltoh32(sh->assert_file_addr);
+	sh->assert_line = ltoh32(sh->assert_line);
+	sh->console_addr = ltoh32(sh->console_addr);
+	sh->msgtrace_addr = ltoh32(sh->msgtrace_addr);
+
+	if ((sh->flags & SDPCM_SHARED_VERSION_MASK) != SDPCM_SHARED_VERSION) {
+		DHD_ERROR(("%s: sdpcm_shared version %d in dhd "
+			   "is different than sdpcm_shared version %d in dongle\n",
+			   __func__, SDPCM_SHARED_VERSION,
+			   sh->flags & SDPCM_SHARED_VERSION_MASK));
+		return BCME_ERROR;
+	}
+
+	return BCME_OK;
+}
+
+static int dhdsdio_checkdied(dhd_bus_t *bus, u8 *data, uint size)
+{
+	int bcmerror = 0;
+	uint msize = 512;
+	char *mbuffer = NULL;
+	uint maxstrlen = 256;
+	char *str = NULL;
+	trap_t tr;
+	sdpcm_shared_t sdpcm_shared;
+	struct bcmstrbuf strbuf;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	if (data == NULL) {
+		/*
+		 * Called after a rx ctrl timeout. "data" is NULL.
+		 * allocate memory to trace the trap or assert.
+		 */
+		size = msize;
+		mbuffer = data = kmalloc(msize, GFP_ATOMIC);
+		if (mbuffer == NULL) {
+			DHD_ERROR(("%s: kmalloc(%d) failed\n", __func__,
+				   msize));
+			bcmerror = BCME_NOMEM;
+			goto done;
+		}
+	}
+
+	str = kmalloc(maxstrlen, GFP_ATOMIC);
+	if (str == NULL) {
+		DHD_ERROR(("%s: kmalloc(%d) failed\n", __func__, maxstrlen));
+		bcmerror = BCME_NOMEM;
+		goto done;
+	}
+
+	bcmerror = dhdsdio_readshared(bus, &sdpcm_shared);
+	if (bcmerror < 0)
+		goto done;
+
+	bcm_binit(&strbuf, data, size);
+
+	bcm_bprintf(&strbuf,
+		    "msgtrace address : 0x%08X\nconsole address  : 0x%08X\n",
+		    sdpcm_shared.msgtrace_addr, sdpcm_shared.console_addr);
+
+	if ((sdpcm_shared.flags & SDPCM_SHARED_ASSERT_BUILT) == 0) {
+		/* NOTE: Misspelled assert is intentional - DO NOT FIX.
+		 * (Avoids conflict with real asserts for programmatic
+		 * parsing of output.)
+		 */
+		bcm_bprintf(&strbuf, "Assrt not built in dongle\n");
+	}
+
+	if ((sdpcm_shared.flags & (SDPCM_SHARED_ASSERT | SDPCM_SHARED_TRAP)) ==
+	    0) {
+		/* NOTE: Misspelled assert is intentional - DO NOT FIX.
+		 * (Avoids conflict with real asserts for programmatic
+		 * parsing of output.)
+		 */
+		bcm_bprintf(&strbuf, "No trap%s in dongle",
+			    (sdpcm_shared.flags & SDPCM_SHARED_ASSERT_BUILT)
+			    ? "/assrt" : "");
+	} else {
+		if (sdpcm_shared.flags & SDPCM_SHARED_ASSERT) {
+			/* Download assert */
+			bcm_bprintf(&strbuf, "Dongle assert");
+			if (sdpcm_shared.assert_exp_addr != 0) {
+				str[0] = '\0';
+				bcmerror = dhdsdio_membytes(bus, false,
+						sdpcm_shared.assert_exp_addr,
+						(u8 *) str, maxstrlen);
+				if (bcmerror < 0)
+					goto done;
+
+				str[maxstrlen - 1] = '\0';
+				bcm_bprintf(&strbuf, " expr \"%s\"", str);
+			}
+
+			if (sdpcm_shared.assert_file_addr != 0) {
+				str[0] = '\0';
+				bcmerror = dhdsdio_membytes(bus, false,
+						sdpcm_shared.assert_file_addr,
+						(u8 *) str, maxstrlen);
+				if (bcmerror < 0)
+					goto done;
+
+				str[maxstrlen - 1] = '\0';
+				bcm_bprintf(&strbuf, " file \"%s\"", str);
+			}
+
+			bcm_bprintf(&strbuf, " line %d ",
+				    sdpcm_shared.assert_line);
+		}
+
+		if (sdpcm_shared.flags & SDPCM_SHARED_TRAP) {
+			bcmerror = dhdsdio_membytes(bus, false,
+					sdpcm_shared.trap_addr, (u8 *)&tr,
+					sizeof(trap_t));
+			if (bcmerror < 0)
+				goto done;
+
+			bcm_bprintf(&strbuf,
+				    "Dongle trap type 0x%x @ epc 0x%x, cpsr 0x%x, spsr 0x%x, sp 0x%x,"
+				    "lp 0x%x, rpc 0x%x Trap offset 0x%x, "
+				    "r0 0x%x, r1 0x%x, r2 0x%x, r3 0x%x, r4 0x%x, r5 0x%x, r6 0x%x, r7 0x%x\n",
+				    tr.type, tr.epc, tr.cpsr, tr.spsr, tr.r13,
+				    tr.r14, tr.pc, sdpcm_shared.trap_addr,
+				    tr.r0, tr.r1, tr.r2, tr.r3, tr.r4, tr.r5,
+				    tr.r6, tr.r7);
+		}
+	}
+
+	if (sdpcm_shared.flags & (SDPCM_SHARED_ASSERT | SDPCM_SHARED_TRAP))
+		DHD_ERROR(("%s: %s\n", __func__, strbuf.origbuf));
+
+#ifdef DHD_DEBUG
+	if (sdpcm_shared.flags & SDPCM_SHARED_TRAP) {
+		/* Mem dump to a file on device */
+		dhdsdio_mem_dump(bus);
+	}
+#endif				/* DHD_DEBUG */
+
+done:
+	if (mbuffer)
+		kfree(mbuffer);
+	if (str)
+		kfree(str);
+
+	return bcmerror;
+}
+
+static int dhdsdio_mem_dump(dhd_bus_t *bus)
+{
+	int ret = 0;
+	int size;		/* Full mem size */
+	int start = 0;		/* Start address */
+	int read_size = 0;	/* Read size of each iteration */
+	u8 *buf = NULL, *databuf = NULL;
+
+	/* Get full mem size */
+	size = bus->ramsize;
+	buf = kmalloc(size, GFP_ATOMIC);
+	if (!buf) {
+		printf("%s: Out of memory (%d bytes)\n", __func__, size);
+		return -1;
+	}
+
+	/* Read mem content */
+	printf("Dump dongle memory");
+	databuf = buf;
+	while (size) {
+		read_size = min(MEMBLOCK, size);
+		ret = dhdsdio_membytes(bus, false, start, databuf, read_size);
+		if (ret) {
+			printf("%s: Error membytes %d\n", __func__, ret);
+			if (buf)
+				kfree(buf);
+			return -1;
+		}
+		printf(".");
+
+		/* Decrement size and increment start address */
+		size -= read_size;
+		start += read_size;
+		databuf += read_size;
+	}
+	printf("Done\n");
+
+	/* free buf before return !!! */
+	if (write_to_file(bus->dhd, buf, bus->ramsize)) {
+		printf("%s: Error writing to files\n", __func__);
+		return -1;
+	}
+
+	/* buf free handled in write_to_file, not here */
+	return 0;
+}
+
+#define CONSOLE_LINE_MAX	192
+
+static int dhdsdio_readconsole(dhd_bus_t *bus)
+{
+	dhd_console_t *c = &bus->console;
+	u8 line[CONSOLE_LINE_MAX], ch;
+	u32 n, idx, addr;
+	int rv;
+
+	/* Don't do anything until FWREADY updates console address */
+	if (bus->console_addr == 0)
+		return 0;
+
+	/* Read console log struct */
+	addr = bus->console_addr + offsetof(hndrte_cons_t, log);
+	rv = dhdsdio_membytes(bus, false, addr, (u8 *)&c->log,
+				sizeof(c->log));
+	if (rv < 0)
+		return rv;
+
+	/* Allocate console buffer (one time only) */
+	if (c->buf == NULL) {
+		c->bufsize = ltoh32(c->log.buf_size);
+		c->buf = kmalloc(c->bufsize, GFP_ATOMIC);
+		if (c->buf == NULL)
+			return BCME_NOMEM;
+	}
+
+	idx = ltoh32(c->log.idx);
+
+	/* Protect against corrupt value */
+	if (idx > c->bufsize)
+		return BCME_ERROR;
+
+	/* Skip reading the console buffer if the index pointer
+	 has not moved */
+	if (idx == c->last)
+		return BCME_OK;
+
+	/* Read the console buffer */
+	addr = ltoh32(c->log.buf);
+	rv = dhdsdio_membytes(bus, false, addr, c->buf, c->bufsize);
+	if (rv < 0)
+		return rv;
+
+	while (c->last != idx) {
+		for (n = 0; n < CONSOLE_LINE_MAX - 2; n++) {
+			if (c->last == idx) {
+				/* This would output a partial line.
+				 * Instead, back up
+				 * the buffer pointer and output this
+				 * line next time around.
+				 */
+				if (c->last >= n)
+					c->last -= n;
+				else
+					c->last = c->bufsize - n;
+				goto break2;
+			}
+			ch = c->buf[c->last];
+			c->last = (c->last + 1) % c->bufsize;
+			if (ch == '\n')
+				break;
+			line[n] = ch;
+		}
+
+		if (n > 0) {
+			if (line[n - 1] == '\r')
+				n--;
+			line[n] = 0;
+			printf("CONSOLE: %s\n", line);
+		}
+	}
+break2:
+
+	return BCME_OK;
+}
+#endif				/* DHD_DEBUG */
+
+int dhdsdio_downloadvars(dhd_bus_t *bus, void *arg, int len)
+{
+	int bcmerror = BCME_OK;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	/* Basic sanity checks */
+	if (bus->dhd->up) {
+		bcmerror = BCME_NOTDOWN;
+		goto err;
+	}
+	if (!len) {
+		bcmerror = BCME_BUFTOOSHORT;
+		goto err;
+	}
+
+	/* Free the old ones and replace with passed variables */
+	if (bus->vars)
+		kfree(bus->vars);
+
+	bus->vars = kmalloc(len, GFP_ATOMIC);
+	bus->varsz = bus->vars ? len : 0;
+	if (bus->vars == NULL) {
+		bcmerror = BCME_NOMEM;
+		goto err;
+	}
+
+	/* Copy the passed variables, which should include the
+		 terminating double-null */
+	bcopy(arg, bus->vars, bus->varsz);
+err:
+	return bcmerror;
+}
+
+static int
+dhdsdio_doiovar(dhd_bus_t *bus, const bcm_iovar_t *vi, u32 actionid,
+		const char *name, void *params, int plen, void *arg, int len,
+		int val_size)
+{
+	int bcmerror = 0;
+	s32 int_val = 0;
+	bool bool_val = 0;
+
+	DHD_TRACE(("%s: Enter, action %d name %s params %p plen %d arg %p "
+		"len %d val_size %d\n",
+		__func__, actionid, name, params, plen, arg, len, val_size));
+
+	bcmerror = bcm_iovar_lencheck(vi, arg, len, IOV_ISSET(actionid));
+	if (bcmerror != 0)
+		goto exit;
+
+	if (plen >= (int)sizeof(int_val))
+		bcopy(params, &int_val, sizeof(int_val));
+
+	bool_val = (int_val != 0) ? true : false;
+
+	/* Some ioctls use the bus */
+	dhd_os_sdlock(bus->dhd);
+
+	/* Check if dongle is in reset. If so, only allow DEVRESET iovars */
+	if (bus->dhd->dongle_reset && !(actionid == IOV_SVAL(IOV_DEVRESET) ||
+					actionid == IOV_GVAL(IOV_DEVRESET))) {
+		bcmerror = BCME_NOTREADY;
+		goto exit;
+	}
+
+	/* Handle sleep stuff before any clock mucking */
+	if (vi->varid == IOV_SLEEP) {
+		if (IOV_ISSET(actionid)) {
+			bcmerror = dhdsdio_bussleep(bus, bool_val);
+		} else {
+			int_val = (s32) bus->sleeping;
+			bcopy(&int_val, arg, val_size);
+		}
+		goto exit;
+	}
+
+	/* Request clock to allow SDIO accesses */
+	if (!bus->dhd->dongle_reset) {
+		BUS_WAKE(bus);
+		dhdsdio_clkctl(bus, CLK_AVAIL, false);
+	}
+
+	switch (actionid) {
+	case IOV_GVAL(IOV_INTR):
+		int_val = (s32) bus->intr;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_INTR):
+		bus->intr = bool_val;
+		bus->intdis = false;
+		if (bus->dhd->up) {
+			if (bus->intr) {
+				DHD_INTR(("%s: enable SDIO device interrupts\n",
+					  __func__));
+				bcmsdh_intr_enable(bus->sdh);
+			} else {
+				DHD_INTR(("%s: disable SDIO interrupts\n",
+					  __func__));
+				bcmsdh_intr_disable(bus->sdh);
+			}
+		}
+		break;
+
+	case IOV_GVAL(IOV_POLLRATE):
+		int_val = (s32) bus->pollrate;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_POLLRATE):
+		bus->pollrate = (uint) int_val;
+		bus->poll = (bus->pollrate != 0);
+		break;
+
+	case IOV_GVAL(IOV_IDLETIME):
+		int_val = bus->idletime;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_IDLETIME):
+		if ((int_val < 0) && (int_val != DHD_IDLE_IMMEDIATE))
+			bcmerror = BCME_BADARG;
+		else
+			bus->idletime = int_val;
+		break;
+
+	case IOV_GVAL(IOV_IDLECLOCK):
+		int_val = (s32) bus->idleclock;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_IDLECLOCK):
+		bus->idleclock = int_val;
+		break;
+
+	case IOV_GVAL(IOV_SD1IDLE):
+		int_val = (s32) sd1idle;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_SD1IDLE):
+		sd1idle = bool_val;
+		break;
+
+	case IOV_SVAL(IOV_MEMBYTES):
+	case IOV_GVAL(IOV_MEMBYTES):
+		{
+			u32 address;
+			uint size, dsize;
+			u8 *data;
+
+			bool set = (actionid == IOV_SVAL(IOV_MEMBYTES));
+
+			ASSERT(plen >= 2 * sizeof(int));
+
+			address = (u32) int_val;
+			bcopy((char *)params + sizeof(int_val), &int_val,
+			      sizeof(int_val));
+			size = (uint) int_val;
+
+			/* Do some validation */
+			dsize = set ? plen - (2 * sizeof(int)) : len;
+			if (dsize < size) {
+				DHD_ERROR(("%s: error on %s membytes, addr "
+				"0x%08x size %d dsize %d\n",
+				__func__, (set ? "set" : "get"),
+				address, size, dsize));
+				bcmerror = BCME_BADARG;
+				break;
+			}
+
+			DHD_INFO(("%s: Request to %s %d bytes at address "
+			"0x%08x\n",
+			__func__, (set ? "write" : "read"), size, address));
+
+			/* If we know about SOCRAM, check for a fit */
+			if ((bus->orig_ramsize) &&
+			    ((address > bus->orig_ramsize)
+			     || (address + size > bus->orig_ramsize))) {
+				DHD_ERROR(("%s: ramsize 0x%08x doesn't have %d "
+				"bytes at 0x%08x\n",
+				__func__, bus->orig_ramsize, size, address));
+				bcmerror = BCME_BADARG;
+				break;
+			}
+
+			/* Generate the actual data pointer */
+			data =
+			    set ? (u8 *) params +
+			    2 * sizeof(int) : (u8 *) arg;
+
+			/* Call to do the transfer */
+			bcmerror =
+			    dhdsdio_membytes(bus, set, address, data, size);
+
+			break;
+		}
+
+	case IOV_GVAL(IOV_MEMSIZE):
+		int_val = (s32) bus->ramsize;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_GVAL(IOV_SDIOD_DRIVE):
+		int_val = (s32) dhd_sdiod_drive_strength;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_SDIOD_DRIVE):
+		dhd_sdiod_drive_strength = int_val;
+		si_sdiod_drive_strength_init(bus->sih, bus->dhd->osh,
+					     dhd_sdiod_drive_strength);
+		break;
+
+	case IOV_SVAL(IOV_DOWNLOAD):
+		bcmerror = dhdsdio_download_state(bus, bool_val);
+		break;
+
+	case IOV_SVAL(IOV_VARS):
+		bcmerror = dhdsdio_downloadvars(bus, arg, len);
+		break;
+
+	case IOV_GVAL(IOV_READAHEAD):
+		int_val = (s32) dhd_readahead;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_READAHEAD):
+		if (bool_val && !dhd_readahead)
+			bus->nextlen = 0;
+		dhd_readahead = bool_val;
+		break;
+
+	case IOV_GVAL(IOV_SDRXCHAIN):
+		int_val = (s32) bus->use_rxchain;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_SDRXCHAIN):
+		if (bool_val && !bus->sd_rxchain)
+			bcmerror = BCME_UNSUPPORTED;
+		else
+			bus->use_rxchain = bool_val;
+		break;
+	case IOV_GVAL(IOV_ALIGNCTL):
+		int_val = (s32) dhd_alignctl;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_ALIGNCTL):
+		dhd_alignctl = bool_val;
+		break;
+
+	case IOV_GVAL(IOV_SDALIGN):
+		int_val = DHD_SDALIGN;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+#ifdef DHD_DEBUG
+	case IOV_GVAL(IOV_VARS):
+		if (bus->varsz < (uint) len)
+			bcopy(bus->vars, arg, bus->varsz);
+		else
+			bcmerror = BCME_BUFTOOSHORT;
+		break;
+#endif				/* DHD_DEBUG */
+
+#ifdef DHD_DEBUG
+	case IOV_GVAL(IOV_SDREG):
+		{
+			sdreg_t *sd_ptr;
+			u32 addr, size;
+
+			sd_ptr = (sdreg_t *) params;
+
+			addr = (unsigned long)bus->regs + sd_ptr->offset;
+			size = sd_ptr->func;
+			int_val = (s32) bcmsdh_reg_read(bus->sdh, addr, size);
+			if (bcmsdh_regfail(bus->sdh))
+				bcmerror = BCME_SDIO_ERROR;
+			bcopy(&int_val, arg, sizeof(s32));
+			break;
+		}
+
+	case IOV_SVAL(IOV_SDREG):
+		{
+			sdreg_t *sd_ptr;
+			u32 addr, size;
+
+			sd_ptr = (sdreg_t *) params;
+
+			addr = (unsigned long)bus->regs + sd_ptr->offset;
+			size = sd_ptr->func;
+			bcmsdh_reg_write(bus->sdh, addr, size, sd_ptr->value);
+			if (bcmsdh_regfail(bus->sdh))
+				bcmerror = BCME_SDIO_ERROR;
+			break;
+		}
+
+		/* Same as above, but offset is not backplane
+		 (not SDIO core) */
+	case IOV_GVAL(IOV_SBREG):
+		{
+			sdreg_t sdreg;
+			u32 addr, size;
+
+			bcopy(params, &sdreg, sizeof(sdreg));
+
+			addr = SI_ENUM_BASE + sdreg.offset;
+			size = sdreg.func;
+			int_val = (s32) bcmsdh_reg_read(bus->sdh, addr, size);
+			if (bcmsdh_regfail(bus->sdh))
+				bcmerror = BCME_SDIO_ERROR;
+			bcopy(&int_val, arg, sizeof(s32));
+			break;
+		}
+
+	case IOV_SVAL(IOV_SBREG):
+		{
+			sdreg_t sdreg;
+			u32 addr, size;
+
+			bcopy(params, &sdreg, sizeof(sdreg));
+
+			addr = SI_ENUM_BASE + sdreg.offset;
+			size = sdreg.func;
+			bcmsdh_reg_write(bus->sdh, addr, size, sdreg.value);
+			if (bcmsdh_regfail(bus->sdh))
+				bcmerror = BCME_SDIO_ERROR;
+			break;
+		}
+
+	case IOV_GVAL(IOV_SDCIS):
+		{
+			*(char *)arg = 0;
+
+			strcat(arg, "\nFunc 0\n");
+			bcmsdh_cis_read(bus->sdh, 0x10,
+					(u8 *) arg + strlen(arg),
+					SBSDIO_CIS_SIZE_LIMIT);
+			strcat(arg, "\nFunc 1\n");
+			bcmsdh_cis_read(bus->sdh, 0x11,
+					(u8 *) arg + strlen(arg),
+					SBSDIO_CIS_SIZE_LIMIT);
+			strcat(arg, "\nFunc 2\n");
+			bcmsdh_cis_read(bus->sdh, 0x12,
+					(u8 *) arg + strlen(arg),
+					SBSDIO_CIS_SIZE_LIMIT);
+			break;
+		}
+
+	case IOV_GVAL(IOV_FORCEEVEN):
+		int_val = (s32) forcealign;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_FORCEEVEN):
+		forcealign = bool_val;
+		break;
+
+	case IOV_GVAL(IOV_TXBOUND):
+		int_val = (s32) dhd_txbound;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_TXBOUND):
+		dhd_txbound = (uint) int_val;
+		break;
+
+	case IOV_GVAL(IOV_RXBOUND):
+		int_val = (s32) dhd_rxbound;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_RXBOUND):
+		dhd_rxbound = (uint) int_val;
+		break;
+
+	case IOV_GVAL(IOV_TXMINMAX):
+		int_val = (s32) dhd_txminmax;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_TXMINMAX):
+		dhd_txminmax = (uint) int_val;
+		break;
+#endif				/* DHD_DEBUG */
+
+#ifdef SDTEST
+	case IOV_GVAL(IOV_EXTLOOP):
+		int_val = (s32) bus->ext_loop;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_EXTLOOP):
+		bus->ext_loop = bool_val;
+		break;
+
+	case IOV_GVAL(IOV_PKTGEN):
+		bcmerror = dhdsdio_pktgen_get(bus, arg);
+		break;
+
+	case IOV_SVAL(IOV_PKTGEN):
+		bcmerror = dhdsdio_pktgen_set(bus, arg);
+		break;
+#endif				/* SDTEST */
+
+	case IOV_SVAL(IOV_DEVRESET):
+		DHD_TRACE(("%s: Called set IOV_DEVRESET=%d dongle_reset=%d "
+			"busstate=%d\n",
+			__func__, bool_val, bus->dhd->dongle_reset,
+			bus->dhd->busstate));
+
+		ASSERT(bus->dhd->osh);
+		/* ASSERT(bus->cl_devid); */
+
+		dhd_bus_devreset(bus->dhd, (u8) bool_val);
+
+		break;
+
+	case IOV_GVAL(IOV_DEVRESET):
+		DHD_TRACE(("%s: Called get IOV_DEVRESET\n", __func__));
+
+		/* Get its status */
+		int_val = (bool) bus->dhd->dongle_reset;
+		bcopy(&int_val, arg, val_size);
+
+		break;
+
+	default:
+		bcmerror = BCME_UNSUPPORTED;
+		break;
+	}
+
+exit:
+	if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
+		bus->activity = false;
+		dhdsdio_clkctl(bus, CLK_NONE, true);
+	}
+
+	dhd_os_sdunlock(bus->dhd);
+
+	if (actionid == IOV_SVAL(IOV_DEVRESET) && bool_val == false)
+		dhd_preinit_ioctls((dhd_pub_t *) bus->dhd);
+
+	return bcmerror;
+}
+
+static int dhdsdio_write_vars(dhd_bus_t *bus)
+{
+	int bcmerror = 0;
+	u32 varsize;
+	u32 varaddr;
+	u8 *vbuffer;
+	u32 varsizew;
+#ifdef DHD_DEBUG
+	char *nvram_ularray;
+#endif				/* DHD_DEBUG */
+
+	/* Even if there are no vars are to be written, we still
+		 need to set the ramsize. */
+	varsize = bus->varsz ? roundup(bus->varsz, 4) : 0;
+	varaddr = (bus->ramsize - 4) - varsize;
+
+	if (bus->vars) {
+		vbuffer = kmalloc(varsize, GFP_ATOMIC);
+		if (!vbuffer)
+			return BCME_NOMEM;
+
+		bzero(vbuffer, varsize);
+		bcopy(bus->vars, vbuffer, bus->varsz);
+
+		/* Write the vars list */
+		bcmerror =
+		    dhdsdio_membytes(bus, true, varaddr, vbuffer, varsize);
+#ifdef DHD_DEBUG
+		/* Verify NVRAM bytes */
+		DHD_INFO(("Compare NVRAM dl & ul; varsize=%d\n", varsize));
+		nvram_ularray = kmalloc(varsize, GFP_ATOMIC);
+		if (!nvram_ularray)
+			return BCME_NOMEM;
+
+		/* Upload image to verify downloaded contents. */
+		memset(nvram_ularray, 0xaa, varsize);
+
+		/* Read the vars list to temp buffer for comparison */
+		bcmerror =
+		    dhdsdio_membytes(bus, false, varaddr, nvram_ularray,
+				     varsize);
+		if (bcmerror) {
+			DHD_ERROR(("%s: error %d on reading %d nvram bytes at "
+			"0x%08x\n", __func__, bcmerror, varsize, varaddr));
+		}
+		/* Compare the org NVRAM with the one read from RAM */
+		if (memcmp(vbuffer, nvram_ularray, varsize)) {
+			DHD_ERROR(("%s: Downloaded NVRAM image is corrupted.\n",
+				   __func__));
+		} else
+			DHD_ERROR(("%s: Download/Upload/Compare of NVRAM ok.\n",
+				__func__));
+
+		kfree(nvram_ularray);
+#endif				/* DHD_DEBUG */
+
+		kfree(vbuffer);
+	}
+
+	/* adjust to the user specified RAM */
+	DHD_INFO(("Physical memory size: %d, usable memory size: %d\n",
+		  bus->orig_ramsize, bus->ramsize));
+	DHD_INFO(("Vars are at %d, orig varsize is %d\n", varaddr, varsize));
+	varsize = ((bus->orig_ramsize - 4) - varaddr);
+
+	/*
+	 * Determine the length token:
+	 * Varsize, converted to words, in lower 16-bits, checksum
+	 * in upper 16-bits.
+	 */
+	if (bcmerror) {
+		varsizew = 0;
+	} else {
+		varsizew = varsize / 4;
+		varsizew = (~varsizew << 16) | (varsizew & 0x0000FFFF);
+		varsizew = htol32(varsizew);
+	}
+
+	DHD_INFO(("New varsize is %d, length token=0x%08x\n", varsize,
+		  varsizew));
+
+	/* Write the length token to the last word */
+	bcmerror = dhdsdio_membytes(bus, true, (bus->orig_ramsize - 4),
+				    (u8 *)&varsizew, 4);
+
+	return bcmerror;
+}
+
+static int dhdsdio_download_state(dhd_bus_t *bus, bool enter)
+{
+	uint retries;
+	int bcmerror = 0;
+
+	/* To enter download state, disable ARM and reset SOCRAM.
+	 * To exit download state, simply reset ARM (default is RAM boot).
+	 */
+	if (enter) {
+
+		bus->alp_only = true;
+
+		if (!(si_setcore(bus->sih, ARM7S_CORE_ID, 0)) &&
+		    !(si_setcore(bus->sih, ARMCM3_CORE_ID, 0))) {
+			DHD_ERROR(("%s: Failed to find ARM core!\n", __func__));
+			bcmerror = BCME_ERROR;
+			goto fail;
+		}
+
+		si_core_disable(bus->sih, 0);
+		if (bcmsdh_regfail(bus->sdh)) {
+			bcmerror = BCME_SDIO_ERROR;
+			goto fail;
+		}
+
+		if (!(si_setcore(bus->sih, SOCRAM_CORE_ID, 0))) {
+			DHD_ERROR(("%s: Failed to find SOCRAM core!\n",
+				   __func__));
+			bcmerror = BCME_ERROR;
+			goto fail;
+		}
+
+		si_core_reset(bus->sih, 0, 0);
+		if (bcmsdh_regfail(bus->sdh)) {
+			DHD_ERROR(("%s: Failure trying reset SOCRAM core?\n",
+				   __func__));
+			bcmerror = BCME_SDIO_ERROR;
+			goto fail;
+		}
+
+		/* Clear the top bit of memory */
+		if (bus->ramsize) {
+			u32 zeros = 0;
+			dhdsdio_membytes(bus, true, bus->ramsize - 4,
+					 (u8 *)&zeros, 4);
+		}
+	} else {
+		if (!(si_setcore(bus->sih, SOCRAM_CORE_ID, 0))) {
+			DHD_ERROR(("%s: Failed to find SOCRAM core!\n",
+				   __func__));
+			bcmerror = BCME_ERROR;
+			goto fail;
+		}
+
+		if (!si_iscoreup(bus->sih)) {
+			DHD_ERROR(("%s: SOCRAM core is down after reset?\n",
+				   __func__));
+			bcmerror = BCME_ERROR;
+			goto fail;
+		}
+
+		bcmerror = dhdsdio_write_vars(bus);
+		if (bcmerror) {
+			DHD_ERROR(("%s: no vars written to RAM\n", __func__));
+			bcmerror = 0;
+		}
+
+		if (!si_setcore(bus->sih, PCMCIA_CORE_ID, 0) &&
+		    !si_setcore(bus->sih, SDIOD_CORE_ID, 0)) {
+			DHD_ERROR(("%s: Can't change back to SDIO core?\n",
+				   __func__));
+			bcmerror = BCME_ERROR;
+			goto fail;
+		}
+		W_SDREG(0xFFFFFFFF, &bus->regs->intstatus, retries);
+
+		if (!(si_setcore(bus->sih, ARM7S_CORE_ID, 0)) &&
+		    !(si_setcore(bus->sih, ARMCM3_CORE_ID, 0))) {
+			DHD_ERROR(("%s: Failed to find ARM core!\n", __func__));
+			bcmerror = BCME_ERROR;
+			goto fail;
+		}
+
+		si_core_reset(bus->sih, 0, 0);
+		if (bcmsdh_regfail(bus->sdh)) {
+			DHD_ERROR(("%s: Failure trying to reset ARM core?\n",
+				   __func__));
+			bcmerror = BCME_SDIO_ERROR;
+			goto fail;
+		}
+
+		/* Allow HT Clock now that the ARM is running. */
+		bus->alp_only = false;
+
+		bus->dhd->busstate = DHD_BUS_LOAD;
+	}
+
+fail:
+	/* Always return to SDIOD core */
+	if (!si_setcore(bus->sih, PCMCIA_CORE_ID, 0))
+		si_setcore(bus->sih, SDIOD_CORE_ID, 0);
+
+	return bcmerror;
+}
+
+int
+dhd_bus_iovar_op(dhd_pub_t *dhdp, const char *name,
+		 void *params, int plen, void *arg, int len, bool set)
+{
+	dhd_bus_t *bus = dhdp->bus;
+	const bcm_iovar_t *vi = NULL;
+	int bcmerror = 0;
+	int val_size;
+	u32 actionid;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	ASSERT(name);
+	ASSERT(len >= 0);
+
+	/* Get MUST have return space */
+	ASSERT(set || (arg && len));
+
+	/* Set does NOT take qualifiers */
+	ASSERT(!set || (!params && !plen));
+
+	/* Look up var locally; if not found pass to host driver */
+	vi = bcm_iovar_lookup(dhdsdio_iovars, name);
+	if (vi == NULL) {
+		dhd_os_sdlock(bus->dhd);
+
+		BUS_WAKE(bus);
+
+		/* Turn on clock in case SD command needs backplane */
+		dhdsdio_clkctl(bus, CLK_AVAIL, false);
+
+		bcmerror =
+		    bcmsdh_iovar_op(bus->sdh, name, params, plen, arg, len,
+				    set);
+
+		/* Check for bus configuration changes of interest */
+
+		/* If it was divisor change, read the new one */
+		if (set && strcmp(name, "sd_divisor") == 0) {
+			if (bcmsdh_iovar_op(bus->sdh, "sd_divisor", NULL, 0,
+					    &bus->sd_divisor, sizeof(s32),
+					    false) != BCME_OK) {
+				bus->sd_divisor = -1;
+				DHD_ERROR(("%s: fail on %s get\n", __func__,
+					   name));
+			} else {
+				DHD_INFO(("%s: noted %s update, value now %d\n",
+					  __func__, name, bus->sd_divisor));
+			}
+		}
+		/* If it was a mode change, read the new one */
+		if (set && strcmp(name, "sd_mode") == 0) {
+			if (bcmsdh_iovar_op(bus->sdh, "sd_mode", NULL, 0,
+					    &bus->sd_mode, sizeof(s32),
+					    false) != BCME_OK) {
+				bus->sd_mode = -1;
+				DHD_ERROR(("%s: fail on %s get\n", __func__,
+					   name));
+			} else {
+				DHD_INFO(("%s: noted %s update, value now %d\n",
+					  __func__, name, bus->sd_mode));
+			}
+		}
+		/* Similar check for blocksize change */
+		if (set && strcmp(name, "sd_blocksize") == 0) {
+			s32 fnum = 2;
+			if (bcmsdh_iovar_op
+			    (bus->sdh, "sd_blocksize", &fnum, sizeof(s32),
+			     &bus->blocksize, sizeof(s32),
+			     false) != BCME_OK) {
+				bus->blocksize = 0;
+				DHD_ERROR(("%s: fail on %s get\n", __func__,
+					   "sd_blocksize"));
+			} else {
+				DHD_INFO(("%s: noted %s update, value now %d\n",
+					  __func__, "sd_blocksize",
+					  bus->blocksize));
+			}
+		}
+		bus->roundup = min(max_roundup, bus->blocksize);
+
+		if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
+			bus->activity = false;
+			dhdsdio_clkctl(bus, CLK_NONE, true);
+		}
+
+		dhd_os_sdunlock(bus->dhd);
+		goto exit;
+	}
+
+	DHD_CTL(("%s: %s %s, len %d plen %d\n", __func__,
+		 name, (set ? "set" : "get"), len, plen));
+
+	/* set up 'params' pointer in case this is a set command so that
+	 * the convenience int and bool code can be common to set and get
+	 */
+	if (params == NULL) {
+		params = arg;
+		plen = len;
+	}
+
+	if (vi->type == IOVT_VOID)
+		val_size = 0;
+	else if (vi->type == IOVT_BUFFER)
+		val_size = len;
+	else
+		/* all other types are integer sized */
+		val_size = sizeof(int);
+
+	actionid = set ? IOV_SVAL(vi->varid) : IOV_GVAL(vi->varid);
+	bcmerror =
+	    dhdsdio_doiovar(bus, vi, actionid, name, params, plen, arg, len,
+			    val_size);
+
+exit:
+	return bcmerror;
+}
+
+void dhd_bus_stop(struct dhd_bus *bus, bool enforce_mutex)
+{
+	osl_t *osh = bus->dhd->osh;
+	u32 local_hostintmask;
+	u8 saveclk;
+	uint retries;
+	int err;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	if (enforce_mutex)
+		dhd_os_sdlock(bus->dhd);
+
+	BUS_WAKE(bus);
+
+	/* Enable clock for device interrupts */
+	dhdsdio_clkctl(bus, CLK_AVAIL, false);
+
+	/* Disable and clear interrupts at the chip level also */
+	W_SDREG(0, &bus->regs->hostintmask, retries);
+	local_hostintmask = bus->hostintmask;
+	bus->hostintmask = 0;
+
+	/* Change our idea of bus state */
+	bus->dhd->busstate = DHD_BUS_DOWN;
+
+	/* Force clocks on backplane to be sure F2 interrupt propagates */
+	saveclk =
+	    bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
+			    &err);
+	if (!err) {
+		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
+				 (saveclk | SBSDIO_FORCE_HT), &err);
+	}
+	if (err) {
+		DHD_ERROR(("%s: Failed to force clock for F2: err %d\n",
+			   __func__, err));
+	}
+
+	/* Turn off the bus (F2), free any pending packets */
+	DHD_INTR(("%s: disable SDIO interrupts\n", __func__));
+	bcmsdh_intr_disable(bus->sdh);
+	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_IOEN,
+			 SDIO_FUNC_ENABLE_1, NULL);
+
+	/* Clear any pending interrupts now that F2 is disabled */
+	W_SDREG(local_hostintmask, &bus->regs->intstatus, retries);
+
+	/* Turn off the backplane clock (only) */
+	dhdsdio_clkctl(bus, CLK_SDONLY, false);
+
+	/* Clear the data packet queues */
+	pktq_flush(osh, &bus->txq, true);
+
+	/* Clear any held glomming stuff */
+	if (bus->glomd)
+		PKTFREE(osh, bus->glomd, false);
+
+	if (bus->glom)
+		PKTFREE(osh, bus->glom, false);
+
+	bus->glom = bus->glomd = NULL;
+
+	/* Clear rx control and wake any waiters */
+	bus->rxlen = 0;
+	dhd_os_ioctl_resp_wake(bus->dhd);
+
+	/* Reset some F2 state stuff */
+	bus->rxskip = false;
+	bus->tx_seq = bus->rx_seq = 0;
+
+	if (enforce_mutex)
+		dhd_os_sdunlock(bus->dhd);
+}
+
+int dhd_bus_init(dhd_pub_t *dhdp, bool enforce_mutex)
+{
+	dhd_bus_t *bus = dhdp->bus;
+	dhd_timeout_t tmo;
+	uint retries = 0;
+	u8 ready, enable;
+	int err, ret = 0;
+	u8 saveclk;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	ASSERT(bus->dhd);
+	if (!bus->dhd)
+		return 0;
+
+	if (enforce_mutex)
+		dhd_os_sdlock(bus->dhd);
+
+	/* Make sure backplane clock is on, needed to generate F2 interrupt */
+	dhdsdio_clkctl(bus, CLK_AVAIL, false);
+	if (bus->clkstate != CLK_AVAIL)
+		goto exit;
+
+	/* Force clocks on backplane to be sure F2 interrupt propagates */
+	saveclk =
+	    bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
+			    &err);
+	if (!err) {
+		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
+				 (saveclk | SBSDIO_FORCE_HT), &err);
+	}
+	if (err) {
+		DHD_ERROR(("%s: Failed to force clock for F2: err %d\n",
+			   __func__, err));
+		goto exit;
+	}
+
+	/* Enable function 2 (frame transfers) */
+	W_SDREG((SDPCM_PROT_VERSION << SMB_DATA_VERSION_SHIFT),
+		&bus->regs->tosbmailboxdata, retries);
+	enable = (SDIO_FUNC_ENABLE_1 | SDIO_FUNC_ENABLE_2);
+
+	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_IOEN, enable, NULL);
+
+	/* Give the dongle some time to do its thing and set IOR2 */
+	dhd_timeout_start(&tmo, DHD_WAIT_F2RDY * 1000);
+
+	ready = 0;
+	while (ready != enable && !dhd_timeout_expired(&tmo))
+		ready =
+		    bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_IORDY,
+				    NULL);
+
+	DHD_INFO(("%s: enable 0x%02x, ready 0x%02x (waited %uus)\n",
+		  __func__, enable, ready, tmo.elapsed));
+
+	/* If F2 successfully enabled, set core and enable interrupts */
+	if (ready == enable) {
+		/* Make sure we're talking to the core. */
+		bus->regs = si_setcore(bus->sih, PCMCIA_CORE_ID, 0);
+		if (!(bus->regs))
+			bus->regs = si_setcore(bus->sih, SDIOD_CORE_ID, 0);
+
+		/* Set up the interrupt mask and enable interrupts */
+		bus->hostintmask = HOSTINTMASK;
+		W_SDREG(bus->hostintmask, &bus->regs->hostintmask, retries);
+
+		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_WATERMARK,
+				 (u8) watermark, &err);
+
+		/* Set bus state according to enable result */
+		dhdp->busstate = DHD_BUS_DATA;
+
+		/* bcmsdh_intr_unmask(bus->sdh); */
+
+		bus->intdis = false;
+		if (bus->intr) {
+			DHD_INTR(("%s: enable SDIO device interrupts\n",
+				  __func__));
+			bcmsdh_intr_enable(bus->sdh);
+		} else {
+			DHD_INTR(("%s: disable SDIO interrupts\n", __func__));
+			bcmsdh_intr_disable(bus->sdh);
+		}
+
+	}
+
+	else {
+		/* Disable F2 again */
+		enable = SDIO_FUNC_ENABLE_1;
+		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_IOEN, enable,
+				 NULL);
+	}
+
+	/* Restore previous clock setting */
+	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
+			 saveclk, &err);
+
+	/* If we didn't come up, turn off backplane clock */
+	if (dhdp->busstate != DHD_BUS_DATA)
+		dhdsdio_clkctl(bus, CLK_NONE, false);
+
+exit:
+	if (enforce_mutex)
+		dhd_os_sdunlock(bus->dhd);
+
+	return ret;
+}
+
+static void dhdsdio_rxfail(dhd_bus_t *bus, bool abort, bool rtx)
+{
+	bcmsdh_info_t *sdh = bus->sdh;
+	sdpcmd_regs_t *regs = bus->regs;
+	uint retries = 0;
+	u16 lastrbc;
+	u8 hi, lo;
+	int err;
+
+	DHD_ERROR(("%s: %sterminate frame%s\n", __func__,
+		   (abort ? "abort command, " : ""),
+		   (rtx ? ", send NAK" : "")));
+
+	if (abort)
+		bcmsdh_abort(sdh, SDIO_FUNC_2);
+
+	bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_FRAMECTRL, SFC_RF_TERM,
+			 &err);
+	bus->f1regdata++;
+
+	/* Wait until the packet has been flushed (device/FIFO stable) */
+	for (lastrbc = retries = 0xffff; retries > 0; retries--) {
+		hi = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_RFRAMEBCHI,
+				     NULL);
+		lo = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_RFRAMEBCLO,
+				     NULL);
+		bus->f1regdata += 2;
+
+		if ((hi == 0) && (lo == 0))
+			break;
+
+		if ((hi > (lastrbc >> 8)) && (lo > (lastrbc & 0x00ff))) {
+			DHD_ERROR(("%s: count growing: last 0x%04x now "
+				"0x%04x\n",
+				__func__, lastrbc, ((hi << 8) + lo)));
+		}
+		lastrbc = (hi << 8) + lo;
+	}
+
+	if (!retries) {
+		DHD_ERROR(("%s: count never zeroed: last 0x%04x\n",
+			   __func__, lastrbc));
+	} else {
+		DHD_INFO(("%s: flush took %d iterations\n", __func__,
+			  (0xffff - retries)));
+	}
+
+	if (rtx) {
+		bus->rxrtx++;
+		W_SDREG(SMB_NAK, &regs->tosbmailbox, retries);
+		bus->f1regdata++;
+		if (retries <= retry_limit)
+			bus->rxskip = true;
+	}
+
+	/* Clear partial in any case */
+	bus->nextlen = 0;
+
+	/* If we can't reach the device, signal failure */
+	if (err || bcmsdh_regfail(sdh))
+		bus->dhd->busstate = DHD_BUS_DOWN;
+}
+
+static void
+dhdsdio_read_control(dhd_bus_t *bus, u8 *hdr, uint len, uint doff)
+{
+	bcmsdh_info_t *sdh = bus->sdh;
+	uint rdlen, pad;
+
+	int sdret;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	/* Control data already received in aligned rxctl */
+	if ((bus->bus == SPI_BUS) && (!bus->usebufpool))
+		goto gotpkt;
+
+	ASSERT(bus->rxbuf);
+	/* Set rxctl for frame (w/optional alignment) */
+	bus->rxctl = bus->rxbuf;
+	if (dhd_alignctl) {
+		bus->rxctl += firstread;
+		pad = ((unsigned long)bus->rxctl % DHD_SDALIGN);
+		if (pad)
+			bus->rxctl += (DHD_SDALIGN - pad);
+		bus->rxctl -= firstread;
+	}
+	ASSERT(bus->rxctl >= bus->rxbuf);
+
+	/* Copy the already-read portion over */
+	bcopy(hdr, bus->rxctl, firstread);
+	if (len <= firstread)
+		goto gotpkt;
+
+	/* Copy the full data pkt in gSPI case and process ioctl. */
+	if (bus->bus == SPI_BUS) {
+		bcopy(hdr, bus->rxctl, len);
+		goto gotpkt;
+	}
+
+	/* Raise rdlen to next SDIO block to avoid tail command */
+	rdlen = len - firstread;
+	if (bus->roundup && bus->blocksize && (rdlen > bus->blocksize)) {
+		pad = bus->blocksize - (rdlen % bus->blocksize);
+		if ((pad <= bus->roundup) && (pad < bus->blocksize) &&
+		    ((len + pad) < bus->dhd->maxctl))
+			rdlen += pad;
+	} else if (rdlen % DHD_SDALIGN) {
+		rdlen += DHD_SDALIGN - (rdlen % DHD_SDALIGN);
+	}
+
+	/* Satisfy length-alignment requirements */
+	if (forcealign && (rdlen & (ALIGNMENT - 1)))
+		rdlen = roundup(rdlen, ALIGNMENT);
+
+	/* Drop if the read is too big or it exceeds our maximum */
+	if ((rdlen + firstread) > bus->dhd->maxctl) {
+		DHD_ERROR(("%s: %d-byte control read exceeds %d-byte buffer\n",
+			   __func__, rdlen, bus->dhd->maxctl));
+		bus->dhd->rx_errors++;
+		dhdsdio_rxfail(bus, false, false);
+		goto done;
+	}
+
+	if ((len - doff) > bus->dhd->maxctl) {
+		DHD_ERROR(("%s: %d-byte ctl frame (%d-byte ctl data) exceeds "
+			"%d-byte limit\n",
+			__func__, len, (len - doff), bus->dhd->maxctl));
+		bus->dhd->rx_errors++;
+		bus->rx_toolong++;
+		dhdsdio_rxfail(bus, false, false);
+		goto done;
+	}
+
+	/* Read remainder of frame body into the rxctl buffer */
+	sdret =
+	    dhd_bcmsdh_recv_buf(bus, bcmsdh_cur_sbwad(sdh), SDIO_FUNC_2, F2SYNC,
+				(bus->rxctl + firstread), rdlen, NULL, NULL,
+				NULL);
+	bus->f2rxdata++;
+	ASSERT(sdret != BCME_PENDING);
+
+	/* Control frame failures need retransmission */
+	if (sdret < 0) {
+		DHD_ERROR(("%s: read %d control bytes failed: %d\n",
+			   __func__, rdlen, sdret));
+		bus->rxc_errors++;	/* dhd.rx_ctlerrs is higher level */
+		dhdsdio_rxfail(bus, true, true);
+		goto done;
+	}
+
+gotpkt:
+
+#ifdef DHD_DEBUG
+	if (DHD_BYTES_ON() && DHD_CTL_ON())
+		prhex("RxCtrl", bus->rxctl, len);
+#endif
+
+	/* Point to valid data and indicate its length */
+	bus->rxctl += doff;
+	bus->rxlen = len - doff;
+
+done:
+	/* Awake any waiters */
+	dhd_os_ioctl_resp_wake(bus->dhd);
+}
+
+static u8 dhdsdio_rxglom(dhd_bus_t *bus, u8 rxseq)
+{
+	u16 dlen, totlen;
+	u8 *dptr, num = 0;
+
+	u16 sublen, check;
+	void *pfirst, *plast, *pnext, *save_pfirst;
+	osl_t *osh = bus->dhd->osh;
+
+	int errcode;
+	u8 chan, seq, doff, sfdoff;
+	u8 txmax;
+
+	int ifidx = 0;
+	bool usechain = bus->use_rxchain;
+
+	/* If packets, issue read(s) and send up packet chain */
+	/* Return sequence numbers consumed? */
+
+	DHD_TRACE(("dhdsdio_rxglom: start: glomd %p glom %p\n", bus->glomd,
+		   bus->glom));
+
+	/* If there's a descriptor, generate the packet chain */
+	if (bus->glomd) {
+		dhd_os_sdlock_rxq(bus->dhd);
+
+		pfirst = plast = pnext = NULL;
+		dlen = (u16) PKTLEN(bus->glomd);
+		dptr = PKTDATA(bus->glomd);
+		if (!dlen || (dlen & 1)) {
+			DHD_ERROR(("%s: bad glomd len(%d), ignore descriptor\n",
+			__func__, dlen));
+			dlen = 0;
+		}
+
+		for (totlen = num = 0; dlen; num++) {
+			/* Get (and move past) next length */
+			sublen = ltoh16_ua(dptr);
+			dlen -= sizeof(u16);
+			dptr += sizeof(u16);
+			if ((sublen < SDPCM_HDRLEN) ||
+			    ((num == 0) && (sublen < (2 * SDPCM_HDRLEN)))) {
+				DHD_ERROR(("%s: descriptor len %d bad: %d\n",
+					   __func__, num, sublen));
+				pnext = NULL;
+				break;
+			}
+			if (sublen % DHD_SDALIGN) {
+				DHD_ERROR(("%s: sublen %d not multiple of %d\n",
+				__func__, sublen, DHD_SDALIGN));
+				usechain = false;
+			}
+			totlen += sublen;
+
+			/* For last frame, adjust read len so total
+				 is a block multiple */
+			if (!dlen) {
+				sublen +=
+				    (roundup(totlen, bus->blocksize) - totlen);
+				totlen = roundup(totlen, bus->blocksize);
+			}
+
+			/* Allocate/chain packet for next subframe */
+			pnext = PKTGET(osh, sublen + DHD_SDALIGN, false);
+			if (pnext == NULL) {
+				DHD_ERROR(("%s: PKTGET failed, num %d len %d\n",
+					   __func__, num, sublen));
+				break;
+			}
+			ASSERT(!PKTLINK(pnext));
+			if (!pfirst) {
+				ASSERT(!plast);
+				pfirst = plast = pnext;
+			} else {
+				ASSERT(plast);
+				PKTSETNEXT(plast, pnext);
+				plast = pnext;
+			}
+
+			/* Adhere to start alignment requirements */
+			PKTALIGN(osh, pnext, sublen, DHD_SDALIGN);
+		}
+
+		/* If all allocations succeeded, save packet chain
+			 in bus structure */
+		if (pnext) {
+			DHD_GLOM(("%s: allocated %d-byte packet chain for %d "
+				"subframes\n", __func__, totlen, num));
+			if (DHD_GLOM_ON() && bus->nextlen) {
+				if (totlen != bus->nextlen) {
+					DHD_GLOM(("%s: glomdesc mismatch: nextlen %d glomdesc %d " "rxseq %d\n",
+						__func__, bus->nextlen,
+						totlen, rxseq));
+				}
+			}
+			bus->glom = pfirst;
+			pfirst = pnext = NULL;
+		} else {
+			if (pfirst)
+				PKTFREE(osh, pfirst, false);
+			bus->glom = NULL;
+			num = 0;
+		}
+
+		/* Done with descriptor packet */
+		PKTFREE(osh, bus->glomd, false);
+		bus->glomd = NULL;
+		bus->nextlen = 0;
+
+		dhd_os_sdunlock_rxq(bus->dhd);
+	}
+
+	/* Ok -- either we just generated a packet chain,
+		 or had one from before */
+	if (bus->glom) {
+		if (DHD_GLOM_ON()) {
+			DHD_GLOM(("%s: try superframe read, packet chain:\n",
+				__func__));
+			for (pnext = bus->glom; pnext; pnext = PKTNEXT(pnext)) {
+				DHD_GLOM(("    %p: %p len 0x%04x (%d)\n",
+					  pnext, (u8 *) PKTDATA(pnext),
+					  PKTLEN(pnext), PKTLEN(pnext)));
+			}
+		}
+
+		pfirst = bus->glom;
+		dlen = (u16) pkttotlen(osh, pfirst);
+
+		/* Do an SDIO read for the superframe.  Configurable iovar to
+		 * read directly into the chained packet, or allocate a large
+		 * packet and and copy into the chain.
+		 */
+		if (usechain) {
+			errcode = dhd_bcmsdh_recv_buf(bus,
+						      bcmsdh_cur_sbwad
+						      (bus->sdh), SDIO_FUNC_2,
+						      F2SYNC,
+						      (u8 *) PKTDATA(pfirst),
+						      dlen, pfirst, NULL, NULL);
+		} else if (bus->dataptr) {
+			errcode = dhd_bcmsdh_recv_buf(bus,
+						      bcmsdh_cur_sbwad
+						      (bus->sdh), SDIO_FUNC_2,
+						      F2SYNC, bus->dataptr,
+						      dlen, NULL, NULL, NULL);
+			sublen =
+			    (u16) pktfrombuf(osh, pfirst, 0, dlen,
+						bus->dataptr);
+			if (sublen != dlen) {
+				DHD_ERROR(("%s: FAILED TO COPY, dlen %d sublen %d\n",
+					__func__, dlen, sublen));
+				errcode = -1;
+			}
+			pnext = NULL;
+		} else {
+			DHD_ERROR(("COULDN'T ALLOC %d-BYTE GLOM, FORCE FAILURE\n",
+				dlen));
+			errcode = -1;
+		}
+		bus->f2rxdata++;
+		ASSERT(errcode != BCME_PENDING);
+
+		/* On failure, kill the superframe, allow a couple retries */
+		if (errcode < 0) {
+			DHD_ERROR(("%s: glom read of %d bytes failed: %d\n",
+				   __func__, dlen, errcode));
+			bus->dhd->rx_errors++;
+
+			if (bus->glomerr++ < 3) {
+				dhdsdio_rxfail(bus, true, true);
+			} else {
+				bus->glomerr = 0;
+				dhdsdio_rxfail(bus, true, false);
+				dhd_os_sdlock_rxq(bus->dhd);
+				PKTFREE(osh, bus->glom, false);
+				dhd_os_sdunlock_rxq(bus->dhd);
+				bus->rxglomfail++;
+				bus->glom = NULL;
+			}
+			return 0;
+		}
+#ifdef DHD_DEBUG
+		if (DHD_GLOM_ON()) {
+			prhex("SUPERFRAME", PKTDATA(pfirst),
+			      min_t(int, PKTLEN(pfirst), 48));
+		}
+#endif
+
+		/* Validate the superframe header */
+		dptr = (u8 *) PKTDATA(pfirst);
+		sublen = ltoh16_ua(dptr);
+		check = ltoh16_ua(dptr + sizeof(u16));
+
+		chan = SDPCM_PACKET_CHANNEL(&dptr[SDPCM_FRAMETAG_LEN]);
+		seq = SDPCM_PACKET_SEQUENCE(&dptr[SDPCM_FRAMETAG_LEN]);
+		bus->nextlen = dptr[SDPCM_FRAMETAG_LEN + SDPCM_NEXTLEN_OFFSET];
+		if ((bus->nextlen << 4) > MAX_RX_DATASZ) {
+			DHD_INFO(("%s: nextlen too large (%d) seq %d\n",
+				__func__, bus->nextlen, seq));
+			bus->nextlen = 0;
+		}
+		doff = SDPCM_DOFFSET_VALUE(&dptr[SDPCM_FRAMETAG_LEN]);
+		txmax = SDPCM_WINDOW_VALUE(&dptr[SDPCM_FRAMETAG_LEN]);
+
+		errcode = 0;
+		if ((u16)~(sublen ^ check)) {
+			DHD_ERROR(("%s (superframe): HW hdr error: len/check "
+				"0x%04x/0x%04x\n", __func__, sublen, check));
+			errcode = -1;
+		} else if (roundup(sublen, bus->blocksize) != dlen) {
+			DHD_ERROR(("%s (superframe): len 0x%04x, rounded "
+				"0x%04x, expect 0x%04x\n",
+				__func__, sublen,
+				roundup(sublen, bus->blocksize), dlen));
+			errcode = -1;
+		} else if (SDPCM_PACKET_CHANNEL(&dptr[SDPCM_FRAMETAG_LEN]) !=
+			   SDPCM_GLOM_CHANNEL) {
+			DHD_ERROR(("%s (superframe): bad channel %d\n",
+				   __func__,
+				   SDPCM_PACKET_CHANNEL(&dptr
+							[SDPCM_FRAMETAG_LEN])));
+			errcode = -1;
+		} else if (SDPCM_GLOMDESC(&dptr[SDPCM_FRAMETAG_LEN])) {
+			DHD_ERROR(("%s (superframe): got second descriptor?\n",
+				   __func__));
+			errcode = -1;
+		} else if ((doff < SDPCM_HDRLEN) ||
+			   (doff > (PKTLEN(pfirst) - SDPCM_HDRLEN))) {
+			DHD_ERROR(("%s (superframe): Bad data offset %d: HW %d "
+				"pkt %d min %d\n",
+				__func__, doff, sublen,
+				PKTLEN(pfirst), SDPCM_HDRLEN));
+			errcode = -1;
+		}
+
+		/* Check sequence number of superframe SW header */
+		if (rxseq != seq) {
+			DHD_INFO(("%s: (superframe) rx_seq %d, expected %d\n",
+				  __func__, seq, rxseq));
+			bus->rx_badseq++;
+			rxseq = seq;
+		}
+
+		/* Check window for sanity */
+		if ((u8) (txmax - bus->tx_seq) > 0x40) {
+			DHD_ERROR(("%s: unlikely tx max %d with tx_seq %d\n",
+				__func__, txmax, bus->tx_seq));
+			txmax = bus->tx_seq + 2;
+		}
+		bus->tx_max = txmax;
+
+		/* Remove superframe header, remember offset */
+		PKTPULL(pfirst, doff);
+		sfdoff = doff;
+
+		/* Validate all the subframe headers */
+		for (num = 0, pnext = pfirst; pnext && !errcode;
+		     num++, pnext = PKTNEXT(pnext)) {
+			dptr = (u8 *) PKTDATA(pnext);
+			dlen = (u16) PKTLEN(pnext);
+			sublen = ltoh16_ua(dptr);
+			check = ltoh16_ua(dptr + sizeof(u16));
+			chan = SDPCM_PACKET_CHANNEL(&dptr[SDPCM_FRAMETAG_LEN]);
+			doff = SDPCM_DOFFSET_VALUE(&dptr[SDPCM_FRAMETAG_LEN]);
+#ifdef DHD_DEBUG
+			if (DHD_GLOM_ON())
+				prhex("subframe", dptr, 32);
+#endif
+
+			if ((u16)~(sublen ^ check)) {
+				DHD_ERROR(("%s (subframe %d): HW hdr error: "
+					   "len/check 0x%04x/0x%04x\n",
+					   __func__, num, sublen, check));
+				errcode = -1;
+			} else if ((sublen > dlen) || (sublen < SDPCM_HDRLEN)) {
+				DHD_ERROR(("%s (subframe %d): length mismatch: "
+					   "len 0x%04x, expect 0x%04x\n",
+					   __func__, num, sublen, dlen));
+				errcode = -1;
+			} else if ((chan != SDPCM_DATA_CHANNEL) &&
+				   (chan != SDPCM_EVENT_CHANNEL)) {
+				DHD_ERROR(("%s (subframe %d): bad channel %d\n",
+					   __func__, num, chan));
+				errcode = -1;
+			} else if ((doff < SDPCM_HDRLEN) || (doff > sublen)) {
+				DHD_ERROR(("%s (subframe %d): Bad data offset %d: HW %d min %d\n",
+					__func__, num, doff, sublen,
+					SDPCM_HDRLEN));
+				errcode = -1;
+			}
+		}
+
+		if (errcode) {
+			/* Terminate frame on error, request
+				 a couple retries */
+			if (bus->glomerr++ < 3) {
+				/* Restore superframe header space */
+				PKTPUSH(pfirst, sfdoff);
+				dhdsdio_rxfail(bus, true, true);
+			} else {
+				bus->glomerr = 0;
+				dhdsdio_rxfail(bus, true, false);
+				dhd_os_sdlock_rxq(bus->dhd);
+				PKTFREE(osh, bus->glom, false);
+				dhd_os_sdunlock_rxq(bus->dhd);
+				bus->rxglomfail++;
+				bus->glom = NULL;
+			}
+			bus->nextlen = 0;
+			return 0;
+		}
+
+		/* Basic SD framing looks ok - process each packet (header) */
+		save_pfirst = pfirst;
+		bus->glom = NULL;
+		plast = NULL;
+
+		dhd_os_sdlock_rxq(bus->dhd);
+		for (num = 0; pfirst; rxseq++, pfirst = pnext) {
+			pnext = PKTNEXT(pfirst);
+			PKTSETNEXT(pfirst, NULL);
+
+			dptr = (u8 *) PKTDATA(pfirst);
+			sublen = ltoh16_ua(dptr);
+			chan = SDPCM_PACKET_CHANNEL(&dptr[SDPCM_FRAMETAG_LEN]);
+			seq = SDPCM_PACKET_SEQUENCE(&dptr[SDPCM_FRAMETAG_LEN]);
+			doff = SDPCM_DOFFSET_VALUE(&dptr[SDPCM_FRAMETAG_LEN]);
+
+			DHD_GLOM(("%s: Get subframe %d, %p(%p/%d), sublen %d "
+				"chan %d seq %d\n",
+				__func__, num, pfirst, PKTDATA(pfirst),
+				PKTLEN(pfirst), sublen, chan, seq));
+
+			ASSERT((chan == SDPCM_DATA_CHANNEL)
+			       || (chan == SDPCM_EVENT_CHANNEL));
+
+			if (rxseq != seq) {
+				DHD_GLOM(("%s: rx_seq %d, expected %d\n",
+					  __func__, seq, rxseq));
+				bus->rx_badseq++;
+				rxseq = seq;
+			}
+#ifdef DHD_DEBUG
+			if (DHD_BYTES_ON() && DHD_DATA_ON())
+				prhex("Rx Subframe Data", dptr, dlen);
+#endif
+
+			PKTSETLEN(pfirst, sublen);
+			PKTPULL(pfirst, doff);
+
+			if (PKTLEN(pfirst) == 0) {
+				PKTFREE(bus->dhd->osh, pfirst, false);
+				if (plast) {
+					PKTSETNEXT(plast, pnext);
+				} else {
+					ASSERT(save_pfirst == pfirst);
+					save_pfirst = pnext;
+				}
+				continue;
+			} else if (dhd_prot_hdrpull(bus->dhd, &ifidx, pfirst) !=
+				   0) {
+				DHD_ERROR(("%s: rx protocol error\n",
+					   __func__));
+				bus->dhd->rx_errors++;
+				PKTFREE(osh, pfirst, false);
+				if (plast) {
+					PKTSETNEXT(plast, pnext);
+				} else {
+					ASSERT(save_pfirst == pfirst);
+					save_pfirst = pnext;
+				}
+				continue;
+			}
+
+			/* this packet will go up, link back into
+				 chain and count it */
+			PKTSETNEXT(pfirst, pnext);
+			plast = pfirst;
+			num++;
+
+#ifdef DHD_DEBUG
+			if (DHD_GLOM_ON()) {
+				DHD_GLOM(("%s subframe %d to stack, %p(%p/%d) "
+				"nxt/lnk %p/%p\n",
+				__func__, num, pfirst, PKTDATA(pfirst),
+				PKTLEN(pfirst), PKTNEXT(pfirst),
+				PKTLINK(pfirst)));
+				prhex("", (u8 *) PKTDATA(pfirst),
+				      min_t(int, PKTLEN(pfirst), 32));
+			}
+#endif				/* DHD_DEBUG */
+		}
+		dhd_os_sdunlock_rxq(bus->dhd);
+		if (num) {
+			dhd_os_sdunlock(bus->dhd);
+			dhd_rx_frame(bus->dhd, ifidx, save_pfirst, num);
+			dhd_os_sdlock(bus->dhd);
+		}
+
+		bus->rxglomframes++;
+		bus->rxglompkts += num;
+	}
+	return num;
+}
+
+/* Return true if there may be more frames to read */
+static uint dhdsdio_readframes(dhd_bus_t *bus, uint maxframes, bool *finished)
+{
+	osl_t *osh = bus->dhd->osh;
+	bcmsdh_info_t *sdh = bus->sdh;
+
+	u16 len, check;	/* Extracted hardware header fields */
+	u8 chan, seq, doff;	/* Extracted software header fields */
+	u8 fcbits;		/* Extracted fcbits from software header */
+	u8 delta;
+
+	void *pkt;		/* Packet for event or data frames */
+	u16 pad;		/* Number of pad bytes to read */
+	u16 rdlen;		/* Total number of bytes to read */
+	u8 rxseq;		/* Next sequence number to expect */
+	uint rxleft = 0;	/* Remaining number of frames allowed */
+	int sdret;		/* Return code from bcmsdh calls */
+	u8 txmax;		/* Maximum tx sequence offered */
+	bool len_consistent;	/* Result of comparing readahead len and
+					 len from hw-hdr */
+	u8 *rxbuf;
+	int ifidx = 0;
+	uint rxcount = 0;	/* Total frames read */
+
+#if defined(DHD_DEBUG) || defined(SDTEST)
+	bool sdtest = false;	/* To limit message spew from test mode */
+#endif
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	ASSERT(maxframes);
+
+#ifdef SDTEST
+	/* Allow pktgen to override maxframes */
+	if (bus->pktgen_count && (bus->pktgen_mode == DHD_PKTGEN_RECV)) {
+		maxframes = bus->pktgen_count;
+		sdtest = true;
+	}
+#endif
+
+	/* Not finished unless we encounter no more frames indication */
+	*finished = false;
+
+	for (rxseq = bus->rx_seq, rxleft = maxframes;
+	     !bus->rxskip && rxleft && bus->dhd->busstate != DHD_BUS_DOWN;
+	     rxseq++, rxleft--) {
+
+		/* Handle glomming separately */
+		if (bus->glom || bus->glomd) {
+			u8 cnt;
+			DHD_GLOM(("%s: calling rxglom: glomd %p, glom %p\n",
+				  __func__, bus->glomd, bus->glom));
+			cnt = dhdsdio_rxglom(bus, rxseq);
+			DHD_GLOM(("%s: rxglom returned %d\n", __func__, cnt));
+			rxseq += cnt - 1;
+			rxleft = (rxleft > cnt) ? (rxleft - cnt) : 1;
+			continue;
+		}
+
+		/* Try doing single read if we can */
+		if (dhd_readahead && bus->nextlen) {
+			u16 nextlen = bus->nextlen;
+			bus->nextlen = 0;
+
+			if (bus->bus == SPI_BUS) {
+				rdlen = len = nextlen;
+			} else {
+				rdlen = len = nextlen << 4;
+
+				/* Pad read to blocksize for efficiency */
+				if (bus->roundup && bus->blocksize
+				    && (rdlen > bus->blocksize)) {
+					pad =
+					    bus->blocksize -
+					    (rdlen % bus->blocksize);
+					if ((pad <= bus->roundup)
+					    && (pad < bus->blocksize)
+					    && ((rdlen + pad + firstread) <
+						MAX_RX_DATASZ))
+						rdlen += pad;
+				} else if (rdlen % DHD_SDALIGN) {
+					rdlen +=
+					    DHD_SDALIGN - (rdlen % DHD_SDALIGN);
+				}
+			}
+
+			/* We use bus->rxctl buffer in WinXP for initial
+			 * control pkt receives.
+			 * Later we use buffer-poll for data as well
+			 * as control packets.
+			 * This is required becuase dhd receives full
+			 * frame in gSPI unlike SDIO.
+			 * After the frame is received we have to
+			 * distinguish whether it is data
+			 * or non-data frame.
+			 */
+			/* Allocate a packet buffer */
+			dhd_os_sdlock_rxq(bus->dhd);
+			pkt = PKTGET(osh, rdlen + DHD_SDALIGN, false);
+			if (!pkt) {
+				if (bus->bus == SPI_BUS) {
+					bus->usebufpool = false;
+					bus->rxctl = bus->rxbuf;
+					if (dhd_alignctl) {
+						bus->rxctl += firstread;
+						pad = ((unsigned long)bus->rxctl %
+						      DHD_SDALIGN);
+						if (pad)
+							bus->rxctl +=
+							    (DHD_SDALIGN - pad);
+						bus->rxctl -= firstread;
+					}
+					ASSERT(bus->rxctl >= bus->rxbuf);
+					rxbuf = bus->rxctl;
+					/* Read the entire frame */
+					sdret = dhd_bcmsdh_recv_buf(bus,
+						    bcmsdh_cur_sbwad
+						    (sdh),
+						    SDIO_FUNC_2,
+						    F2SYNC,
+						    rxbuf,
+						    rdlen, NULL,
+						    NULL, NULL);
+					bus->f2rxdata++;
+					ASSERT(sdret != BCME_PENDING);
+
+					/* Control frame failures need
+					 retransmission */
+					if (sdret < 0) {
+						DHD_ERROR(("%s: read %d control bytes failed: %d\n",
+							__func__,
+							rdlen, sdret));
+						/* dhd.rx_ctlerrs is higher */
+						bus->rxc_errors++;
+						dhd_os_sdunlock_rxq(bus->dhd);
+						dhdsdio_rxfail(bus, true,
+						       (bus->bus ==
+							SPI_BUS) ? false
+						       : true);
+						continue;
+					}
+				} else {
+					/* Give up on data,
+					request rtx of events */
+					DHD_ERROR(("%s (nextlen): PKTGET failed: len %d rdlen %d " "expected rxseq %d\n",
+						__func__, len, rdlen, rxseq));
+					/* Just go try again w/normal
+					header read */
+					dhd_os_sdunlock_rxq(bus->dhd);
+					continue;
+				}
+			} else {
+				if (bus->bus == SPI_BUS)
+					bus->usebufpool = true;
+
+				ASSERT(!PKTLINK(pkt));
+				PKTALIGN(osh, pkt, rdlen, DHD_SDALIGN);
+				rxbuf = (u8 *) PKTDATA(pkt);
+				/* Read the entire frame */
+				sdret =
+				    dhd_bcmsdh_recv_buf(bus,
+						bcmsdh_cur_sbwad(sdh),
+						SDIO_FUNC_2, F2SYNC,
+						rxbuf, rdlen, pkt, NULL,
+						NULL);
+				bus->f2rxdata++;
+				ASSERT(sdret != BCME_PENDING);
+
+				if (sdret < 0) {
+					DHD_ERROR(("%s (nextlen): read %d bytes failed: %d\n",
+						__func__, rdlen, sdret));
+					PKTFREE(bus->dhd->osh, pkt, false);
+					bus->dhd->rx_errors++;
+					dhd_os_sdunlock_rxq(bus->dhd);
+					/* Force retry w/normal header read.
+					 * Don't attemp NAK for
+					 * gSPI
+					 */
+					dhdsdio_rxfail(bus, true,
+						       (bus->bus ==
+							SPI_BUS) ? false :
+						       true);
+					continue;
+				}
+			}
+			dhd_os_sdunlock_rxq(bus->dhd);
+
+			/* Now check the header */
+			bcopy(rxbuf, bus->rxhdr, SDPCM_HDRLEN);
+
+			/* Extract hardware header fields */
+			len = ltoh16_ua(bus->rxhdr);
+			check = ltoh16_ua(bus->rxhdr + sizeof(u16));
+
+			/* All zeros means readahead info was bad */
+			if (!(len | check)) {
+				DHD_INFO(("%s (nextlen): read zeros in HW "
+					"header???\n", __func__));
+				dhd_os_sdlock_rxq(bus->dhd);
+				PKTFREE2();
+				dhd_os_sdunlock_rxq(bus->dhd);
+				GSPI_PR55150_BAILOUT;
+				continue;
+			}
+
+			/* Validate check bytes */
+			if ((u16)~(len ^ check)) {
+				DHD_ERROR(("%s (nextlen): HW hdr error: nextlen/len/check" " 0x%04x/0x%04x/0x%04x\n",
+					__func__, nextlen, len, check));
+				dhd_os_sdlock_rxq(bus->dhd);
+				PKTFREE2();
+				dhd_os_sdunlock_rxq(bus->dhd);
+				bus->rx_badhdr++;
+				dhdsdio_rxfail(bus, false, false);
+				GSPI_PR55150_BAILOUT;
+				continue;
+			}
+
+			/* Validate frame length */
+			if (len < SDPCM_HDRLEN) {
+				DHD_ERROR(("%s (nextlen): HW hdr length "
+					"invalid: %d\n", __func__, len));
+				dhd_os_sdlock_rxq(bus->dhd);
+				PKTFREE2();
+				dhd_os_sdunlock_rxq(bus->dhd);
+				GSPI_PR55150_BAILOUT;
+				continue;
+			}
+
+			/* Check for consistency withreadahead info */
+			len_consistent = (nextlen != (roundup(len, 16) >> 4));
+			if (len_consistent) {
+				/* Mismatch, force retry w/normal
+					header (may be >4K) */
+				DHD_ERROR(("%s (nextlen): mismatch, nextlen %d len %d rnd %d; " "expected rxseq %d\n",
+					__func__, nextlen,
+					len, roundup(len, 16), rxseq));
+				dhd_os_sdlock_rxq(bus->dhd);
+				PKTFREE2();
+				dhd_os_sdunlock_rxq(bus->dhd);
+				dhdsdio_rxfail(bus, true,
+					       (bus->bus ==
+						SPI_BUS) ? false : true);
+				GSPI_PR55150_BAILOUT;
+				continue;
+			}
+
+			/* Extract software header fields */
+			chan =
+			    SDPCM_PACKET_CHANNEL(&bus->rxhdr
+						 [SDPCM_FRAMETAG_LEN]);
+			seq =
+			    SDPCM_PACKET_SEQUENCE(&bus->rxhdr
+						  [SDPCM_FRAMETAG_LEN]);
+			doff =
+			    SDPCM_DOFFSET_VALUE(&bus->rxhdr
+						[SDPCM_FRAMETAG_LEN]);
+			txmax =
+			    SDPCM_WINDOW_VALUE(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
+
+			bus->nextlen =
+			    bus->rxhdr[SDPCM_FRAMETAG_LEN +
+				       SDPCM_NEXTLEN_OFFSET];
+			if ((bus->nextlen << 4) > MAX_RX_DATASZ) {
+				DHD_INFO(("%s (nextlen): got frame w/nextlen too large" " (%d), seq %d\n",
+					__func__, bus->nextlen, seq));
+				bus->nextlen = 0;
+			}
+
+			bus->dhd->rx_readahead_cnt++;
+			/* Handle Flow Control */
+			fcbits =
+			    SDPCM_FCMASK_VALUE(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
+
+			delta = 0;
+			if (~bus->flowcontrol & fcbits) {
+				bus->fc_xoff++;
+				delta = 1;
+			}
+			if (bus->flowcontrol & ~fcbits) {
+				bus->fc_xon++;
+				delta = 1;
+			}
+
+			if (delta) {
+				bus->fc_rcvd++;
+				bus->flowcontrol = fcbits;
+			}
+
+			/* Check and update sequence number */
+			if (rxseq != seq) {
+				DHD_INFO(("%s (nextlen): rx_seq %d, expected "
+					"%d\n", __func__, seq, rxseq));
+				bus->rx_badseq++;
+				rxseq = seq;
+			}
+
+			/* Check window for sanity */
+			if ((u8) (txmax - bus->tx_seq) > 0x40) {
+				DHD_ERROR(("%s: got unlikely tx max %d with "
+					"tx_seq %d\n",
+					__func__, txmax, bus->tx_seq));
+				txmax = bus->tx_seq + 2;
+			}
+			bus->tx_max = txmax;
+
+#ifdef DHD_DEBUG
+			if (DHD_BYTES_ON() && DHD_DATA_ON())
+				prhex("Rx Data", rxbuf, len);
+			else if (DHD_HDRS_ON())
+				prhex("RxHdr", bus->rxhdr, SDPCM_HDRLEN);
+#endif
+
+			if (chan == SDPCM_CONTROL_CHANNEL) {
+				if (bus->bus == SPI_BUS) {
+					dhdsdio_read_control(bus, rxbuf, len,
+							     doff);
+					if (bus->usebufpool) {
+						dhd_os_sdlock_rxq(bus->dhd);
+						PKTFREE(bus->dhd->osh, pkt,
+							false);
+						dhd_os_sdunlock_rxq(bus->dhd);
+					}
+					continue;
+				} else {
+					DHD_ERROR(("%s (nextlen): readahead on control" " packet %d?\n",
+						__func__, seq));
+					/* Force retry w/normal header read */
+					bus->nextlen = 0;
+					dhdsdio_rxfail(bus, false, true);
+					dhd_os_sdlock_rxq(bus->dhd);
+					PKTFREE2();
+					dhd_os_sdunlock_rxq(bus->dhd);
+					continue;
+				}
+			}
+
+			if ((bus->bus == SPI_BUS) && !bus->usebufpool) {
+				DHD_ERROR(("Received %d bytes on %d channel. Running out of " "rx pktbuf's or not yet malloced.\n",
+					len, chan));
+				continue;
+			}
+
+			/* Validate data offset */
+			if ((doff < SDPCM_HDRLEN) || (doff > len)) {
+				DHD_ERROR(("%s (nextlen): bad data offset %d: HW len %d min %d\n",
+					__func__, doff, len, SDPCM_HDRLEN));
+				dhd_os_sdlock_rxq(bus->dhd);
+				PKTFREE2();
+				dhd_os_sdunlock_rxq(bus->dhd);
+				ASSERT(0);
+				dhdsdio_rxfail(bus, false, false);
+				continue;
+			}
+
+			/* All done with this one -- now deliver the packet */
+			goto deliver;
+		}
+		/* gSPI frames should not be handled in fractions */
+		if (bus->bus == SPI_BUS)
+			break;
+
+		/* Read frame header (hardware and software) */
+		sdret =
+		    dhd_bcmsdh_recv_buf(bus, bcmsdh_cur_sbwad(sdh), SDIO_FUNC_2,
+					F2SYNC, bus->rxhdr, firstread, NULL,
+					NULL, NULL);
+		bus->f2rxhdrs++;
+		ASSERT(sdret != BCME_PENDING);
+
+		if (sdret < 0) {
+			DHD_ERROR(("%s: RXHEADER FAILED: %d\n", __func__,
+				   sdret));
+			bus->rx_hdrfail++;
+			dhdsdio_rxfail(bus, true, true);
+			continue;
+		}
+#ifdef DHD_DEBUG
+		if (DHD_BYTES_ON() || DHD_HDRS_ON())
+			prhex("RxHdr", bus->rxhdr, SDPCM_HDRLEN);
+#endif
+
+		/* Extract hardware header fields */
+		len = ltoh16_ua(bus->rxhdr);
+		check = ltoh16_ua(bus->rxhdr + sizeof(u16));
+
+		/* All zeros means no more frames */
+		if (!(len | check)) {
+			*finished = true;
+			break;
+		}
+
+		/* Validate check bytes */
+		if ((u16) ~(len ^ check)) {
+			DHD_ERROR(("%s: HW hdr err: len/check 0x%04x/0x%04x\n",
+				__func__, len, check));
+			bus->rx_badhdr++;
+			dhdsdio_rxfail(bus, false, false);
+			continue;
+		}
+
+		/* Validate frame length */
+		if (len < SDPCM_HDRLEN) {
+			DHD_ERROR(("%s: HW hdr length invalid: %d\n",
+				   __func__, len));
+			continue;
+		}
+
+		/* Extract software header fields */
+		chan = SDPCM_PACKET_CHANNEL(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
+		seq = SDPCM_PACKET_SEQUENCE(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
+		doff = SDPCM_DOFFSET_VALUE(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
+		txmax = SDPCM_WINDOW_VALUE(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
+
+		/* Validate data offset */
+		if ((doff < SDPCM_HDRLEN) || (doff > len)) {
+			DHD_ERROR(("%s: Bad data offset %d: HW len %d, min %d "
+				"seq %d\n",
+				__func__, doff, len, SDPCM_HDRLEN, seq));
+			bus->rx_badhdr++;
+			ASSERT(0);
+			dhdsdio_rxfail(bus, false, false);
+			continue;
+		}
+
+		/* Save the readahead length if there is one */
+		bus->nextlen =
+		    bus->rxhdr[SDPCM_FRAMETAG_LEN + SDPCM_NEXTLEN_OFFSET];
+		if ((bus->nextlen << 4) > MAX_RX_DATASZ) {
+			DHD_INFO(("%s (nextlen): got frame w/nextlen too large "
+				"(%d), seq %d\n",
+				__func__, bus->nextlen, seq));
+			bus->nextlen = 0;
+		}
+
+		/* Handle Flow Control */
+		fcbits = SDPCM_FCMASK_VALUE(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
+
+		delta = 0;
+		if (~bus->flowcontrol & fcbits) {
+			bus->fc_xoff++;
+			delta = 1;
+		}
+		if (bus->flowcontrol & ~fcbits) {
+			bus->fc_xon++;
+			delta = 1;
+		}
+
+		if (delta) {
+			bus->fc_rcvd++;
+			bus->flowcontrol = fcbits;
+		}
+
+		/* Check and update sequence number */
+		if (rxseq != seq) {
+			DHD_INFO(("%s: rx_seq %d, expected %d\n", __func__,
+				  seq, rxseq));
+			bus->rx_badseq++;
+			rxseq = seq;
+		}
+
+		/* Check window for sanity */
+		if ((u8) (txmax - bus->tx_seq) > 0x40) {
+			DHD_ERROR(("%s: unlikely tx max %d with tx_seq %d\n",
+				__func__, txmax, bus->tx_seq));
+			txmax = bus->tx_seq + 2;
+		}
+		bus->tx_max = txmax;
+
+		/* Call a separate function for control frames */
+		if (chan == SDPCM_CONTROL_CHANNEL) {
+			dhdsdio_read_control(bus, bus->rxhdr, len, doff);
+			continue;
+		}
+
+		ASSERT((chan == SDPCM_DATA_CHANNEL)
+		       || (chan == SDPCM_EVENT_CHANNEL)
+		       || (chan == SDPCM_TEST_CHANNEL)
+		       || (chan == SDPCM_GLOM_CHANNEL));
+
+		/* Length to read */
+		rdlen = (len > firstread) ? (len - firstread) : 0;
+
+		/* May pad read to blocksize for efficiency */
+		if (bus->roundup && bus->blocksize &&
+			(rdlen > bus->blocksize)) {
+			pad = bus->blocksize - (rdlen % bus->blocksize);
+			if ((pad <= bus->roundup) && (pad < bus->blocksize) &&
+			    ((rdlen + pad + firstread) < MAX_RX_DATASZ))
+				rdlen += pad;
+		} else if (rdlen % DHD_SDALIGN) {
+			rdlen += DHD_SDALIGN - (rdlen % DHD_SDALIGN);
+		}
+
+		/* Satisfy length-alignment requirements */
+		if (forcealign && (rdlen & (ALIGNMENT - 1)))
+			rdlen = roundup(rdlen, ALIGNMENT);
+
+		if ((rdlen + firstread) > MAX_RX_DATASZ) {
+			/* Too long -- skip this frame */
+			DHD_ERROR(("%s: too long: len %d rdlen %d\n",
+				   __func__, len, rdlen));
+			bus->dhd->rx_errors++;
+			bus->rx_toolong++;
+			dhdsdio_rxfail(bus, false, false);
+			continue;
+		}
+
+		dhd_os_sdlock_rxq(bus->dhd);
+		pkt = PKTGET(osh, (rdlen + firstread + DHD_SDALIGN), false);
+		if (!pkt) {
+			/* Give up on data, request rtx of events */
+			DHD_ERROR(("%s: PKTGET failed: rdlen %d chan %d\n",
+				   __func__, rdlen, chan));
+			bus->dhd->rx_dropped++;
+			dhd_os_sdunlock_rxq(bus->dhd);
+			dhdsdio_rxfail(bus, false, RETRYCHAN(chan));
+			continue;
+		}
+		dhd_os_sdunlock_rxq(bus->dhd);
+
+		ASSERT(!PKTLINK(pkt));
+
+		/* Leave room for what we already read, and align remainder */
+		ASSERT(firstread < (PKTLEN(pkt)));
+		PKTPULL(pkt, firstread);
+		PKTALIGN(osh, pkt, rdlen, DHD_SDALIGN);
+
+		/* Read the remaining frame data */
+		sdret =
+		    dhd_bcmsdh_recv_buf(bus, bcmsdh_cur_sbwad(sdh), SDIO_FUNC_2,
+					F2SYNC, ((u8 *) PKTDATA(pkt)), rdlen,
+					pkt, NULL, NULL);
+		bus->f2rxdata++;
+		ASSERT(sdret != BCME_PENDING);
+
+		if (sdret < 0) {
+			DHD_ERROR(("%s: read %d %s bytes failed: %d\n",
+				   __func__, rdlen,
+				   ((chan ==
+				     SDPCM_EVENT_CHANNEL) ? "event" : ((chan ==
+					SDPCM_DATA_CHANNEL)
+				       ? "data" : "test")),
+				   sdret));
+			dhd_os_sdlock_rxq(bus->dhd);
+			PKTFREE(bus->dhd->osh, pkt, false);
+			dhd_os_sdunlock_rxq(bus->dhd);
+			bus->dhd->rx_errors++;
+			dhdsdio_rxfail(bus, true, RETRYCHAN(chan));
+			continue;
+		}
+
+		/* Copy the already-read portion */
+		PKTPUSH(pkt, firstread);
+		bcopy(bus->rxhdr, PKTDATA(pkt), firstread);
+
+#ifdef DHD_DEBUG
+		if (DHD_BYTES_ON() && DHD_DATA_ON())
+			prhex("Rx Data", PKTDATA(pkt), len);
+#endif
+
+deliver:
+		/* Save superframe descriptor and allocate packet frame */
+		if (chan == SDPCM_GLOM_CHANNEL) {
+			if (SDPCM_GLOMDESC(&bus->rxhdr[SDPCM_FRAMETAG_LEN])) {
+				DHD_GLOM(("%s: glom descriptor, %d bytes:\n",
+					__func__, len));
+#ifdef DHD_DEBUG
+				if (DHD_GLOM_ON()) {
+					prhex("Glom Data", PKTDATA(pkt), len);
+				}
+#endif
+				PKTSETLEN(pkt, len);
+				ASSERT(doff == SDPCM_HDRLEN);
+				PKTPULL(pkt, SDPCM_HDRLEN);
+				bus->glomd = pkt;
+			} else {
+				DHD_ERROR(("%s: glom superframe w/o "
+					"descriptor!\n", __func__));
+				dhdsdio_rxfail(bus, false, false);
+			}
+			continue;
+		}
+
+		/* Fill in packet len and prio, deliver upward */
+		PKTSETLEN(pkt, len);
+		PKTPULL(pkt, doff);
+
+#ifdef SDTEST
+		/* Test channel packets are processed separately */
+		if (chan == SDPCM_TEST_CHANNEL) {
+			dhdsdio_testrcv(bus, pkt, seq);
+			continue;
+		}
+#endif				/* SDTEST */
+
+		if (PKTLEN(pkt) == 0) {
+			dhd_os_sdlock_rxq(bus->dhd);
+			PKTFREE(bus->dhd->osh, pkt, false);
+			dhd_os_sdunlock_rxq(bus->dhd);
+			continue;
+		} else if (dhd_prot_hdrpull(bus->dhd, &ifidx, pkt) != 0) {
+			DHD_ERROR(("%s: rx protocol error\n", __func__));
+			dhd_os_sdlock_rxq(bus->dhd);
+			PKTFREE(bus->dhd->osh, pkt, false);
+			dhd_os_sdunlock_rxq(bus->dhd);
+			bus->dhd->rx_errors++;
+			continue;
+		}
+
+		/* Unlock during rx call */
+		dhd_os_sdunlock(bus->dhd);
+		dhd_rx_frame(bus->dhd, ifidx, pkt, 1);
+		dhd_os_sdlock(bus->dhd);
+	}
+	rxcount = maxframes - rxleft;
+#ifdef DHD_DEBUG
+	/* Message if we hit the limit */
+	if (!rxleft && !sdtest)
+		DHD_DATA(("%s: hit rx limit of %d frames\n", __func__,
+			  maxframes));
+	else
+#endif				/* DHD_DEBUG */
+		DHD_DATA(("%s: processed %d frames\n", __func__, rxcount));
+	/* Back off rxseq if awaiting rtx, update rx_seq */
+	if (bus->rxskip)
+		rxseq--;
+	bus->rx_seq = rxseq;
+
+	return rxcount;
+}
+
+static u32 dhdsdio_hostmail(dhd_bus_t *bus)
+{
+	sdpcmd_regs_t *regs = bus->regs;
+	u32 intstatus = 0;
+	u32 hmb_data;
+	u8 fcbits;
+	uint retries = 0;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	/* Read mailbox data and ack that we did so */
+	R_SDREG(hmb_data, &regs->tohostmailboxdata, retries);
+	if (retries <= retry_limit)
+		W_SDREG(SMB_INT_ACK, &regs->tosbmailbox, retries);
+	bus->f1regdata += 2;
+
+	/* Dongle recomposed rx frames, accept them again */
+	if (hmb_data & HMB_DATA_NAKHANDLED) {
+		DHD_INFO(("Dongle reports NAK handled, expect rtx of %d\n",
+			  bus->rx_seq));
+		if (!bus->rxskip)
+			DHD_ERROR(("%s: unexpected NAKHANDLED!\n", __func__));
+
+		bus->rxskip = false;
+		intstatus |= I_HMB_FRAME_IND;
+	}
+
+	/*
+	 * DEVREADY does not occur with gSPI.
+	 */
+	if (hmb_data & (HMB_DATA_DEVREADY | HMB_DATA_FWREADY)) {
+		bus->sdpcm_ver =
+		    (hmb_data & HMB_DATA_VERSION_MASK) >>
+		    HMB_DATA_VERSION_SHIFT;
+		if (bus->sdpcm_ver != SDPCM_PROT_VERSION)
+			DHD_ERROR(("Version mismatch, dongle reports %d, "
+				"expecting %d\n",
+				bus->sdpcm_ver, SDPCM_PROT_VERSION));
+		else
+			DHD_INFO(("Dongle ready, protocol version %d\n",
+				  bus->sdpcm_ver));
+	}
+
+	/*
+	 * Flow Control has been moved into the RX headers and this out of band
+	 * method isn't used any more.  Leae this here for possibly
+	 * remaining backward
+	 * compatible with older dongles
+	 */
+	if (hmb_data & HMB_DATA_FC) {
+		fcbits =
+		    (hmb_data & HMB_DATA_FCDATA_MASK) >> HMB_DATA_FCDATA_SHIFT;
+
+		if (fcbits & ~bus->flowcontrol)
+			bus->fc_xoff++;
+		if (bus->flowcontrol & ~fcbits)
+			bus->fc_xon++;
+
+		bus->fc_rcvd++;
+		bus->flowcontrol = fcbits;
+	}
+
+	/* Shouldn't be any others */
+	if (hmb_data & ~(HMB_DATA_DEVREADY |
+			 HMB_DATA_NAKHANDLED |
+			 HMB_DATA_FC |
+			 HMB_DATA_FWREADY |
+			 HMB_DATA_FCDATA_MASK | HMB_DATA_VERSION_MASK)) {
+		DHD_ERROR(("Unknown mailbox data content: 0x%02x\n", hmb_data));
+	}
+
+	return intstatus;
+}
+
+bool dhdsdio_dpc(dhd_bus_t *bus)
+{
+	bcmsdh_info_t *sdh = bus->sdh;
+	sdpcmd_regs_t *regs = bus->regs;
+	u32 intstatus, newstatus = 0;
+	uint retries = 0;
+	uint rxlimit = dhd_rxbound;	/* Rx frames to read before resched */
+	uint txlimit = dhd_txbound;	/* Tx frames to send before resched */
+	uint framecnt = 0;	/* Temporary counter of tx/rx frames */
+	bool rxdone = true;	/* Flag for no more read data */
+	bool resched = false;	/* Flag indicating resched wanted */
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	/* Start with leftover status bits */
+	intstatus = bus->intstatus;
+
+	dhd_os_sdlock(bus->dhd);
+
+	/* If waiting for HTAVAIL, check status */
+	if (bus->clkstate == CLK_PENDING) {
+		int err;
+		u8 clkctl, devctl = 0;
+
+#ifdef DHD_DEBUG
+		/* Check for inconsistent device control */
+		devctl =
+		    bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, &err);
+		if (err) {
+			DHD_ERROR(("%s: error reading DEVCTL: %d\n",
+				   __func__, err));
+			bus->dhd->busstate = DHD_BUS_DOWN;
+		} else {
+			ASSERT(devctl & SBSDIO_DEVCTL_CA_INT_ONLY);
+		}
+#endif				/* DHD_DEBUG */
+
+		/* Read CSR, if clock on switch to AVAIL, else ignore */
+		clkctl =
+		    bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
+				    &err);
+		if (err) {
+			DHD_ERROR(("%s: error reading CSR: %d\n", __func__,
+				   err));
+			bus->dhd->busstate = DHD_BUS_DOWN;
+		}
+
+		DHD_INFO(("DPC: PENDING, devctl 0x%02x clkctl 0x%02x\n", devctl,
+			  clkctl));
+
+		if (SBSDIO_HTAV(clkctl)) {
+			devctl =
+			    bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL,
+					    &err);
+			if (err) {
+				DHD_ERROR(("%s: error reading DEVCTL: %d\n",
+					   __func__, err));
+				bus->dhd->busstate = DHD_BUS_DOWN;
+			}
+			devctl &= ~SBSDIO_DEVCTL_CA_INT_ONLY;
+			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL,
+					 devctl, &err);
+			if (err) {
+				DHD_ERROR(("%s: error writing DEVCTL: %d\n",
+					   __func__, err));
+				bus->dhd->busstate = DHD_BUS_DOWN;
+			}
+			bus->clkstate = CLK_AVAIL;
+		} else {
+			goto clkwait;
+		}
+	}
+
+	BUS_WAKE(bus);
+
+	/* Make sure backplane clock is on */
+	dhdsdio_clkctl(bus, CLK_AVAIL, true);
+	if (bus->clkstate == CLK_PENDING)
+		goto clkwait;
+
+	/* Pending interrupt indicates new device status */
+	if (bus->ipend) {
+		bus->ipend = false;
+		R_SDREG(newstatus, &regs->intstatus, retries);
+		bus->f1regdata++;
+		if (bcmsdh_regfail(bus->sdh))
+			newstatus = 0;
+		newstatus &= bus->hostintmask;
+		bus->fcstate = !!(newstatus & I_HMB_FC_STATE);
+		if (newstatus) {
+			W_SDREG(newstatus, &regs->intstatus, retries);
+			bus->f1regdata++;
+		}
+	}
+
+	/* Merge new bits with previous */
+	intstatus |= newstatus;
+	bus->intstatus = 0;
+
+	/* Handle flow-control change: read new state in case our ack
+	 * crossed another change interrupt.  If change still set, assume
+	 * FC ON for safety, let next loop through do the debounce.
+	 */
+	if (intstatus & I_HMB_FC_CHANGE) {
+		intstatus &= ~I_HMB_FC_CHANGE;
+		W_SDREG(I_HMB_FC_CHANGE, &regs->intstatus, retries);
+		R_SDREG(newstatus, &regs->intstatus, retries);
+		bus->f1regdata += 2;
+		bus->fcstate =
+		    !!(newstatus & (I_HMB_FC_STATE | I_HMB_FC_CHANGE));
+		intstatus |= (newstatus & bus->hostintmask);
+	}
+
+	/* Handle host mailbox indication */
+	if (intstatus & I_HMB_HOST_INT) {
+		intstatus &= ~I_HMB_HOST_INT;
+		intstatus |= dhdsdio_hostmail(bus);
+	}
+
+	/* Generally don't ask for these, can get CRC errors... */
+	if (intstatus & I_WR_OOSYNC) {
+		DHD_ERROR(("Dongle reports WR_OOSYNC\n"));
+		intstatus &= ~I_WR_OOSYNC;
+	}
+
+	if (intstatus & I_RD_OOSYNC) {
+		DHD_ERROR(("Dongle reports RD_OOSYNC\n"));
+		intstatus &= ~I_RD_OOSYNC;
+	}
+
+	if (intstatus & I_SBINT) {
+		DHD_ERROR(("Dongle reports SBINT\n"));
+		intstatus &= ~I_SBINT;
+	}
+
+	/* Would be active due to wake-wlan in gSPI */
+	if (intstatus & I_CHIPACTIVE) {
+		DHD_INFO(("Dongle reports CHIPACTIVE\n"));
+		intstatus &= ~I_CHIPACTIVE;
+	}
+
+	/* Ignore frame indications if rxskip is set */
+	if (bus->rxskip)
+		intstatus &= ~I_HMB_FRAME_IND;
+
+	/* On frame indication, read available frames */
+	if (PKT_AVAILABLE()) {
+		framecnt = dhdsdio_readframes(bus, rxlimit, &rxdone);
+		if (rxdone || bus->rxskip)
+			intstatus &= ~I_HMB_FRAME_IND;
+		rxlimit -= min(framecnt, rxlimit);
+	}
+
+	/* Keep still-pending events for next scheduling */
+	bus->intstatus = intstatus;
+
+clkwait:
+#if defined(OOB_INTR_ONLY)
+	bcmsdh_oob_intr_set(1);
+#endif				/* (OOB_INTR_ONLY) */
+	/* Re-enable interrupts to detect new device events (mailbox, rx frame)
+	 * or clock availability.  (Allows tx loop to check ipend if desired.)
+	 * (Unless register access seems hosed, as we may not be able to ACK...)
+	 */
+	if (bus->intr && bus->intdis && !bcmsdh_regfail(sdh)) {
+		DHD_INTR(("%s: enable SDIO interrupts, rxdone %d framecnt %d\n",
+			  __func__, rxdone, framecnt));
+		bus->intdis = false;
+		bcmsdh_intr_enable(sdh);
+	}
+
+	if (DATAOK(bus) && bus->ctrl_frame_stat &&
+		(bus->clkstate == CLK_AVAIL)) {
+		int ret, i;
+
+		ret =
+		    dhd_bcmsdh_send_buf(bus, bcmsdh_cur_sbwad(sdh), SDIO_FUNC_2,
+					F2SYNC, (u8 *) bus->ctrl_frame_buf,
+					(u32) bus->ctrl_frame_len, NULL,
+					NULL, NULL);
+		ASSERT(ret != BCME_PENDING);
+
+		if (ret < 0) {
+			/* On failure, abort the command and
+				terminate the frame */
+			DHD_INFO(("%s: sdio error %d, abort command and "
+				"terminate frame.\n", __func__, ret));
+			bus->tx_sderrs++;
+
+			bcmsdh_abort(sdh, SDIO_FUNC_2);
+
+			bcmsdh_cfg_write(sdh, SDIO_FUNC_1,
+					 SBSDIO_FUNC1_FRAMECTRL, SFC_WF_TERM,
+					 NULL);
+			bus->f1regdata++;
+
+			for (i = 0; i < 3; i++) {
+				u8 hi, lo;
+				hi = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
+						     SBSDIO_FUNC1_WFRAMEBCHI,
+						     NULL);
+				lo = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
+						     SBSDIO_FUNC1_WFRAMEBCLO,
+						     NULL);
+				bus->f1regdata += 2;
+				if ((hi == 0) && (lo == 0))
+					break;
+			}
+
+		}
+		if (ret == 0)
+			bus->tx_seq = (bus->tx_seq + 1) % SDPCM_SEQUENCE_WRAP;
+
+		printf("Return_dpc value is : %d\n", ret);
+		bus->ctrl_frame_stat = false;
+		dhd_wait_event_wakeup(bus->dhd);
+	}
+	/* Send queued frames (limit 1 if rx may still be pending) */
+	else if ((bus->clkstate == CLK_AVAIL) && !bus->fcstate &&
+		 pktq_mlen(&bus->txq, ~bus->flowcontrol) && txlimit
+		 && DATAOK(bus)) {
+		framecnt = rxdone ? txlimit : min(txlimit, dhd_txminmax);
+		framecnt = dhdsdio_sendfromq(bus, framecnt);
+		txlimit -= framecnt;
+	}
+
+	/* Resched if events or tx frames are pending,
+		 else await next interrupt */
+	/* On failed register access, all bets are off:
+		 no resched or interrupts */
+	if ((bus->dhd->busstate == DHD_BUS_DOWN) || bcmsdh_regfail(sdh)) {
+		DHD_ERROR(("%s: failed backplane access over SDIO, halting "
+			"operation %d\n", __func__, bcmsdh_regfail(sdh)));
+		bus->dhd->busstate = DHD_BUS_DOWN;
+		bus->intstatus = 0;
+	} else if (bus->clkstate == CLK_PENDING) {
+		DHD_INFO(("%s: rescheduled due to CLK_PENDING awaiting "
+			"I_CHIPACTIVE interrupt\n", __func__));
+		resched = true;
+	} else if (bus->intstatus || bus->ipend ||
+		(!bus->fcstate && pktq_mlen(&bus->txq, ~bus->flowcontrol) &&
+			DATAOK(bus)) || PKT_AVAILABLE()) {
+		resched = true;
+	}
+
+	bus->dpc_sched = resched;
+
+	/* If we're done for now, turn off clock request. */
+	if ((bus->clkstate != CLK_PENDING)
+	    && bus->idletime == DHD_IDLE_IMMEDIATE) {
+		bus->activity = false;
+		dhdsdio_clkctl(bus, CLK_NONE, false);
+	}
+
+	dhd_os_sdunlock(bus->dhd);
+
+	return resched;
+}
+
+bool dhd_bus_dpc(struct dhd_bus *bus)
+{
+	bool resched;
+
+	/* Call the DPC directly. */
+	DHD_TRACE(("Calling dhdsdio_dpc() from %s\n", __func__));
+	resched = dhdsdio_dpc(bus);
+
+	return resched;
+}
+
+void dhdsdio_isr(void *arg)
+{
+	dhd_bus_t *bus = (dhd_bus_t *) arg;
+	bcmsdh_info_t *sdh;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	if (!bus) {
+		DHD_ERROR(("%s : bus is null pointer , exit\n", __func__));
+		return;
+	}
+	sdh = bus->sdh;
+
+	if (bus->dhd->busstate == DHD_BUS_DOWN) {
+		DHD_ERROR(("%s : bus is down. we have nothing to do\n",
+			   __func__));
+		return;
+	}
+	/* Count the interrupt call */
+	bus->intrcount++;
+	bus->ipend = true;
+
+	/* Shouldn't get this interrupt if we're sleeping? */
+	if (bus->sleeping) {
+		DHD_ERROR(("INTERRUPT WHILE SLEEPING??\n"));
+		return;
+	}
+
+	/* Disable additional interrupts (is this needed now)? */
+	if (bus->intr)
+		DHD_INTR(("%s: disable SDIO interrupts\n", __func__));
+	else
+		DHD_ERROR(("dhdsdio_isr() w/o interrupt configured!\n"));
+
+	bcmsdh_intr_disable(sdh);
+	bus->intdis = true;
+
+#if defined(SDIO_ISR_THREAD)
+	DHD_TRACE(("Calling dhdsdio_dpc() from %s\n", __func__));
+	while (dhdsdio_dpc(bus))
+		;
+#else
+	bus->dpc_sched = true;
+	dhd_sched_dpc(bus->dhd);
+#endif
+
+}
+
+#ifdef SDTEST
+static void dhdsdio_pktgen_init(dhd_bus_t *bus)
+{
+	/* Default to specified length, or full range */
+	if (dhd_pktgen_len) {
+		bus->pktgen_maxlen = min(dhd_pktgen_len, MAX_PKTGEN_LEN);
+		bus->pktgen_minlen = bus->pktgen_maxlen;
+	} else {
+		bus->pktgen_maxlen = MAX_PKTGEN_LEN;
+		bus->pktgen_minlen = 0;
+	}
+	bus->pktgen_len = (u16) bus->pktgen_minlen;
+
+	/* Default to per-watchdog burst with 10s print time */
+	bus->pktgen_freq = 1;
+	bus->pktgen_print = 10000 / dhd_watchdog_ms;
+	bus->pktgen_count = (dhd_pktgen * dhd_watchdog_ms + 999) / 1000;
+
+	/* Default to echo mode */
+	bus->pktgen_mode = DHD_PKTGEN_ECHO;
+	bus->pktgen_stop = 1;
+}
+
+static void dhdsdio_pktgen(dhd_bus_t *bus)
+{
+	void *pkt;
+	u8 *data;
+	uint pktcount;
+	uint fillbyte;
+	osl_t *osh = bus->dhd->osh;
+	u16 len;
+
+	/* Display current count if appropriate */
+	if (bus->pktgen_print && (++bus->pktgen_ptick >= bus->pktgen_print)) {
+		bus->pktgen_ptick = 0;
+		printf("%s: send attempts %d rcvd %d\n",
+		       __func__, bus->pktgen_sent, bus->pktgen_rcvd);
+	}
+
+	/* For recv mode, just make sure dongle has started sending */
+	if (bus->pktgen_mode == DHD_PKTGEN_RECV) {
+		if (!bus->pktgen_rcvd)
+			dhdsdio_sdtest_set(bus, true);
+		return;
+	}
+
+	/* Otherwise, generate or request the specified number of packets */
+	for (pktcount = 0; pktcount < bus->pktgen_count; pktcount++) {
+		/* Stop if total has been reached */
+		if (bus->pktgen_total
+		    && (bus->pktgen_sent >= bus->pktgen_total)) {
+			bus->pktgen_count = 0;
+			break;
+		}
+
+		/* Allocate an appropriate-sized packet */
+		len = bus->pktgen_len;
+		pkt = PKTGET(osh,
+			(len + SDPCM_HDRLEN + SDPCM_TEST_HDRLEN + DHD_SDALIGN),
+			true);
+		if (!pkt) {
+			DHD_ERROR(("%s: PKTGET failed!\n", __func__));
+			break;
+		}
+		PKTALIGN(osh, pkt, (len + SDPCM_HDRLEN + SDPCM_TEST_HDRLEN),
+			 DHD_SDALIGN);
+		data = (u8 *) PKTDATA(pkt) + SDPCM_HDRLEN;
+
+		/* Write test header cmd and extra based on mode */
+		switch (bus->pktgen_mode) {
+		case DHD_PKTGEN_ECHO:
+			*data++ = SDPCM_TEST_ECHOREQ;
+			*data++ = (u8) bus->pktgen_sent;
+			break;
+
+		case DHD_PKTGEN_SEND:
+			*data++ = SDPCM_TEST_DISCARD;
+			*data++ = (u8) bus->pktgen_sent;
+			break;
+
+		case DHD_PKTGEN_RXBURST:
+			*data++ = SDPCM_TEST_BURST;
+			*data++ = (u8) bus->pktgen_count;
+			break;
+
+		default:
+			DHD_ERROR(("Unrecognized pktgen mode %d\n",
+				   bus->pktgen_mode));
+			PKTFREE(osh, pkt, true);
+			bus->pktgen_count = 0;
+			return;
+		}
+
+		/* Write test header length field */
+		*data++ = (len >> 0);
+		*data++ = (len >> 8);
+
+		/* Then fill in the remainder -- N/A for burst,
+			 but who cares... */
+		for (fillbyte = 0; fillbyte < len; fillbyte++)
+			*data++ =
+			    SDPCM_TEST_FILL(fillbyte, (u8) bus->pktgen_sent);
+
+#ifdef DHD_DEBUG
+		if (DHD_BYTES_ON() && DHD_DATA_ON()) {
+			data = (u8 *) PKTDATA(pkt) + SDPCM_HDRLEN;
+			prhex("dhdsdio_pktgen: Tx Data", data,
+			      PKTLEN(pkt) - SDPCM_HDRLEN);
+		}
+#endif
+
+		/* Send it */
+		if (dhdsdio_txpkt(bus, pkt, SDPCM_TEST_CHANNEL, true)) {
+			bus->pktgen_fail++;
+			if (bus->pktgen_stop
+			    && bus->pktgen_stop == bus->pktgen_fail)
+				bus->pktgen_count = 0;
+		}
+		bus->pktgen_sent++;
+
+		/* Bump length if not fixed, wrap at max */
+		if (++bus->pktgen_len > bus->pktgen_maxlen)
+			bus->pktgen_len = (u16) bus->pktgen_minlen;
+
+		/* Special case for burst mode: just send one request! */
+		if (bus->pktgen_mode == DHD_PKTGEN_RXBURST)
+			break;
+	}
+}
+
+static void dhdsdio_sdtest_set(dhd_bus_t *bus, bool start)
+{
+	void *pkt;
+	u8 *data;
+	osl_t *osh = bus->dhd->osh;
+
+	/* Allocate the packet */
+	pkt = PKTGET(osh, SDPCM_HDRLEN + SDPCM_TEST_HDRLEN + DHD_SDALIGN,
+			true);
+	if (!pkt) {
+		DHD_ERROR(("%s: PKTGET failed!\n", __func__));
+		return;
+	}
+	PKTALIGN(osh, pkt, (SDPCM_HDRLEN + SDPCM_TEST_HDRLEN), DHD_SDALIGN);
+	data = (u8 *) PKTDATA(pkt) + SDPCM_HDRLEN;
+
+	/* Fill in the test header */
+	*data++ = SDPCM_TEST_SEND;
+	*data++ = start;
+	*data++ = (bus->pktgen_maxlen >> 0);
+	*data++ = (bus->pktgen_maxlen >> 8);
+
+	/* Send it */
+	if (dhdsdio_txpkt(bus, pkt, SDPCM_TEST_CHANNEL, true))
+		bus->pktgen_fail++;
+}
+
+static void dhdsdio_testrcv(dhd_bus_t *bus, void *pkt, uint seq)
+{
+	osl_t *osh = bus->dhd->osh;
+	u8 *data;
+	uint pktlen;
+
+	u8 cmd;
+	u8 extra;
+	u16 len;
+	u16 offset;
+
+	/* Check for min length */
+	pktlen = PKTLEN(pkt);
+	if (pktlen < SDPCM_TEST_HDRLEN) {
+		DHD_ERROR(("dhdsdio_restrcv: toss runt frame, pktlen %d\n",
+			   pktlen));
+		PKTFREE(osh, pkt, false);
+		return;
+	}
+
+	/* Extract header fields */
+	data = PKTDATA(pkt);
+	cmd = *data++;
+	extra = *data++;
+	len = *data++;
+	len += *data++ << 8;
+
+	/* Check length for relevant commands */
+	if (cmd == SDPCM_TEST_DISCARD || cmd == SDPCM_TEST_ECHOREQ
+	    || cmd == SDPCM_TEST_ECHORSP) {
+		if (pktlen != len + SDPCM_TEST_HDRLEN) {
+			DHD_ERROR(("dhdsdio_testrcv: frame length mismatch, "
+				"pktlen %d seq %d" " cmd %d extra %d len %d\n",
+				pktlen, seq, cmd, extra, len));
+			PKTFREE(osh, pkt, false);
+			return;
+		}
+	}
+
+	/* Process as per command */
+	switch (cmd) {
+	case SDPCM_TEST_ECHOREQ:
+		/* Rx->Tx turnaround ok (even on NDIS w/current
+			 implementation) */
+		*(u8 *) (PKTDATA(pkt)) = SDPCM_TEST_ECHORSP;
+		if (dhdsdio_txpkt(bus, pkt, SDPCM_TEST_CHANNEL, true) == 0) {
+			bus->pktgen_sent++;
+		} else {
+			bus->pktgen_fail++;
+			PKTFREE(osh, pkt, false);
+		}
+		bus->pktgen_rcvd++;
+		break;
+
+	case SDPCM_TEST_ECHORSP:
+		if (bus->ext_loop) {
+			PKTFREE(osh, pkt, false);
+			bus->pktgen_rcvd++;
+			break;
+		}
+
+		for (offset = 0; offset < len; offset++, data++) {
+			if (*data != SDPCM_TEST_FILL(offset, extra)) {
+				DHD_ERROR(("dhdsdio_testrcv: echo data mismatch: " "offset %d (len %d) expect 0x%02x rcvd 0x%02x\n",
+					offset, len,
+					SDPCM_TEST_FILL(offset, extra), *data));
+				break;
+			}
+		}
+		PKTFREE(osh, pkt, false);
+		bus->pktgen_rcvd++;
+		break;
+
+	case SDPCM_TEST_DISCARD:
+		PKTFREE(osh, pkt, false);
+		bus->pktgen_rcvd++;
+		break;
+
+	case SDPCM_TEST_BURST:
+	case SDPCM_TEST_SEND:
+	default:
+		DHD_INFO(("dhdsdio_testrcv: unsupported or unknown command, "
+			"pktlen %d seq %d" " cmd %d extra %d len %d\n",
+			pktlen, seq, cmd, extra, len));
+		PKTFREE(osh, pkt, false);
+		break;
+	}
+
+	/* For recv mode, stop at limie (and tell dongle to stop sending) */
+	if (bus->pktgen_mode == DHD_PKTGEN_RECV) {
+		if (bus->pktgen_total
+		    && (bus->pktgen_rcvd >= bus->pktgen_total)) {
+			bus->pktgen_count = 0;
+			dhdsdio_sdtest_set(bus, false);
+		}
+	}
+}
+#endif				/* SDTEST */
+
+extern bool dhd_bus_watchdog(dhd_pub_t *dhdp)
+{
+	dhd_bus_t *bus;
+
+	DHD_TIMER(("%s: Enter\n", __func__));
+
+	bus = dhdp->bus;
+
+	if (bus->dhd->dongle_reset)
+		return false;
+
+	/* Ignore the timer if simulating bus down */
+	if (bus->sleeping)
+		return false;
+
+	dhd_os_sdlock(bus->dhd);
+
+	/* Poll period: check device if appropriate. */
+	if (bus->poll && (++bus->polltick >= bus->pollrate)) {
+		u32 intstatus = 0;
+
+		/* Reset poll tick */
+		bus->polltick = 0;
+
+		/* Check device if no interrupts */
+		if (!bus->intr || (bus->intrcount == bus->lastintrs)) {
+
+			if (!bus->dpc_sched) {
+				u8 devpend;
+				devpend = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_0,
+							  SDIOD_CCCR_INTPEND,
+							  NULL);
+				intstatus =
+				    devpend & (INTR_STATUS_FUNC1 |
+					       INTR_STATUS_FUNC2);
+			}
+
+			/* If there is something, make like the ISR and
+				 schedule the DPC */
+			if (intstatus) {
+				bus->pollcnt++;
+				bus->ipend = true;
+				if (bus->intr)
+					bcmsdh_intr_disable(bus->sdh);
+
+				bus->dpc_sched = true;
+				dhd_sched_dpc(bus->dhd);
+
+			}
+		}
+
+		/* Update interrupt tracking */
+		bus->lastintrs = bus->intrcount;
+	}
+#ifdef DHD_DEBUG
+	/* Poll for console output periodically */
+	if (dhdp->busstate == DHD_BUS_DATA && dhd_console_ms != 0) {
+		bus->console.count += dhd_watchdog_ms;
+		if (bus->console.count >= dhd_console_ms) {
+			bus->console.count -= dhd_console_ms;
+			/* Make sure backplane clock is on */
+			dhdsdio_clkctl(bus, CLK_AVAIL, false);
+			if (dhdsdio_readconsole(bus) < 0)
+				dhd_console_ms = 0;	/* On error,
+							 stop trying */
+		}
+	}
+#endif				/* DHD_DEBUG */
+
+#ifdef SDTEST
+	/* Generate packets if configured */
+	if (bus->pktgen_count && (++bus->pktgen_tick >= bus->pktgen_freq)) {
+		/* Make sure backplane clock is on */
+		dhdsdio_clkctl(bus, CLK_AVAIL, false);
+		bus->pktgen_tick = 0;
+		dhdsdio_pktgen(bus);
+	}
+#endif
+
+	/* On idle timeout clear activity flag and/or turn off clock */
+	if ((bus->idletime > 0) && (bus->clkstate == CLK_AVAIL)) {
+		if (++bus->idlecount >= bus->idletime) {
+			bus->idlecount = 0;
+			if (bus->activity) {
+				bus->activity = false;
+				dhd_os_wd_timer(bus->dhd, dhd_watchdog_ms);
+			} else {
+				dhdsdio_clkctl(bus, CLK_NONE, false);
+			}
+		}
+	}
+
+	dhd_os_sdunlock(bus->dhd);
+
+	return bus->ipend;
+}
+
+#ifdef DHD_DEBUG
+extern int dhd_bus_console_in(dhd_pub_t *dhdp, unsigned char *msg, uint msglen)
+{
+	dhd_bus_t *bus = dhdp->bus;
+	u32 addr, val;
+	int rv;
+	void *pkt;
+
+	/* Address could be zero if CONSOLE := 0 in dongle Makefile */
+	if (bus->console_addr == 0)
+		return BCME_UNSUPPORTED;
+
+	/* Exclusive bus access */
+	dhd_os_sdlock(bus->dhd);
+
+	/* Don't allow input if dongle is in reset */
+	if (bus->dhd->dongle_reset) {
+		dhd_os_sdunlock(bus->dhd);
+		return BCME_NOTREADY;
+	}
+
+	/* Request clock to allow SDIO accesses */
+	BUS_WAKE(bus);
+	/* No pend allowed since txpkt is called later, ht clk has to be on */
+	dhdsdio_clkctl(bus, CLK_AVAIL, false);
+
+	/* Zero cbuf_index */
+	addr = bus->console_addr + offsetof(hndrte_cons_t, cbuf_idx);
+	val = htol32(0);
+	rv = dhdsdio_membytes(bus, true, addr, (u8 *)&val, sizeof(val));
+	if (rv < 0)
+		goto done;
+
+	/* Write message into cbuf */
+	addr = bus->console_addr + offsetof(hndrte_cons_t, cbuf);
+	rv = dhdsdio_membytes(bus, true, addr, (u8 *)msg, msglen);
+	if (rv < 0)
+		goto done;
+
+	/* Write length into vcons_in */
+	addr = bus->console_addr + offsetof(hndrte_cons_t, vcons_in);
+	val = htol32(msglen);
+	rv = dhdsdio_membytes(bus, true, addr, (u8 *)&val, sizeof(val));
+	if (rv < 0)
+		goto done;
+
+	/* Bump dongle by sending an empty event pkt.
+	 * sdpcm_sendup (RX) checks for virtual console input.
+	 */
+	pkt = PKTGET(bus->dhd->osh, 4 + SDPCM_RESERVE, true);
+	if ((pkt != NULL) && bus->clkstate == CLK_AVAIL)
+		dhdsdio_txpkt(bus, pkt, SDPCM_EVENT_CHANNEL, true);
+
+done:
+	if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
+		bus->activity = false;
+		dhdsdio_clkctl(bus, CLK_NONE, true);
+	}
+
+	dhd_os_sdunlock(bus->dhd);
+
+	return rv;
+}
+#endif				/* DHD_DEBUG */
+
+#ifdef DHD_DEBUG
+static void dhd_dump_cis(uint fn, u8 *cis)
+{
+	uint byte, tag, tdata;
+	DHD_INFO(("Function %d CIS:\n", fn));
+
+	for (tdata = byte = 0; byte < SBSDIO_CIS_SIZE_LIMIT; byte++) {
+		if ((byte % 16) == 0)
+			DHD_INFO(("    "));
+		DHD_INFO(("%02x ", cis[byte]));
+		if ((byte % 16) == 15)
+			DHD_INFO(("\n"));
+		if (!tdata--) {
+			tag = cis[byte];
+			if (tag == 0xff)
+				break;
+			else if (!tag)
+				tdata = 0;
+			else if ((byte + 1) < SBSDIO_CIS_SIZE_LIMIT)
+				tdata = cis[byte + 1] + 1;
+			else
+				DHD_INFO(("]"));
+		}
+	}
+	if ((byte % 16) != 15)
+		DHD_INFO(("\n"));
+}
+#endif				/* DHD_DEBUG */
+
+static bool dhdsdio_chipmatch(u16 chipid)
+{
+	if (chipid == BCM4325_CHIP_ID)
+		return true;
+	if (chipid == BCM4329_CHIP_ID)
+		return true;
+	if (chipid == BCM4319_CHIP_ID)
+		return true;
+	return false;
+}
+
+static void *dhdsdio_probe(u16 venid, u16 devid, u16 bus_no,
+			   u16 slot, u16 func, uint bustype, void *regsva,
+			   osl_t *osh, void *sdh)
+{
+	int ret;
+	dhd_bus_t *bus;
+
+	/* Init global variables at run-time, not as part of the declaration.
+	 * This is required to support init/de-init of the driver.
+	 * Initialization
+	 * of globals as part of the declaration results in non-deterministic
+	 * behavior since the value of the globals may be different on the
+	 * first time that the driver is initialized vs subsequent
+	 * initializations.
+	 */
+	dhd_txbound = DHD_TXBOUND;
+	dhd_rxbound = DHD_RXBOUND;
+	dhd_alignctl = true;
+	sd1idle = true;
+	dhd_readahead = true;
+	retrydata = false;
+	dhd_doflow = false;
+	dhd_dongle_memsize = 0;
+	dhd_txminmax = DHD_TXMINMAX;
+
+	forcealign = true;
+
+	dhd_common_init();
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+	DHD_INFO(("%s: venid 0x%04x devid 0x%04x\n", __func__, venid, devid));
+
+	/* We make assumptions about address window mappings */
+	ASSERT((unsigned long)regsva == SI_ENUM_BASE);
+
+	/* BCMSDH passes venid and devid based on CIS parsing -- but
+	 * low-power start
+	 * means early parse could fail, so here we should get either an ID
+	 * we recognize OR (-1) indicating we must request power first.
+	 */
+	/* Check the Vendor ID */
+	switch (venid) {
+	case 0x0000:
+	case VENDOR_BROADCOM:
+		break;
+	default:
+		DHD_ERROR(("%s: unknown vendor: 0x%04x\n", __func__, venid));
+		return NULL;
+	}
+
+	/* Check the Device ID and make sure it's one that we support */
+	switch (devid) {
+	case BCM4325_D11DUAL_ID:	/* 4325 802.11a/g id */
+	case BCM4325_D11G_ID:	/* 4325 802.11g 2.4Ghz band id */
+	case BCM4325_D11A_ID:	/* 4325 802.11a 5Ghz band id */
+		DHD_INFO(("%s: found 4325 Dongle\n", __func__));
+		break;
+	case BCM4329_D11NDUAL_ID:	/* 4329 802.11n dualband device */
+	case BCM4329_D11N2G_ID:	/* 4329 802.11n 2.4G device */
+	case BCM4329_D11N5G_ID:	/* 4329 802.11n 5G device */
+	case 0x4329:
+		DHD_INFO(("%s: found 4329 Dongle\n", __func__));
+		break;
+	case BCM4319_D11N_ID:	/* 4319 802.11n id */
+	case BCM4319_D11N2G_ID:	/* 4319 802.11n2g id */
+	case BCM4319_D11N5G_ID:	/* 4319 802.11n5g id */
+		DHD_INFO(("%s: found 4319 Dongle\n", __func__));
+		break;
+	case 0:
+		DHD_INFO(("%s: allow device id 0, will check chip internals\n",
+			  __func__));
+		break;
+
+	default:
+		DHD_ERROR(("%s: skipping 0x%04x/0x%04x, not a dongle\n",
+			   __func__, venid, devid));
+		return NULL;
+	}
+
+	if (osh == NULL) {
+		/* Ask the OS interface part for an OSL handle */
+		osh = dhd_osl_attach(sdh, DHD_BUS);
+		if (!osh) {
+			DHD_ERROR(("%s: osl_attach failed!\n", __func__));
+			return NULL;
+		}
+	}
+
+	/* Allocate private bus interface state */
+	bus = kzalloc(sizeof(dhd_bus_t), GFP_ATOMIC);
+	if (!bus) {
+		DHD_ERROR(("%s: kmalloc of dhd_bus_t failed\n", __func__));
+		goto fail;
+	}
+	bus->sdh = sdh;
+	bus->cl_devid = (u16) devid;
+	bus->bus = DHD_BUS;
+	bus->tx_seq = SDPCM_SEQUENCE_WRAP - 1;
+	bus->usebufpool = false;	/* Use bufpool if allocated,
+					 else use locally malloced rxbuf */
+
+	/* attempt to attach to the dongle */
+	if (!(dhdsdio_probe_attach(bus, osh, sdh, regsva, devid))) {
+		DHD_ERROR(("%s: dhdsdio_probe_attach failed\n", __func__));
+		goto fail;
+	}
+
+	/* Attach to the dhd/OS/network interface */
+	bus->dhd = dhd_attach(osh, bus, SDPCM_RESERVE);
+	if (!bus->dhd) {
+		DHD_ERROR(("%s: dhd_attach failed\n", __func__));
+		goto fail;
+	}
+
+	/* Allocate buffers */
+	if (!(dhdsdio_probe_malloc(bus, osh, sdh))) {
+		DHD_ERROR(("%s: dhdsdio_probe_malloc failed\n", __func__));
+		goto fail;
+	}
+
+	if (!(dhdsdio_probe_init(bus, osh, sdh))) {
+		DHD_ERROR(("%s: dhdsdio_probe_init failed\n", __func__));
+		goto fail;
+	}
+
+	/* Register interrupt callback, but mask it (not operational yet). */
+	DHD_INTR(("%s: disable SDIO interrupts (not interested yet)\n",
+		  __func__));
+	bcmsdh_intr_disable(sdh);
+	ret = bcmsdh_intr_reg(sdh, dhdsdio_isr, bus);
+	if (ret != 0) {
+		DHD_ERROR(("%s: FAILED: bcmsdh_intr_reg returned %d\n",
+			   __func__, ret));
+		goto fail;
+	}
+	DHD_INTR(("%s: registered SDIO interrupt function ok\n", __func__));
+
+	DHD_INFO(("%s: completed!!\n", __func__));
+
+	/* if firmware path present try to download and bring up bus */
+	ret = dhd_bus_start(bus->dhd);
+	if (ret != 0) {
+		if (ret == BCME_NOTUP) {
+			DHD_ERROR(("%s: dongle is not responding\n", __func__));
+			goto fail;
+		}
+	}
+	/* Ok, have the per-port tell the stack we're open for business */
+	if (dhd_net_attach(bus->dhd, 0) != 0) {
+		DHD_ERROR(("%s: Net attach failed!!\n", __func__));
+		goto fail;
+	}
+
+	return bus;
+
+fail:
+	dhdsdio_release(bus, osh);
+	return NULL;
+}
+
+static bool
+dhdsdio_probe_attach(struct dhd_bus *bus, osl_t *osh, void *sdh, void *regsva,
+		     u16 devid)
+{
+	u8 clkctl = 0;
+	int err = 0;
+
+	bus->alp_only = true;
+
+	/* Return the window to backplane enumeration space for core access */
+	if (dhdsdio_set_siaddr_window(bus, SI_ENUM_BASE))
+		DHD_ERROR(("%s: FAILED to return to SI_ENUM_BASE\n", __func__));
+
+#ifdef DHD_DEBUG
+	printf("F1 signature read @0x18000000=0x%4x\n",
+	       bcmsdh_reg_read(bus->sdh, SI_ENUM_BASE, 4));
+
+#endif				/* DHD_DEBUG */
+
+	/* Force PLL off until si_attach() programs PLL control regs */
+
+	bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
+			 DHD_INIT_CLKCTL1, &err);
+	if (!err)
+		clkctl =
+		    bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
+				    &err);
+
+	if (err || ((clkctl & ~SBSDIO_AVBITS) != DHD_INIT_CLKCTL1)) {
+		DHD_ERROR(("dhdsdio_probe: ChipClkCSR access: err %d wrote "
+			"0x%02x read 0x%02x\n",
+			err, DHD_INIT_CLKCTL1, clkctl));
+		goto fail;
+	}
+#ifdef DHD_DEBUG
+	if (DHD_INFO_ON()) {
+		uint fn, numfn;
+		u8 *cis[SDIOD_MAX_IOFUNCS];
+		int err = 0;
+
+		numfn = bcmsdh_query_iofnum(sdh);
+		ASSERT(numfn <= SDIOD_MAX_IOFUNCS);
+
+		/* Make sure ALP is available before trying to read CIS */
+		SPINWAIT(((clkctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
+						    SBSDIO_FUNC1_CHIPCLKCSR,
+						    NULL)),
+			  !SBSDIO_ALPAV(clkctl)), PMU_MAX_TRANSITION_DLY);
+
+		/* Now request ALP be put on the bus */
+		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
+				 DHD_INIT_CLKCTL2, &err);
+		udelay(65);
+
+		for (fn = 0; fn <= numfn; fn++) {
+			cis[fn] = kmalloc(SBSDIO_CIS_SIZE_LIMIT, GFP_ATOMIC);
+			if (!cis[fn]) {
+				DHD_INFO(("dhdsdio_probe: fn %d cis malloc "
+					"failed\n", fn));
+				break;
+			}
+			bzero(cis[fn], SBSDIO_CIS_SIZE_LIMIT);
+
+			err = bcmsdh_cis_read(sdh, fn, cis[fn],
+						SBSDIO_CIS_SIZE_LIMIT);
+			if (err) {
+				DHD_INFO(("dhdsdio_probe: fn %d cis read "
+					"err %d\n", fn, err));
+				kfree(cis[fn]);
+				break;
+			}
+			dhd_dump_cis(fn, cis[fn]);
+		}
+
+		while (fn-- > 0) {
+			ASSERT(cis[fn]);
+			kfree(cis[fn]);
+		}
+
+		if (err) {
+			DHD_ERROR(("dhdsdio_probe: error read/parsing CIS\n"));
+			goto fail;
+		}
+	}
+#endif				/* DHD_DEBUG */
+
+	/* si_attach() will provide an SI handle and scan the backplane */
+	bus->sih = si_attach((uint) devid, osh, regsva, DHD_BUS, sdh,
+				   &bus->vars, &bus->varsz);
+	if (!(bus->sih)) {
+		DHD_ERROR(("%s: si_attach failed!\n", __func__));
+		goto fail;
+	}
+
+	bcmsdh_chipinfo(sdh, bus->sih->chip, bus->sih->chiprev);
+
+	if (!dhdsdio_chipmatch((u16) bus->sih->chip)) {
+		DHD_ERROR(("%s: unsupported chip: 0x%04x\n",
+			   __func__, bus->sih->chip));
+		goto fail;
+	}
+
+	si_sdiod_drive_strength_init(bus->sih, osh, dhd_sdiod_drive_strength);
+
+	/* Get info on the ARM and SOCRAM cores... */
+	if (!DHD_NOPMU(bus)) {
+		if ((si_setcore(bus->sih, ARM7S_CORE_ID, 0)) ||
+		    (si_setcore(bus->sih, ARMCM3_CORE_ID, 0))) {
+			bus->armrev = si_corerev(bus->sih);
+		} else {
+			DHD_ERROR(("%s: failed to find ARM core!\n", __func__));
+			goto fail;
+		}
+		bus->orig_ramsize = si_socram_size(bus->sih);
+		if (!(bus->orig_ramsize)) {
+			DHD_ERROR(("%s: failed to find SOCRAM memory!\n",
+				   __func__));
+			goto fail;
+		}
+		bus->ramsize = bus->orig_ramsize;
+		if (dhd_dongle_memsize)
+			dhd_dongle_setmemsize(bus, dhd_dongle_memsize);
+
+		DHD_ERROR(("DHD: dongle ram size is set to %d(orig %d)\n",
+			   bus->ramsize, bus->orig_ramsize));
+	}
+
+	/* ...but normally deal with the SDPCMDEV core */
+	bus->regs = si_setcore(bus->sih, PCMCIA_CORE_ID, 0);
+	if (!bus->regs) {
+		bus->regs = si_setcore(bus->sih, SDIOD_CORE_ID, 0);
+		if (!bus->regs) {
+			DHD_ERROR(("%s: failed to find SDIODEV core!\n",
+					__func__));
+			goto fail;
+		}
+	}
+	bus->sdpcmrev = si_corerev(bus->sih);
+
+	/* Set core control so an SDIO reset does a backplane reset */
+	OR_REG(osh, &bus->regs->corecontrol, CC_BPRESEN);
+
+	pktq_init(&bus->txq, (PRIOMASK + 1), QLEN);
+
+	/* Locate an appropriately-aligned portion of hdrbuf */
+	bus->rxhdr = (u8 *) roundup((unsigned long)&bus->hdrbuf[0], DHD_SDALIGN);
+
+	/* Set the poll and/or interrupt flags */
+	bus->intr = (bool) dhd_intr;
+	bus->poll = (bool) dhd_poll;
+	if (bus->poll)
+		bus->pollrate = 1;
+
+	return true;
+
+fail:
+	return false;
+}
+
+static bool dhdsdio_probe_malloc(dhd_bus_t *bus, osl_t *osh, void *sdh)
+{
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	if (bus->dhd->maxctl) {
+		bus->rxblen =
+		    roundup((bus->dhd->maxctl + SDPCM_HDRLEN),
+			    ALIGNMENT) + DHD_SDALIGN;
+		bus->rxbuf = kmalloc(bus->rxblen, GFP_ATOMIC);
+		if (!(bus->rxbuf)) {
+			DHD_ERROR(("%s: kmalloc of %d-byte rxbuf failed\n",
+				   __func__, bus->rxblen));
+			goto fail;
+		}
+	}
+
+	/* Allocate buffer to receive glomed packet */
+	bus->databuf = kmalloc(MAX_DATA_BUF, GFP_ATOMIC);
+	if (!(bus->databuf)) {
+		DHD_ERROR(("%s: kmalloc of %d-byte databuf failed\n",
+			   __func__, MAX_DATA_BUF));
+		/* release rxbuf which was already located as above */
+		if (!bus->rxblen)
+			kfree(bus->rxbuf);
+		goto fail;
+	}
+
+	/* Align the buffer */
+	if ((unsigned long)bus->databuf % DHD_SDALIGN)
+		bus->dataptr =
+		    bus->databuf + (DHD_SDALIGN -
+				    ((unsigned long)bus->databuf % DHD_SDALIGN));
+	else
+		bus->dataptr = bus->databuf;
+
+	return true;
+
+fail:
+	return false;
+}
+
+static bool dhdsdio_probe_init(dhd_bus_t *bus, osl_t *osh, void *sdh)
+{
+	s32 fnum;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+#ifdef SDTEST
+	dhdsdio_pktgen_init(bus);
+#endif				/* SDTEST */
+
+	/* Disable F2 to clear any intermediate frame state on the dongle */
+	bcmsdh_cfg_write(sdh, SDIO_FUNC_0, SDIOD_CCCR_IOEN, SDIO_FUNC_ENABLE_1,
+			 NULL);
+
+	bus->dhd->busstate = DHD_BUS_DOWN;
+	bus->sleeping = false;
+	bus->rxflow = false;
+	bus->prev_rxlim_hit = 0;
+
+	/* Done with backplane-dependent accesses, can drop clock... */
+	bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, 0, NULL);
+
+	/* ...and initialize clock/power states */
+	bus->clkstate = CLK_SDONLY;
+	bus->idletime = (s32) dhd_idletime;
+	bus->idleclock = DHD_IDLE_ACTIVE;
+
+	/* Query the SD clock speed */
+	if (bcmsdh_iovar_op(sdh, "sd_divisor", NULL, 0,
+			    &bus->sd_divisor, sizeof(s32),
+			    false) != BCME_OK) {
+		DHD_ERROR(("%s: fail on %s get\n", __func__, "sd_divisor"));
+		bus->sd_divisor = -1;
+	} else {
+		DHD_INFO(("%s: Initial value for %s is %d\n",
+			  __func__, "sd_divisor", bus->sd_divisor));
+	}
+
+	/* Query the SD bus mode */
+	if (bcmsdh_iovar_op(sdh, "sd_mode", NULL, 0,
+			    &bus->sd_mode, sizeof(s32), false) != BCME_OK) {
+		DHD_ERROR(("%s: fail on %s get\n", __func__, "sd_mode"));
+		bus->sd_mode = -1;
+	} else {
+		DHD_INFO(("%s: Initial value for %s is %d\n",
+			  __func__, "sd_mode", bus->sd_mode));
+	}
+
+	/* Query the F2 block size, set roundup accordingly */
+	fnum = 2;
+	if (bcmsdh_iovar_op(sdh, "sd_blocksize", &fnum, sizeof(s32),
+			    &bus->blocksize, sizeof(s32), false) != BCME_OK) {
+		bus->blocksize = 0;
+		DHD_ERROR(("%s: fail on %s get\n", __func__, "sd_blocksize"));
+	} else {
+		DHD_INFO(("%s: Initial value for %s is %d\n",
+			  __func__, "sd_blocksize", bus->blocksize));
+	}
+	bus->roundup = min(max_roundup, bus->blocksize);
+
+	/* Query if bus module supports packet chaining,
+		 default to use if supported */
+	if (bcmsdh_iovar_op(sdh, "sd_rxchain", NULL, 0,
+			    &bus->sd_rxchain, sizeof(s32),
+			    false) != BCME_OK) {
+		bus->sd_rxchain = false;
+	} else {
+		DHD_INFO(("%s: bus module (through bcmsdh API) %s chaining\n",
+			  __func__,
+			  (bus->sd_rxchain ? "supports" : "does not support")));
+	}
+	bus->use_rxchain = (bool) bus->sd_rxchain;
+
+	return true;
+}
+
+bool
+dhd_bus_download_firmware(struct dhd_bus *bus, osl_t *osh,
+			  char *fw_path, char *nv_path)
+{
+	bool ret;
+	bus->fw_path = fw_path;
+	bus->nv_path = nv_path;
+
+	ret = dhdsdio_download_firmware(bus, osh, bus->sdh);
+
+	return ret;
+}
+
+static bool
+dhdsdio_download_firmware(struct dhd_bus *bus, osl_t *osh, void *sdh)
+{
+	bool ret;
+
+	/* Download the firmware */
+	dhdsdio_clkctl(bus, CLK_AVAIL, false);
+
+	ret = _dhdsdio_download_firmware(bus) == 0;
+
+	dhdsdio_clkctl(bus, CLK_SDONLY, false);
+
+	return ret;
+}
+
+/* Detach and free everything */
+static void dhdsdio_release(dhd_bus_t *bus, osl_t *osh)
+{
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	if (bus) {
+		ASSERT(osh);
+
+		/* De-register interrupt handler */
+		bcmsdh_intr_disable(bus->sdh);
+		bcmsdh_intr_dereg(bus->sdh);
+
+		if (bus->dhd) {
+
+			dhdsdio_release_dongle(bus, osh);
+
+			dhd_detach(bus->dhd);
+			bus->dhd = NULL;
+		}
+
+		dhdsdio_release_malloc(bus, osh);
+
+		kfree(bus);
+	}
+
+	if (osh)
+		dhd_osl_detach(osh);
+
+	DHD_TRACE(("%s: Disconnected\n", __func__));
+}
+
+static void dhdsdio_release_malloc(dhd_bus_t *bus, osl_t *osh)
+{
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	if (bus->dhd && bus->dhd->dongle_reset)
+		return;
+
+	if (bus->rxbuf) {
+		kfree(bus->rxbuf);
+		bus->rxctl = bus->rxbuf = NULL;
+		bus->rxlen = 0;
+	}
+
+	if (bus->databuf) {
+		kfree(bus->databuf);
+		bus->databuf = NULL;
+	}
+}
+
+static void dhdsdio_release_dongle(dhd_bus_t *bus, osl_t *osh)
+{
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	if (bus->dhd && bus->dhd->dongle_reset)
+		return;
+
+	if (bus->sih) {
+		dhdsdio_clkctl(bus, CLK_AVAIL, false);
+#if !defined(BCMLXSDMMC)
+		si_watchdog(bus->sih, 4);
+#endif				/* !defined(BCMLXSDMMC) */
+		dhdsdio_clkctl(bus, CLK_NONE, false);
+		si_detach(bus->sih);
+		if (bus->vars && bus->varsz)
+			kfree(bus->vars);
+		bus->vars = NULL;
+	}
+
+	DHD_TRACE(("%s: Disconnected\n", __func__));
+}
+
+static void dhdsdio_disconnect(void *ptr)
+{
+	dhd_bus_t *bus = (dhd_bus_t *)ptr;
+
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	if (bus) {
+		ASSERT(bus->dhd);
+		dhdsdio_release(bus, bus->dhd->osh);
+	}
+
+	DHD_TRACE(("%s: Disconnected\n", __func__));
+}
+
+/* Register/Unregister functions are called by the main DHD entry
+ * point (e.g. module insertion) to link with the bus driver, in
+ * order to look for or await the device.
+ */
+
+static bcmsdh_driver_t dhd_sdio = {
+	dhdsdio_probe,
+	dhdsdio_disconnect
+};
+
+int dhd_bus_register(void)
+{
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	return bcmsdh_register(&dhd_sdio);
+}
+
+void dhd_bus_unregister(void)
+{
+	DHD_TRACE(("%s: Enter\n", __func__));
+
+	bcmsdh_unregister();
+}
+
+#ifdef BCMEMBEDIMAGE
+static int dhdsdio_download_code_array(struct dhd_bus *bus)
+{
+	int bcmerror = -1;
+	int offset = 0;
+
+	DHD_INFO(("%s: download embedded firmware...\n", __func__));
+
+	/* Download image */
+	while ((offset + MEMBLOCK) < sizeof(dlarray)) {
+		bcmerror =
+		    dhdsdio_membytes(bus, true, offset, dlarray + offset,
+				     MEMBLOCK);
+		if (bcmerror) {
+			DHD_ERROR(("%s: error %d on writing %d membytes at "
+				"0x%08x\n",
+				__func__, bcmerror, MEMBLOCK, offset));
+			goto err;
+		}
+
+		offset += MEMBLOCK;
+	}
+
+	if (offset < sizeof(dlarray)) {
+		bcmerror = dhdsdio_membytes(bus, true, offset,
+					    dlarray + offset,
+					    sizeof(dlarray) - offset);
+		if (bcmerror) {
+			DHD_ERROR(("%s: error %d on writing %d membytes at "
+				"0x%08x\n", __func__, bcmerror,
+				sizeof(dlarray) - offset, offset));
+			goto err;
+		}
+	}
+#ifdef DHD_DEBUG
+	/* Upload and compare the downloaded code */
+	{
+		unsigned char *ularray;
+
+		ularray = kmalloc(bus->ramsize, GFP_ATOMIC);
+		/* Upload image to verify downloaded contents. */
+		offset = 0;
+		memset(ularray, 0xaa, bus->ramsize);
+		while ((offset + MEMBLOCK) < sizeof(dlarray)) {
+			bcmerror =
+			    dhdsdio_membytes(bus, false, offset,
+					     ularray + offset, MEMBLOCK);
+			if (bcmerror) {
+				DHD_ERROR(("%s: error %d on reading %d membytes"
+					" at 0x%08x\n",
+					__func__, bcmerror, MEMBLOCK, offset));
+				goto err;
+			}
+
+			offset += MEMBLOCK;
+		}
+
+		if (offset < sizeof(dlarray)) {
+			bcmerror = dhdsdio_membytes(bus, false, offset,
+						    ularray + offset,
+						    sizeof(dlarray) - offset);
+			if (bcmerror) {
+				DHD_ERROR(("%s: error %d on reading %d membytes at 0x%08x\n",
+				__func__, bcmerror,
+				sizeof(dlarray) - offset, offset));
+				goto err;
+			}
+		}
+
+		if (memcmp(dlarray, ularray, sizeof(dlarray))) {
+			DHD_ERROR(("%s: Downloaded image is corrupted.\n",
+				   __func__));
+			ASSERT(0);
+			goto err;
+		} else
+			DHD_ERROR(("%s: Download/Upload/Compare succeeded.\n",
+				__func__));
+
+		kfree(ularray);
+	}
+#endif				/* DHD_DEBUG */
+
+err:
+	return bcmerror;
+}
+#endif				/* BCMEMBEDIMAGE */
+
+static int dhdsdio_download_code_file(struct dhd_bus *bus, char *fw_path)
+{
+	int bcmerror = -1;
+	int offset = 0;
+	uint len;
+	void *image = NULL;
+	u8 *memblock = NULL, *memptr;
+
+	DHD_INFO(("%s: download firmware %s\n", __func__, fw_path));
+
+	image = dhd_os_open_image(fw_path);
+	if (image == NULL)
+		goto err;
+
+	memptr = memblock = kmalloc(MEMBLOCK + DHD_SDALIGN, GFP_ATOMIC);
+	if (memblock == NULL) {
+		DHD_ERROR(("%s: Failed to allocate memory %d bytes\n",
+			   __func__, MEMBLOCK));
+		goto err;
+	}
+	if ((u32)(unsigned long)memblock % DHD_SDALIGN)
+		memptr +=
+		    (DHD_SDALIGN - ((u32)(unsigned long)memblock % DHD_SDALIGN));
+
+	/* Download image */
+	while ((len =
+		dhd_os_get_image_block((char *)memptr, MEMBLOCK, image))) {
+		bcmerror = dhdsdio_membytes(bus, true, offset, memptr, len);
+		if (bcmerror) {
+			DHD_ERROR(("%s: error %d on writing %d membytes at "
+			"0x%08x\n", __func__, bcmerror, MEMBLOCK, offset));
+			goto err;
+		}
+
+		offset += MEMBLOCK;
+	}
+
+err:
+	if (memblock)
+		kfree(memblock);
+
+	if (image)
+		dhd_os_close_image(image);
+
+	return bcmerror;
+}
+
+/*
+ * ProcessVars:Takes a buffer of "<var>=<value>\n" lines read from a file
+ * and ending in a NUL.
+ * Removes carriage returns, empty lines, comment lines, and converts
+ * newlines to NULs.
+ * Shortens buffer as needed and pads with NULs.  End of buffer is marked
+ * by two NULs.
+*/
+
+static uint process_nvram_vars(char *varbuf, uint len)
+{
+	char *dp;
+	bool findNewline;
+	int column;
+	uint buf_len, n;
+
+	dp = varbuf;
+
+	findNewline = false;
+	column = 0;
+
+	for (n = 0; n < len; n++) {
+		if (varbuf[n] == 0)
+			break;
+		if (varbuf[n] == '\r')
+			continue;
+		if (findNewline && varbuf[n] != '\n')
+			continue;
+		findNewline = false;
+		if (varbuf[n] == '#') {
+			findNewline = true;
+			continue;
+		}
+		if (varbuf[n] == '\n') {
+			if (column == 0)
+				continue;
+			*dp++ = 0;
+			column = 0;
+			continue;
+		}
+		*dp++ = varbuf[n];
+		column++;
+	}
+	buf_len = dp - varbuf;
+
+	while (dp < varbuf + n)
+		*dp++ = 0;
+
+	return buf_len;
+}
+
+/*
+	EXAMPLE: nvram_array
+	nvram_arry format:
+	name=value
+	Use carriage return at the end of each assignment,
+	 and an empty string with
+	carriage return at the end of array.
+
+	For example:
+	unsigned char  nvram_array[] = {"name1=value1\n",
+	"name2=value2\n", "\n"};
+	Hex values start with 0x, and mac addr format: xx:xx:xx:xx:xx:xx.
+
+	Search "EXAMPLE: nvram_array" to see how the array is activated.
+*/
+
+void dhd_bus_set_nvram_params(struct dhd_bus *bus, const char *nvram_params)
+{
+	bus->nvram_params = nvram_params;
+}
+
+static int dhdsdio_download_nvram(struct dhd_bus *bus)
+{
+	int bcmerror = -1;
+	uint len;
+	void *image = NULL;
+	char *memblock = NULL;
+	char *bufp;
+	char *nv_path;
+	bool nvram_file_exists;
+
+	nv_path = bus->nv_path;
+
+	nvram_file_exists = ((nv_path != NULL) && (nv_path[0] != '\0'));
+	if (!nvram_file_exists && (bus->nvram_params == NULL))
+		return 0;
+
+	if (nvram_file_exists) {
+		image = dhd_os_open_image(nv_path);
+		if (image == NULL)
+			goto err;
+	}
+
+	memblock = kmalloc(MEMBLOCK, GFP_ATOMIC);
+	if (memblock == NULL) {
+		DHD_ERROR(("%s: Failed to allocate memory %d bytes\n",
+			   __func__, MEMBLOCK));
+		goto err;
+	}
+
+	/* Download variables */
+	if (nvram_file_exists) {
+		len = dhd_os_get_image_block(memblock, MEMBLOCK, image);
+	} else {
+		len = strlen(bus->nvram_params);
+		ASSERT(len <= MEMBLOCK);
+		if (len > MEMBLOCK)
+			len = MEMBLOCK;
+		memcpy(memblock, bus->nvram_params, len);
+	}
+
+	if (len > 0 && len < MEMBLOCK) {
+		bufp = (char *)memblock;
+		bufp[len] = 0;
+		len = process_nvram_vars(bufp, len);
+		bufp += len;
+		*bufp++ = 0;
+		if (len)
+			bcmerror = dhdsdio_downloadvars(bus, memblock, len + 1);
+		if (bcmerror) {
+			DHD_ERROR(("%s: error downloading vars: %d\n",
+				   __func__, bcmerror));
+		}
+	} else {
+		DHD_ERROR(("%s: error reading nvram file: %d\n",
+			   __func__, len));
+		bcmerror = BCME_SDIO_ERROR;
+	}
+
+err:
+	if (memblock)
+		kfree(memblock);
+
+	if (image)
+		dhd_os_close_image(image);
+
+	return bcmerror;
+}
+
+static int _dhdsdio_download_firmware(struct dhd_bus *bus)
+{
+	int bcmerror = -1;
+
+	bool embed = false;	/* download embedded firmware */
+	bool dlok = false;	/* download firmware succeeded */
+
+	/* Out immediately if no image to download */
+	if ((bus->fw_path == NULL) || (bus->fw_path[0] == '\0')) {
+#ifdef BCMEMBEDIMAGE
+		embed = true;
+#else
+		return bcmerror;
+#endif
+	}
+
+	/* Keep arm in reset */
+	if (dhdsdio_download_state(bus, true)) {
+		DHD_ERROR(("%s: error placing ARM core in reset\n", __func__));
+		goto err;
+	}
+
+	/* External image takes precedence if specified */
+	if ((bus->fw_path != NULL) && (bus->fw_path[0] != '\0')) {
+		if (dhdsdio_download_code_file(bus, bus->fw_path)) {
+			DHD_ERROR(("%s: dongle image file download failed\n",
+				   __func__));
+#ifdef BCMEMBEDIMAGE
+			embed = true;
+#else
+			goto err;
+#endif
+		} else {
+			embed = false;
+			dlok = true;
+		}
+	}
+#ifdef BCMEMBEDIMAGE
+	if (embed) {
+		if (dhdsdio_download_code_array(bus)) {
+			DHD_ERROR(("%s: dongle image array download failed\n",
+				   __func__));
+			goto err;
+		} else {
+			dlok = true;
+		}
+	}
+#endif
+	if (!dlok) {
+		DHD_ERROR(("%s: dongle image download failed\n", __func__));
+		goto err;
+	}
+
+	/* EXAMPLE: nvram_array */
+	/* If a valid nvram_arry is specified as above, it can be passed
+		 down to dongle */
+	/* dhd_bus_set_nvram_params(bus, (char *)&nvram_array); */
+
+	/* External nvram takes precedence if specified */
+	if (dhdsdio_download_nvram(bus)) {
+		DHD_ERROR(("%s: dongle nvram file download failed\n",
+			   __func__));
+	}
+
+	/* Take arm out of reset */
+	if (dhdsdio_download_state(bus, false)) {
+		DHD_ERROR(("%s: error getting out of ARM core reset\n",
+			   __func__));
+		goto err;
+	}
+
+	bcmerror = 0;
+
+err:
+	return bcmerror;
+}
+
+static int
+dhd_bcmsdh_recv_buf(dhd_bus_t *bus, u32 addr, uint fn, uint flags,
+		    u8 *buf, uint nbytes, void *pkt,
+		    bcmsdh_cmplt_fn_t complete, void *handle)
+{
+	int status;
+
+	/* 4329: GSPI check */
+	status =
+	    bcmsdh_recv_buf(bus->sdh, addr, fn, flags, buf, nbytes, pkt,
+			    complete, handle);
+	return status;
+}
+
+static int
+dhd_bcmsdh_send_buf(dhd_bus_t *bus, u32 addr, uint fn, uint flags,
+		    u8 *buf, uint nbytes, void *pkt,
+		    bcmsdh_cmplt_fn_t complete, void *handle)
+{
+	return bcmsdh_send_buf
+		(bus->sdh, addr, fn, flags, buf, nbytes, pkt, complete,
+		 handle);
+}
+
+uint dhd_bus_chip(struct dhd_bus *bus)
+{
+	ASSERT(bus->sih != NULL);
+	return bus->sih->chip;
+}
+
+void *dhd_bus_pub(struct dhd_bus *bus)
+{
+	return bus->dhd;
+}
+
+void *dhd_bus_txq(struct dhd_bus *bus)
+{
+	return &bus->txq;
+}
+
+uint dhd_bus_hdrlen(struct dhd_bus *bus)
+{
+	return SDPCM_HDRLEN;
+}
+
+int dhd_bus_devreset(dhd_pub_t *dhdp, u8 flag)
+{
+	int bcmerror = 0;
+	dhd_bus_t *bus;
+
+	bus = dhdp->bus;
+
+	if (flag == true) {
+		if (!bus->dhd->dongle_reset) {
+			/* Expect app to have torn down any
+			 connection before calling */
+			/* Stop the bus, disable F2 */
+			dhd_bus_stop(bus, false);
+
+			/* Clean tx/rx buffer pointers,
+			 detach from the dongle */
+			dhdsdio_release_dongle(bus, bus->dhd->osh);
+
+			bus->dhd->dongle_reset = true;
+			bus->dhd->up = false;
+
+			DHD_TRACE(("%s:  WLAN OFF DONE\n", __func__));
+			/* App can now remove power from device */
+		} else
+			bcmerror = BCME_SDIO_ERROR;
+	} else {
+		/* App must have restored power to device before calling */
+
+		DHD_TRACE(("\n\n%s: == WLAN ON ==\n", __func__));
+
+		if (bus->dhd->dongle_reset) {
+			/* Turn on WLAN */
+			/* Reset SD client */
+			bcmsdh_reset(bus->sdh);
+
+			/* Attempt to re-attach & download */
+			if (dhdsdio_probe_attach(bus, bus->dhd->osh, bus->sdh,
+						 (u32 *) SI_ENUM_BASE,
+						 bus->cl_devid)) {
+				/* Attempt to download binary to the dongle */
+				if (dhdsdio_probe_init
+				    (bus, bus->dhd->osh, bus->sdh)
+				    && dhdsdio_download_firmware(bus,
+								 bus->dhd->osh,
+								 bus->sdh)) {
+
+					/* Re-init bus, enable F2 transfer */
+					dhd_bus_init((dhd_pub_t *) bus->dhd,
+						     false);
+
+#if defined(OOB_INTR_ONLY)
+					dhd_enable_oob_intr(bus, true);
+#endif				/* defined(OOB_INTR_ONLY) */
+
+					bus->dhd->dongle_reset = false;
+					bus->dhd->up = true;
+
+					DHD_TRACE(("%s: WLAN ON DONE\n",
+						   __func__));
+				} else
+					bcmerror = BCME_SDIO_ERROR;
+			} else
+				bcmerror = BCME_SDIO_ERROR;
+		} else {
+			bcmerror = BCME_NOTDOWN;
+			DHD_ERROR(("%s: Set DEVRESET=false invoked when device "
+				"is on\n", __func__));
+			bcmerror = BCME_SDIO_ERROR;
+		}
+	}
+	return bcmerror;
+}
diff --git a/drivers/staging/brcm80211/brcmfmac/dngl_stats.h b/drivers/staging/brcm80211/brcmfmac/dngl_stats.h
new file mode 100644
index 0000000..699cbff
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/dngl_stats.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _dngl_stats_h_
+#define _dngl_stats_h_
+
+typedef struct {
+	unsigned long rx_packets;	/* total packets received */
+	unsigned long tx_packets;	/* total packets transmitted */
+	unsigned long rx_bytes;	/* total bytes received */
+	unsigned long tx_bytes;	/* total bytes transmitted */
+	unsigned long rx_errors;	/* bad packets received */
+	unsigned long tx_errors;	/* packet transmit problems */
+	unsigned long rx_dropped;	/* packets dropped by dongle */
+	unsigned long tx_dropped;	/* packets dropped by dongle */
+	unsigned long multicast;	/* multicast packets received */
+} dngl_stats_t;
+
+#endif				/* _dngl_stats_h_ */
diff --git a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
new file mode 100644
index 0000000..3f29488
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
@@ -0,0 +1,4229 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/if_arp.h>
+#include <linuxver.h>
+#include <osl.h>
+
+#include <bcmutils.h>
+#include <bcmendian.h>
+#include <proto/ethernet.h>
+
+#include <asm/uaccess.h>
+
+#include <dngl_stats.h>
+#include <dhd.h>
+#include <dhdioctl.h>
+#include <wlioctl.h>
+
+#include <proto/ethernet.h>
+#include <dngl_stats.h>
+#include <dhd.h>
+
+#include <linux/kthread.h>
+#include <linux/netdevice.h>
+#include <linux/sched.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <net/cfg80211.h>
+
+#include <net/rtnetlink.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/firmware.h>
+#include <wl_cfg80211.h>
+
+static struct sdio_func *cfg80211_sdio_func;
+static struct wl_dev *wl_cfg80211_dev;
+
+u32 wl_dbg_level = WL_DBG_ERR | WL_DBG_INFO;
+
+#define WL_4329_FW_FILE "brcm/bcm4329-fullmac-4.bin"
+#define WL_4329_NVRAM_FILE "brcm/bcm4329-fullmac-4.txt"
+
+/*
+** cfg80211_ops api/callback list
+*/
+static s32 wl_cfg80211_change_iface(struct wiphy *wiphy,
+				      struct net_device *ndev,
+				      enum nl80211_iftype type, u32 *flags,
+				      struct vif_params *params);
+static s32 __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
+				struct cfg80211_scan_request *request,
+				struct cfg80211_ssid *this_ssid);
+static s32 wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
+			      struct cfg80211_scan_request *request);
+static s32 wl_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed);
+static s32 wl_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *dev,
+				   struct cfg80211_ibss_params *params);
+static s32 wl_cfg80211_leave_ibss(struct wiphy *wiphy,
+				    struct net_device *dev);
+static s32 wl_cfg80211_get_station(struct wiphy *wiphy,
+				     struct net_device *dev, u8 *mac,
+				     struct station_info *sinfo);
+static s32 wl_cfg80211_set_power_mgmt(struct wiphy *wiphy,
+					struct net_device *dev, bool enabled,
+					s32 timeout);
+static s32 wl_cfg80211_set_bitrate_mask(struct wiphy *wiphy,
+					  struct net_device *dev,
+					  const u8 *addr,
+					  const struct cfg80211_bitrate_mask
+					  *mask);
+static int wl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
+			       struct cfg80211_connect_params *sme);
+static s32 wl_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
+				    u16 reason_code);
+static s32 wl_cfg80211_set_tx_power(struct wiphy *wiphy,
+				      enum nl80211_tx_power_setting type,
+				      s32 dbm);
+static s32 wl_cfg80211_get_tx_power(struct wiphy *wiphy, s32 *dbm);
+static s32 wl_cfg80211_config_default_key(struct wiphy *wiphy,
+					    struct net_device *dev,
+					    u8 key_idx);
+static s32 wl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *dev,
+				 u8 key_idx, const u8 *mac_addr,
+				 struct key_params *params);
+static s32 wl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *dev,
+				 u8 key_idx, const u8 *mac_addr);
+static s32 wl_cfg80211_get_key(struct wiphy *wiphy, struct net_device *dev,
+				 u8 key_idx, const u8 *mac_addr,
+				 void *cookie, void (*callback) (void *cookie,
+								 struct
+								 key_params *
+								 params));
+static s32 wl_cfg80211_config_default_mgmt_key(struct wiphy *wiphy,
+						 struct net_device *dev,
+						 u8 key_idx);
+static s32 wl_cfg80211_resume(struct wiphy *wiphy);
+static s32 wl_cfg80211_suspend(struct wiphy *wiphy);
+static s32 wl_cfg80211_set_pmksa(struct wiphy *wiphy, struct net_device *dev,
+				   struct cfg80211_pmksa *pmksa);
+static s32 wl_cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *dev,
+				   struct cfg80211_pmksa *pmksa);
+static s32 wl_cfg80211_flush_pmksa(struct wiphy *wiphy,
+				     struct net_device *dev);
+/*
+** event & event Q handlers for cfg80211 interfaces
+*/
+static s32 wl_create_event_handler(struct wl_priv *wl);
+static void wl_destroy_event_handler(struct wl_priv *wl);
+static s32 wl_event_handler(void *data);
+static void wl_init_eq(struct wl_priv *wl);
+static void wl_flush_eq(struct wl_priv *wl);
+static void wl_lock_eq(struct wl_priv *wl);
+static void wl_unlock_eq(struct wl_priv *wl);
+static void wl_init_eq_lock(struct wl_priv *wl);
+static void wl_init_eloop_handler(struct wl_event_loop *el);
+static struct wl_event_q *wl_deq_event(struct wl_priv *wl);
+static s32 wl_enq_event(struct wl_priv *wl, u32 type,
+			  const wl_event_msg_t *msg, void *data);
+static void wl_put_event(struct wl_event_q *e);
+static void wl_wakeup_event(struct wl_priv *wl);
+static s32 wl_notify_connect_status(struct wl_priv *wl,
+				      struct net_device *ndev,
+				      const wl_event_msg_t *e, void *data);
+static s32 wl_notify_roaming_status(struct wl_priv *wl,
+				      struct net_device *ndev,
+				      const wl_event_msg_t *e, void *data);
+static s32 wl_notify_scan_status(struct wl_priv *wl, struct net_device *ndev,
+				   const wl_event_msg_t *e, void *data);
+static s32 wl_bss_connect_done(struct wl_priv *wl, struct net_device *ndev,
+				 const wl_event_msg_t *e, void *data,
+				bool completed);
+static s32 wl_bss_roaming_done(struct wl_priv *wl, struct net_device *ndev,
+				 const wl_event_msg_t *e, void *data);
+static s32 wl_notify_mic_status(struct wl_priv *wl, struct net_device *ndev,
+				  const wl_event_msg_t *e, void *data);
+
+/*
+** register/deregister sdio function
+*/
+struct sdio_func *wl_cfg80211_get_sdio_func(void);
+static void wl_clear_sdio_func(void);
+
+/*
+** ioctl utilites
+*/
+static s32 wl_dev_bufvar_get(struct net_device *dev, s8 *name, s8 *buf,
+			       s32 buf_len);
+static __used s32 wl_dev_bufvar_set(struct net_device *dev, s8 *name,
+				      s8 *buf, s32 len);
+static s32 wl_dev_intvar_set(struct net_device *dev, s8 *name, s32 val);
+static s32 wl_dev_intvar_get(struct net_device *dev, s8 *name,
+			       s32 *retval);
+static s32 wl_dev_ioctl(struct net_device *dev, u32 cmd, void *arg,
+			  u32 len);
+
+/*
+** cfg80211 set_wiphy_params utilities
+*/
+static s32 wl_set_frag(struct net_device *dev, u32 frag_threshold);
+static s32 wl_set_rts(struct net_device *dev, u32 frag_threshold);
+static s32 wl_set_retry(struct net_device *dev, u32 retry, bool l);
+
+/*
+** wl profile utilities
+*/
+static s32 wl_update_prof(struct wl_priv *wl, const wl_event_msg_t *e,
+			    void *data, s32 item);
+static void *wl_read_prof(struct wl_priv *wl, s32 item);
+static void wl_init_prof(struct wl_profile *prof);
+
+/*
+** cfg80211 connect utilites
+*/
+static s32 wl_set_wpa_version(struct net_device *dev,
+				struct cfg80211_connect_params *sme);
+static s32 wl_set_auth_type(struct net_device *dev,
+			      struct cfg80211_connect_params *sme);
+static s32 wl_set_set_cipher(struct net_device *dev,
+			       struct cfg80211_connect_params *sme);
+static s32 wl_set_key_mgmt(struct net_device *dev,
+			     struct cfg80211_connect_params *sme);
+static s32 wl_set_set_sharedkey(struct net_device *dev,
+				  struct cfg80211_connect_params *sme);
+static s32 wl_get_assoc_ies(struct wl_priv *wl);
+static void wl_ch_to_chanspec(int ch,
+	struct wl_join_params *join_params, size_t *join_params_size);
+
+/*
+** information element utilities
+*/
+static void wl_rst_ie(struct wl_priv *wl);
+static __used s32 wl_add_ie(struct wl_priv *wl, u8 t, u8 l, u8 *v);
+static s32 wl_mrg_ie(struct wl_priv *wl, u8 *ie_stream, u16 ie_size);
+static s32 wl_cp_ie(struct wl_priv *wl, u8 *dst, u16 dst_size);
+static u32 wl_get_ielen(struct wl_priv *wl);
+
+static s32 wl_mode_to_nl80211_iftype(s32 mode);
+
+static struct wireless_dev *wl_alloc_wdev(s32 sizeof_iface,
+					  struct device *dev);
+static void wl_free_wdev(struct wl_priv *wl);
+
+static s32 wl_inform_bss(struct wl_priv *wl);
+static s32 wl_inform_single_bss(struct wl_priv *wl, struct wl_bss_info *bi);
+static s32 wl_update_bss_info(struct wl_priv *wl);
+
+static s32 wl_add_keyext(struct wiphy *wiphy, struct net_device *dev,
+			   u8 key_idx, const u8 *mac_addr,
+			   struct key_params *params);
+
+/*
+** key indianess swap utilities
+*/
+static void swap_key_from_BE(struct wl_wsec_key *key);
+static void swap_key_to_BE(struct wl_wsec_key *key);
+
+/*
+** wl_priv memory init/deinit utilities
+*/
+static s32 wl_init_priv_mem(struct wl_priv *wl);
+static void wl_deinit_priv_mem(struct wl_priv *wl);
+
+static void wl_delay(u32 ms);
+
+/*
+** store/restore cfg80211 instance data
+*/
+static void wl_set_drvdata(struct wl_dev *dev, void *data);
+static void *wl_get_drvdata(struct wl_dev *dev);
+
+/*
+** ibss mode utilities
+*/
+static bool wl_is_ibssmode(struct wl_priv *wl);
+static bool wl_is_ibssstarter(struct wl_priv *wl);
+
+/*
+** dongle up/down , default configuration utilities
+*/
+static bool wl_is_linkdown(struct wl_priv *wl, const wl_event_msg_t *e);
+static bool wl_is_linkup(struct wl_priv *wl, const wl_event_msg_t *e);
+static bool wl_is_nonetwork(struct wl_priv *wl, const wl_event_msg_t *e);
+static void wl_link_up(struct wl_priv *wl);
+static void wl_link_down(struct wl_priv *wl);
+static s32 wl_dongle_mode(struct net_device *ndev, s32 iftype);
+static s32 __wl_cfg80211_up(struct wl_priv *wl);
+static s32 __wl_cfg80211_down(struct wl_priv *wl);
+static s32 wl_dongle_probecap(struct wl_priv *wl);
+static void wl_init_conf(struct wl_conf *conf);
+
+/*
+** dongle configuration utilities
+*/
+#ifndef EMBEDDED_PLATFORM
+static s32 wl_dongle_mode(struct net_device *ndev, s32 iftype);
+static s32 wl_dongle_country(struct net_device *ndev, u8 ccode);
+static s32 wl_dongle_up(struct net_device *ndev, u32 up);
+static s32 wl_dongle_power(struct net_device *ndev, u32 power_mode);
+static s32 wl_dongle_glom(struct net_device *ndev, u32 glom,
+			    u32 dongle_align);
+static s32 wl_dongle_roam(struct net_device *ndev, u32 roamvar,
+			    u32 bcn_timeout);
+static s32 wl_dongle_eventmsg(struct net_device *ndev);
+static s32 wl_dongle_scantime(struct net_device *ndev, s32 scan_assoc_time,
+				s32 scan_unassoc_time);
+static s32 wl_dongle_offload(struct net_device *ndev, s32 arpoe,
+			       s32 arp_ol);
+static s32 wl_pattern_atoh(s8 *src, s8 *dst);
+static s32 wl_dongle_filter(struct net_device *ndev, u32 filter_mode);
+static s32 wl_update_wiphybands(struct wl_priv *wl);
+#endif				/* !EMBEDDED_PLATFORM */
+static s32 wl_config_dongle(struct wl_priv *wl, bool need_lock);
+
+/*
+** iscan handler
+*/
+static void wl_iscan_timer(unsigned long data);
+static void wl_term_iscan(struct wl_priv *wl);
+static s32 wl_init_iscan(struct wl_priv *wl);
+static s32 wl_iscan_thread(void *data);
+static s32 wl_dev_iovar_setbuf(struct net_device *dev, s8 *iovar,
+				 void *param, s32 paramlen, void *bufptr,
+				 s32 buflen);
+static s32 wl_dev_iovar_getbuf(struct net_device *dev, s8 *iovar,
+				 void *param, s32 paramlen, void *bufptr,
+				 s32 buflen);
+static s32 wl_run_iscan(struct wl_iscan_ctrl *iscan, struct wlc_ssid *ssid,
+			  u16 action);
+static s32 wl_do_iscan(struct wl_priv *wl);
+static s32 wl_wakeup_iscan(struct wl_iscan_ctrl *iscan);
+static s32 wl_invoke_iscan(struct wl_priv *wl);
+static s32 wl_get_iscan_results(struct wl_iscan_ctrl *iscan, u32 *status,
+				  struct wl_scan_results **bss_list);
+static void wl_notify_iscan_complete(struct wl_iscan_ctrl *iscan, bool aborted);
+static void wl_init_iscan_eloop(struct wl_iscan_eloop *el);
+static s32 wl_iscan_done(struct wl_priv *wl);
+static s32 wl_iscan_pending(struct wl_priv *wl);
+static s32 wl_iscan_inprogress(struct wl_priv *wl);
+static s32 wl_iscan_aborted(struct wl_priv *wl);
+
+/*
+** fw/nvram downloading handler
+*/
+static void wl_init_fw(struct wl_fw_ctrl *fw);
+
+/*
+* find most significant bit set
+*/
+static __used u32 wl_find_msb(u16 bit16);
+
+/*
+* update pmklist to dongle
+*/
+static __used s32 wl_update_pmklist(struct net_device *dev,
+				      struct wl_pmk_list *pmk_list, s32 err);
+
+static void wl_set_mpc(struct net_device *ndev, int mpc);
+
+/*
+* debufs support
+*/
+static int wl_debugfs_add_netdev_params(struct wl_priv *wl);
+static void wl_debugfs_remove_netdev(struct wl_priv *wl);
+
+#define WL_PRIV_GET() 							\
+	({								\
+	struct wl_iface *ci;						\
+	if (unlikely(!(wl_cfg80211_dev && 				\
+		(ci = wl_get_drvdata(wl_cfg80211_dev))))) {		\
+		WL_ERR(("wl_cfg80211_dev is unavailable\n"));		\
+		BUG();							\
+	} 								\
+	ci_to_wl(ci);							\
+})
+
+#define CHECK_SYS_UP()							\
+do {									\
+	struct wl_priv *wl = wiphy_to_wl(wiphy);			\
+	if (unlikely(!test_bit(WL_STATUS_READY, &wl->status))) {	\
+		WL_INFO(("device is not ready : status (%d)\n",		\
+			(int)wl->status));				\
+		return -EIO;						\
+	}								\
+} while (0)
+
+extern int dhd_wait_pend8021x(struct net_device *dev);
+
+#if (WL_DBG_LEVEL > 0)
+#define WL_DBG_ESTR_MAX	32
+static s8 wl_dbg_estr[][WL_DBG_ESTR_MAX] = {
+	"SET_SSID", "JOIN", "START", "AUTH", "AUTH_IND",
+	"DEAUTH", "DEAUTH_IND", "ASSOC", "ASSOC_IND", "REASSOC",
+	"REASSOC_IND", "DISASSOC", "DISASSOC_IND", "QUIET_START", "QUIET_END",
+	"BEACON_RX", "LINK", "MIC_ERROR", "NDIS_LINK", "ROAM",
+	"TXFAIL", "PMKID_CACHE", "RETROGRADE_TSF", "PRUNE", "AUTOAUTH",
+	"EAPOL_MSG", "SCAN_COMPLETE", "ADDTS_IND", "DELTS_IND", "BCNSENT_IND",
+	"BCNRX_MSG", "BCNLOST_MSG", "ROAM_PREP", "PFN_NET_FOUND",
+	"PFN_NET_LOST",
+	"RESET_COMPLETE", "JOIN_START", "ROAM_START", "ASSOC_START",
+	"IBSS_ASSOC",
+	"RADIO", "PSM_WATCHDOG",
+	"PROBREQ_MSG",
+	"SCAN_CONFIRM_IND", "PSK_SUP", "COUNTRY_CODE_CHANGED",
+	"EXCEEDED_MEDIUM_TIME", "ICV_ERROR",
+	"UNICAST_DECODE_ERROR", "MULTICAST_DECODE_ERROR", "TRACE",
+	"IF",
+	"RSSI", "PFN_SCAN_COMPLETE", "ACTION_FRAME", "ACTION_FRAME_COMPLETE",
+};
+#endif				/* WL_DBG_LEVEL */
+
+#define CHAN2G(_channel, _freq, _flags) {			\
+	.band			= IEEE80211_BAND_2GHZ,		\
+	.center_freq		= (_freq),			\
+	.hw_value		= (_channel),			\
+	.flags			= (_flags),			\
+	.max_antenna_gain	= 0,				\
+	.max_power		= 30,				\
+}
+
+#define CHAN5G(_channel, _flags) {				\
+	.band			= IEEE80211_BAND_5GHZ,		\
+	.center_freq		= 5000 + (5 * (_channel)),	\
+	.hw_value		= (_channel),			\
+	.flags			= (_flags),			\
+	.max_antenna_gain	= 0,				\
+	.max_power		= 30,				\
+}
+
+#define RATE_TO_BASE100KBPS(rate)   (((rate) * 10) / 2)
+#define RATETAB_ENT(_rateid, _flags) \
+	{                                                               \
+		.bitrate        = RATE_TO_BASE100KBPS(_rateid),     \
+		.hw_value       = (_rateid),                            \
+		.flags          = (_flags),                             \
+	}
+
+static struct ieee80211_rate __wl_rates[] = {
+	RATETAB_ENT(WLC_RATE_1M, 0),
+	RATETAB_ENT(WLC_RATE_2M, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATETAB_ENT(WLC_RATE_5M5, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATETAB_ENT(WLC_RATE_11M, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATETAB_ENT(WLC_RATE_6M, 0),
+	RATETAB_ENT(WLC_RATE_9M, 0),
+	RATETAB_ENT(WLC_RATE_12M, 0),
+	RATETAB_ENT(WLC_RATE_18M, 0),
+	RATETAB_ENT(WLC_RATE_24M, 0),
+	RATETAB_ENT(WLC_RATE_36M, 0),
+	RATETAB_ENT(WLC_RATE_48M, 0),
+	RATETAB_ENT(WLC_RATE_54M, 0),
+};
+
+#define wl_a_rates		(__wl_rates + 4)
+#define wl_a_rates_size	8
+#define wl_g_rates		(__wl_rates + 0)
+#define wl_g_rates_size	12
+
+static struct ieee80211_channel __wl_2ghz_channels[] = {
+	CHAN2G(1, 2412, 0),
+	CHAN2G(2, 2417, 0),
+	CHAN2G(3, 2422, 0),
+	CHAN2G(4, 2427, 0),
+	CHAN2G(5, 2432, 0),
+	CHAN2G(6, 2437, 0),
+	CHAN2G(7, 2442, 0),
+	CHAN2G(8, 2447, 0),
+	CHAN2G(9, 2452, 0),
+	CHAN2G(10, 2457, 0),
+	CHAN2G(11, 2462, 0),
+	CHAN2G(12, 2467, 0),
+	CHAN2G(13, 2472, 0),
+	CHAN2G(14, 2484, 0),
+};
+
+static struct ieee80211_channel __wl_5ghz_a_channels[] = {
+	CHAN5G(34, 0), CHAN5G(36, 0),
+	CHAN5G(38, 0), CHAN5G(40, 0),
+	CHAN5G(42, 0), CHAN5G(44, 0),
+	CHAN5G(46, 0), CHAN5G(48, 0),
+	CHAN5G(52, 0), CHAN5G(56, 0),
+	CHAN5G(60, 0), CHAN5G(64, 0),
+	CHAN5G(100, 0), CHAN5G(104, 0),
+	CHAN5G(108, 0), CHAN5G(112, 0),
+	CHAN5G(116, 0), CHAN5G(120, 0),
+	CHAN5G(124, 0), CHAN5G(128, 0),
+	CHAN5G(132, 0), CHAN5G(136, 0),
+	CHAN5G(140, 0), CHAN5G(149, 0),
+	CHAN5G(153, 0), CHAN5G(157, 0),
+	CHAN5G(161, 0), CHAN5G(165, 0),
+	CHAN5G(184, 0), CHAN5G(188, 0),
+	CHAN5G(192, 0), CHAN5G(196, 0),
+	CHAN5G(200, 0), CHAN5G(204, 0),
+	CHAN5G(208, 0), CHAN5G(212, 0),
+	CHAN5G(216, 0),
+};
+
+static struct ieee80211_channel __wl_5ghz_n_channels[] = {
+	CHAN5G(32, 0), CHAN5G(34, 0),
+	CHAN5G(36, 0), CHAN5G(38, 0),
+	CHAN5G(40, 0), CHAN5G(42, 0),
+	CHAN5G(44, 0), CHAN5G(46, 0),
+	CHAN5G(48, 0), CHAN5G(50, 0),
+	CHAN5G(52, 0), CHAN5G(54, 0),
+	CHAN5G(56, 0), CHAN5G(58, 0),
+	CHAN5G(60, 0), CHAN5G(62, 0),
+	CHAN5G(64, 0), CHAN5G(66, 0),
+	CHAN5G(68, 0), CHAN5G(70, 0),
+	CHAN5G(72, 0), CHAN5G(74, 0),
+	CHAN5G(76, 0), CHAN5G(78, 0),
+	CHAN5G(80, 0), CHAN5G(82, 0),
+	CHAN5G(84, 0), CHAN5G(86, 0),
+	CHAN5G(88, 0), CHAN5G(90, 0),
+	CHAN5G(92, 0), CHAN5G(94, 0),
+	CHAN5G(96, 0), CHAN5G(98, 0),
+	CHAN5G(100, 0), CHAN5G(102, 0),
+	CHAN5G(104, 0), CHAN5G(106, 0),
+	CHAN5G(108, 0), CHAN5G(110, 0),
+	CHAN5G(112, 0), CHAN5G(114, 0),
+	CHAN5G(116, 0), CHAN5G(118, 0),
+	CHAN5G(120, 0), CHAN5G(122, 0),
+	CHAN5G(124, 0), CHAN5G(126, 0),
+	CHAN5G(128, 0), CHAN5G(130, 0),
+	CHAN5G(132, 0), CHAN5G(134, 0),
+	CHAN5G(136, 0), CHAN5G(138, 0),
+	CHAN5G(140, 0), CHAN5G(142, 0),
+	CHAN5G(144, 0), CHAN5G(145, 0),
+	CHAN5G(146, 0), CHAN5G(147, 0),
+	CHAN5G(148, 0), CHAN5G(149, 0),
+	CHAN5G(150, 0), CHAN5G(151, 0),
+	CHAN5G(152, 0), CHAN5G(153, 0),
+	CHAN5G(154, 0), CHAN5G(155, 0),
+	CHAN5G(156, 0), CHAN5G(157, 0),
+	CHAN5G(158, 0), CHAN5G(159, 0),
+	CHAN5G(160, 0), CHAN5G(161, 0),
+	CHAN5G(162, 0), CHAN5G(163, 0),
+	CHAN5G(164, 0), CHAN5G(165, 0),
+	CHAN5G(166, 0), CHAN5G(168, 0),
+	CHAN5G(170, 0), CHAN5G(172, 0),
+	CHAN5G(174, 0), CHAN5G(176, 0),
+	CHAN5G(178, 0), CHAN5G(180, 0),
+	CHAN5G(182, 0), CHAN5G(184, 0),
+	CHAN5G(186, 0), CHAN5G(188, 0),
+	CHAN5G(190, 0), CHAN5G(192, 0),
+	CHAN5G(194, 0), CHAN5G(196, 0),
+	CHAN5G(198, 0), CHAN5G(200, 0),
+	CHAN5G(202, 0), CHAN5G(204, 0),
+	CHAN5G(206, 0), CHAN5G(208, 0),
+	CHAN5G(210, 0), CHAN5G(212, 0),
+	CHAN5G(214, 0), CHAN5G(216, 0),
+	CHAN5G(218, 0), CHAN5G(220, 0),
+	CHAN5G(222, 0), CHAN5G(224, 0),
+	CHAN5G(226, 0), CHAN5G(228, 0),
+};
+
+static struct ieee80211_supported_band __wl_band_2ghz = {
+	.band = IEEE80211_BAND_2GHZ,
+	.channels = __wl_2ghz_channels,
+	.n_channels = ARRAY_SIZE(__wl_2ghz_channels),
+	.bitrates = wl_g_rates,
+	.n_bitrates = wl_g_rates_size,
+};
+
+static struct ieee80211_supported_band __wl_band_5ghz_a = {
+	.band = IEEE80211_BAND_5GHZ,
+	.channels = __wl_5ghz_a_channels,
+	.n_channels = ARRAY_SIZE(__wl_5ghz_a_channels),
+	.bitrates = wl_a_rates,
+	.n_bitrates = wl_a_rates_size,
+};
+
+static struct ieee80211_supported_band __wl_band_5ghz_n = {
+	.band = IEEE80211_BAND_5GHZ,
+	.channels = __wl_5ghz_n_channels,
+	.n_channels = ARRAY_SIZE(__wl_5ghz_n_channels),
+	.bitrates = wl_a_rates,
+	.n_bitrates = wl_a_rates_size,
+};
+
+static const u32 __wl_cipher_suites[] = {
+	WLAN_CIPHER_SUITE_WEP40,
+	WLAN_CIPHER_SUITE_WEP104,
+	WLAN_CIPHER_SUITE_TKIP,
+	WLAN_CIPHER_SUITE_CCMP,
+	WLAN_CIPHER_SUITE_AES_CMAC,
+};
+
+static void swap_key_from_BE(struct wl_wsec_key *key)
+{
+	key->index = htod32(key->index);
+	key->len = htod32(key->len);
+	key->algo = htod32(key->algo);
+	key->flags = htod32(key->flags);
+	key->rxiv.hi = htod32(key->rxiv.hi);
+	key->rxiv.lo = htod16(key->rxiv.lo);
+	key->iv_initialized = htod32(key->iv_initialized);
+}
+
+static void swap_key_to_BE(struct wl_wsec_key *key)
+{
+	key->index = dtoh32(key->index);
+	key->len = dtoh32(key->len);
+	key->algo = dtoh32(key->algo);
+	key->flags = dtoh32(key->flags);
+	key->rxiv.hi = dtoh32(key->rxiv.hi);
+	key->rxiv.lo = dtoh16(key->rxiv.lo);
+	key->iv_initialized = dtoh32(key->iv_initialized);
+}
+
+static s32
+wl_dev_ioctl(struct net_device *dev, u32 cmd, void *arg, u32 len)
+{
+	struct ifreq ifr;
+	struct wl_ioctl ioc;
+	mm_segment_t fs;
+	s32 err = 0;
+
+	memset(&ioc, 0, sizeof(ioc));
+	ioc.cmd = cmd;
+	ioc.buf = arg;
+	ioc.len = len;
+	strcpy(ifr.ifr_name, dev->name);
+	ifr.ifr_data = (caddr_t)&ioc;
+
+	fs = get_fs();
+	set_fs(get_ds());
+	err = dev->netdev_ops->ndo_do_ioctl(dev, &ifr, SIOCDEVPRIVATE);
+	set_fs(fs);
+
+	return err;
+}
+
+static s32
+wl_cfg80211_change_iface(struct wiphy *wiphy, struct net_device *ndev,
+			 enum nl80211_iftype type, u32 *flags,
+			 struct vif_params *params)
+{
+	struct wl_priv *wl = wiphy_to_wl(wiphy);
+	struct wireless_dev *wdev;
+	s32 infra = 0;
+	s32 ap = 0;
+	s32 err = 0;
+
+	CHECK_SYS_UP();
+	switch (type) {
+	case NL80211_IFTYPE_MONITOR:
+	case NL80211_IFTYPE_WDS:
+		WL_ERR(("type (%d) : currently we do not support this type\n",
+			type));
+		return -EOPNOTSUPP;
+	case NL80211_IFTYPE_ADHOC:
+		wl->conf->mode = WL_MODE_IBSS;
+		break;
+	case NL80211_IFTYPE_STATION:
+		wl->conf->mode = WL_MODE_BSS;
+		infra = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+	infra = htod32(infra);
+	ap = htod32(ap);
+	wdev = ndev->ieee80211_ptr;
+	wdev->iftype = type;
+	WL_DBG(("%s : ap (%d), infra (%d)\n", ndev->name, ap, infra));
+	err = wl_dev_ioctl(ndev, WLC_SET_INFRA, &infra, sizeof(infra));
+	if (unlikely(err)) {
+		WL_ERR(("WLC_SET_INFRA error (%d)\n", err));
+		return err;
+	}
+	err = wl_dev_ioctl(ndev, WLC_SET_AP, &ap, sizeof(ap));
+	if (unlikely(err)) {
+		WL_ERR(("WLC_SET_AP error (%d)\n", err));
+		return err;
+	}
+
+	/* -EINPROGRESS: Call commit handler */
+	return -EINPROGRESS;
+}
+
+static void wl_iscan_prep(struct wl_scan_params *params, struct wlc_ssid *ssid)
+{
+	memcpy(&params->bssid, &ether_bcast, ETHER_ADDR_LEN);
+	params->bss_type = DOT11_BSSTYPE_ANY;
+	params->scan_type = 0;
+	params->nprobes = -1;
+	params->active_time = -1;
+	params->passive_time = -1;
+	params->home_time = -1;
+	params->channel_num = 0;
+
+	params->nprobes = htod32(params->nprobes);
+	params->active_time = htod32(params->active_time);
+	params->passive_time = htod32(params->passive_time);
+	params->home_time = htod32(params->home_time);
+	if (ssid && ssid->SSID_len)
+		memcpy(&params->ssid, ssid, sizeof(wlc_ssid_t));
+
+}
+
+static s32
+wl_dev_iovar_setbuf(struct net_device *dev, s8 * iovar, void *param,
+		    s32 paramlen, void *bufptr, s32 buflen)
+{
+	s32 iolen;
+
+	iolen = bcm_mkiovar(iovar, param, paramlen, bufptr, buflen);
+	BUG_ON(unlikely(!iolen));
+
+	return wl_dev_ioctl(dev, WLC_SET_VAR, bufptr, iolen);
+}
+
+static s32
+wl_dev_iovar_getbuf(struct net_device *dev, s8 * iovar, void *param,
+		    s32 paramlen, void *bufptr, s32 buflen)
+{
+	s32 iolen;
+
+	iolen = bcm_mkiovar(iovar, param, paramlen, bufptr, buflen);
+	BUG_ON(unlikely(!iolen));
+
+	return wl_dev_ioctl(dev, WLC_GET_VAR, bufptr, buflen);
+}
+
+static s32
+wl_run_iscan(struct wl_iscan_ctrl *iscan, struct wlc_ssid *ssid, u16 action)
+{
+	s32 params_size =
+	    (WL_SCAN_PARAMS_FIXED_SIZE + offsetof(wl_iscan_params_t, params));
+	struct wl_iscan_params *params;
+	s32 err = 0;
+
+	if (ssid && ssid->SSID_len)
+		params_size += sizeof(struct wlc_ssid);
+	params = (struct wl_iscan_params *)kzalloc(params_size, GFP_KERNEL);
+	if (unlikely(!params))
+		return -ENOMEM;
+	memset(params, 0, params_size);
+	BUG_ON(unlikely(params_size >= WLC_IOCTL_SMLEN));
+
+	wl_iscan_prep(&params->params, ssid);
+
+	params->version = htod32(ISCAN_REQ_VERSION);
+	params->action = htod16(action);
+	params->scan_duration = htod16(0);
+
+	/* params_size += offsetof(wl_iscan_params_t, params); */
+	err = wl_dev_iovar_setbuf(iscan->dev, "iscan", params, params_size,
+				iscan->ioctl_buf, WLC_IOCTL_SMLEN);
+	if (unlikely(err)) {
+		if (err == -EBUSY) {
+			WL_INFO(("system busy : iscan canceled\n"));
+		} else {
+			WL_ERR(("error (%d)\n", err));
+		}
+	}
+	kfree(params);
+	return err;
+}
+
+static s32 wl_do_iscan(struct wl_priv *wl)
+{
+	struct wl_iscan_ctrl *iscan = wl_to_iscan(wl);
+	struct net_device *ndev = wl_to_ndev(wl);
+	struct wlc_ssid ssid;
+	s32 passive_scan;
+	s32 err = 0;
+
+	/* Broadcast scan by default */
+	memset(&ssid, 0, sizeof(ssid));
+
+	iscan->state = WL_ISCAN_STATE_SCANING;
+
+	passive_scan = wl->active_scan ? 0 : 1;
+	err = wl_dev_ioctl(wl_to_ndev(wl), WLC_SET_PASSIVE_SCAN,
+			&passive_scan, sizeof(passive_scan));
+	if (unlikely(err)) {
+		WL_DBG(("error (%d)\n", err));
+		return err;
+	}
+	wl_set_mpc(ndev, 0);
+	wl->iscan_kickstart = true;
+	wl_run_iscan(iscan, &ssid, WL_SCAN_ACTION_START);
+	mod_timer(&iscan->timer, jiffies + iscan->timer_ms * HZ / 1000);
+	iscan->timer_on = 1;
+
+	return err;
+}
+
+static s32
+__wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
+		   struct cfg80211_scan_request *request,
+		   struct cfg80211_ssid *this_ssid)
+{
+	struct wl_priv *wl = ndev_to_wl(ndev);
+	struct cfg80211_ssid *ssids;
+	struct wl_scan_req *sr = wl_to_sr(wl);
+	s32 passive_scan;
+	bool iscan_req;
+	bool spec_scan;
+	s32 err = 0;
+
+	if (unlikely(test_bit(WL_STATUS_SCANNING, &wl->status))) {
+		WL_ERR(("Scanning already : status (%d)\n", (int)wl->status));
+		return -EAGAIN;
+	}
+	if (unlikely(test_bit(WL_STATUS_SCAN_ABORTING, &wl->status))) {
+		WL_ERR(("Scanning being aborted : status (%d)\n",
+			(int)wl->status));
+		return -EAGAIN;
+	}
+
+	iscan_req = false;
+	spec_scan = false;
+	if (request) {		/* scan bss */
+		ssids = request->ssids;
+		if (wl->iscan_on && (!ssids || !ssids->ssid_len)) {	/* for
+							 * specific scan,
+							 * ssids->ssid_len has
+							 * non-zero(ssid string)
+							 * length.
+							 * Otherwise this is 0.
+							 * we do not iscan for
+							 * specific scan request
+							 */
+			iscan_req = true;
+		}
+	} else {		/* scan in ibss */
+		/* we don't do iscan in ibss */
+		ssids = this_ssid;
+	}
+	wl->scan_request = request;
+	set_bit(WL_STATUS_SCANNING, &wl->status);
+	if (iscan_req) {
+		err = wl_do_iscan(wl);
+		if (likely(!err))
+			return err;
+		else
+			goto scan_out;
+	} else {
+		WL_DBG(("ssid \"%s\", ssid_len (%d)\n",
+			ssids->ssid, ssids->ssid_len));
+		memset(&sr->ssid, 0, sizeof(sr->ssid));
+		sr->ssid.SSID_len =
+			    min_t(u8, sizeof(sr->ssid.SSID), ssids->ssid_len);
+		if (sr->ssid.SSID_len) {
+			memcpy(sr->ssid.SSID, ssids->ssid, sr->ssid.SSID_len);
+			sr->ssid.SSID_len = htod32(sr->ssid.SSID_len);
+			WL_DBG(("Specific scan ssid=\"%s\" len=%d\n",
+					sr->ssid.SSID, sr->ssid.SSID_len));
+			spec_scan = true;
+		} else {
+			WL_DBG(("Broadcast scan\n"));
+		}
+		WL_DBG(("sr->ssid.SSID_len (%d)\n", sr->ssid.SSID_len));
+		passive_scan = wl->active_scan ? 0 : 1;
+		err = wl_dev_ioctl(ndev, WLC_SET_PASSIVE_SCAN,
+				&passive_scan, sizeof(passive_scan));
+		if (unlikely(err)) {
+			WL_ERR(("WLC_SET_PASSIVE_SCAN error (%d)\n", err));
+			goto scan_out;
+		}
+		wl_set_mpc(ndev, 0);
+		err = wl_dev_ioctl(ndev, WLC_SCAN, &sr->ssid,
+				sizeof(sr->ssid));
+		if (err) {
+			if (err == -EBUSY) {
+				WL_INFO(("system busy : scan for \"%s\" "
+					"canceled\n", sr->ssid.SSID));
+			} else {
+				WL_ERR(("WLC_SCAN error (%d)\n", err));
+			}
+			wl_set_mpc(ndev, 1);
+			goto scan_out;
+		}
+	}
+
+	return 0;
+
+scan_out:
+	clear_bit(WL_STATUS_SCANNING, &wl->status);
+	wl->scan_request = NULL;
+	return err;
+}
+
+static s32
+wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
+		 struct cfg80211_scan_request *request)
+{
+	s32 err = 0;
+
+	CHECK_SYS_UP();
+	err = __wl_cfg80211_scan(wiphy, ndev, request, NULL);
+	if (unlikely(err)) {
+		WL_DBG(("scan error (%d)\n", err));
+		return err;
+	}
+
+	return err;
+}
+
+static s32 wl_dev_intvar_set(struct net_device *dev, s8 *name, s32 val)
+{
+	s8 buf[WLC_IOCTL_SMLEN];
+	u32 len;
+	s32 err = 0;
+
+	val = htod32(val);
+	len = bcm_mkiovar(name, (char *)(&val), sizeof(val), buf, sizeof(buf));
+	BUG_ON(unlikely(!len));
+
+	err = wl_dev_ioctl(dev, WLC_SET_VAR, buf, len);
+	if (unlikely(err)) {
+		WL_ERR(("error (%d)\n", err));
+	}
+
+	return err;
+}
+
+static s32
+wl_dev_intvar_get(struct net_device *dev, s8 *name, s32 *retval)
+{
+	union {
+		s8 buf[WLC_IOCTL_SMLEN];
+		s32 val;
+	} var;
+	u32 len;
+	u32 data_null;
+	s32 err = 0;
+
+	len =
+	    bcm_mkiovar(name, (char *)(&data_null), 0, (char *)(&var),
+			sizeof(var.buf));
+	BUG_ON(unlikely(!len));
+	err = wl_dev_ioctl(dev, WLC_GET_VAR, &var, len);
+	if (unlikely(err)) {
+		WL_ERR(("error (%d)\n", err));
+	}
+	*retval = dtoh32(var.val);
+
+	return err;
+}
+
+static s32 wl_set_rts(struct net_device *dev, u32 rts_threshold)
+{
+	s32 err = 0;
+
+	err = wl_dev_intvar_set(dev, "rtsthresh", rts_threshold);
+	if (unlikely(err)) {
+		WL_ERR(("Error (%d)\n", err));
+		return err;
+	}
+	return err;
+}
+
+static s32 wl_set_frag(struct net_device *dev, u32 frag_threshold)
+{
+	s32 err = 0;
+
+	err = wl_dev_intvar_set(dev, "fragthresh", frag_threshold);
+	if (unlikely(err)) {
+		WL_ERR(("Error (%d)\n", err));
+		return err;
+	}
+	return err;
+}
+
+static s32 wl_set_retry(struct net_device *dev, u32 retry, bool l)
+{
+	s32 err = 0;
+	u32 cmd = (l ? WLC_SET_LRL : WLC_SET_SRL);
+
+	retry = htod32(retry);
+	err = wl_dev_ioctl(dev, cmd, &retry, sizeof(retry));
+	if (unlikely(err)) {
+		WL_ERR(("cmd (%d) , error (%d)\n", cmd, err));
+		return err;
+	}
+	return err;
+}
+
+static s32 wl_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
+{
+	struct wl_priv *wl = wiphy_to_wl(wiphy);
+	struct net_device *ndev = wl_to_ndev(wl);
+	s32 err = 0;
+
+	CHECK_SYS_UP();
+	if (changed & WIPHY_PARAM_RTS_THRESHOLD &&
+	    (wl->conf->rts_threshold != wiphy->rts_threshold)) {
+		wl->conf->rts_threshold = wiphy->rts_threshold;
+		err = wl_set_rts(ndev, wl->conf->rts_threshold);
+		if (!err)
+			return err;
+	}
+	if (changed & WIPHY_PARAM_FRAG_THRESHOLD &&
+	    (wl->conf->frag_threshold != wiphy->frag_threshold)) {
+		wl->conf->frag_threshold = wiphy->frag_threshold;
+		err = wl_set_frag(ndev, wl->conf->frag_threshold);
+		if (!err)
+			return err;
+	}
+	if (changed & WIPHY_PARAM_RETRY_LONG
+	    && (wl->conf->retry_long != wiphy->retry_long)) {
+		wl->conf->retry_long = wiphy->retry_long;
+		err = wl_set_retry(ndev, wl->conf->retry_long, true);
+		if (!err)
+			return err;
+	}
+	if (changed & WIPHY_PARAM_RETRY_SHORT
+	    && (wl->conf->retry_short != wiphy->retry_short)) {
+		wl->conf->retry_short = wiphy->retry_short;
+		err = wl_set_retry(ndev, wl->conf->retry_short, false);
+		if (!err) {
+			return err;
+		}
+	}
+
+	return err;
+}
+
+static s32
+wl_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *dev,
+		      struct cfg80211_ibss_params *params)
+{
+	struct wl_priv *wl = wiphy_to_wl(wiphy);
+	struct cfg80211_bss *bss;
+	struct ieee80211_channel *chan;
+	struct wl_join_params join_params;
+	struct cfg80211_ssid ssid;
+	s32 scan_retry = 0;
+	s32 err = 0;
+
+	CHECK_SYS_UP();
+	if (params->bssid) {
+		WL_ERR(("Invalid bssid\n"));
+		return -EOPNOTSUPP;
+	}
+	bss = cfg80211_get_ibss(wiphy, NULL, params->ssid, params->ssid_len);
+	if (!bss) {
+		memcpy(ssid.ssid, params->ssid, params->ssid_len);
+		ssid.ssid_len = params->ssid_len;
+		do {
+			if (unlikely
+			    (__wl_cfg80211_scan(wiphy, dev, NULL, &ssid) ==
+			     -EBUSY)) {
+				wl_delay(150);
+			} else {
+				break;
+			}
+		} while (++scan_retry < WL_SCAN_RETRY_MAX);
+		rtnl_unlock();	/* to allow scan_inform to paropagate
+					 to cfg80211 plane */
+		schedule_timeout_interruptible(4 * HZ);	/* wait 4 secons
+						 till scan done.... */
+		rtnl_lock();
+		bss = cfg80211_get_ibss(wiphy, NULL,
+					params->ssid, params->ssid_len);
+	}
+	if (bss) {
+		wl->ibss_starter = false;
+		WL_DBG(("Found IBSS\n"));
+	} else {
+		wl->ibss_starter = true;
+	}
+	chan = params->channel;
+	if (chan)
+		wl->channel = ieee80211_frequency_to_channel(chan->center_freq);
+	/*
+	 ** Join with specific BSSID and cached SSID
+	 ** If SSID is zero join based on BSSID only
+	 */
+	memset(&join_params, 0, sizeof(join_params));
+	memcpy((void *)join_params.ssid.SSID, (void *)params->ssid,
+	       params->ssid_len);
+	join_params.ssid.SSID_len = htod32(params->ssid_len);
+	if (params->bssid)
+		memcpy(&join_params.params.bssid, params->bssid,
+		       ETHER_ADDR_LEN);
+	else
+		memset(&join_params.params.bssid, 0, ETHER_ADDR_LEN);
+
+	err = wl_dev_ioctl(dev, WLC_SET_SSID, &join_params,
+			sizeof(join_params));
+	if (unlikely(err)) {
+		WL_ERR(("Error (%d)\n", err));
+		return err;
+	}
+	return err;
+}
+
+static s32 wl_cfg80211_leave_ibss(struct wiphy *wiphy, struct net_device *dev)
+{
+	struct wl_priv *wl = wiphy_to_wl(wiphy);
+	s32 err = 0;
+
+	CHECK_SYS_UP();
+	wl_link_down(wl);
+
+	return err;
+}
+
+static s32
+wl_set_wpa_version(struct net_device *dev, struct cfg80211_connect_params *sme)
+{
+	struct wl_priv *wl = ndev_to_wl(dev);
+	struct wl_security *sec;
+	s32 val = 0;
+	s32 err = 0;
+
+	if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_1)
+		val = WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED;
+	else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)
+		val = WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED;
+	else
+		val = WPA_AUTH_DISABLED;
+	WL_DBG(("setting wpa_auth to 0x%0x\n", val));
+	err = wl_dev_intvar_set(dev, "wpa_auth", val);
+	if (unlikely(err)) {
+		WL_ERR(("set wpa_auth failed (%d)\n", err));
+		return err;
+	}
+	sec = wl_read_prof(wl, WL_PROF_SEC);
+	sec->wpa_versions = sme->crypto.wpa_versions;
+	return err;
+}
+
+static s32
+wl_set_auth_type(struct net_device *dev, struct cfg80211_connect_params *sme)
+{
+	struct wl_priv *wl = ndev_to_wl(dev);
+	struct wl_security *sec;
+	s32 val = 0;
+	s32 err = 0;
+
+	switch (sme->auth_type) {
+	case NL80211_AUTHTYPE_OPEN_SYSTEM:
+		val = 0;
+		WL_DBG(("open system\n"));
+		break;
+	case NL80211_AUTHTYPE_SHARED_KEY:
+		val = 1;
+		WL_DBG(("shared key\n"));
+		break;
+	case NL80211_AUTHTYPE_AUTOMATIC:
+		val = 2;
+		WL_DBG(("automatic\n"));
+		break;
+	case NL80211_AUTHTYPE_NETWORK_EAP:
+		WL_DBG(("network eap\n"));
+	default:
+		val = 2;
+		WL_ERR(("invalid auth type (%d)\n", sme->auth_type));
+		break;
+	}
+
+	err = wl_dev_intvar_set(dev, "auth", val);
+	if (unlikely(err)) {
+		WL_ERR(("set auth failed (%d)\n", err));
+		return err;
+	}
+	sec = wl_read_prof(wl, WL_PROF_SEC);
+	sec->auth_type = sme->auth_type;
+	return err;
+}
+
+static s32
+wl_set_set_cipher(struct net_device *dev, struct cfg80211_connect_params *sme)
+{
+	struct wl_priv *wl = ndev_to_wl(dev);
+	struct wl_security *sec;
+	s32 pval = 0;
+	s32 gval = 0;
+	s32 err = 0;
+
+	if (sme->crypto.n_ciphers_pairwise) {
+		switch (sme->crypto.ciphers_pairwise[0]) {
+		case WLAN_CIPHER_SUITE_WEP40:
+		case WLAN_CIPHER_SUITE_WEP104:
+			pval = WEP_ENABLED;
+			break;
+		case WLAN_CIPHER_SUITE_TKIP:
+			pval = TKIP_ENABLED;
+			break;
+		case WLAN_CIPHER_SUITE_CCMP:
+			pval = AES_ENABLED;
+			break;
+		case WLAN_CIPHER_SUITE_AES_CMAC:
+			pval = AES_ENABLED;
+			break;
+		default:
+			WL_ERR(("invalid cipher pairwise (%d)\n",
+				sme->crypto.ciphers_pairwise[0]));
+			return -EINVAL;
+		}
+	}
+	if (sme->crypto.cipher_group) {
+		switch (sme->crypto.cipher_group) {
+		case WLAN_CIPHER_SUITE_WEP40:
+		case WLAN_CIPHER_SUITE_WEP104:
+			gval = WEP_ENABLED;
+			break;
+		case WLAN_CIPHER_SUITE_TKIP:
+			gval = TKIP_ENABLED;
+			break;
+		case WLAN_CIPHER_SUITE_CCMP:
+			gval = AES_ENABLED;
+			break;
+		case WLAN_CIPHER_SUITE_AES_CMAC:
+			gval = AES_ENABLED;
+			break;
+		default:
+			WL_ERR(("invalid cipher group (%d)\n",
+				sme->crypto.cipher_group));
+			return -EINVAL;
+		}
+	}
+
+	WL_DBG(("pval (%d) gval (%d)\n", pval, gval));
+	err = wl_dev_intvar_set(dev, "wsec", pval | gval);
+	if (unlikely(err)) {
+		WL_ERR(("error (%d)\n", err));
+		return err;
+	}
+
+	sec = wl_read_prof(wl, WL_PROF_SEC);
+	sec->cipher_pairwise = sme->crypto.ciphers_pairwise[0];
+	sec->cipher_group = sme->crypto.cipher_group;
+
+	return err;
+}
+
+static s32
+wl_set_key_mgmt(struct net_device *dev, struct cfg80211_connect_params *sme)
+{
+	struct wl_priv *wl = ndev_to_wl(dev);
+	struct wl_security *sec;
+	s32 val = 0;
+	s32 err = 0;
+
+	if (sme->crypto.n_akm_suites) {
+		err = wl_dev_intvar_get(dev, "wpa_auth", &val);
+		if (unlikely(err)) {
+			WL_ERR(("could not get wpa_auth (%d)\n", err));
+			return err;
+		}
+		if (val & (WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED)) {
+			switch (sme->crypto.akm_suites[0]) {
+			case WLAN_AKM_SUITE_8021X:
+				val = WPA_AUTH_UNSPECIFIED;
+				break;
+			case WLAN_AKM_SUITE_PSK:
+				val = WPA_AUTH_PSK;
+				break;
+			default:
+				WL_ERR(("invalid cipher group (%d)\n",
+					sme->crypto.cipher_group));
+				return -EINVAL;
+			}
+		} else if (val & (WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED)) {
+			switch (sme->crypto.akm_suites[0]) {
+			case WLAN_AKM_SUITE_8021X:
+				val = WPA2_AUTH_UNSPECIFIED;
+				break;
+			case WLAN_AKM_SUITE_PSK:
+				val = WPA2_AUTH_PSK;
+				break;
+			default:
+				WL_ERR(("invalid cipher group (%d)\n",
+					sme->crypto.cipher_group));
+				return -EINVAL;
+			}
+		}
+
+		WL_DBG(("setting wpa_auth to %d\n", val));
+		err = wl_dev_intvar_set(dev, "wpa_auth", val);
+		if (unlikely(err)) {
+			WL_ERR(("could not set wpa_auth (%d)\n", err));
+			return err;
+		}
+	}
+	sec = wl_read_prof(wl, WL_PROF_SEC);
+	sec->wpa_auth = sme->crypto.akm_suites[0];
+
+	return err;
+}
+
+static s32
+wl_set_set_sharedkey(struct net_device *dev,
+		     struct cfg80211_connect_params *sme)
+{
+	struct wl_priv *wl = ndev_to_wl(dev);
+	struct wl_security *sec;
+	struct wl_wsec_key key;
+	s32 val;
+	s32 err = 0;
+
+	WL_DBG(("key len (%d)\n", sme->key_len));
+	if (sme->key_len) {
+		sec = wl_read_prof(wl, WL_PROF_SEC);
+		WL_DBG(("wpa_versions 0x%x cipher_pairwise 0x%x\n",
+			sec->wpa_versions, sec->cipher_pairwise));
+		if (!
+		    (sec->wpa_versions & (NL80211_WPA_VERSION_1 |
+					  NL80211_WPA_VERSION_2))
+&& (sec->cipher_pairwise & (WLAN_CIPHER_SUITE_WEP40 |
+			    WLAN_CIPHER_SUITE_WEP104))) {
+			memset(&key, 0, sizeof(key));
+			key.len = (u32) sme->key_len;
+			key.index = (u32) sme->key_idx;
+			if (unlikely(key.len > sizeof(key.data))) {
+				WL_ERR(("Too long key length (%u)\n", key.len));
+				return -EINVAL;
+			}
+			memcpy(key.data, sme->key, key.len);
+			key.flags = WL_PRIMARY_KEY;
+			switch (sec->cipher_pairwise) {
+			case WLAN_CIPHER_SUITE_WEP40:
+				key.algo = CRYPTO_ALGO_WEP1;
+				break;
+			case WLAN_CIPHER_SUITE_WEP104:
+				key.algo = CRYPTO_ALGO_WEP128;
+				break;
+			default:
+				WL_ERR(("Invalid algorithm (%d)\n",
+					sme->crypto.ciphers_pairwise[0]));
+				return -EINVAL;
+			}
+			/* Set the new key/index */
+			WL_DBG(("key length (%d) key index (%d) algo (%d)\n",
+				key.len, key.index, key.algo));
+			WL_DBG(("key \"%s\"\n", key.data));
+			swap_key_from_BE(&key);
+			err = wl_dev_ioctl(dev, WLC_SET_KEY, &key,
+					sizeof(key));
+			if (unlikely(err)) {
+				WL_ERR(("WLC_SET_KEY error (%d)\n", err));
+				return err;
+			}
+			if (sec->auth_type == NL80211_AUTHTYPE_OPEN_SYSTEM) {
+				WL_DBG(("set auth_type to shared key\n"));
+				val = 1;	/* shared key */
+				err = wl_dev_intvar_set(dev, "auth", val);
+				if (unlikely(err)) {
+					WL_ERR(("set auth failed (%d)\n", err));
+					return err;
+				}
+			}
+		}
+	}
+	return err;
+}
+
+static s32
+wl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
+		    struct cfg80211_connect_params *sme)
+{
+	struct wl_priv *wl = wiphy_to_wl(wiphy);
+	struct ieee80211_channel *chan = sme->channel;
+	struct wl_join_params join_params;
+	size_t join_params_size;
+
+	s32 err = 0;
+
+	CHECK_SYS_UP();
+	if (unlikely(!sme->ssid)) {
+		WL_ERR(("Invalid ssid\n"));
+		return -EOPNOTSUPP;
+	}
+	if (chan) {
+		wl->channel = ieee80211_frequency_to_channel(chan->center_freq);
+		WL_DBG(("channel (%d), center_req (%d)\n", wl->channel,
+			chan->center_freq));
+	}
+	WL_DBG(("ie (%p), ie_len (%zd)\n", sme->ie, sme->ie_len));
+	err = wl_set_wpa_version(dev, sme);
+	if (unlikely(err))
+		return err;
+
+	err = wl_set_auth_type(dev, sme);
+	if (unlikely(err))
+		return err;
+
+	err = wl_set_set_cipher(dev, sme);
+	if (unlikely(err))
+		return err;
+
+	err = wl_set_key_mgmt(dev, sme);
+	if (unlikely(err))
+		return err;
+
+	err = wl_set_set_sharedkey(dev, sme);
+	if (unlikely(err))
+		return err;
+
+	wl_update_prof(wl, NULL, sme->bssid, WL_PROF_BSSID);
+	/*
+	 **  Join with specific BSSID and cached SSID
+	 **  If SSID is zero join based on BSSID only
+	 */
+	memset(&join_params, 0, sizeof(join_params));
+	join_params_size = sizeof(join_params.ssid);
+
+	join_params.ssid.SSID_len = min(sizeof(join_params.ssid.SSID), sme->ssid_len);
+	memcpy(&join_params.ssid.SSID, sme->ssid, join_params.ssid.SSID_len);
+	join_params.ssid.SSID_len = htod32(join_params.ssid.SSID_len);
+	wl_update_prof(wl, NULL, &join_params.ssid, WL_PROF_SSID);
+	memcpy(&join_params.params.bssid, &ether_bcast, ETHER_ADDR_LEN);
+
+	wl_ch_to_chanspec(wl->channel, &join_params, &join_params_size);
+	WL_DBG(("join_param_size %d\n", join_params_size));
+
+	if (join_params.ssid.SSID_len < IEEE80211_MAX_SSID_LEN) {
+		WL_DBG(("ssid \"%s\", len (%d)\n", join_params.ssid.SSID,
+			join_params.ssid.SSID_len));
+	}
+	err = wl_dev_ioctl(dev, WLC_SET_SSID, &join_params, join_params_size);
+	if (unlikely(err)) {
+		WL_ERR(("error (%d)\n", err));
+		return err;
+	}
+	set_bit(WL_STATUS_CONNECTING, &wl->status);
+
+	return err;
+}
+
+static s32
+wl_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
+		       u16 reason_code)
+{
+	struct wl_priv *wl = wiphy_to_wl(wiphy);
+	scb_val_t scbval;
+	bool act = false;
+	s32 err = 0;
+
+	WL_DBG(("Reason %d\n", reason_code));
+	CHECK_SYS_UP();
+	act = *(bool *) wl_read_prof(wl, WL_PROF_ACT);
+	if (likely(act)) {
+		scbval.val = reason_code;
+		memcpy(&scbval.ea, &wl->bssid, ETHER_ADDR_LEN);
+		scbval.val = htod32(scbval.val);
+		err = wl_dev_ioctl(dev, WLC_DISASSOC, &scbval,
+				sizeof(scb_val_t));
+		if (unlikely(err)) {
+			WL_ERR(("error (%d)\n", err));
+			return err;
+		}
+	}
+
+	return err;
+}
+
+static s32
+wl_cfg80211_set_tx_power(struct wiphy *wiphy,
+			 enum nl80211_tx_power_setting type, s32 dbm)
+{
+
+	struct wl_priv *wl = wiphy_to_wl(wiphy);
+	struct net_device *ndev = wl_to_ndev(wl);
+	u16 txpwrmw;
+	s32 err = 0;
+	s32 disable = 0;
+
+	CHECK_SYS_UP();
+	switch (type) {
+	case NL80211_TX_POWER_AUTOMATIC:
+		break;
+	case NL80211_TX_POWER_LIMITED:
+		if (dbm < 0) {
+			WL_ERR(("TX_POWER_LIMITTED - dbm is negative\n"));
+			return -EINVAL;
+		}
+		break;
+	case NL80211_TX_POWER_FIXED:
+		if (dbm < 0) {
+			WL_ERR(("TX_POWER_FIXED - dbm is negative..\n"));
+			return -EINVAL;
+		}
+		break;
+	}
+	/* Make sure radio is off or on as far as software is concerned */
+	disable = WL_RADIO_SW_DISABLE << 16;
+	disable = htod32(disable);
+	err = wl_dev_ioctl(ndev, WLC_SET_RADIO, &disable, sizeof(disable));
+	if (unlikely(err)) {
+		WL_ERR(("WLC_SET_RADIO error (%d)\n", err));
+		return err;
+	}
+
+	if (dbm > 0xffff)
+		txpwrmw = 0xffff;
+	else
+		txpwrmw = (u16) dbm;
+	err = wl_dev_intvar_set(ndev, "qtxpower",
+			(s32) (bcm_mw_to_qdbm(txpwrmw)));
+	if (unlikely(err)) {
+		WL_ERR(("qtxpower error (%d)\n", err));
+		return err;
+	}
+	wl->conf->tx_power = dbm;
+
+	return err;
+}
+
+static s32 wl_cfg80211_get_tx_power(struct wiphy *wiphy, s32 *dbm)
+{
+	struct wl_priv *wl = wiphy_to_wl(wiphy);
+	struct net_device *ndev = wl_to_ndev(wl);
+	s32 txpwrdbm;
+	u8 result;
+	s32 err = 0;
+
+	CHECK_SYS_UP();
+	err = wl_dev_intvar_get(ndev, "qtxpower", &txpwrdbm);
+	if (unlikely(err)) {
+		WL_ERR(("error (%d)\n", err));
+		return err;
+	}
+	result = (u8) (txpwrdbm & ~WL_TXPWR_OVERRIDE);
+	*dbm = (s32) bcm_qdbm_to_mw(result);
+
+	return err;
+}
+
+static s32
+wl_cfg80211_config_default_key(struct wiphy *wiphy, struct net_device *dev,
+			       u8 key_idx)
+{
+	u32 index;
+	s32 wsec;
+	s32 err = 0;
+
+	WL_DBG(("key index (%d)\n", key_idx));
+	CHECK_SYS_UP();
+
+	err = wl_dev_ioctl(dev, WLC_GET_WSEC, &wsec, sizeof(wsec));
+	if (unlikely(err)) {
+		WL_ERR(("WLC_GET_WSEC error (%d)\n", err));
+		return err;
+	}
+	wsec = dtoh32(wsec);
+	if (wsec & WEP_ENABLED) {
+		/* Just select a new current key */
+		index = (u32) key_idx;
+		index = htod32(index);
+		err = wl_dev_ioctl(dev, WLC_SET_KEY_PRIMARY, &index,
+				sizeof(index));
+		if (unlikely(err)) {
+			WL_ERR(("error (%d)\n", err));
+		}
+	}
+	return err;
+}
+
+static s32
+wl_add_keyext(struct wiphy *wiphy, struct net_device *dev,
+	      u8 key_idx, const u8 *mac_addr, struct key_params *params)
+{
+	struct wl_wsec_key key;
+	s32 err = 0;
+
+	memset(&key, 0, sizeof(key));
+	key.index = (u32) key_idx;
+	/* Instead of bcast for ea address for default wep keys,
+		 driver needs it to be Null */
+	if (!ETHER_ISMULTI(mac_addr))
+		memcpy((char *)&key.ea, (void *)mac_addr, ETHER_ADDR_LEN);
+	key.len = (u32) params->key_len;
+	/* check for key index change */
+	if (key.len == 0) {
+		/* key delete */
+		swap_key_from_BE(&key);
+		err = wl_dev_ioctl(dev, WLC_SET_KEY, &key, sizeof(key));
+		if (unlikely(err)) {
+			WL_ERR(("key delete error (%d)\n", err));
+			return err;
+		}
+	} else {
+		if (key.len > sizeof(key.data)) {
+			WL_ERR(("Invalid key length (%d)\n", key.len));
+			return -EINVAL;
+		}
+
+		WL_DBG(("Setting the key index %d\n", key.index));
+		memcpy(key.data, params->key, key.len);
+
+		if (params->cipher == WLAN_CIPHER_SUITE_TKIP) {
+			u8 keybuf[8];
+			memcpy(keybuf, &key.data[24], sizeof(keybuf));
+			memcpy(&key.data[24], &key.data[16], sizeof(keybuf));
+			memcpy(&key.data[16], keybuf, sizeof(keybuf));
+		}
+
+		/* if IW_ENCODE_EXT_RX_SEQ_VALID set */
+		if (params->seq && params->seq_len == 6) {
+			/* rx iv */
+			u8 *ivptr;
+			ivptr = (u8 *) params->seq;
+			key.rxiv.hi = (ivptr[5] << 24) | (ivptr[4] << 16) |
+			    (ivptr[3] << 8) | ivptr[2];
+			key.rxiv.lo = (ivptr[1] << 8) | ivptr[0];
+			key.iv_initialized = true;
+		}
+
+		switch (params->cipher) {
+		case WLAN_CIPHER_SUITE_WEP40:
+			key.algo = CRYPTO_ALGO_WEP1;
+			WL_DBG(("WLAN_CIPHER_SUITE_WEP40\n"));
+			break;
+		case WLAN_CIPHER_SUITE_WEP104:
+			key.algo = CRYPTO_ALGO_WEP128;
+			WL_DBG(("WLAN_CIPHER_SUITE_WEP104\n"));
+			break;
+		case WLAN_CIPHER_SUITE_TKIP:
+			key.algo = CRYPTO_ALGO_TKIP;
+			WL_DBG(("WLAN_CIPHER_SUITE_TKIP\n"));
+			break;
+		case WLAN_CIPHER_SUITE_AES_CMAC:
+			key.algo = CRYPTO_ALGO_AES_CCM;
+			WL_DBG(("WLAN_CIPHER_SUITE_AES_CMAC\n"));
+			break;
+		case WLAN_CIPHER_SUITE_CCMP:
+			key.algo = CRYPTO_ALGO_AES_CCM;
+			WL_DBG(("WLAN_CIPHER_SUITE_CCMP\n"));
+			break;
+		default:
+			WL_ERR(("Invalid cipher (0x%x)\n", params->cipher));
+			return -EINVAL;
+		}
+		swap_key_from_BE(&key);
+
+		dhd_wait_pend8021x(dev);
+		err = wl_dev_ioctl(dev, WLC_SET_KEY, &key, sizeof(key));
+		if (unlikely(err)) {
+			WL_ERR(("WLC_SET_KEY error (%d)\n", err));
+			return err;
+		}
+	}
+	return err;
+}
+
+static s32
+wl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *dev,
+		    u8 key_idx, const u8 *mac_addr,
+		    struct key_params *params)
+{
+	struct wl_wsec_key key;
+	s32 val;
+	s32 wsec;
+	s32 err = 0;
+
+	WL_DBG(("key index (%d)\n", key_idx));
+	CHECK_SYS_UP();
+
+	if (mac_addr)
+		return wl_add_keyext(wiphy, dev, key_idx, mac_addr, params);
+	memset(&key, 0, sizeof(key));
+
+	key.len = (u32) params->key_len;
+	key.index = (u32) key_idx;
+
+	if (unlikely(key.len > sizeof(key.data))) {
+		WL_ERR(("Too long key length (%u)\n", key.len));
+		return -EINVAL;
+	}
+	memcpy(key.data, params->key, key.len);
+
+	key.flags = WL_PRIMARY_KEY;
+	switch (params->cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+		key.algo = CRYPTO_ALGO_WEP1;
+		WL_DBG(("WLAN_CIPHER_SUITE_WEP40\n"));
+		break;
+	case WLAN_CIPHER_SUITE_WEP104:
+		key.algo = CRYPTO_ALGO_WEP128;
+		WL_DBG(("WLAN_CIPHER_SUITE_WEP104\n"));
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		key.algo = CRYPTO_ALGO_TKIP;
+		WL_DBG(("WLAN_CIPHER_SUITE_TKIP\n"));
+		break;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		key.algo = CRYPTO_ALGO_AES_CCM;
+		WL_DBG(("WLAN_CIPHER_SUITE_AES_CMAC\n"));
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		key.algo = CRYPTO_ALGO_AES_CCM;
+		WL_DBG(("WLAN_CIPHER_SUITE_CCMP\n"));
+		break;
+	default:
+		WL_ERR(("Invalid cipher (0x%x)\n", params->cipher));
+		return -EINVAL;
+	}
+
+	/* Set the new key/index */
+	swap_key_from_BE(&key);
+	err = wl_dev_ioctl(dev, WLC_SET_KEY, &key, sizeof(key));
+	if (unlikely(err)) {
+		WL_ERR(("WLC_SET_KEY error (%d)\n", err));
+		return err;
+	}
+
+	val = WEP_ENABLED;
+	err = wl_dev_intvar_get(dev, "wsec", &wsec);
+	if (unlikely(err)) {
+		WL_ERR(("get wsec error (%d)\n", err));
+		return err;
+	}
+	wsec &= ~(WEP_ENABLED);
+	wsec |= val;
+	err = wl_dev_intvar_set(dev, "wsec", wsec);
+	if (unlikely(err)) {
+		WL_ERR(("set wsec error (%d)\n", err));
+		return err;
+	}
+
+	val = 1;		/* assume shared key. otherwise 0 */
+	val = htod32(val);
+	err = wl_dev_ioctl(dev, WLC_SET_AUTH, &val, sizeof(val));
+	if (unlikely(err)) {
+		WL_ERR(("WLC_SET_AUTH error (%d)\n", err));
+		return err;
+	}
+	return err;
+}
+
+static s32
+wl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *dev,
+		    u8 key_idx, const u8 *mac_addr)
+{
+	struct wl_wsec_key key;
+	s32 err = 0;
+	s32 val;
+	s32 wsec;
+
+	CHECK_SYS_UP();
+	memset(&key, 0, sizeof(key));
+
+	key.index = (u32) key_idx;
+	key.flags = WL_PRIMARY_KEY;
+	key.algo = CRYPTO_ALGO_OFF;
+
+	WL_DBG(("key index (%d)\n", key_idx));
+	/* Set the new key/index */
+	swap_key_from_BE(&key);
+	err = wl_dev_ioctl(dev, WLC_SET_KEY, &key, sizeof(key));
+	if (unlikely(err)) {
+		if (err == -EINVAL) {
+			if (key.index >= DOT11_MAX_DEFAULT_KEYS) {
+				/* we ignore this key index in this case */
+				WL_DBG(("invalid key index (%d)\n", key_idx));
+			}
+		} else {
+			WL_ERR(("WLC_SET_KEY error (%d)\n", err));
+		}
+		return err;
+	}
+
+	val = 0;
+	err = wl_dev_intvar_get(dev, "wsec", &wsec);
+	if (unlikely(err)) {
+		WL_ERR(("get wsec error (%d)\n", err));
+		return err;
+	}
+	wsec &= ~(WEP_ENABLED);
+	wsec |= val;
+	err = wl_dev_intvar_set(dev, "wsec", wsec);
+	if (unlikely(err)) {
+		WL_ERR(("set wsec error (%d)\n", err));
+		return err;
+	}
+
+	val = 0;		/* assume open key. otherwise 1 */
+	val = htod32(val);
+	err = wl_dev_ioctl(dev, WLC_SET_AUTH, &val, sizeof(val));
+	if (unlikely(err)) {
+		WL_ERR(("WLC_SET_AUTH error (%d)\n", err));
+		return err;
+	}
+	return err;
+}
+
+static s32
+wl_cfg80211_get_key(struct wiphy *wiphy, struct net_device *dev,
+		    u8 key_idx, const u8 *mac_addr, void *cookie,
+		    void (*callback) (void *cookie, struct key_params * params))
+{
+	struct key_params params;
+	struct wl_wsec_key key;
+	struct wl_priv *wl = wiphy_to_wl(wiphy);
+	struct wl_security *sec;
+	s32 wsec;
+	s32 err = 0;
+
+	WL_DBG(("key index (%d)\n", key_idx));
+	CHECK_SYS_UP();
+
+	memset(&key, 0, sizeof(key));
+	key.index = key_idx;
+	swap_key_to_BE(&key);
+	memset(&params, 0, sizeof(params));
+	params.key_len = (u8) min_t(u8, DOT11_MAX_KEY_SIZE, key.len);
+	memcpy(params.key, key.data, params.key_len);
+
+	err = wl_dev_ioctl(dev, WLC_GET_WSEC, &wsec, sizeof(wsec));
+	if (unlikely(err)) {
+		WL_ERR(("WLC_GET_WSEC error (%d)\n", err));
+		return err;
+	}
+	wsec = dtoh32(wsec);
+	switch (wsec) {
+	case WEP_ENABLED:
+		sec = wl_read_prof(wl, WL_PROF_SEC);
+		if (sec->cipher_pairwise & WLAN_CIPHER_SUITE_WEP40) {
+			params.cipher = WLAN_CIPHER_SUITE_WEP40;
+			WL_DBG(("WLAN_CIPHER_SUITE_WEP40\n"));
+		} else if (sec->cipher_pairwise & WLAN_CIPHER_SUITE_WEP104) {
+			params.cipher = WLAN_CIPHER_SUITE_WEP104;
+			WL_DBG(("WLAN_CIPHER_SUITE_WEP104\n"));
+		}
+		break;
+	case TKIP_ENABLED:
+		params.cipher = WLAN_CIPHER_SUITE_TKIP;
+		WL_DBG(("WLAN_CIPHER_SUITE_TKIP\n"));
+		break;
+	case AES_ENABLED:
+		params.cipher = WLAN_CIPHER_SUITE_AES_CMAC;
+		WL_DBG(("WLAN_CIPHER_SUITE_AES_CMAC\n"));
+		break;
+	default:
+		WL_ERR(("Invalid algo (0x%x)\n", wsec));
+		return -EINVAL;
+	}
+
+	callback(cookie, &params);
+	return err;
+}
+
+static s32
+wl_cfg80211_config_default_mgmt_key(struct wiphy *wiphy,
+				    struct net_device *dev, u8 key_idx)
+{
+	WL_INFO(("Not supported\n"));
+	CHECK_SYS_UP();
+	return -EOPNOTSUPP;
+}
+
+static s32
+wl_cfg80211_get_station(struct wiphy *wiphy, struct net_device *dev,
+			u8 *mac, struct station_info *sinfo)
+{
+	struct wl_priv *wl = wiphy_to_wl(wiphy);
+	scb_val_t scb_val;
+	int rssi;
+	s32 rate;
+	s32 err = 0;
+
+	CHECK_SYS_UP();
+	if (unlikely
+	    (memcmp(mac, wl_read_prof(wl, WL_PROF_BSSID), ETHER_ADDR_LEN))) {
+		WL_ERR(("Wrong Mac address\n"));
+		return -ENOENT;
+	}
+
+	/* Report the current tx rate */
+	err = wl_dev_ioctl(dev, WLC_GET_RATE, &rate, sizeof(rate));
+	if (err) {
+		WL_ERR(("Could not get rate (%d)\n", err));
+	} else {
+		rate = dtoh32(rate);
+		sinfo->filled |= STATION_INFO_TX_BITRATE;
+		sinfo->txrate.legacy = rate * 5;
+		WL_DBG(("Rate %d Mbps\n", (rate / 2)));
+	}
+
+	if (test_bit(WL_STATUS_CONNECTED, &wl->status)) {
+		scb_val.val = 0;
+		err = wl_dev_ioctl(dev, WLC_GET_RSSI, &scb_val,
+				sizeof(scb_val_t));
+		if (unlikely(err)) {
+			WL_ERR(("Could not get rssi (%d)\n", err));
+			return err;
+		}
+		rssi = dtoh32(scb_val.val);
+		sinfo->filled |= STATION_INFO_SIGNAL;
+		sinfo->signal = rssi;
+		WL_DBG(("RSSI %d dBm\n", rssi));
+	}
+
+	return err;
+}
+
+static s32
+wl_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,
+			   bool enabled, s32 timeout)
+{
+	s32 pm;
+	s32 err = 0;
+
+	CHECK_SYS_UP();
+	pm = enabled ? PM_FAST : PM_OFF;
+	pm = htod32(pm);
+	WL_DBG(("power save %s\n", (pm ? "enabled" : "disabled")));
+	err = wl_dev_ioctl(dev, WLC_SET_PM, &pm, sizeof(pm));
+	if (unlikely(err)) {
+		if (err == -ENODEV)
+			WL_DBG(("net_device is not ready yet\n"));
+		else
+			WL_ERR(("error (%d)\n", err));
+		return err;
+	}
+	return err;
+}
+
+static __used u32 wl_find_msb(u16 bit16)
+{
+	u32 ret = 0;
+
+	if (bit16 & 0xff00) {
+		ret += 8;
+		bit16 >>= 8;
+	}
+
+	if (bit16 & 0xf0) {
+		ret += 4;
+		bit16 >>= 4;
+	}
+
+	if (bit16 & 0xc) {
+		ret += 2;
+		bit16 >>= 2;
+	}
+
+	if (bit16 & 2)
+		ret += bit16 & 2;
+	else if (bit16)
+		ret += bit16;
+
+	return ret;
+}
+
+static s32
+wl_cfg80211_set_bitrate_mask(struct wiphy *wiphy, struct net_device *dev,
+			     const u8 *addr,
+			     const struct cfg80211_bitrate_mask *mask)
+{
+	struct wl_rateset rateset;
+	s32 rate;
+	s32 val;
+	s32 err_bg;
+	s32 err_a;
+	u32 legacy;
+	s32 err = 0;
+
+	CHECK_SYS_UP();
+	/* addr param is always NULL. ignore it */
+	/* Get current rateset */
+	err = wl_dev_ioctl(dev, WLC_GET_CURR_RATESET, &rateset,
+			sizeof(rateset));
+	if (unlikely(err)) {
+		WL_ERR(("could not get current rateset (%d)\n", err));
+		return err;
+	}
+
+	rateset.count = dtoh32(rateset.count);
+
+	legacy = wl_find_msb(mask->control[IEEE80211_BAND_2GHZ].legacy);
+	if (!legacy)
+		legacy = wl_find_msb(mask->control[IEEE80211_BAND_5GHZ].legacy);
+
+	val = wl_g_rates[legacy - 1].bitrate * 100000;
+
+	if (val < rateset.count) {
+		/* Select rate by rateset index */
+		rate = rateset.rates[val] & 0x7f;
+	} else {
+		/* Specified rate in bps */
+		rate = val / 500000;
+	}
+
+	WL_DBG(("rate %d mbps\n", (rate / 2)));
+
+	/*
+	 *
+	 *      Set rate override,
+	 *      Since the is a/b/g-blind, both a/bg_rate are enforced.
+	 */
+	err_bg = wl_dev_intvar_set(dev, "bg_rate", rate);
+	err_a = wl_dev_intvar_set(dev, "a_rate", rate);
+	if (unlikely(err_bg && err_a)) {
+		WL_ERR(("could not set fixed rate (%d) (%d)\n", err_bg, err_a));
+		return err_bg | err_a;
+	}
+
+	return err;
+}
+
+static s32 wl_cfg80211_resume(struct wiphy *wiphy)
+{
+	s32 err = 0;
+
+	CHECK_SYS_UP();
+	wl_invoke_iscan(wiphy_to_wl(wiphy));
+
+	return err;
+}
+
+static s32 wl_cfg80211_suspend(struct wiphy *wiphy)
+{
+	struct wl_priv *wl = wiphy_to_wl(wiphy);
+	struct net_device *ndev = wl_to_ndev(wl);
+	s32 err = 0;
+
+	CHECK_SYS_UP();
+
+	set_bit(WL_STATUS_SCAN_ABORTING, &wl->status);
+	wl_term_iscan(wl);
+	if (wl->scan_request) {
+		cfg80211_scan_done(wl->scan_request, true);	/* true means
+								 abort */
+		wl_set_mpc(ndev, 1);
+		wl->scan_request = NULL;
+	}
+	clear_bit(WL_STATUS_SCANNING, &wl->status);
+	clear_bit(WL_STATUS_SCAN_ABORTING, &wl->status);
+
+	return err;
+}
+
+static __used s32
+wl_update_pmklist(struct net_device *dev, struct wl_pmk_list *pmk_list,
+		  s32 err)
+{
+	int i, j;
+
+	WL_DBG(("No of elements %d\n", pmk_list->pmkids.npmkid));
+	for (i = 0; i < pmk_list->pmkids.npmkid; i++) {
+		WL_DBG(("PMKID[%d]: %pM =\n", i,
+			&pmk_list->pmkids.pmkid[i].BSSID));
+		for (j = 0; j < WPA2_PMKID_LEN; j++) {
+			WL_DBG(("%02x\n", pmk_list->pmkids.pmkid[i].PMKID[j]));
+		}
+	}
+	if (likely(!err)) {
+		err = wl_dev_bufvar_set(dev, "pmkid_info", (char *)pmk_list,
+					sizeof(*pmk_list));
+	}
+
+	return err;
+}
+
+static s32
+wl_cfg80211_set_pmksa(struct wiphy *wiphy, struct net_device *dev,
+		      struct cfg80211_pmksa *pmksa)
+{
+	struct wl_priv *wl = wiphy_to_wl(wiphy);
+	s32 err = 0;
+	int i;
+
+	CHECK_SYS_UP();
+	for (i = 0; i < wl->pmk_list->pmkids.npmkid; i++)
+		if (!memcmp(pmksa->bssid, &wl->pmk_list->pmkids.pmkid[i].BSSID,
+			    ETHER_ADDR_LEN))
+			break;
+	if (i < WL_NUM_PMKIDS_MAX) {
+		memcpy(&wl->pmk_list->pmkids.pmkid[i].BSSID, pmksa->bssid,
+		       ETHER_ADDR_LEN);
+		memcpy(&wl->pmk_list->pmkids.pmkid[i].PMKID, pmksa->pmkid,
+		       WPA2_PMKID_LEN);
+		if (i == wl->pmk_list->pmkids.npmkid)
+			wl->pmk_list->pmkids.npmkid++;
+	} else {
+		err = -EINVAL;
+	}
+	WL_DBG(("set_pmksa,IW_PMKSA_ADD - PMKID: %pM =\n",
+		&wl->pmk_list->pmkids.pmkid[wl->pmk_list->pmkids.npmkid].BSSID));
+	for (i = 0; i < WPA2_PMKID_LEN; i++) {
+		WL_DBG(("%02x\n",
+			wl->pmk_list->pmkids.pmkid[wl->pmk_list->pmkids.npmkid].
+			PMKID[i]));
+	}
+
+	err = wl_update_pmklist(dev, wl->pmk_list, err);
+
+	return err;
+}
+
+static s32
+wl_cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *dev,
+		      struct cfg80211_pmksa *pmksa)
+{
+	struct wl_priv *wl = wiphy_to_wl(wiphy);
+	struct _pmkid_list pmkid;
+	s32 err = 0;
+	int i;
+
+	CHECK_SYS_UP();
+	memcpy(&pmkid.pmkid[0].BSSID, pmksa->bssid, ETHER_ADDR_LEN);
+	memcpy(&pmkid.pmkid[0].PMKID, pmksa->pmkid, WPA2_PMKID_LEN);
+
+	WL_DBG(("del_pmksa,IW_PMKSA_REMOVE - PMKID: %pM =\n",
+		&pmkid.pmkid[0].BSSID));
+	for (i = 0; i < WPA2_PMKID_LEN; i++) {
+		WL_DBG(("%02x\n", pmkid.pmkid[0].PMKID[i]));
+	}
+
+	for (i = 0; i < wl->pmk_list->pmkids.npmkid; i++)
+		if (!memcmp
+		    (pmksa->bssid, &wl->pmk_list->pmkids.pmkid[i].BSSID,
+		     ETHER_ADDR_LEN))
+			break;
+
+	if ((wl->pmk_list->pmkids.npmkid > 0)
+	    && (i < wl->pmk_list->pmkids.npmkid)) {
+		memset(&wl->pmk_list->pmkids.pmkid[i], 0, sizeof(pmkid_t));
+		for (; i < (wl->pmk_list->pmkids.npmkid - 1); i++) {
+			memcpy(&wl->pmk_list->pmkids.pmkid[i].BSSID,
+			       &wl->pmk_list->pmkids.pmkid[i + 1].BSSID,
+			       ETHER_ADDR_LEN);
+			memcpy(&wl->pmk_list->pmkids.pmkid[i].PMKID,
+			       &wl->pmk_list->pmkids.pmkid[i + 1].PMKID,
+			       WPA2_PMKID_LEN);
+		}
+		wl->pmk_list->pmkids.npmkid--;
+	} else {
+		err = -EINVAL;
+	}
+
+	err = wl_update_pmklist(dev, wl->pmk_list, err);
+
+	return err;
+
+}
+
+static s32
+wl_cfg80211_flush_pmksa(struct wiphy *wiphy, struct net_device *dev)
+{
+	struct wl_priv *wl = wiphy_to_wl(wiphy);
+	s32 err = 0;
+
+	CHECK_SYS_UP();
+	memset(wl->pmk_list, 0, sizeof(*wl->pmk_list));
+	err = wl_update_pmklist(dev, wl->pmk_list, err);
+	return err;
+
+}
+
+static struct cfg80211_ops wl_cfg80211_ops = {
+	.change_virtual_intf = wl_cfg80211_change_iface,
+	.scan = wl_cfg80211_scan,
+	.set_wiphy_params = wl_cfg80211_set_wiphy_params,
+	.join_ibss = wl_cfg80211_join_ibss,
+	.leave_ibss = wl_cfg80211_leave_ibss,
+	.get_station = wl_cfg80211_get_station,
+	.set_tx_power = wl_cfg80211_set_tx_power,
+	.get_tx_power = wl_cfg80211_get_tx_power,
+	.add_key = wl_cfg80211_add_key,
+	.del_key = wl_cfg80211_del_key,
+	.get_key = wl_cfg80211_get_key,
+	.set_default_key = wl_cfg80211_config_default_key,
+	.set_default_mgmt_key = wl_cfg80211_config_default_mgmt_key,
+	.set_power_mgmt = wl_cfg80211_set_power_mgmt,
+	.set_bitrate_mask = wl_cfg80211_set_bitrate_mask,
+	.connect = wl_cfg80211_connect,
+	.disconnect = wl_cfg80211_disconnect,
+	.suspend = wl_cfg80211_suspend,
+	.resume = wl_cfg80211_resume,
+	.set_pmksa = wl_cfg80211_set_pmksa,
+	.del_pmksa = wl_cfg80211_del_pmksa,
+	.flush_pmksa = wl_cfg80211_flush_pmksa
+};
+
+static s32 wl_mode_to_nl80211_iftype(s32 mode)
+{
+	s32 err = 0;
+
+	switch (mode) {
+	case WL_MODE_BSS:
+		return NL80211_IFTYPE_STATION;
+	case WL_MODE_IBSS:
+		return NL80211_IFTYPE_ADHOC;
+	default:
+		return NL80211_IFTYPE_UNSPECIFIED;
+	}
+
+	return err;
+}
+
+static struct wireless_dev *wl_alloc_wdev(s32 sizeof_iface,
+					  struct device *dev)
+{
+	struct wireless_dev *wdev;
+	s32 err = 0;
+
+	wdev = kzalloc(sizeof(*wdev), GFP_KERNEL);
+	if (unlikely(!wdev)) {
+		WL_ERR(("Could not allocate wireless device\n"));
+		return ERR_PTR(-ENOMEM);
+	}
+	wdev->wiphy =
+	    wiphy_new(&wl_cfg80211_ops, sizeof(struct wl_priv) + sizeof_iface);
+	if (unlikely(!wdev->wiphy)) {
+		WL_ERR(("Couldn not allocate wiphy device\n"));
+		err = -ENOMEM;
+		goto wiphy_new_out;
+	}
+	set_wiphy_dev(wdev->wiphy, dev);
+	wdev->wiphy->max_scan_ssids = WL_NUM_SCAN_MAX;
+	wdev->wiphy->max_num_pmkids = WL_NUM_PMKIDS_MAX;
+	wdev->wiphy->interface_modes =
+	    BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_ADHOC);
+	wdev->wiphy->bands[IEEE80211_BAND_2GHZ] = &__wl_band_2ghz;
+	wdev->wiphy->bands[IEEE80211_BAND_5GHZ] = &__wl_band_5ghz_a;	/* Set
+						* it as 11a by default.
+						* This will be updated with
+						* 11n phy tables in
+						* "ifconfig up"
+						* if phy has 11n capability
+						*/
+	wdev->wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
+	wdev->wiphy->cipher_suites = __wl_cipher_suites;
+	wdev->wiphy->n_cipher_suites = ARRAY_SIZE(__wl_cipher_suites);
+#ifndef WL_POWERSAVE_DISABLED
+	wdev->wiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;	/* enable power
+								 * save mode
+								 * by default
+								 */
+#else
+	wdev->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
+#endif				/* !WL_POWERSAVE_DISABLED */
+	err = wiphy_register(wdev->wiphy);
+	if (unlikely(err < 0)) {
+		WL_ERR(("Couldn not register wiphy device (%d)\n", err));
+		goto wiphy_register_out;
+	}
+	return wdev;
+
+wiphy_register_out:
+	wiphy_free(wdev->wiphy);
+
+wiphy_new_out:
+	kfree(wdev);
+
+	return ERR_PTR(err);
+}
+
+static void wl_free_wdev(struct wl_priv *wl)
+{
+	struct wireless_dev *wdev = wl_to_wdev(wl);
+
+	if (unlikely(!wdev)) {
+		WL_ERR(("wdev is invalid\n"));
+		return;
+	}
+	wiphy_unregister(wdev->wiphy);
+	wiphy_free(wdev->wiphy);
+	kfree(wdev);
+	wl_to_wdev(wl) = NULL;
+}
+
+static s32 wl_inform_bss(struct wl_priv *wl)
+{
+	struct wl_scan_results *bss_list;
+	struct wl_bss_info *bi = NULL;	/* must be initialized */
+	s32 err = 0;
+	int i;
+
+	bss_list = wl->bss_list;
+	if (unlikely(bss_list->version != WL_BSS_INFO_VERSION)) {
+		WL_ERR(("Version %d != WL_BSS_INFO_VERSION\n",
+			bss_list->version));
+		return -EOPNOTSUPP;
+	}
+	WL_DBG(("scanned AP count (%d)\n", bss_list->count));
+	bi = next_bss(bss_list, bi);
+	for_each_bss(bss_list, bi, i) {
+		err = wl_inform_single_bss(wl, bi);
+		if (unlikely(err))
+			break;
+	}
+	return err;
+}
+
+static s32 wl_inform_single_bss(struct wl_priv *wl, struct wl_bss_info *bi)
+{
+	struct wiphy *wiphy = wl_to_wiphy(wl);
+	struct ieee80211_mgmt *mgmt;
+	struct ieee80211_channel *channel;
+	struct ieee80211_supported_band *band;
+	struct wl_cfg80211_bss_info *notif_bss_info;
+	struct wl_scan_req *sr = wl_to_sr(wl);
+	struct beacon_proberesp *beacon_proberesp;
+	s32 mgmt_type;
+	u32 signal;
+	u32 freq;
+	s32 err = 0;
+
+	if (unlikely(dtoh32(bi->length) > WL_BSS_INFO_MAX)) {
+		WL_DBG(("Beacon is larger than buffer. Discarding\n"));
+		return err;
+	}
+	notif_bss_info =
+	    kzalloc(sizeof(*notif_bss_info) + sizeof(*mgmt) - sizeof(u8) +
+		    WL_BSS_INFO_MAX, GFP_KERNEL);
+	if (unlikely(!notif_bss_info)) {
+		WL_ERR(("notif_bss_info alloc failed\n"));
+		return -ENOMEM;
+	}
+	mgmt = (struct ieee80211_mgmt *)notif_bss_info->frame_buf;
+	notif_bss_info->channel =
+		bi->ctl_ch ? bi->ctl_ch : CHSPEC_CHANNEL(bi->chanspec);
+
+	if (notif_bss_info->channel <= CH_MAX_2G_CHANNEL)
+		band = wiphy->bands[IEEE80211_BAND_2GHZ];
+	else
+		band = wiphy->bands[IEEE80211_BAND_5GHZ];
+	notif_bss_info->rssi = bi->RSSI;
+	memcpy(mgmt->bssid, &bi->BSSID, ETHER_ADDR_LEN);
+	mgmt_type = wl->active_scan ?
+		IEEE80211_STYPE_PROBE_RESP : IEEE80211_STYPE_BEACON;
+	if (!memcmp(bi->SSID, sr->ssid.SSID, bi->SSID_len)) {
+		mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+							mgmt_type);
+	}
+	beacon_proberesp = wl->active_scan ?
+		(struct beacon_proberesp *)&mgmt->u.probe_resp :
+		(struct beacon_proberesp *)&mgmt->u.beacon;
+	beacon_proberesp->timestamp = 0;
+	beacon_proberesp->beacon_int = cpu_to_le16(bi->beacon_period);
+	beacon_proberesp->capab_info = cpu_to_le16(bi->capability);
+	wl_rst_ie(wl);
+	/*
+	* wl_add_ie is not necessary because it can only add duplicated
+	* SSID, rate information to frame_buf
+	*/
+	/*
+	* wl_add_ie(wl, WLAN_EID_SSID, bi->SSID_len, bi->SSID);
+	* wl_add_ie(wl, WLAN_EID_SUPP_RATES, bi->rateset.count,
+	* bi->rateset.rates);
+	*/
+	wl_mrg_ie(wl, ((u8 *) bi) + bi->ie_offset, bi->ie_length);
+	wl_cp_ie(wl, beacon_proberesp->variable, WL_BSS_INFO_MAX -
+		 offsetof(struct wl_cfg80211_bss_info, frame_buf));
+	notif_bss_info->frame_len =
+	    offsetof(struct ieee80211_mgmt,
+		     u.beacon.variable) + wl_get_ielen(wl);
+	freq = ieee80211_channel_to_frequency(notif_bss_info->channel);
+	channel = ieee80211_get_channel(wiphy, freq);
+
+	WL_DBG(("SSID : \"%s\", rssi %d, channel %d, capability : 0x04%x, bssid %pM\n",
+		bi->SSID,
+		notif_bss_info->rssi, notif_bss_info->channel,
+		mgmt->u.beacon.capab_info, &bi->BSSID));
+
+	signal = notif_bss_info->rssi * 100;
+	if (unlikely(!cfg80211_inform_bss_frame(wiphy, channel, mgmt,
+						le16_to_cpu
+						(notif_bss_info->frame_len),
+						signal, GFP_KERNEL))) {
+		WL_ERR(("cfg80211_inform_bss_frame error\n"));
+		kfree(notif_bss_info);
+		return -EINVAL;
+	}
+	kfree(notif_bss_info);
+
+	return err;
+}
+
+static bool wl_is_linkup(struct wl_priv *wl, const wl_event_msg_t *e)
+{
+	u32 event = ntoh32(e->event_type);
+	u16 flags = ntoh16(e->flags);
+
+	if (event == WLC_E_LINK) {
+		if (flags & WLC_EVENT_MSG_LINK) {
+			if (wl_is_ibssmode(wl)) {
+				if (wl_is_ibssstarter(wl)) {
+				}
+			} else {
+				return true;
+			}
+		}
+	}
+
+	return false;
+}
+
+static bool wl_is_linkdown(struct wl_priv *wl, const wl_event_msg_t *e)
+{
+	u32 event = ntoh32(e->event_type);
+	u16 flags = ntoh16(e->flags);
+
+	if (event == WLC_E_DEAUTH_IND || event == WLC_E_DISASSOC_IND) {
+		return true;
+	} else if (event == WLC_E_LINK) {
+		if (!(flags & WLC_EVENT_MSG_LINK))
+			return true;
+	}
+
+	return false;
+}
+
+static bool wl_is_nonetwork(struct wl_priv *wl, const wl_event_msg_t *e)
+{
+	u32 event = ntoh32(e->event_type);
+	u32 status = ntoh32(e->status);
+
+	if (event == WLC_E_SET_SSID || event == WLC_E_LINK) {
+		if (status == WLC_E_STATUS_NO_NETWORKS)
+			return true;
+	}
+
+	return false;
+}
+
+static s32
+wl_notify_connect_status(struct wl_priv *wl, struct net_device *ndev,
+			 const wl_event_msg_t *e, void *data)
+{
+	bool act;
+	s32 err = 0;
+
+	if (wl_is_linkup(wl, e)) {
+		wl_link_up(wl);
+		if (wl_is_ibssmode(wl)) {
+			cfg80211_ibss_joined(ndev, (s8 *)&e->addr,
+					     GFP_KERNEL);
+			WL_DBG(("joined in IBSS network\n"));
+		} else {
+			wl_bss_connect_done(wl, ndev, e, data, true);
+			WL_DBG(("joined in BSS network \"%s\"\n",
+				((struct wlc_ssid *)
+				 wl_read_prof(wl, WL_PROF_SSID))->SSID));
+		}
+		act = true;
+		wl_update_prof(wl, e, &act, WL_PROF_ACT);
+	} else if (wl_is_linkdown(wl, e)) {
+		cfg80211_disconnected(ndev, 0, NULL, 0, GFP_KERNEL);
+		clear_bit(WL_STATUS_CONNECTED, &wl->status);
+		wl_link_down(wl);
+		wl_init_prof(wl->profile);
+	} else if (wl_is_nonetwork(wl, e)) {
+		wl_bss_connect_done(wl, ndev, e, data, false);
+	}
+
+	return err;
+}
+
+static s32
+wl_notify_roaming_status(struct wl_priv *wl, struct net_device *ndev,
+			 const wl_event_msg_t *e, void *data)
+{
+	bool act;
+	s32 err = 0;
+
+	wl_bss_roaming_done(wl, ndev, e, data);
+	act = true;
+	wl_update_prof(wl, e, &act, WL_PROF_ACT);
+
+	return err;
+}
+
+static __used s32
+wl_dev_bufvar_set(struct net_device *dev, s8 *name, s8 *buf, s32 len)
+{
+	struct wl_priv *wl = ndev_to_wl(dev);
+	u32 buflen;
+
+	buflen = bcm_mkiovar(name, buf, len, wl->ioctl_buf, WL_IOCTL_LEN_MAX);
+	BUG_ON(unlikely(!buflen));
+
+	return wl_dev_ioctl(dev, WLC_SET_VAR, wl->ioctl_buf, buflen);
+}
+
+static s32
+wl_dev_bufvar_get(struct net_device *dev, s8 *name, s8 *buf,
+		  s32 buf_len)
+{
+	struct wl_priv *wl = ndev_to_wl(dev);
+	u32 len;
+	s32 err = 0;
+
+	len = bcm_mkiovar(name, NULL, 0, wl->ioctl_buf, WL_IOCTL_LEN_MAX);
+	BUG_ON(unlikely(!len));
+	err = wl_dev_ioctl(dev, WLC_GET_VAR, (void *)wl->ioctl_buf,
+			WL_IOCTL_LEN_MAX);
+	if (unlikely(err)) {
+		WL_ERR(("error (%d)\n", err));
+		return err;
+	}
+	memcpy(buf, wl->ioctl_buf, buf_len);
+
+	return err;
+}
+
+static s32 wl_get_assoc_ies(struct wl_priv *wl)
+{
+	struct net_device *ndev = wl_to_ndev(wl);
+	struct wl_assoc_ielen *assoc_info;
+	struct wl_connect_info *conn_info = wl_to_conn(wl);
+	u32 req_len;
+	u32 resp_len;
+	s32 err = 0;
+
+	err = wl_dev_bufvar_get(ndev, "assoc_info", wl->extra_buf,
+				WL_ASSOC_INFO_MAX);
+	if (unlikely(err)) {
+		WL_ERR(("could not get assoc info (%d)\n", err));
+		return err;
+	}
+	assoc_info = (struct wl_assoc_ielen *)wl->extra_buf;
+	req_len = assoc_info->req_len;
+	resp_len = assoc_info->resp_len;
+	if (req_len) {
+		err = wl_dev_bufvar_get(ndev, "assoc_req_ies", wl->extra_buf,
+					WL_ASSOC_INFO_MAX);
+		if (unlikely(err)) {
+			WL_ERR(("could not get assoc req (%d)\n", err));
+			return err;
+		}
+		conn_info->req_ie_len = req_len;
+		conn_info->req_ie =
+		    kmemdup(wl->extra_buf, conn_info->req_ie_len, GFP_KERNEL);
+	} else {
+		conn_info->req_ie_len = 0;
+		conn_info->req_ie = NULL;
+	}
+	if (resp_len) {
+		err = wl_dev_bufvar_get(ndev, "assoc_resp_ies", wl->extra_buf,
+					WL_ASSOC_INFO_MAX);
+		if (unlikely(err)) {
+			WL_ERR(("could not get assoc resp (%d)\n", err));
+			return err;
+		}
+		conn_info->resp_ie_len = resp_len;
+		conn_info->resp_ie =
+		    kmemdup(wl->extra_buf, conn_info->resp_ie_len, GFP_KERNEL);
+	} else {
+		conn_info->resp_ie_len = 0;
+		conn_info->resp_ie = NULL;
+	}
+	WL_DBG(("req len (%d) resp len (%d)\n", conn_info->req_ie_len,
+		conn_info->resp_ie_len));
+
+	return err;
+}
+
+static void wl_ch_to_chanspec(int ch, struct wl_join_params *join_params,
+	size_t *join_params_size)
+{
+	chanspec_t chanspec = 0;
+
+	if (ch != 0) {
+		join_params->params.chanspec_num = 1;
+		join_params->params.chanspec_list[0] = ch;
+
+		if (join_params->params.chanspec_list[0])
+			chanspec |= WL_CHANSPEC_BAND_2G;
+		else
+			chanspec |= WL_CHANSPEC_BAND_5G;
+
+		chanspec |= WL_CHANSPEC_BW_20;
+		chanspec |= WL_CHANSPEC_CTL_SB_NONE;
+
+		*join_params_size += WL_ASSOC_PARAMS_FIXED_SIZE +
+			join_params->params.chanspec_num * sizeof(chanspec_t);
+
+		join_params->params.chanspec_list[0] &= WL_CHANSPEC_CHAN_MASK;
+		join_params->params.chanspec_list[0] |= chanspec;
+		join_params->params.chanspec_list[0] =
+		htodchanspec(join_params->params.chanspec_list[0]);
+
+		join_params->params.chanspec_num =
+			htod32(join_params->params.chanspec_num);
+
+		WL_DBG(("join_params->params.chanspec_list[0]= %#X, channel %d, chanspec %#X\n",
+			join_params->params.chanspec_list[0], ch, chanspec));
+	}
+}
+
+static s32 wl_update_bss_info(struct wl_priv *wl)
+{
+	struct cfg80211_bss *bss;
+	struct wl_bss_info *bi;
+	struct wlc_ssid *ssid;
+	struct bcm_tlv *tim;
+	u16 beacon_interval;
+	u8 dtim_period;
+	size_t ie_len;
+	u8 *ie;
+	s32 err = 0;
+
+	if (wl_is_ibssmode(wl))
+		return err;
+
+	ssid = (struct wlc_ssid *)wl_read_prof(wl, WL_PROF_SSID);
+	bss =
+	    cfg80211_get_bss(wl_to_wiphy(wl), NULL, (s8 *)&wl->bssid,
+			     ssid->SSID, ssid->SSID_len, WLAN_CAPABILITY_ESS,
+			     WLAN_CAPABILITY_ESS);
+
+	rtnl_lock();
+	if (unlikely(!bss)) {
+		WL_DBG(("Could not find the AP\n"));
+		*(u32 *) wl->extra_buf = htod32(WL_EXTRA_BUF_MAX);
+		err = wl_dev_ioctl(wl_to_ndev(wl), WLC_GET_BSS_INFO,
+				wl->extra_buf, WL_EXTRA_BUF_MAX);
+		if (unlikely(err)) {
+			WL_ERR(("Could not get bss info %d\n", err));
+			goto update_bss_info_out;
+		}
+		bi = (struct wl_bss_info *)(wl->extra_buf + 4);
+		if (unlikely(memcmp(&bi->BSSID, &wl->bssid, ETHER_ADDR_LEN))) {
+			err = -EIO;
+			goto update_bss_info_out;
+		}
+		err = wl_inform_single_bss(wl, bi);
+		if (unlikely(err))
+			goto update_bss_info_out;
+
+		ie = ((u8 *)bi) + bi->ie_offset;
+		ie_len = bi->ie_length;
+		beacon_interval = cpu_to_le16(bi->beacon_period);
+	} else {
+		WL_DBG(("Found the AP in the list - BSSID %pM\n", bss->bssid));
+		ie = bss->information_elements;
+		ie_len = bss->len_information_elements;
+		beacon_interval = bss->beacon_interval;
+		cfg80211_put_bss(bss);
+	}
+
+	tim = bcm_parse_tlvs(ie, ie_len, WLAN_EID_TIM);
+	if (tim) {
+		dtim_period = tim->data[1];
+	} else {
+		/*
+		* active scan was done so we could not get dtim
+		* information out of probe response.
+		* so we speficially query dtim information to dongle.
+		*/
+		err = wl_dev_ioctl(wl_to_ndev(wl), WLC_GET_DTIMPRD,
+			&dtim_period, sizeof(dtim_period));
+		if (unlikely(err)) {
+			WL_ERR(("WLC_GET_DTIMPRD error (%d)\n", err));
+			goto update_bss_info_out;
+		}
+	}
+
+	wl_update_prof(wl, NULL, &beacon_interval, WL_PROF_BEACONINT);
+	wl_update_prof(wl, NULL, &dtim_period, WL_PROF_DTIMPERIOD);
+
+update_bss_info_out:
+	rtnl_unlock();
+	return err;
+}
+
+static s32
+wl_bss_roaming_done(struct wl_priv *wl, struct net_device *ndev,
+		    const wl_event_msg_t *e, void *data)
+{
+	struct wl_connect_info *conn_info = wl_to_conn(wl);
+	s32 err = 0;
+
+	wl_get_assoc_ies(wl);
+	memcpy(&wl->bssid, &e->addr, ETHER_ADDR_LEN);
+	wl_update_bss_info(wl);
+	cfg80211_roamed(ndev,
+			(u8 *)&wl->bssid,
+			conn_info->req_ie, conn_info->req_ie_len,
+			conn_info->resp_ie, conn_info->resp_ie_len, GFP_KERNEL);
+	WL_DBG(("Report roaming result\n"));
+
+	set_bit(WL_STATUS_CONNECTED, &wl->status);
+
+	return err;
+}
+
+static s32
+wl_bss_connect_done(struct wl_priv *wl, struct net_device *ndev,
+		    const wl_event_msg_t *e, void *data, bool completed)
+{
+	struct wl_connect_info *conn_info = wl_to_conn(wl);
+	s32 err = 0;
+
+	wl_get_assoc_ies(wl);
+	memcpy(&wl->bssid, &e->addr, ETHER_ADDR_LEN);
+	wl_update_bss_info(wl);
+	if (test_and_clear_bit(WL_STATUS_CONNECTING, &wl->status)) {
+		cfg80211_connect_result(ndev,
+					(u8 *)&wl->bssid,
+					conn_info->req_ie,
+					conn_info->req_ie_len,
+					conn_info->resp_ie,
+					conn_info->resp_ie_len,
+					completed ? WLAN_STATUS_SUCCESS : WLAN_STATUS_AUTH_TIMEOUT,
+					GFP_KERNEL);
+		WL_DBG(("Report connect result - connection %s\n",
+			completed ? "succeeded" : "failed"));
+	} else {
+		cfg80211_roamed(ndev,
+				(u8 *)&wl->bssid,
+				conn_info->req_ie, conn_info->req_ie_len,
+				conn_info->resp_ie, conn_info->resp_ie_len,
+				GFP_KERNEL);
+		WL_DBG(("Report roaming result\n"));
+	}
+	set_bit(WL_STATUS_CONNECTED, &wl->status);
+
+	return err;
+}
+
+static s32
+wl_notify_mic_status(struct wl_priv *wl, struct net_device *ndev,
+		     const wl_event_msg_t *e, void *data)
+{
+	u16 flags = ntoh16(e->flags);
+	enum nl80211_key_type key_type;
+
+	rtnl_lock();
+	if (flags & WLC_EVENT_MSG_GROUP)
+		key_type = NL80211_KEYTYPE_GROUP;
+	else
+		key_type = NL80211_KEYTYPE_PAIRWISE;
+
+	cfg80211_michael_mic_failure(ndev, (u8 *)&e->addr, key_type, -1,
+				     NULL, GFP_KERNEL);
+	rtnl_unlock();
+
+	return 0;
+}
+
+static s32
+wl_notify_scan_status(struct wl_priv *wl, struct net_device *ndev,
+		      const wl_event_msg_t *e, void *data)
+{
+	struct channel_info channel_inform;
+	struct wl_scan_results *bss_list;
+	u32 len = WL_SCAN_BUF_MAX;
+	s32 err = 0;
+
+	if (wl->iscan_on && wl->iscan_kickstart)
+		return wl_wakeup_iscan(wl_to_iscan(wl));
+
+	if (unlikely(!test_and_clear_bit(WL_STATUS_SCANNING, &wl->status))) {
+		WL_ERR(("Scan complete while device not scanning\n"));
+		return -EINVAL;
+	}
+	if (unlikely(!wl->scan_request)) {
+	}
+	rtnl_lock();
+	err = wl_dev_ioctl(ndev, WLC_GET_CHANNEL, &channel_inform,
+			sizeof(channel_inform));
+	if (unlikely(err)) {
+		WL_ERR(("scan busy (%d)\n", err));
+		goto scan_done_out;
+	}
+	channel_inform.scan_channel = dtoh32(channel_inform.scan_channel);
+	if (unlikely(channel_inform.scan_channel)) {
+
+		WL_DBG(("channel_inform.scan_channel (%d)\n",
+			channel_inform.scan_channel));
+	}
+	wl->bss_list = wl->scan_results;
+	bss_list = wl->bss_list;
+	memset(bss_list, 0, len);
+	bss_list->buflen = htod32(len);
+	err = wl_dev_ioctl(ndev, WLC_SCAN_RESULTS, bss_list, len);
+	if (unlikely(err)) {
+		WL_ERR(("%s Scan_results error (%d)\n", ndev->name, err));
+		err = -EINVAL;
+		goto scan_done_out;
+	}
+	bss_list->buflen = dtoh32(bss_list->buflen);
+	bss_list->version = dtoh32(bss_list->version);
+	bss_list->count = dtoh32(bss_list->count);
+
+	err = wl_inform_bss(wl);
+	if (err)
+		goto scan_done_out;
+
+scan_done_out:
+	if (wl->scan_request) {
+		cfg80211_scan_done(wl->scan_request, false);
+		wl_set_mpc(ndev, 1);
+		wl->scan_request = NULL;
+	}
+	rtnl_unlock();
+	return err;
+}
+
+static void wl_init_conf(struct wl_conf *conf)
+{
+	conf->mode = (u32)-1;
+	conf->frag_threshold = (u32)-1;
+	conf->rts_threshold = (u32)-1;
+	conf->retry_short = (u32)-1;
+	conf->retry_long = (u32)-1;
+	conf->tx_power = -1;
+}
+
+static void wl_init_prof(struct wl_profile *prof)
+{
+	memset(prof, 0, sizeof(*prof));
+}
+
+static void wl_init_eloop_handler(struct wl_event_loop *el)
+{
+	memset(el, 0, sizeof(*el));
+	el->handler[WLC_E_SCAN_COMPLETE] = wl_notify_scan_status;
+	el->handler[WLC_E_JOIN] = wl_notify_connect_status;
+	el->handler[WLC_E_LINK] = wl_notify_connect_status;
+	el->handler[WLC_E_DEAUTH_IND] = wl_notify_connect_status;
+	el->handler[WLC_E_DISASSOC_IND] = wl_notify_connect_status;
+	el->handler[WLC_E_ASSOC_IND] = wl_notify_connect_status;
+	el->handler[WLC_E_REASSOC_IND] = wl_notify_connect_status;
+	el->handler[WLC_E_ROAM] = wl_notify_roaming_status;
+	el->handler[WLC_E_MIC_ERROR] = wl_notify_mic_status;
+	el->handler[WLC_E_SET_SSID] = wl_notify_connect_status;
+}
+
+static s32 wl_init_priv_mem(struct wl_priv *wl)
+{
+	wl->scan_results = (void *)kzalloc(WL_SCAN_BUF_MAX, GFP_KERNEL);
+	if (unlikely(!wl->scan_results)) {
+		WL_ERR(("Scan results alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->conf = (void *)kzalloc(sizeof(*wl->conf), GFP_KERNEL);
+	if (unlikely(!wl->conf)) {
+		WL_ERR(("wl_conf alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->profile = (void *)kzalloc(sizeof(*wl->profile), GFP_KERNEL);
+	if (unlikely(!wl->profile)) {
+		WL_ERR(("wl_profile alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->bss_info = (void *)kzalloc(WL_BSS_INFO_MAX, GFP_KERNEL);
+	if (unlikely(!wl->bss_info)) {
+		WL_ERR(("Bss information alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->scan_req_int =
+	    (void *)kzalloc(sizeof(*wl->scan_req_int), GFP_KERNEL);
+	if (unlikely(!wl->scan_req_int)) {
+		WL_ERR(("Scan req alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->ioctl_buf = (void *)kzalloc(WL_IOCTL_LEN_MAX, GFP_KERNEL);
+	if (unlikely(!wl->ioctl_buf)) {
+		WL_ERR(("Ioctl buf alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->extra_buf = (void *)kzalloc(WL_EXTRA_BUF_MAX, GFP_KERNEL);
+	if (unlikely(!wl->extra_buf)) {
+		WL_ERR(("Extra buf alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->iscan = (void *)kzalloc(sizeof(*wl->iscan), GFP_KERNEL);
+	if (unlikely(!wl->iscan)) {
+		WL_ERR(("Iscan buf alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->fw = (void *)kzalloc(sizeof(*wl->fw), GFP_KERNEL);
+	if (unlikely(!wl->fw)) {
+		WL_ERR(("fw object alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->pmk_list = (void *)kzalloc(sizeof(*wl->pmk_list), GFP_KERNEL);
+	if (unlikely(!wl->pmk_list)) {
+		WL_ERR(("pmk list alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+
+	return 0;
+
+init_priv_mem_out:
+	wl_deinit_priv_mem(wl);
+
+	return -ENOMEM;
+}
+
+static void wl_deinit_priv_mem(struct wl_priv *wl)
+{
+	kfree(wl->scan_results);
+	wl->scan_results = NULL;
+	kfree(wl->bss_info);
+	wl->bss_info = NULL;
+	kfree(wl->conf);
+	wl->conf = NULL;
+	kfree(wl->profile);
+	wl->profile = NULL;
+	kfree(wl->scan_req_int);
+	wl->scan_req_int = NULL;
+	kfree(wl->ioctl_buf);
+	wl->ioctl_buf = NULL;
+	kfree(wl->extra_buf);
+	wl->extra_buf = NULL;
+	kfree(wl->iscan);
+	wl->iscan = NULL;
+	kfree(wl->fw);
+	wl->fw = NULL;
+	kfree(wl->pmk_list);
+	wl->pmk_list = NULL;
+}
+
+static s32 wl_create_event_handler(struct wl_priv *wl)
+{
+	sema_init(&wl->event_sync, 0);
+	wl->event_tsk = kthread_run(wl_event_handler, wl, "wl_event_handler");
+	if (IS_ERR(wl->event_tsk)) {
+		wl->event_tsk = NULL;
+		WL_ERR(("failed to create event thread\n"));
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+static void wl_destroy_event_handler(struct wl_priv *wl)
+{
+	if (wl->event_tsk) {
+		send_sig(SIGTERM, wl->event_tsk, 1);
+		kthread_stop(wl->event_tsk);
+		wl->event_tsk = NULL;
+	}
+}
+
+static void wl_term_iscan(struct wl_priv *wl)
+{
+	struct wl_iscan_ctrl *iscan = wl_to_iscan(wl);
+
+	if (wl->iscan_on && iscan->tsk) {
+		iscan->state = WL_ISCAN_STATE_IDLE;
+		send_sig(SIGTERM, iscan->tsk, 1);
+		kthread_stop(iscan->tsk);
+		iscan->tsk = NULL;
+	}
+}
+
+static void wl_notify_iscan_complete(struct wl_iscan_ctrl *iscan, bool aborted)
+{
+	struct wl_priv *wl = iscan_to_wl(iscan);
+	struct net_device *ndev = wl_to_ndev(wl);
+
+	if (unlikely(!test_and_clear_bit(WL_STATUS_SCANNING, &wl->status))) {
+		WL_ERR(("Scan complete while device not scanning\n"));
+		return;
+	}
+	if (likely(wl->scan_request)) {
+		cfg80211_scan_done(wl->scan_request, aborted);
+		wl_set_mpc(ndev, 1);
+		wl->scan_request = NULL;
+	}
+	wl->iscan_kickstart = false;
+}
+
+static s32 wl_wakeup_iscan(struct wl_iscan_ctrl *iscan)
+{
+	if (likely(iscan->state != WL_ISCAN_STATE_IDLE)) {
+		WL_DBG(("wake up iscan\n"));
+		up(&iscan->sync);
+		return 0;
+	}
+
+	return -EIO;
+}
+
+static s32
+wl_get_iscan_results(struct wl_iscan_ctrl *iscan, u32 *status,
+		     struct wl_scan_results **bss_list)
+{
+	struct wl_iscan_results list;
+	struct wl_scan_results *results;
+	struct wl_iscan_results *list_buf;
+	s32 err = 0;
+
+	memset(iscan->scan_buf, 0, WL_ISCAN_BUF_MAX);
+	list_buf = (struct wl_iscan_results *)iscan->scan_buf;
+	results = &list_buf->results;
+	results->buflen = WL_ISCAN_RESULTS_FIXED_SIZE;
+	results->version = 0;
+	results->count = 0;
+
+	memset(&list, 0, sizeof(list));
+	list.results.buflen = htod32(WL_ISCAN_BUF_MAX);
+	err = wl_dev_iovar_getbuf(iscan->dev, "iscanresults", &list,
+				WL_ISCAN_RESULTS_FIXED_SIZE, iscan->scan_buf,
+				WL_ISCAN_BUF_MAX);
+	if (unlikely(err)) {
+		WL_ERR(("error (%d)\n", err));
+		return err;
+	}
+	results->buflen = dtoh32(results->buflen);
+	results->version = dtoh32(results->version);
+	results->count = dtoh32(results->count);
+	WL_DBG(("results->count = %d\n", results->count));
+	WL_DBG(("results->buflen = %d\n", results->buflen));
+	*status = dtoh32(list_buf->status);
+	*bss_list = results;
+
+	return err;
+}
+
+static s32 wl_iscan_done(struct wl_priv *wl)
+{
+	struct wl_iscan_ctrl *iscan = wl->iscan;
+	s32 err = 0;
+
+	iscan->state = WL_ISCAN_STATE_IDLE;
+	rtnl_lock();
+	wl_inform_bss(wl);
+	wl_notify_iscan_complete(iscan, false);
+	rtnl_unlock();
+
+	return err;
+}
+
+static s32 wl_iscan_pending(struct wl_priv *wl)
+{
+	struct wl_iscan_ctrl *iscan = wl->iscan;
+	s32 err = 0;
+
+	/* Reschedule the timer */
+	mod_timer(&iscan->timer, jiffies + iscan->timer_ms * HZ / 1000);
+	iscan->timer_on = 1;
+
+	return err;
+}
+
+static s32 wl_iscan_inprogress(struct wl_priv *wl)
+{
+	struct wl_iscan_ctrl *iscan = wl->iscan;
+	s32 err = 0;
+
+	rtnl_lock();
+	wl_inform_bss(wl);
+	wl_run_iscan(iscan, NULL, WL_SCAN_ACTION_CONTINUE);
+	rtnl_unlock();
+	/* Reschedule the timer */
+	mod_timer(&iscan->timer, jiffies + iscan->timer_ms * HZ / 1000);
+	iscan->timer_on = 1;
+
+	return err;
+}
+
+static s32 wl_iscan_aborted(struct wl_priv *wl)
+{
+	struct wl_iscan_ctrl *iscan = wl->iscan;
+	s32 err = 0;
+
+	iscan->state = WL_ISCAN_STATE_IDLE;
+	rtnl_lock();
+	wl_notify_iscan_complete(iscan, true);
+	rtnl_unlock();
+
+	return err;
+}
+
+static s32 wl_iscan_thread(void *data)
+{
+	struct sched_param param = {.sched_priority = MAX_RT_PRIO - 1 };
+	struct wl_iscan_ctrl *iscan = (struct wl_iscan_ctrl *)data;
+	struct wl_priv *wl = iscan_to_wl(iscan);
+	struct wl_iscan_eloop *el = &iscan->el;
+	u32 status;
+	int err = 0;
+
+	sched_setscheduler(current, SCHED_FIFO, &param);
+	allow_signal(SIGTERM);
+	status = WL_SCAN_RESULTS_PARTIAL;
+	while (likely(!down_interruptible(&iscan->sync))) {
+		if (kthread_should_stop())
+			break;
+		if (iscan->timer_on) {
+			del_timer_sync(&iscan->timer);
+			iscan->timer_on = 0;
+		}
+		rtnl_lock();
+		err = wl_get_iscan_results(iscan, &status, &wl->bss_list);
+		if (unlikely(err)) {
+			status = WL_SCAN_RESULTS_ABORTED;
+			WL_ERR(("Abort iscan\n"));
+		}
+		rtnl_unlock();
+		el->handler[status] (wl);
+	}
+	if (iscan->timer_on) {
+		del_timer_sync(&iscan->timer);
+		iscan->timer_on = 0;
+	}
+	WL_DBG(("%s was terminated\n", __func__));
+
+	return 0;
+}
+
+static void wl_iscan_timer(unsigned long data)
+{
+	struct wl_iscan_ctrl *iscan = (struct wl_iscan_ctrl *)data;
+
+	if (iscan) {
+		iscan->timer_on = 0;
+		WL_DBG(("timer expired\n"));
+		wl_wakeup_iscan(iscan);
+	}
+}
+
+static s32 wl_invoke_iscan(struct wl_priv *wl)
+{
+	struct wl_iscan_ctrl *iscan = wl_to_iscan(wl);
+	int err = 0;
+
+	if (wl->iscan_on && !iscan->tsk) {
+		iscan->state = WL_ISCAN_STATE_IDLE;
+		sema_init(&iscan->sync, 0);
+		iscan->tsk = kthread_run(wl_iscan_thread, iscan, "wl_iscan");
+		if (IS_ERR(iscan->tsk)) {
+			WL_ERR(("Could not create iscan thread\n"));
+			iscan->tsk = NULL;
+			return -ENOMEM;
+		}
+	}
+
+	return err;
+}
+
+static void wl_init_iscan_eloop(struct wl_iscan_eloop *el)
+{
+	memset(el, 0, sizeof(*el));
+	el->handler[WL_SCAN_RESULTS_SUCCESS] = wl_iscan_done;
+	el->handler[WL_SCAN_RESULTS_PARTIAL] = wl_iscan_inprogress;
+	el->handler[WL_SCAN_RESULTS_PENDING] = wl_iscan_pending;
+	el->handler[WL_SCAN_RESULTS_ABORTED] = wl_iscan_aborted;
+	el->handler[WL_SCAN_RESULTS_NO_MEM] = wl_iscan_aborted;
+}
+
+static s32 wl_init_iscan(struct wl_priv *wl)
+{
+	struct wl_iscan_ctrl *iscan = wl_to_iscan(wl);
+	int err = 0;
+
+	if (wl->iscan_on) {
+		iscan->dev = wl_to_ndev(wl);
+		iscan->state = WL_ISCAN_STATE_IDLE;
+		wl_init_iscan_eloop(&iscan->el);
+		iscan->timer_ms = WL_ISCAN_TIMER_INTERVAL_MS;
+		init_timer(&iscan->timer);
+		iscan->timer.data = (unsigned long) iscan;
+		iscan->timer.function = wl_iscan_timer;
+		sema_init(&iscan->sync, 0);
+		iscan->tsk = kthread_run(wl_iscan_thread, iscan, "wl_iscan");
+		if (IS_ERR(iscan->tsk)) {
+			WL_ERR(("Could not create iscan thread\n"));
+			iscan->tsk = NULL;
+			return -ENOMEM;
+		}
+		iscan->data = wl;
+	}
+
+	return err;
+}
+
+static void wl_init_fw(struct wl_fw_ctrl *fw)
+{
+	fw->status = 0;		/* init fw loading status.
+				 0 means nothing was loaded yet */
+}
+
+static s32 wl_init_priv(struct wl_priv *wl)
+{
+	struct wiphy *wiphy = wl_to_wiphy(wl);
+	s32 err = 0;
+
+	wl->scan_request = NULL;
+	wl->pwr_save = !!(wiphy->flags & WIPHY_FLAG_PS_ON_BY_DEFAULT);
+	wl->iscan_on = true;	/* iscan on & off switch.
+				 we enable iscan per default */
+	wl->roam_on = false;	/* roam on & off switch.
+				 we enable roam per default */
+
+	wl->iscan_kickstart = false;
+	wl->active_scan = true;	/* we do active scan for
+				 specific scan per default */
+	wl->dongle_up = false;	/* dongle is not up yet */
+	wl_init_eq(wl);
+	err = wl_init_priv_mem(wl);
+	if (unlikely(err))
+		return err;
+	if (unlikely(wl_create_event_handler(wl)))
+		return -ENOMEM;
+	wl_init_eloop_handler(&wl->el);
+	mutex_init(&wl->usr_sync);
+	err = wl_init_iscan(wl);
+	if (unlikely(err))
+		return err;
+	wl_init_fw(wl->fw);
+	wl_init_conf(wl->conf);
+	wl_init_prof(wl->profile);
+	wl_link_down(wl);
+
+	return err;
+}
+
+static void wl_deinit_priv(struct wl_priv *wl)
+{
+	wl_destroy_event_handler(wl);
+	wl->dongle_up = false;	/* dongle down */
+	wl_flush_eq(wl);
+	wl_link_down(wl);
+	wl_term_iscan(wl);
+	wl_deinit_priv_mem(wl);
+}
+
+s32 wl_cfg80211_attach(struct net_device *ndev, void *data)
+{
+	struct wireless_dev *wdev;
+	struct wl_priv *wl;
+	struct wl_iface *ci;
+	s32 err = 0;
+
+	if (unlikely(!ndev)) {
+		WL_ERR(("ndev is invaild\n"));
+		return -ENODEV;
+	}
+	wl_cfg80211_dev = kzalloc(sizeof(struct wl_dev), GFP_KERNEL);
+	if (unlikely(!wl_cfg80211_dev)) {
+		WL_ERR(("wl_cfg80211_dev is invalid\n"));
+		return -ENOMEM;
+	}
+	WL_DBG(("func %p\n", wl_cfg80211_get_sdio_func()));
+	wdev = wl_alloc_wdev(sizeof(struct wl_iface), &wl_cfg80211_get_sdio_func()->dev);
+	if (unlikely(IS_ERR(wdev)))
+		return -ENOMEM;
+
+	wdev->iftype = wl_mode_to_nl80211_iftype(WL_MODE_BSS);
+	wl = wdev_to_wl(wdev);
+	wl->wdev = wdev;
+	wl->pub = data;
+	ci = (struct wl_iface *)wl_to_ci(wl);
+	ci->wl = wl;
+	ndev->ieee80211_ptr = wdev;
+	SET_NETDEV_DEV(ndev, wiphy_dev(wdev->wiphy));
+	wdev->netdev = ndev;
+	err = wl_init_priv(wl);
+	if (unlikely(err)) {
+		WL_ERR(("Failed to init iwm_priv (%d)\n", err));
+		goto cfg80211_attach_out;
+	}
+	wl_set_drvdata(wl_cfg80211_dev, ci);
+	set_bit(WL_STATUS_READY, &wl->status);
+
+	return err;
+
+cfg80211_attach_out:
+	wl_free_wdev(wl);
+	return err;
+}
+
+void wl_cfg80211_detach(void)
+{
+	struct wl_priv *wl;
+
+	wl = WL_PRIV_GET();
+
+	wl_deinit_priv(wl);
+	wl_free_wdev(wl);
+	wl_set_drvdata(wl_cfg80211_dev, NULL);
+	kfree(wl_cfg80211_dev);
+	wl_cfg80211_dev = NULL;
+	wl_clear_sdio_func();
+}
+
+static void wl_wakeup_event(struct wl_priv *wl)
+{
+	up(&wl->event_sync);
+}
+
+static s32 wl_event_handler(void *data)
+{
+	struct wl_priv *wl = (struct wl_priv *)data;
+	struct sched_param param = {.sched_priority = MAX_RT_PRIO - 1 };
+	struct wl_event_q *e;
+
+	sched_setscheduler(current, SCHED_FIFO, &param);
+	allow_signal(SIGTERM);
+	while (likely(!down_interruptible(&wl->event_sync))) {
+		if (kthread_should_stop())
+			break;
+		e = wl_deq_event(wl);
+		if (unlikely(!e)) {
+			WL_ERR(("eqeue empty..\n"));
+			BUG();
+		}
+		WL_DBG(("event type (%d)\n", e->etype));
+		if (wl->el.handler[e->etype]) {
+			wl->el.handler[e->etype] (wl, wl_to_ndev(wl), &e->emsg,
+						  e->edata);
+		} else {
+			WL_DBG(("Unknown Event (%d): ignoring\n", e->etype));
+		}
+		wl_put_event(e);
+	}
+	WL_DBG(("%s was terminated\n", __func__));
+	return 0;
+}
+
+void
+wl_cfg80211_event(struct net_device *ndev, const wl_event_msg_t * e, void *data)
+{
+	u32 event_type = ntoh32(e->event_type);
+	struct wl_priv *wl = ndev_to_wl(ndev);
+#if (WL_DBG_LEVEL > 0)
+	s8 *estr = (event_type <= sizeof(wl_dbg_estr) / WL_DBG_ESTR_MAX - 1) ?
+	    wl_dbg_estr[event_type] : (s8 *) "Unknown";
+#endif				/* (WL_DBG_LEVEL > 0) */
+	WL_DBG(("event_type (%d):" "WLC_E_" "%s\n", event_type, estr));
+	if (likely(!wl_enq_event(wl, event_type, e, data)))
+		wl_wakeup_event(wl);
+}
+
+static void wl_init_eq(struct wl_priv *wl)
+{
+	wl_init_eq_lock(wl);
+	INIT_LIST_HEAD(&wl->eq_list);
+}
+
+static void wl_flush_eq(struct wl_priv *wl)
+{
+	struct wl_event_q *e;
+
+	wl_lock_eq(wl);
+	while (!list_empty(&wl->eq_list)) {
+		e = list_first_entry(&wl->eq_list, struct wl_event_q, eq_list);
+		list_del(&e->eq_list);
+		kfree(e);
+	}
+	wl_unlock_eq(wl);
+}
+
+/*
+* retrieve first queued event from head
+*/
+
+static struct wl_event_q *wl_deq_event(struct wl_priv *wl)
+{
+	struct wl_event_q *e = NULL;
+
+	wl_lock_eq(wl);
+	if (likely(!list_empty(&wl->eq_list))) {
+		e = list_first_entry(&wl->eq_list, struct wl_event_q, eq_list);
+		list_del(&e->eq_list);
+	}
+	wl_unlock_eq(wl);
+
+	return e;
+}
+
+/*
+** push event to tail of the queue
+*/
+
+static s32
+wl_enq_event(struct wl_priv *wl, u32 event, const wl_event_msg_t *msg,
+	     void *data)
+{
+	struct wl_event_q *e;
+	s32 err = 0;
+
+	e = kzalloc(sizeof(struct wl_event_q), GFP_KERNEL);
+	if (unlikely(!e)) {
+		WL_ERR(("event alloc failed\n"));
+		return -ENOMEM;
+	}
+
+	e->etype = event;
+	memcpy(&e->emsg, msg, sizeof(wl_event_msg_t));
+	if (data) {
+	}
+	wl_lock_eq(wl);
+	list_add_tail(&e->eq_list, &wl->eq_list);
+	wl_unlock_eq(wl);
+
+	return err;
+}
+
+static void wl_put_event(struct wl_event_q *e)
+{
+	kfree(e);
+}
+
+void wl_cfg80211_sdio_func(void *func)
+{
+	cfg80211_sdio_func = (struct sdio_func *)func;
+}
+
+static void wl_clear_sdio_func(void)
+{
+	cfg80211_sdio_func = NULL;
+}
+
+struct sdio_func *wl_cfg80211_get_sdio_func(void)
+{
+	return cfg80211_sdio_func;
+}
+
+static s32 wl_dongle_mode(struct net_device *ndev, s32 iftype)
+{
+	s32 infra = 0;
+	s32 ap = 0;
+	s32 err = 0;
+
+	switch (iftype) {
+	case NL80211_IFTYPE_MONITOR:
+	case NL80211_IFTYPE_WDS:
+		WL_ERR(("type (%d) : currently we do not support this mode\n",
+			iftype));
+		err = -EINVAL;
+		return err;
+	case NL80211_IFTYPE_ADHOC:
+		break;
+	case NL80211_IFTYPE_STATION:
+		infra = 1;
+		break;
+	default:
+		err = -EINVAL;
+		WL_ERR(("invalid type (%d)\n", iftype));
+		return err;
+	}
+	infra = htod32(infra);
+	ap = htod32(ap);
+	WL_DBG(("%s ap (%d), infra (%d)\n", ndev->name, ap, infra));
+	err = wl_dev_ioctl(ndev, WLC_SET_INFRA, &infra, sizeof(infra));
+	if (unlikely(err)) {
+		WL_ERR(("WLC_SET_INFRA error (%d)\n", err));
+		return err;
+	}
+	err = wl_dev_ioctl(ndev, WLC_SET_AP, &ap, sizeof(ap));
+	if (unlikely(err)) {
+		WL_ERR(("WLC_SET_AP error (%d)\n", err));
+		return err;
+	}
+
+	return -EINPROGRESS;
+}
+
+#ifndef EMBEDDED_PLATFORM
+static s32 wl_dongle_country(struct net_device *ndev, u8 ccode)
+{
+
+	s32 err = 0;
+
+	return err;
+}
+
+static s32 wl_dongle_up(struct net_device *ndev, u32 up)
+{
+	s32 err = 0;
+
+	err = wl_dev_ioctl(ndev, WLC_UP, &up, sizeof(up));
+	if (unlikely(err)) {
+		WL_ERR(("WLC_UP error (%d)\n", err));
+	}
+	return err;
+}
+
+static s32 wl_dongle_power(struct net_device *ndev, u32 power_mode)
+{
+	s32 err = 0;
+
+	err = wl_dev_ioctl(ndev, WLC_SET_PM, &power_mode, sizeof(power_mode));
+	if (unlikely(err)) {
+		WL_ERR(("WLC_SET_PM error (%d)\n", err));
+	}
+	return err;
+}
+
+static s32
+wl_dongle_glom(struct net_device *ndev, u32 glom, u32 dongle_align)
+{
+	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
+						 '\0' + bitvec  */
+	s32 err = 0;
+
+	/* Match Host and Dongle rx alignment */
+	bcm_mkiovar("bus:txglomalign", (char *)&dongle_align, 4, iovbuf,
+		    sizeof(iovbuf));
+	err = wl_dev_ioctl(ndev, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+	if (unlikely(err)) {
+		WL_ERR(("txglomalign error (%d)\n", err));
+		goto dongle_glom_out;
+	}
+	/* disable glom option per default */
+	bcm_mkiovar("bus:txglom", (char *)&glom, 4, iovbuf, sizeof(iovbuf));
+	err = wl_dev_ioctl(ndev, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+	if (unlikely(err)) {
+		WL_ERR(("txglom error (%d)\n", err));
+		goto dongle_glom_out;
+	}
+dongle_glom_out:
+	return err;
+}
+
+static s32
+wl_dongle_roam(struct net_device *ndev, u32 roamvar, u32 bcn_timeout)
+{
+	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
+						 '\0' + bitvec  */
+	s32 err = 0;
+
+	/* Setup timeout if Beacons are lost and roam is
+		 off to report link down */
+	if (roamvar) {
+		bcm_mkiovar("bcn_timeout", (char *)&bcn_timeout, 4, iovbuf,
+			    sizeof(iovbuf));
+		err = wl_dev_ioctl(ndev, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+		if (unlikely(err)) {
+			WL_ERR(("bcn_timeout error (%d)\n", err));
+			goto dongle_rom_out;
+		}
+	}
+	/* Enable/Disable built-in roaming to allow supplicant
+		 to take care of roaming */
+	bcm_mkiovar("roam_off", (char *)&roamvar, 4, iovbuf, sizeof(iovbuf));
+	err = wl_dev_ioctl(ndev, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+	if (unlikely(err)) {
+		WL_ERR(("roam_off error (%d)\n", err));
+		goto dongle_rom_out;
+	}
+dongle_rom_out:
+	return err;
+}
+
+static s32 wl_dongle_eventmsg(struct net_device *ndev)
+{
+
+	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
+						 '\0' + bitvec  */
+	s8 eventmask[WL_EVENTING_MASK_LEN];
+	s32 err = 0;
+
+	/* Setup event_msgs */
+	bcm_mkiovar("event_msgs", eventmask, WL_EVENTING_MASK_LEN, iovbuf,
+		    sizeof(iovbuf));
+	err = wl_dev_ioctl(ndev, WLC_GET_VAR, iovbuf, sizeof(iovbuf));
+	if (unlikely(err)) {
+		WL_ERR(("Get event_msgs error (%d)\n", err));
+		goto dongle_eventmsg_out;
+	}
+	memcpy(eventmask, iovbuf, WL_EVENTING_MASK_LEN);
+
+	setbit(eventmask, WLC_E_SET_SSID);
+	setbit(eventmask, WLC_E_PRUNE);
+	setbit(eventmask, WLC_E_AUTH);
+	setbit(eventmask, WLC_E_REASSOC);
+	setbit(eventmask, WLC_E_REASSOC_IND);
+	setbit(eventmask, WLC_E_DEAUTH_IND);
+	setbit(eventmask, WLC_E_DISASSOC_IND);
+	setbit(eventmask, WLC_E_DISASSOC);
+	setbit(eventmask, WLC_E_JOIN);
+	setbit(eventmask, WLC_E_ASSOC_IND);
+	setbit(eventmask, WLC_E_PSK_SUP);
+	setbit(eventmask, WLC_E_LINK);
+	setbit(eventmask, WLC_E_NDIS_LINK);
+	setbit(eventmask, WLC_E_MIC_ERROR);
+	setbit(eventmask, WLC_E_PMKID_CACHE);
+	setbit(eventmask, WLC_E_TXFAIL);
+	setbit(eventmask, WLC_E_JOIN_START);
+	setbit(eventmask, WLC_E_SCAN_COMPLETE);
+
+	bcm_mkiovar("event_msgs", eventmask, WL_EVENTING_MASK_LEN, iovbuf,
+		    sizeof(iovbuf));
+	err = wl_dev_ioctl(ndev, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+	if (unlikely(err)) {
+		WL_ERR(("Set event_msgs error (%d)\n", err));
+		goto dongle_eventmsg_out;
+	}
+
+dongle_eventmsg_out:
+	return err;
+}
+
+static s32
+wl_dongle_scantime(struct net_device *ndev, s32 scan_assoc_time,
+		   s32 scan_unassoc_time)
+{
+	s32 err = 0;
+
+	err = wl_dev_ioctl(ndev, WLC_SET_SCAN_CHANNEL_TIME, &scan_assoc_time,
+			sizeof(scan_assoc_time));
+	if (err) {
+		if (err == -EOPNOTSUPP) {
+			WL_INFO(("Scan assoc time is not supported\n"));
+		} else {
+			WL_ERR(("Scan assoc time error (%d)\n", err));
+		}
+		goto dongle_scantime_out;
+	}
+	err = wl_dev_ioctl(ndev, WLC_SET_SCAN_UNASSOC_TIME, &scan_unassoc_time,
+			sizeof(scan_unassoc_time));
+	if (err) {
+		if (err == -EOPNOTSUPP) {
+			WL_INFO(("Scan unassoc time is not supported\n"));
+		} else {
+			WL_ERR(("Scan unassoc time error (%d)\n", err));
+		}
+		goto dongle_scantime_out;
+	}
+
+dongle_scantime_out:
+	return err;
+}
+
+static s32
+wl_dongle_offload(struct net_device *ndev, s32 arpoe, s32 arp_ol)
+{
+	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
+							 '\0' + bitvec  */
+	s32 err = 0;
+
+	/* Set ARP offload */
+	bcm_mkiovar("arpoe", (char *)&arpoe, 4, iovbuf, sizeof(iovbuf));
+	err = wl_dev_ioctl(ndev, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+	if (err) {
+		if (err == -EOPNOTSUPP)
+			WL_INFO(("arpoe is not supported\n"));
+		else
+			WL_ERR(("arpoe error (%d)\n", err));
+
+		goto dongle_offload_out;
+	}
+	bcm_mkiovar("arp_ol", (char *)&arp_ol, 4, iovbuf, sizeof(iovbuf));
+	err = wl_dev_ioctl(ndev, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+	if (err) {
+		if (err == -EOPNOTSUPP)
+			WL_INFO(("arp_ol is not supported\n"));
+		else
+			WL_ERR(("arp_ol error (%d)\n", err));
+
+		goto dongle_offload_out;
+	}
+
+dongle_offload_out:
+	return err;
+}
+
+static s32 wl_pattern_atoh(s8 *src, s8 *dst)
+{
+	int i;
+	if (strncmp(src, "0x", 2) != 0 && strncmp(src, "0X", 2) != 0) {
+		WL_ERR(("Mask invalid format. Needs to start with 0x\n"));
+		return -1;
+	}
+	src = src + 2;		/* Skip past 0x */
+	if (strlen(src) % 2 != 0) {
+		WL_ERR(("Mask invalid format. Needs to be of even length\n"));
+		return -1;
+	}
+	for (i = 0; *src != '\0'; i++) {
+		char num[3];
+		strncpy(num, src, 2);
+		num[2] = '\0';
+		dst[i] = (u8) simple_strtoul(num, NULL, 16);
+		src += 2;
+	}
+	return i;
+}
+
+static s32 wl_dongle_filter(struct net_device *ndev, u32 filter_mode)
+{
+	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
+							 '\0' + bitvec  */
+	const s8 *str;
+	struct wl_pkt_filter pkt_filter;
+	struct wl_pkt_filter *pkt_filterp;
+	s32 buf_len;
+	s32 str_len;
+	u32 mask_size;
+	u32 pattern_size;
+	s8 buf[256];
+	s32 err = 0;
+
+/* add a default packet filter pattern */
+	str = "pkt_filter_add";
+	str_len = strlen(str);
+	strncpy(buf, str, str_len);
+	buf[str_len] = '\0';
+	buf_len = str_len + 1;
+
+	pkt_filterp = (struct wl_pkt_filter *)(buf + str_len + 1);
+
+	/* Parse packet filter id. */
+	pkt_filter.id = htod32(100);
+
+	/* Parse filter polarity. */
+	pkt_filter.negate_match = htod32(0);
+
+	/* Parse filter type. */
+	pkt_filter.type = htod32(0);
+
+	/* Parse pattern filter offset. */
+	pkt_filter.u.pattern.offset = htod32(0);
+
+	/* Parse pattern filter mask. */
+	mask_size = htod32(wl_pattern_atoh("0xff",
+					   (char *)pkt_filterp->u.pattern.
+					   mask_and_pattern));
+
+	/* Parse pattern filter pattern. */
+	pattern_size = htod32(wl_pattern_atoh("0x00",
+					      (char *)&pkt_filterp->u.pattern.
+					      mask_and_pattern[mask_size]));
+
+	if (mask_size != pattern_size) {
+		WL_ERR(("Mask and pattern not the same size\n"));
+		err = -EINVAL;
+		goto dongle_filter_out;
+	}
+
+	pkt_filter.u.pattern.size_bytes = mask_size;
+	buf_len += WL_PKT_FILTER_FIXED_LEN;
+	buf_len += (WL_PKT_FILTER_PATTERN_FIXED_LEN + 2 * mask_size);
+
+	/* Keep-alive attributes are set in local
+	 * variable (keep_alive_pkt), and
+	 * then memcpy'ed into buffer (keep_alive_pktp) since there is no
+	 * guarantee that the buffer is properly aligned.
+	 */
+	memcpy((char *)pkt_filterp, &pkt_filter,
+	       WL_PKT_FILTER_FIXED_LEN + WL_PKT_FILTER_PATTERN_FIXED_LEN);
+
+	err = wl_dev_ioctl(ndev, WLC_SET_VAR, buf, buf_len);
+	if (err) {
+		if (err == -EOPNOTSUPP) {
+			WL_INFO(("filter not supported\n"));
+		} else {
+			WL_ERR(("filter (%d)\n", err));
+		}
+		goto dongle_filter_out;
+	}
+
+	/* set mode to allow pattern */
+	bcm_mkiovar("pkt_filter_mode", (char *)&filter_mode, 4, iovbuf,
+		    sizeof(iovbuf));
+	err = wl_dev_ioctl(ndev, WLC_SET_VAR, iovbuf, sizeof(iovbuf));
+	if (err) {
+		if (err == -EOPNOTSUPP) {
+			WL_INFO(("filter_mode not supported\n"));
+		} else {
+			WL_ERR(("filter_mode (%d)\n", err));
+		}
+		goto dongle_filter_out;
+	}
+
+dongle_filter_out:
+	return err;
+}
+#endif				/* !EMBEDDED_PLATFORM */
+
+s32 wl_config_dongle(struct wl_priv *wl, bool need_lock)
+{
+#ifndef DHD_SDALIGN
+#define DHD_SDALIGN	32
+#endif
+	struct net_device *ndev;
+	struct wireless_dev *wdev;
+	s32 err = 0;
+
+	if (wl->dongle_up)
+		return err;
+
+	ndev = wl_to_ndev(wl);
+	wdev = ndev->ieee80211_ptr;
+	if (need_lock)
+		rtnl_lock();
+
+#ifndef EMBEDDED_PLATFORM
+	err = wl_dongle_up(ndev, 0);
+	if (unlikely(err))
+		goto default_conf_out;
+	err = wl_dongle_country(ndev, 0);
+	if (unlikely(err))
+		goto default_conf_out;
+	err = wl_dongle_power(ndev, PM_FAST);
+	if (unlikely(err))
+		goto default_conf_out;
+	err = wl_dongle_glom(ndev, 0, DHD_SDALIGN);
+	if (unlikely(err))
+		goto default_conf_out;
+	err = wl_dongle_roam(ndev, (wl->roam_on ? 0 : 1), 3);
+	if (unlikely(err))
+		goto default_conf_out;
+	err = wl_dongle_eventmsg(ndev);
+	if (unlikely(err))
+		goto default_conf_out;
+
+	wl_dongle_scantime(ndev, 40, 80);
+	wl_dongle_offload(ndev, 1, 0xf);
+	wl_dongle_filter(ndev, 1);
+#endif				/* !EMBEDDED_PLATFORM */
+
+	err = wl_dongle_mode(ndev, wdev->iftype);
+	if (unlikely(err && err != -EINPROGRESS))
+		goto default_conf_out;
+	err = wl_dongle_probecap(wl);
+	if (unlikely(err))
+		goto default_conf_out;
+
+	/* -EINPROGRESS: Call commit handler */
+
+default_conf_out:
+	if (need_lock)
+		rtnl_unlock();
+
+	wl->dongle_up = true;
+
+	return err;
+
+}
+
+static s32 wl_update_wiphybands(struct wl_priv *wl)
+{
+	struct wiphy *wiphy;
+	s32 phy_list;
+	s8 phy;
+	s32 err = 0;
+
+	err = wl_dev_ioctl(wl_to_ndev(wl), WLC_GET_PHYLIST, &phy_list,
+			sizeof(phy_list));
+	if (unlikely(err)) {
+		WL_ERR(("error (%d)\n", err));
+		return err;
+	}
+
+	phy = ((char *)&phy_list)[1];
+	WL_DBG(("%c phy\n", phy));
+	if (phy == 'n' || phy == 'a') {
+		wiphy = wl_to_wiphy(wl);
+		wiphy->bands[IEEE80211_BAND_5GHZ] = &__wl_band_5ghz_n;
+	}
+
+	return err;
+}
+
+static s32 __wl_cfg80211_up(struct wl_priv *wl)
+{
+	s32 err = 0;
+
+	wl_debugfs_add_netdev_params(wl);
+
+	err = wl_config_dongle(wl, false);
+	if (unlikely(err))
+		return err;
+
+	wl_invoke_iscan(wl);
+	set_bit(WL_STATUS_READY, &wl->status);
+	return err;
+}
+
+static s32 __wl_cfg80211_down(struct wl_priv *wl)
+{
+	s32 err = 0;
+
+	/* Check if cfg80211 interface is already down */
+	if (!test_bit(WL_STATUS_READY, &wl->status))
+		return err;	/* it is even not ready */
+
+	set_bit(WL_STATUS_SCAN_ABORTING, &wl->status);
+	wl_term_iscan(wl);
+	if (wl->scan_request) {
+		cfg80211_scan_done(wl->scan_request, true);	/* true
+								 means abort */
+		/* wl_set_mpc(wl_to_ndev(wl), 1); */	/* BUG
+						* this operation cannot help
+						* but here because sdio
+						* is already down through
+						* rmmod process.
+						* Need to figure out how to
+						* address this issue
+						*/
+		wl->scan_request = NULL;
+	}
+	clear_bit(WL_STATUS_READY, &wl->status);
+	clear_bit(WL_STATUS_SCANNING, &wl->status);
+	clear_bit(WL_STATUS_SCAN_ABORTING, &wl->status);
+	clear_bit(WL_STATUS_CONNECTED, &wl->status);
+
+	wl_debugfs_remove_netdev(wl);
+
+	return err;
+}
+
+s32 wl_cfg80211_up(void)
+{
+	struct wl_priv *wl;
+	s32 err = 0;
+
+	wl = WL_PRIV_GET();
+	mutex_lock(&wl->usr_sync);
+	err = __wl_cfg80211_up(wl);
+	mutex_unlock(&wl->usr_sync);
+
+	return err;
+}
+
+s32 wl_cfg80211_down(void)
+{
+	struct wl_priv *wl;
+	s32 err = 0;
+
+	wl = WL_PRIV_GET();
+	mutex_lock(&wl->usr_sync);
+	err = __wl_cfg80211_down(wl);
+	mutex_unlock(&wl->usr_sync);
+
+	return err;
+}
+
+static s32 wl_dongle_probecap(struct wl_priv *wl)
+{
+	s32 err = 0;
+
+	err = wl_update_wiphybands(wl);
+	if (unlikely(err))
+		return err;
+
+	return err;
+}
+
+static void *wl_read_prof(struct wl_priv *wl, s32 item)
+{
+	switch (item) {
+	case WL_PROF_SEC:
+		return &wl->profile->sec;
+	case WL_PROF_ACT:
+		return &wl->profile->active;
+	case WL_PROF_BSSID:
+		return &wl->profile->bssid;
+	case WL_PROF_SSID:
+		return &wl->profile->ssid;
+	}
+	WL_ERR(("invalid item (%d)\n", item));
+	return NULL;
+}
+
+static s32
+wl_update_prof(struct wl_priv *wl, const wl_event_msg_t *e, void *data,
+	       s32 item)
+{
+	s32 err = 0;
+	struct wlc_ssid *ssid;
+
+	switch (item) {
+	case WL_PROF_SSID:
+		ssid = (wlc_ssid_t *) data;
+		memset(wl->profile->ssid.SSID, 0,
+		       sizeof(wl->profile->ssid.SSID));
+		memcpy(wl->profile->ssid.SSID, ssid->SSID, ssid->SSID_len);
+		wl->profile->ssid.SSID_len = ssid->SSID_len;
+		break;
+	case WL_PROF_BSSID:
+		if (data)
+			memcpy(wl->profile->bssid, data, ETHER_ADDR_LEN);
+		else
+			memset(wl->profile->bssid, 0, ETHER_ADDR_LEN);
+		break;
+	case WL_PROF_SEC:
+		memcpy(&wl->profile->sec, data, sizeof(wl->profile->sec));
+		break;
+	case WL_PROF_ACT:
+		wl->profile->active = *(bool *)data;
+		break;
+	case WL_PROF_BEACONINT:
+		wl->profile->beacon_interval = *(u16 *)data;
+		break;
+	case WL_PROF_DTIMPERIOD:
+		wl->profile->dtim_period = *(u8 *)data;
+		break;
+	default:
+		WL_ERR(("unsupported item (%d)\n", item));
+		err = -EOPNOTSUPP;
+		break;
+	}
+
+	return err;
+}
+
+void wl_cfg80211_dbg_level(u32 level)
+{
+	/*
+	* prohibit to change debug level
+	* by insmod parameter.
+	* eventually debug level will be configured
+	* in compile time by using CONFIG_XXX
+	*/
+	/* wl_dbg_level = level; */
+}
+
+static bool wl_is_ibssmode(struct wl_priv *wl)
+{
+	return wl->conf->mode == WL_MODE_IBSS;
+}
+
+static bool wl_is_ibssstarter(struct wl_priv *wl)
+{
+	return wl->ibss_starter;
+}
+
+static void wl_rst_ie(struct wl_priv *wl)
+{
+	struct wl_ie *ie = wl_to_ie(wl);
+
+	ie->offset = 0;
+}
+
+static __used s32 wl_add_ie(struct wl_priv *wl, u8 t, u8 l, u8 *v)
+{
+	struct wl_ie *ie = wl_to_ie(wl);
+	s32 err = 0;
+
+	if (unlikely(ie->offset + l + 2 > WL_TLV_INFO_MAX)) {
+		WL_ERR(("ei crosses buffer boundary\n"));
+		return -ENOSPC;
+	}
+	ie->buf[ie->offset] = t;
+	ie->buf[ie->offset + 1] = l;
+	memcpy(&ie->buf[ie->offset + 2], v, l);
+	ie->offset += l + 2;
+
+	return err;
+}
+
+static s32 wl_mrg_ie(struct wl_priv *wl, u8 *ie_stream, u16 ie_size)
+{
+	struct wl_ie *ie = wl_to_ie(wl);
+	s32 err = 0;
+
+	if (unlikely(ie->offset + ie_size > WL_TLV_INFO_MAX)) {
+		WL_ERR(("ei_stream crosses buffer boundary\n"));
+		return -ENOSPC;
+	}
+	memcpy(&ie->buf[ie->offset], ie_stream, ie_size);
+	ie->offset += ie_size;
+
+	return err;
+}
+
+static s32 wl_cp_ie(struct wl_priv *wl, u8 *dst, u16 dst_size)
+{
+	struct wl_ie *ie = wl_to_ie(wl);
+	s32 err = 0;
+
+	if (unlikely(ie->offset > dst_size)) {
+		WL_ERR(("dst_size is not enough\n"));
+		return -ENOSPC;
+	}
+	memcpy(dst, &ie->buf[0], ie->offset);
+
+	return err;
+}
+
+static u32 wl_get_ielen(struct wl_priv *wl)
+{
+	struct wl_ie *ie = wl_to_ie(wl);
+
+	return ie->offset;
+}
+
+static void wl_link_up(struct wl_priv *wl)
+{
+	wl->link_up = true;
+}
+
+static void wl_link_down(struct wl_priv *wl)
+{
+	struct wl_connect_info *conn_info = wl_to_conn(wl);
+
+	wl->link_up = false;
+	kfree(conn_info->req_ie);
+	conn_info->req_ie = NULL;
+	conn_info->req_ie_len = 0;
+	kfree(conn_info->resp_ie);
+	conn_info->resp_ie = NULL;
+	conn_info->resp_ie_len = 0;
+}
+
+static void wl_lock_eq(struct wl_priv *wl)
+{
+	spin_lock_irq(&wl->eq_lock);
+}
+
+static void wl_unlock_eq(struct wl_priv *wl)
+{
+	spin_unlock_irq(&wl->eq_lock);
+}
+
+static void wl_init_eq_lock(struct wl_priv *wl)
+{
+	spin_lock_init(&wl->eq_lock);
+}
+
+static void wl_delay(u32 ms)
+{
+	if (ms < 1000 / HZ) {
+		cond_resched();
+		mdelay(ms);
+	} else {
+		msleep(ms);
+	}
+}
+
+static void wl_set_drvdata(struct wl_dev *dev, void *data)
+{
+	dev->driver_data = data;
+}
+
+static void *wl_get_drvdata(struct wl_dev *dev)
+{
+	return dev->driver_data;
+}
+
+s32 wl_cfg80211_read_fw(s8 *buf, u32 size)
+{
+	const struct firmware *fw_entry;
+	struct wl_priv *wl;
+
+	wl = WL_PRIV_GET();
+
+	fw_entry = wl->fw->fw_entry;
+
+	if (fw_entry->size < wl->fw->ptr + size)
+		size = fw_entry->size - wl->fw->ptr;
+
+	memcpy(buf, &fw_entry->data[wl->fw->ptr], size);
+	wl->fw->ptr += size;
+	return size;
+}
+
+void wl_cfg80211_release_fw(void)
+{
+	struct wl_priv *wl;
+
+	wl = WL_PRIV_GET();
+	release_firmware(wl->fw->fw_entry);
+	wl->fw->ptr = 0;
+}
+
+void *wl_cfg80211_request_fw(s8 *file_name)
+{
+	struct wl_priv *wl;
+	const struct firmware *fw_entry = NULL;
+	s32 err = 0;
+
+	WL_DBG(("file name : \"%s\"\n", file_name));
+	wl = WL_PRIV_GET();
+
+	if (!test_bit(WL_FW_LOADING_DONE, &wl->fw->status)) {
+		err = request_firmware(&wl->fw->fw_entry, file_name,
+				&wl_cfg80211_get_sdio_func()->dev);
+		if (unlikely(err)) {
+			WL_ERR(("Could not download fw (%d)\n", err));
+			goto req_fw_out;
+		}
+		set_bit(WL_FW_LOADING_DONE, &wl->fw->status);
+		fw_entry = wl->fw->fw_entry;
+		if (fw_entry) {
+			WL_DBG(("fw size (%zd), data (%p)\n", fw_entry->size,
+				fw_entry->data));
+		}
+	} else if (!test_bit(WL_NVRAM_LOADING_DONE, &wl->fw->status)) {
+		err = request_firmware(&wl->fw->fw_entry, file_name,
+				&wl_cfg80211_get_sdio_func()->dev);
+		if (unlikely(err)) {
+			WL_ERR(("Could not download nvram (%d)\n", err));
+			goto req_fw_out;
+		}
+		set_bit(WL_NVRAM_LOADING_DONE, &wl->fw->status);
+		fw_entry = wl->fw->fw_entry;
+		if (fw_entry) {
+			WL_DBG(("nvram size (%zd), data (%p)\n", fw_entry->size,
+				fw_entry->data));
+		}
+	} else {
+		WL_DBG(("Downloading already done. Nothing to do more\n"));
+		err = -EPERM;
+	}
+
+req_fw_out:
+	if (unlikely(err)) {
+		return NULL;
+	}
+	wl->fw->ptr = 0;
+	return (void *)fw_entry->data;
+}
+
+s8 *wl_cfg80211_get_fwname(void)
+{
+	struct wl_priv *wl;
+
+	wl = WL_PRIV_GET();
+	strcpy(wl->fw->fw_name, WL_4329_FW_FILE);
+	return wl->fw->fw_name;
+}
+
+s8 *wl_cfg80211_get_nvramname(void)
+{
+	struct wl_priv *wl;
+
+	wl = WL_PRIV_GET();
+	strcpy(wl->fw->nvram_name, WL_4329_NVRAM_FILE);
+	return wl->fw->nvram_name;
+}
+
+static void wl_set_mpc(struct net_device *ndev, int mpc)
+{
+	s32 err = 0;
+
+	err = wl_dev_intvar_set(ndev, "mpc", mpc);
+	if (unlikely(err)) {
+		WL_ERR(("fail to set mpc\n"));
+		return;
+	}
+	WL_DBG(("MPC : %d\n", mpc));
+}
+
+static int wl_debugfs_add_netdev_params(struct wl_priv *wl)
+{
+	char buf[10+IFNAMSIZ];
+	struct dentry *fd;
+	s32 err = 0;
+
+	sprintf(buf, "netdev:%s", wl_to_ndev(wl)->name);
+	wl->debugfsdir = debugfs_create_dir(buf, wl_to_wiphy(wl)->debugfsdir);
+
+	fd = debugfs_create_u16("beacon_int", S_IRUGO, wl->debugfsdir,
+		(u16 *)&wl->profile->beacon_interval);
+	if (!fd) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	fd = debugfs_create_u8("dtim_period", S_IRUGO, wl->debugfsdir,
+		(u8 *)&wl->profile->dtim_period);
+	if (!fd) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+err_out:
+	return err;
+}
+
+static void wl_debugfs_remove_netdev(struct wl_priv *wl)
+{
+	debugfs_remove_recursive(wl->debugfsdir);
+	wl->debugfsdir = NULL;
+}
diff --git a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
new file mode 100644
index 0000000..770e63f
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
@@ -0,0 +1,394 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wl_cfg80211_h_
+#define _wl_cfg80211_h_
+
+#include <linux/wireless.h>
+#include <linux/wireless.h>
+#include <net/cfg80211.h>
+#include <proto/ethernet.h>
+#include <wlioctl.h>
+
+struct wl_conf;
+struct wl_iface;
+struct wl_priv;
+struct wl_security;
+struct wl_ibss;
+
+#if defined(IL_BIGENDIAN)
+#include <bcmendian.h>
+#define htod32(i) (bcmswap32(i))
+#define htod16(i) (bcmswap16(i))
+#define dtoh32(i) (bcmswap32(i))
+#define dtoh16(i) (bcmswap16(i))
+#define htodchanspec(i) htod16(i)
+#define dtohchanspec(i) dtoh16(i)
+#else
+#define htod32(i) i
+#define htod16(i) i
+#define dtoh32(i) i
+#define dtoh16(i) i
+#define htodchanspec(i) i
+#define dtohchanspec(i) i
+#endif
+
+#define WL_DBG_NONE	0
+#define WL_DBG_DBG 	(1 << 2)
+#define WL_DBG_INFO	(1 << 1)
+#define WL_DBG_ERR	(1 << 0)
+#define WL_DBG_MASK ((WL_DBG_DBG | WL_DBG_INFO | WL_DBG_ERR) << 1)
+
+#define WL_DBG_LEVEL 1		/* 0 invalidates all debug messages.
+				 default is 1 */
+#define	WL_ERR(args)									\
+do {										\
+	if (wl_dbg_level & WL_DBG_ERR) {				\
+		if (net_ratelimit()) {						\
+			printk(KERN_ERR "ERROR @%s : ", __func__);	\
+			printk args;						\
+		} 								\
+	}									\
+} while (0)
+#define	WL_INFO(args)									\
+do {										\
+	if (wl_dbg_level & WL_DBG_INFO) {				\
+		if (net_ratelimit()) {						\
+			printk(KERN_ERR "INFO @%s : ", __func__);	\
+			printk args;						\
+		}								\
+	}									\
+} while (0)
+#if (WL_DBG_LEVEL > 0)
+#define	WL_DBG(args)								\
+do {									\
+	if (wl_dbg_level & WL_DBG_DBG) {			\
+		printk(KERN_ERR "DEBUG @%s :", __func__);	\
+		printk args;							\
+	}									\
+} while (0)
+#else				/* !(WL_DBG_LEVEL > 0) */
+#define	WL_DBG(args)
+#endif				/* (WL_DBG_LEVEL > 0) */
+
+#define WL_SCAN_RETRY_MAX	3	/* used for ibss scan */
+#define WL_NUM_SCAN_MAX		1
+#define WL_NUM_PMKIDS_MAX	MAXPMKID	/* will be used
+						 * for 2.6.33 kernel
+						 * or later
+						 */
+#define WL_SCAN_BUF_MAX 		(1024 * 8)
+#define WL_TLV_INFO_MAX 		1024
+#define WL_BSS_INFO_MAX			2048
+#define WL_ASSOC_INFO_MAX	512	/*
+				 * needs to grab assoc info from dongle to
+				 * report it to cfg80211 through "connect"
+				 * event
+				 */
+#define WL_IOCTL_LEN_MAX	1024
+#define WL_EXTRA_BUF_MAX	2048
+#define WL_ISCAN_BUF_MAX	2048	/*
+				 * the buf lengh can be WLC_IOCTL_MAXLEN (8K)
+				 * to reduce iteration
+				 */
+#define WL_ISCAN_TIMER_INTERVAL_MS	3000
+#define WL_SCAN_ERSULTS_LAST 	(WL_SCAN_RESULTS_NO_MEM+1)
+#define WL_AP_MAX	256	/* virtually unlimitted as long
+				 * as kernel memory allows
+				 */
+#define WL_FILE_NAME_MAX		256
+
+/* dongle status */
+enum wl_status {
+	WL_STATUS_READY,
+	WL_STATUS_SCANNING,
+	WL_STATUS_SCAN_ABORTING,
+	WL_STATUS_CONNECTING,
+	WL_STATUS_CONNECTED
+};
+
+/* wi-fi mode */
+enum wl_mode {
+	WL_MODE_BSS,
+	WL_MODE_IBSS,
+	WL_MODE_AP
+};
+
+/* dongle profile list */
+enum wl_prof_list {
+	WL_PROF_MODE,
+	WL_PROF_SSID,
+	WL_PROF_SEC,
+	WL_PROF_IBSS,
+	WL_PROF_BAND,
+	WL_PROF_BSSID,
+	WL_PROF_ACT,
+	WL_PROF_BEACONINT,
+	WL_PROF_DTIMPERIOD
+};
+
+/* dongle iscan state */
+enum wl_iscan_state {
+	WL_ISCAN_STATE_IDLE,
+	WL_ISCAN_STATE_SCANING
+};
+
+/* fw downloading status */
+enum wl_fw_status {
+	WL_FW_LOADING_DONE,
+	WL_NVRAM_LOADING_DONE
+};
+
+/* beacon / probe_response */
+struct beacon_proberesp {
+	__le64 timestamp;
+	__le16 beacon_int;
+	__le16 capab_info;
+	u8 variable[0];
+} __attribute__ ((packed));
+
+/* dongle configuration */
+struct wl_conf {
+	u32 mode;		/* adhoc , infrastructure or ap */
+	u32 frag_threshold;
+	u32 rts_threshold;
+	u32 retry_short;
+	u32 retry_long;
+	s32 tx_power;
+	struct ieee80211_channel channel;
+};
+
+/* cfg80211 main event loop */
+struct wl_event_loop {
+	s32(*handler[WLC_E_LAST]) (struct wl_priv *wl,
+				     struct net_device *ndev,
+				     const wl_event_msg_t *e, void *data);
+};
+
+/* representing interface of cfg80211 plane */
+struct wl_iface {
+	struct wl_priv *wl;
+};
+
+struct wl_dev {
+	void *driver_data;	/* to store cfg80211 object information */
+};
+
+/* bss inform structure for cfg80211 interface */
+struct wl_cfg80211_bss_info {
+	u16 band;
+	u16 channel;
+	s16 rssi;
+	u16 frame_len;
+	u8 frame_buf[1];
+};
+
+/* basic structure of scan request */
+struct wl_scan_req {
+	struct wlc_ssid ssid;
+};
+
+/* basic structure of information element */
+struct wl_ie {
+	u16 offset;
+	u8 buf[WL_TLV_INFO_MAX];
+};
+
+/* event queue for cfg80211 main event */
+struct wl_event_q {
+	struct list_head eq_list;
+	u32 etype;
+	wl_event_msg_t emsg;
+	s8 edata[1];
+};
+
+/* security information with currently associated ap */
+struct wl_security {
+	u32 wpa_versions;
+	u32 auth_type;
+	u32 cipher_pairwise;
+	u32 cipher_group;
+	u32 wpa_auth;
+};
+
+/* ibss information for currently joined ibss network */
+struct wl_ibss {
+	u8 beacon_interval;	/* in millisecond */
+	u8 atim;		/* in millisecond */
+	s8 join_only;
+	u8 band;
+	u8 channel;
+};
+
+/* dongle profile */
+struct wl_profile {
+	u32 mode;
+	struct wlc_ssid ssid;
+	u8 bssid[ETHER_ADDR_LEN];
+	u16 beacon_interval;
+	u8 dtim_period;
+	struct wl_security sec;
+	struct wl_ibss ibss;
+	s32 band;
+	bool active;
+};
+
+/* dongle iscan event loop */
+struct wl_iscan_eloop {
+	s32(*handler[WL_SCAN_ERSULTS_LAST]) (struct wl_priv *wl);
+};
+
+/* dongle iscan controller */
+struct wl_iscan_ctrl {
+	struct net_device *dev;
+	struct timer_list timer;
+	u32 timer_ms;
+	u32 timer_on;
+	s32 state;
+	struct task_struct *tsk;
+	struct semaphore sync;
+	struct wl_iscan_eloop el;
+	void *data;
+	s8 ioctl_buf[WLC_IOCTL_SMLEN];
+	s8 scan_buf[WL_ISCAN_BUF_MAX];
+};
+
+/* association inform */
+struct wl_connect_info {
+	u8 *req_ie;
+	s32 req_ie_len;
+	u8 *resp_ie;
+	s32 resp_ie_len;
+};
+
+/* firmware /nvram downloading controller */
+struct wl_fw_ctrl {
+	const struct firmware *fw_entry;
+	unsigned long status;
+	u32 ptr;
+	s8 fw_name[WL_FILE_NAME_MAX];
+	s8 nvram_name[WL_FILE_NAME_MAX];
+};
+
+/* assoc ie length */
+struct wl_assoc_ielen {
+	u32 req_len;
+	u32 resp_len;
+};
+
+/* wpa2 pmk list */
+struct wl_pmk_list {
+	pmkid_list_t pmkids;
+	pmkid_t foo[MAXPMKID - 1];
+};
+
+/* dongle private data of cfg80211 interface */
+struct wl_priv {
+	struct wireless_dev *wdev;	/* representing wl cfg80211 device */
+	struct wl_conf *conf;	/* dongle configuration */
+	struct cfg80211_scan_request *scan_request;	/* scan request
+							 object */
+	struct wl_event_loop el;	/* main event loop */
+	struct list_head eq_list;	/* used for event queue */
+	spinlock_t eq_lock;	/* for event queue synchronization */
+	struct mutex usr_sync;	/* maily for dongle up/down synchronization */
+	struct wl_scan_results *bss_list;	/* bss_list holding scanned
+						 ap information */
+	struct wl_scan_results *scan_results;
+	struct wl_scan_req *scan_req_int;	/* scan request object for
+						 internal purpose */
+	struct wl_cfg80211_bss_info *bss_info;	/* bss information for
+						 cfg80211 layer */
+	struct wl_ie ie;	/* information element object for
+					 internal purpose */
+	struct ether_addr bssid;	/* bssid of currently engaged network */
+	struct semaphore event_sync;	/* for synchronization of main event
+					 thread */
+	struct wl_profile *profile;	/* holding dongle profile */
+	struct wl_iscan_ctrl *iscan;	/* iscan controller */
+	struct wl_connect_info conn_info;	/* association information
+						 container */
+	struct wl_fw_ctrl *fw;	/* control firwmare / nvram paramter
+				 downloading */
+	struct wl_pmk_list *pmk_list;	/* wpa2 pmk list */
+	struct task_struct *event_tsk;	/* task of main event handler thread */
+	unsigned long status;		/* current dongle status */
+	void *pub;
+	u32 channel;		/* current channel */
+	bool iscan_on;		/* iscan on/off switch */
+	bool iscan_kickstart;	/* indicate iscan already started */
+	bool active_scan;	/* current scan mode */
+	bool ibss_starter;	/* indicates this sta is ibss starter */
+	bool link_up;		/* link/connection up flag */
+	bool pwr_save;		/* indicate whether dongle to support
+					 power save mode */
+	bool dongle_up;		/* indicate whether dongle up or not */
+	bool roam_on;		/* on/off switch for dongle self-roaming */
+	bool scan_tried;	/* indicates if first scan attempted */
+	u8 *ioctl_buf;	/* ioctl buffer */
+	u8 *extra_buf;	/* maily to grab assoc information */
+	struct dentry *debugfsdir;
+	u8 ci[0] __attribute__ ((__aligned__(NETDEV_ALIGN)));
+};
+
+#define wl_to_dev(w) (wiphy_dev(wl->wdev->wiphy))
+#define wl_to_wiphy(w) (w->wdev->wiphy)
+#define wiphy_to_wl(w) ((struct wl_priv *)(wiphy_priv(w)))
+#define wl_to_wdev(w) (w->wdev)
+#define wdev_to_wl(w) ((struct wl_priv *)(wdev_priv(w)))
+#define wl_to_ndev(w) (w->wdev->netdev)
+#define ndev_to_wl(n) (wdev_to_wl(n->ieee80211_ptr))
+#define ci_to_wl(c) (ci->wl)
+#define wl_to_ci(w) (&w->ci)
+#define wl_to_sr(w) (w->scan_req_int)
+#define wl_to_ie(w) (&w->ie)
+#define iscan_to_wl(i) ((struct wl_priv *)(i->data))
+#define wl_to_iscan(w) (w->iscan)
+#define wl_to_conn(w) (&w->conn_info)
+
+static inline struct wl_bss_info *next_bss(struct wl_scan_results *list,
+					   struct wl_bss_info *bss)
+{
+	return bss = bss ?
+		(struct wl_bss_info *)((unsigned long)bss +
+				       dtoh32(bss->length)) : list->bss_info;
+}
+
+#define for_each_bss(list, bss, __i)	\
+	for (__i = 0; __i < list->count && __i < WL_AP_MAX; __i++, bss = next_bss(list, bss))
+
+extern s32 wl_cfg80211_attach(struct net_device *ndev, void *data);
+extern void wl_cfg80211_detach(void);
+/* event handler from dongle */
+extern void wl_cfg80211_event(struct net_device *ndev, const wl_event_msg_t *e,
+			      void *data);
+extern void wl_cfg80211_sdio_func(void *func);	/* set sdio function info */
+extern struct sdio_func *wl_cfg80211_get_sdio_func(void);	/* set sdio function info */
+extern s32 wl_cfg80211_up(void);	/* dongle up */
+extern s32 wl_cfg80211_down(void);	/* dongle down */
+extern void wl_cfg80211_dbg_level(u32 level);	/* set dongle
+							 debugging level */
+extern void *wl_cfg80211_request_fw(s8 *file_name);	/* request fw /nvram
+							 downloading */
+extern s32 wl_cfg80211_read_fw(s8 *buf, u32 size);	/* read fw
+								 image */
+extern void wl_cfg80211_release_fw(void);	/* release fw */
+extern s8 *wl_cfg80211_get_fwname(void);	/* get firmware name for
+						 the dongle */
+extern s8 *wl_cfg80211_get_nvramname(void);	/* get nvram name for
+						 the dongle */
+
+#endif				/* _wl_cfg80211_h_ */
diff --git a/drivers/staging/brcm80211/brcmfmac/wl_iw.c b/drivers/staging/brcm80211/brcmfmac/wl_iw.c
new file mode 100644
index 0000000..979a494
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/wl_iw.c
@@ -0,0 +1,3767 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/kthread.h>
+#include <bcmdefs.h>
+#include <linuxver.h>
+#include <osl.h>
+#include <wlioctl.h>
+
+#include <bcmutils.h>
+#include <bcmendian.h>
+#include <proto/ethernet.h>
+
+#include <linux/if_arp.h>
+#include <asm/uaccess.h>
+
+#include <dngl_stats.h>
+#include <dhd.h>
+#include <dhdioctl.h>
+
+typedef void wlc_info_t;
+typedef void wl_info_t;
+typedef const struct si_pub si_t;
+#include <wlioctl.h>
+
+#include <proto/ethernet.h>
+#include <dngl_stats.h>
+#include <dhd.h>
+#define WL_ERROR(x) printf x
+#define WL_TRACE(x)
+#define WL_ASSOC(x)
+#define WL_INFORM(x)
+#define WL_WSEC(x)
+#define WL_SCAN(x)
+
+#include <wl_iw.h>
+
+#define IW_WSEC_ENABLED(wsec)	((wsec) & (WEP_ENABLED |	\
+					 TKIP_ENABLED | AES_ENABLED))
+
+#include <linux/rtnetlink.h>
+
+#define WL_IW_USE_ISCAN  1
+#define ENABLE_ACTIVE_PASSIVE_SCAN_SUPPRESS  1
+
+bool g_set_essid_before_scan = true;
+
+#define WL_IW_IOCTL_CALL(func_call) \
+	do {				\
+		func_call;		\
+	} while (0)
+
+static int g_onoff = G_WLAN_SET_ON;
+wl_iw_extra_params_t g_wl_iw_params;
+
+extern bool wl_iw_conn_status_str(u32 event_type, u32 status,
+				  u32 reason, char *stringBuf, uint buflen);
+
+uint wl_msg_level = WL_ERROR_VAL;
+
+#define MAX_WLIW_IOCTL_LEN 1024
+
+#if defined(IL_BIGENDIAN)
+#include <bcmendian.h>
+#define htod32(i) (bcmswap32(i))
+#define htod16(i) (bcmswap16(i))
+#define dtoh32(i) (bcmswap32(i))
+#define dtoh16(i) (bcmswap16(i))
+#define htodchanspec(i) htod16(i)
+#define dtohchanspec(i) dtoh16(i)
+#else
+#define htod32(i) i
+#define htod16(i) i
+#define dtoh32(i) i
+#define dtoh16(i) i
+#define htodchanspec(i) i
+#define dtohchanspec(i) i
+#endif
+
+#ifdef CONFIG_WIRELESS_EXT
+
+extern struct iw_statistics *dhd_get_wireless_stats(struct net_device *dev);
+extern int dhd_wait_pend8021x(struct net_device *dev);
+#endif
+
+#if WIRELESS_EXT < 19
+#define IW_IOCTL_IDX(cmd)	((cmd) - SIOCIWFIRST)
+#define IW_EVENT_IDX(cmd)	((cmd) - IWEVFIRST)
+#endif
+
+static void *g_scan;
+static volatile uint g_scan_specified_ssid;
+static wlc_ssid_t g_specific_ssid;
+
+static wlc_ssid_t g_ssid;
+
+#if defined(WL_IW_USE_ISCAN)
+#define ISCAN_STATE_IDLE   0
+#define ISCAN_STATE_SCANING 1
+
+#define WLC_IW_ISCAN_MAXLEN   2048
+typedef struct iscan_buf {
+	struct iscan_buf *next;
+	char iscan_buf[WLC_IW_ISCAN_MAXLEN];
+} iscan_buf_t;
+
+typedef struct iscan_info {
+	struct net_device *dev;
+	struct timer_list timer;
+	u32 timer_ms;
+	u32 timer_on;
+	int iscan_state;
+	iscan_buf_t *list_hdr;
+	iscan_buf_t *list_cur;
+
+	struct task_struct *sysioc_tsk;
+	struct semaphore sysioc_sem;
+
+#if defined CSCAN
+	char ioctlbuf[WLC_IOCTL_MEDLEN];
+#else
+	char ioctlbuf[WLC_IOCTL_SMLEN];
+#endif
+	wl_iscan_params_t *iscan_ex_params_p;
+	int iscan_ex_param_size;
+} iscan_info_t;
+iscan_info_t *g_iscan;
+static void wl_iw_timerfunc(unsigned long data);
+static void wl_iw_set_event_mask(struct net_device *dev);
+static int wl_iw_iscan(iscan_info_t *iscan, wlc_ssid_t *ssid, u16 action);
+#endif				/* defined(WL_IW_USE_ISCAN) */
+
+static int
+wl_iw_set_scan(struct net_device *dev,
+	       struct iw_request_info *info,
+	       union iwreq_data *wrqu, char *extra);
+
+static int
+wl_iw_get_scan(struct net_device *dev,
+	       struct iw_request_info *info,
+	       struct iw_point *dwrq, char *extra);
+
+static uint
+wl_iw_get_scan_prep(wl_scan_results_t *list,
+		    struct iw_request_info *info, char *extra, short max_size);
+
+static void swap_key_from_BE(wl_wsec_key_t *key)
+{
+	key->index = htod32(key->index);
+	key->len = htod32(key->len);
+	key->algo = htod32(key->algo);
+	key->flags = htod32(key->flags);
+	key->rxiv.hi = htod32(key->rxiv.hi);
+	key->rxiv.lo = htod16(key->rxiv.lo);
+	key->iv_initialized = htod32(key->iv_initialized);
+}
+
+static void swap_key_to_BE(wl_wsec_key_t *key)
+{
+	key->index = dtoh32(key->index);
+	key->len = dtoh32(key->len);
+	key->algo = dtoh32(key->algo);
+	key->flags = dtoh32(key->flags);
+	key->rxiv.hi = dtoh32(key->rxiv.hi);
+	key->rxiv.lo = dtoh16(key->rxiv.lo);
+	key->iv_initialized = dtoh32(key->iv_initialized);
+}
+
+static int dev_wlc_ioctl(struct net_device *dev, int cmd, void *arg, int len)
+{
+	struct ifreq ifr;
+	wl_ioctl_t ioc;
+	mm_segment_t fs;
+	int ret = -EINVAL;
+
+	if (!dev) {
+		WL_ERROR(("%s: dev is null\n", __func__));
+		return ret;
+	}
+
+	WL_INFORM(("\n%s, PID:%x: send Local IOCTL -> dhd: cmd:0x%x, buf:%p, "
+		"len:%d ,\n", __func__, current->pid, cmd, arg, len));
+
+	if (g_onoff == G_WLAN_SET_ON) {
+		memset(&ioc, 0, sizeof(ioc));
+		ioc.cmd = cmd;
+		ioc.buf = arg;
+		ioc.len = len;
+
+		strcpy(ifr.ifr_name, dev->name);
+		ifr.ifr_data = (caddr_t)&ioc;
+
+		ret = dev_open(dev);
+		if (ret) {
+			WL_ERROR(("%s: Error dev_open: %d\n", __func__, ret));
+			return ret;
+		}
+
+		fs = get_fs();
+		set_fs(get_ds());
+		ret = dev->netdev_ops->ndo_do_ioctl(dev, &ifr, SIOCDEVPRIVATE);
+		set_fs(fs);
+	} else {
+		WL_TRACE(("%s: call after driver stop : ignored\n", __func__));
+	}
+	return ret;
+}
+
+static int dev_wlc_intvar_set(struct net_device *dev, char *name, int val)
+{
+	char buf[WLC_IOCTL_SMLEN];
+	uint len;
+
+	val = htod32(val);
+	len = bcm_mkiovar(name, (char *)(&val), sizeof(val), buf, sizeof(buf));
+	ASSERT(len);
+
+	return dev_wlc_ioctl(dev, WLC_SET_VAR, buf, len);
+}
+
+#if defined(WL_IW_USE_ISCAN)
+static int
+dev_iw_iovar_setbuf(struct net_device *dev,
+		    char *iovar,
+		    void *param, int paramlen, void *bufptr, int buflen)
+{
+	int iolen;
+
+	iolen = bcm_mkiovar(iovar, param, paramlen, bufptr, buflen);
+	ASSERT(iolen);
+
+	if (iolen == 0)
+		return 0;
+
+	return dev_wlc_ioctl(dev, WLC_SET_VAR, bufptr, iolen);
+}
+
+static int
+dev_iw_iovar_getbuf(struct net_device *dev,
+		    char *iovar,
+		    void *param, int paramlen, void *bufptr, int buflen)
+{
+	int iolen;
+
+	iolen = bcm_mkiovar(iovar, param, paramlen, bufptr, buflen);
+	ASSERT(iolen);
+
+	return dev_wlc_ioctl(dev, WLC_GET_VAR, bufptr, buflen);
+}
+#endif				/* defined(WL_IW_USE_ISCAN) */
+
+#if WIRELESS_EXT > 17
+static int
+dev_wlc_bufvar_set(struct net_device *dev, char *name, char *buf, int len)
+{
+	static char ioctlbuf[MAX_WLIW_IOCTL_LEN];
+	uint buflen;
+
+	buflen = bcm_mkiovar(name, buf, len, ioctlbuf, sizeof(ioctlbuf));
+	ASSERT(buflen);
+
+	return dev_wlc_ioctl(dev, WLC_SET_VAR, ioctlbuf, buflen);
+}
+#endif				/* WIRELESS_EXT > 17 */
+
+static int
+dev_wlc_bufvar_get(struct net_device *dev, char *name, char *buf, int buflen)
+{
+	static char ioctlbuf[MAX_WLIW_IOCTL_LEN];
+	int error;
+	uint len;
+
+	len = bcm_mkiovar(name, NULL, 0, ioctlbuf, sizeof(ioctlbuf));
+	ASSERT(len);
+	error =
+	    dev_wlc_ioctl(dev, WLC_GET_VAR, (void *)ioctlbuf,
+			  MAX_WLIW_IOCTL_LEN);
+	if (!error)
+		bcopy(ioctlbuf, buf, buflen);
+
+	return error;
+}
+
+static int dev_wlc_intvar_get(struct net_device *dev, char *name, int *retval)
+{
+	union {
+		char buf[WLC_IOCTL_SMLEN];
+		int val;
+	} var;
+	int error;
+
+	uint len;
+	uint data_null;
+
+	len =
+	    bcm_mkiovar(name, (char *)(&data_null), 0, (char *)(&var),
+			sizeof(var.buf));
+	ASSERT(len);
+	error = dev_wlc_ioctl(dev, WLC_GET_VAR, (void *)&var, len);
+
+	*retval = dtoh32(var.val);
+
+	return error;
+}
+
+#if WIRELESS_EXT < 13
+struct iw_request_info {
+	__u16 cmd;
+	__u16 flags;
+};
+
+typedef int (*iw_handler) (struct net_device *dev,
+			   struct iw_request_info *info,
+			   void *wrqu, char *extra);
+#endif
+
+static int
+wl_iw_config_commit(struct net_device *dev,
+		    struct iw_request_info *info, void *zwrq, char *extra)
+{
+	wlc_ssid_t ssid;
+	int error;
+	struct sockaddr bssid;
+
+	WL_TRACE(("%s: SIOCSIWCOMMIT\n", dev->name));
+
+	error = dev_wlc_ioctl(dev, WLC_GET_SSID, &ssid, sizeof(ssid));
+	if (error)
+		return error;
+
+	ssid.SSID_len = dtoh32(ssid.SSID_len);
+
+	if (!ssid.SSID_len)
+		return 0;
+
+	bzero(&bssid, sizeof(struct sockaddr));
+	error = dev_wlc_ioctl(dev, WLC_REASSOC, &bssid, ETHER_ADDR_LEN);
+	if (error) {
+		WL_ERROR(("%s: WLC_REASSOC to %s failed \n", __func__,
+			  ssid.SSID));
+		return error;
+	}
+
+	return 0;
+}
+
+static int
+wl_iw_get_name(struct net_device *dev,
+	       struct iw_request_info *info, char *cwrq, char *extra)
+{
+	WL_TRACE(("%s: SIOCGIWNAME\n", dev->name));
+
+	strcpy(cwrq, "IEEE 802.11-DS");
+
+	return 0;
+}
+
+static int
+wl_iw_set_freq(struct net_device *dev,
+	       struct iw_request_info *info, struct iw_freq *fwrq, char *extra)
+{
+	int error, chan;
+	uint sf = 0;
+
+	WL_TRACE(("\n %s %s: SIOCSIWFREQ\n", __func__, dev->name));
+
+	if (fwrq->e == 0 && fwrq->m < MAXCHANNEL) {
+		chan = fwrq->m;
+	} else {
+		if (fwrq->e >= 6) {
+			fwrq->e -= 6;
+			while (fwrq->e--)
+				fwrq->m *= 10;
+		} else if (fwrq->e < 6) {
+			while (fwrq->e++ < 6)
+				fwrq->m /= 10;
+		}
+		if (fwrq->m > 4000 && fwrq->m < 5000)
+			sf = WF_CHAN_FACTOR_4_G;
+
+		chan = wf_mhz2channel(fwrq->m, sf);
+	}
+	chan = htod32(chan);
+
+	error = dev_wlc_ioctl(dev, WLC_SET_CHANNEL, &chan, sizeof(chan));
+	if (error)
+		return error;
+
+	g_wl_iw_params.target_channel = chan;
+	return -EINPROGRESS;
+}
+
+static int
+wl_iw_get_freq(struct net_device *dev,
+	       struct iw_request_info *info, struct iw_freq *fwrq, char *extra)
+{
+	channel_info_t ci;
+	int error;
+
+	WL_TRACE(("%s: SIOCGIWFREQ\n", dev->name));
+
+	error = dev_wlc_ioctl(dev, WLC_GET_CHANNEL, &ci, sizeof(ci));
+	if (error)
+		return error;
+
+	fwrq->m = dtoh32(ci.hw_channel);
+	fwrq->e = dtoh32(0);
+	return 0;
+}
+
+static int
+wl_iw_set_mode(struct net_device *dev,
+	       struct iw_request_info *info, __u32 *uwrq, char *extra)
+{
+	int infra = 0, ap = 0, error = 0;
+
+	WL_TRACE(("%s: SIOCSIWMODE\n", dev->name));
+
+	switch (*uwrq) {
+	case IW_MODE_MASTER:
+		infra = ap = 1;
+		break;
+	case IW_MODE_ADHOC:
+	case IW_MODE_AUTO:
+		break;
+	case IW_MODE_INFRA:
+		infra = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+	infra = htod32(infra);
+	ap = htod32(ap);
+
+	error = dev_wlc_ioctl(dev, WLC_SET_INFRA, &infra, sizeof(infra));
+	if (error)
+		return error;
+
+	error = dev_wlc_ioctl(dev, WLC_SET_AP, &ap, sizeof(ap));
+	if (error)
+		return error;
+
+	return -EINPROGRESS;
+}
+
+static int
+wl_iw_get_mode(struct net_device *dev,
+	       struct iw_request_info *info, __u32 *uwrq, char *extra)
+{
+	int error, infra = 0, ap = 0;
+
+	WL_TRACE(("%s: SIOCGIWMODE\n", dev->name));
+
+	error = dev_wlc_ioctl(dev, WLC_GET_INFRA, &infra, sizeof(infra));
+	if (error)
+		return error;
+
+	error = dev_wlc_ioctl(dev, WLC_GET_AP, &ap, sizeof(ap));
+	if (error)
+		return error;
+
+	infra = dtoh32(infra);
+	ap = dtoh32(ap);
+	*uwrq = infra ? ap ? IW_MODE_MASTER : IW_MODE_INFRA : IW_MODE_ADHOC;
+
+	return 0;
+}
+
+static int
+wl_iw_get_range(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *dwrq, char *extra)
+{
+	struct iw_range *range = (struct iw_range *)extra;
+	wl_u32_list_t *list;
+	wl_rateset_t rateset;
+	s8 *channels;
+	int error, i, k;
+	uint sf, ch;
+
+	int phytype;
+	int bw_cap = 0, sgi_tx = 0, nmode = 0;
+	channel_info_t ci;
+	u8 nrate_list2copy = 0;
+	u16 nrate_list[4][8] = { {13, 26, 39, 52, 78, 104, 117, 130},
+	{14, 29, 43, 58, 87, 116, 130, 144},
+	{27, 54, 81, 108, 162, 216, 243, 270},
+	{30, 60, 90, 120, 180, 240, 270, 300}
+	};
+
+	WL_TRACE(("%s: SIOCGIWRANGE\n", dev->name));
+
+	if (!extra)
+		return -EINVAL;
+
+	channels = kmalloc((MAXCHANNEL + 1) * 4, GFP_KERNEL);
+	if (!channels) {
+		WL_ERROR(("Could not alloc channels\n"));
+		return -ENOMEM;
+	}
+	list = (wl_u32_list_t *) channels;
+
+	dwrq->length = sizeof(struct iw_range);
+	memset(range, 0, sizeof(range));
+
+	range->min_nwid = range->max_nwid = 0;
+
+	list->count = htod32(MAXCHANNEL);
+	error = dev_wlc_ioctl(dev, WLC_GET_VALID_CHANNELS, channels,
+				(MAXCHANNEL + 1) * 4);
+	if (error) {
+		kfree(channels);
+		return error;
+	}
+	for (i = 0; i < dtoh32(list->count) && i < IW_MAX_FREQUENCIES; i++) {
+		range->freq[i].i = dtoh32(list->element[i]);
+
+		ch = dtoh32(list->element[i]);
+		if (ch <= CH_MAX_2G_CHANNEL)
+			sf = WF_CHAN_FACTOR_2_4_G;
+		else
+			sf = WF_CHAN_FACTOR_5_G;
+
+		range->freq[i].m = wf_channel2mhz(ch, sf);
+		range->freq[i].e = 6;
+	}
+	range->num_frequency = range->num_channels = i;
+
+	range->max_qual.qual = 5;
+	range->max_qual.level = 0x100 - 200;
+	range->max_qual.noise = 0x100 - 200;
+	range->sensitivity = 65535;
+
+#if WIRELESS_EXT > 11
+	range->avg_qual.qual = 3;
+	range->avg_qual.level = 0x100 + WL_IW_RSSI_GOOD;
+	range->avg_qual.noise = 0x100 - 75;
+#endif
+
+	error = dev_wlc_ioctl(dev, WLC_GET_CURR_RATESET, &rateset,
+				sizeof(rateset));
+	if (error) {
+		kfree(channels);
+		return error;
+	}
+	rateset.count = dtoh32(rateset.count);
+	range->num_bitrates = rateset.count;
+	for (i = 0; i < rateset.count && i < IW_MAX_BITRATES; i++)
+		range->bitrate[i] = (rateset.rates[i] & 0x7f) * 500000;
+	dev_wlc_intvar_get(dev, "nmode", &nmode);
+	dev_wlc_ioctl(dev, WLC_GET_PHYTYPE, &phytype, sizeof(phytype));
+
+	if (nmode == 1 && phytype == WLC_PHY_TYPE_SSN) {
+		dev_wlc_intvar_get(dev, "mimo_bw_cap", &bw_cap);
+		dev_wlc_intvar_get(dev, "sgi_tx", &sgi_tx);
+		dev_wlc_ioctl(dev, WLC_GET_CHANNEL, &ci,
+			      sizeof(channel_info_t));
+		ci.hw_channel = dtoh32(ci.hw_channel);
+
+		if (bw_cap == 0 || (bw_cap == 2 && ci.hw_channel <= 14)) {
+			if (sgi_tx == 0)
+				nrate_list2copy = 0;
+			else
+				nrate_list2copy = 1;
+		}
+		if (bw_cap == 1 || (bw_cap == 2 && ci.hw_channel >= 36)) {
+			if (sgi_tx == 0)
+				nrate_list2copy = 2;
+			else
+				nrate_list2copy = 3;
+		}
+		range->num_bitrates += 8;
+		for (k = 0; i < range->num_bitrates; k++, i++) {
+			range->bitrate[i] =
+			    (nrate_list[nrate_list2copy][k]) * 500000;
+		}
+	}
+
+	error = dev_wlc_ioctl(dev, WLC_GET_PHYTYPE, &i, sizeof(i));
+	if (error) {
+		kfree(channels);
+		return error;
+	}
+	i = dtoh32(i);
+	if (i == WLC_PHY_TYPE_A)
+		range->throughput = 24000000;
+	else
+		range->throughput = 1500000;
+
+	range->min_rts = 0;
+	range->max_rts = 2347;
+	range->min_frag = 256;
+	range->max_frag = 2346;
+
+	range->max_encoding_tokens = DOT11_MAX_DEFAULT_KEYS;
+	range->num_encoding_sizes = 4;
+	range->encoding_size[0] = WEP1_KEY_SIZE;
+	range->encoding_size[1] = WEP128_KEY_SIZE;
+#if WIRELESS_EXT > 17
+	range->encoding_size[2] = TKIP_KEY_SIZE;
+#else
+	range->encoding_size[2] = 0;
+#endif
+	range->encoding_size[3] = AES_KEY_SIZE;
+
+	range->min_pmp = 0;
+	range->max_pmp = 0;
+	range->min_pmt = 0;
+	range->max_pmt = 0;
+	range->pmp_flags = 0;
+	range->pm_capa = 0;
+
+	range->num_txpower = 2;
+	range->txpower[0] = 1;
+	range->txpower[1] = 255;
+	range->txpower_capa = IW_TXPOW_MWATT;
+
+#if WIRELESS_EXT > 10
+	range->we_version_compiled = WIRELESS_EXT;
+	range->we_version_source = 19;
+
+	range->retry_capa = IW_RETRY_LIMIT;
+	range->retry_flags = IW_RETRY_LIMIT;
+	range->r_time_flags = 0;
+	range->min_retry = 1;
+	range->max_retry = 255;
+	range->min_r_time = 0;
+	range->max_r_time = 0;
+#endif
+
+#if WIRELESS_EXT > 17
+	range->enc_capa = IW_ENC_CAPA_WPA;
+	range->enc_capa |= IW_ENC_CAPA_CIPHER_TKIP;
+	range->enc_capa |= IW_ENC_CAPA_CIPHER_CCMP;
+	range->enc_capa |= IW_ENC_CAPA_WPA2;
+
+	IW_EVENT_CAPA_SET_KERNEL(range->event_capa);
+	IW_EVENT_CAPA_SET(range->event_capa, SIOCGIWAP);
+	IW_EVENT_CAPA_SET(range->event_capa, SIOCGIWSCAN);
+	IW_EVENT_CAPA_SET(range->event_capa, IWEVTXDROP);
+	IW_EVENT_CAPA_SET(range->event_capa, IWEVMICHAELMICFAILURE);
+	IW_EVENT_CAPA_SET(range->event_capa, IWEVPMKIDCAND);
+#endif				/* WIRELESS_EXT > 17 */
+
+	kfree(channels);
+
+	return 0;
+}
+
+static int rssi_to_qual(int rssi)
+{
+	if (rssi <= WL_IW_RSSI_NO_SIGNAL)
+		return 0;
+	else if (rssi <= WL_IW_RSSI_VERY_LOW)
+		return 1;
+	else if (rssi <= WL_IW_RSSI_LOW)
+		return 2;
+	else if (rssi <= WL_IW_RSSI_GOOD)
+		return 3;
+	else if (rssi <= WL_IW_RSSI_VERY_GOOD)
+		return 4;
+	else
+		return 5;
+}
+
+static int
+wl_iw_set_spy(struct net_device *dev,
+	      struct iw_request_info *info, struct iw_point *dwrq, char *extra)
+{
+	wl_iw_t *iw = *(wl_iw_t **) netdev_priv(dev);
+	struct sockaddr *addr = (struct sockaddr *)extra;
+	int i;
+
+	WL_TRACE(("%s: SIOCSIWSPY\n", dev->name));
+
+	if (!extra)
+		return -EINVAL;
+
+	iw->spy_num = min_t(int, ARRAY_SIZE(iw->spy_addr), dwrq->length);
+	for (i = 0; i < iw->spy_num; i++)
+		memcpy(&iw->spy_addr[i], addr[i].sa_data, ETHER_ADDR_LEN);
+	memset(iw->spy_qual, 0, sizeof(iw->spy_qual));
+
+	return 0;
+}
+
+static int
+wl_iw_get_spy(struct net_device *dev,
+	      struct iw_request_info *info, struct iw_point *dwrq, char *extra)
+{
+	wl_iw_t *iw = *(wl_iw_t **) netdev_priv(dev);
+	struct sockaddr *addr = (struct sockaddr *)extra;
+	struct iw_quality *qual = (struct iw_quality *)&addr[iw->spy_num];
+	int i;
+
+	WL_TRACE(("%s: SIOCGIWSPY\n", dev->name));
+
+	if (!extra)
+		return -EINVAL;
+
+	dwrq->length = iw->spy_num;
+	for (i = 0; i < iw->spy_num; i++) {
+		memcpy(addr[i].sa_data, &iw->spy_addr[i], ETHER_ADDR_LEN);
+		addr[i].sa_family = AF_UNIX;
+		memcpy(&qual[i], &iw->spy_qual[i], sizeof(struct iw_quality));
+		iw->spy_qual[i].updated = 0;
+	}
+
+	return 0;
+}
+
+static int
+wl_iw_ch_to_chanspec(int ch, wl_join_params_t *join_params,
+		     int *join_params_size)
+{
+	chanspec_t chanspec = 0;
+
+	if (ch != 0) {
+		join_params->params.chanspec_num = 1;
+		join_params->params.chanspec_list[0] = ch;
+
+		if (join_params->params.chanspec_list[0])
+			chanspec |= WL_CHANSPEC_BAND_2G;
+		else
+			chanspec |= WL_CHANSPEC_BAND_5G;
+
+		chanspec |= WL_CHANSPEC_BW_20;
+		chanspec |= WL_CHANSPEC_CTL_SB_NONE;
+
+		*join_params_size += WL_ASSOC_PARAMS_FIXED_SIZE +
+		    join_params->params.chanspec_num * sizeof(chanspec_t);
+
+		join_params->params.chanspec_list[0] &= WL_CHANSPEC_CHAN_MASK;
+		join_params->params.chanspec_list[0] |= chanspec;
+		join_params->params.chanspec_list[0] =
+		    htodchanspec(join_params->params.chanspec_list[0]);
+
+		join_params->params.chanspec_num =
+		    htod32(join_params->params.chanspec_num);
+
+		WL_TRACE(("%s  join_params->params.chanspec_list[0]= %X\n",
+			  __func__, join_params->params.chanspec_list[0]));
+	}
+	return 1;
+}
+
+static int
+wl_iw_set_wap(struct net_device *dev,
+	      struct iw_request_info *info, struct sockaddr *awrq, char *extra)
+{
+	int error = -EINVAL;
+	wl_join_params_t join_params;
+	int join_params_size;
+
+	WL_TRACE(("%s: SIOCSIWAP\n", dev->name));
+
+	if (awrq->sa_family != ARPHRD_ETHER) {
+		WL_ERROR(("Invalid Header...sa_family\n"));
+		return -EINVAL;
+	}
+
+	if (ETHER_ISBCAST(awrq->sa_data) || ETHER_ISNULLADDR(awrq->sa_data)) {
+		scb_val_t scbval;
+		bzero(&scbval, sizeof(scb_val_t));
+		(void)dev_wlc_ioctl(dev, WLC_DISASSOC, &scbval,
+				    sizeof(scb_val_t));
+		return 0;
+	}
+
+	memset(&join_params, 0, sizeof(join_params));
+	join_params_size = sizeof(join_params.ssid);
+
+	memcpy(join_params.ssid.SSID, g_ssid.SSID, g_ssid.SSID_len);
+	join_params.ssid.SSID_len = htod32(g_ssid.SSID_len);
+	memcpy(&join_params.params.bssid, awrq->sa_data, ETHER_ADDR_LEN);
+
+	WL_TRACE(("%s  target_channel=%d\n", __func__,
+		  g_wl_iw_params.target_channel));
+	wl_iw_ch_to_chanspec(g_wl_iw_params.target_channel, &join_params,
+			     &join_params_size);
+
+	error = dev_wlc_ioctl(dev, WLC_SET_SSID, &join_params,
+				join_params_size);
+	if (error) {
+		WL_ERROR(("%s Invalid ioctl data=%d\n", __func__, error));
+	}
+
+	if (g_ssid.SSID_len) {
+		WL_TRACE(("%s: join SSID=%s BSSID=%pM ch=%d\n",
+			  __func__, g_ssid.SSID, awrq->sa_data,
+			  g_wl_iw_params.target_channel));
+	}
+
+	memset(&g_ssid, 0, sizeof(g_ssid));
+	return 0;
+}
+
+static int
+wl_iw_get_wap(struct net_device *dev,
+	      struct iw_request_info *info, struct sockaddr *awrq, char *extra)
+{
+	WL_TRACE(("%s: SIOCGIWAP\n", dev->name));
+
+	awrq->sa_family = ARPHRD_ETHER;
+	memset(awrq->sa_data, 0, ETHER_ADDR_LEN);
+
+	(void)dev_wlc_ioctl(dev, WLC_GET_BSSID, awrq->sa_data, ETHER_ADDR_LEN);
+
+	return 0;
+}
+
+#if WIRELESS_EXT > 17
+static int
+wl_iw_mlme(struct net_device *dev,
+	   struct iw_request_info *info, struct sockaddr *awrq, char *extra)
+{
+	struct iw_mlme *mlme;
+	scb_val_t scbval;
+	int error = -EINVAL;
+
+	WL_TRACE(("%s: SIOCSIWMLME DISASSOC/DEAUTH\n", dev->name));
+
+	mlme = (struct iw_mlme *)extra;
+	if (mlme == NULL) {
+		WL_ERROR(("Invalid ioctl data.\n"));
+		return error;
+	}
+
+	scbval.val = mlme->reason_code;
+	bcopy(&mlme->addr.sa_data, &scbval.ea, ETHER_ADDR_LEN);
+
+	if (mlme->cmd == IW_MLME_DISASSOC) {
+		scbval.val = htod32(scbval.val);
+		error =
+		    dev_wlc_ioctl(dev, WLC_DISASSOC, &scbval,
+				  sizeof(scb_val_t));
+	} else if (mlme->cmd == IW_MLME_DEAUTH) {
+		scbval.val = htod32(scbval.val);
+		error =
+		    dev_wlc_ioctl(dev, WLC_SCB_DEAUTHENTICATE_FOR_REASON,
+				  &scbval, sizeof(scb_val_t));
+	} else {
+		WL_ERROR(("Invalid ioctl data.\n"));
+		return error;
+	}
+
+	return error;
+}
+#endif				/* WIRELESS_EXT > 17 */
+
+#ifndef WL_IW_USE_ISCAN
+static int
+wl_iw_get_aplist(struct net_device *dev,
+		 struct iw_request_info *info,
+		 struct iw_point *dwrq, char *extra)
+{
+	wl_scan_results_t *list;
+	struct sockaddr *addr = (struct sockaddr *)extra;
+	struct iw_quality qual[IW_MAX_AP];
+	wl_bss_info_t *bi = NULL;
+	int error, i;
+	uint buflen = dwrq->length;
+
+	WL_TRACE(("%s: SIOCGIWAPLIST\n", dev->name));
+
+	if (!extra)
+		return -EINVAL;
+
+	list = kmalloc(buflen, GFP_KERNEL);
+	if (!list)
+		return -ENOMEM;
+	memset(list, 0, buflen);
+	list->buflen = htod32(buflen);
+	error = dev_wlc_ioctl(dev, WLC_SCAN_RESULTS, list, buflen);
+	if (error) {
+		WL_ERROR(("%d: Scan results error %d\n", __LINE__, error));
+		kfree(list);
+		return error;
+	}
+	list->buflen = dtoh32(list->buflen);
+	list->version = dtoh32(list->version);
+	list->count = dtoh32(list->count);
+	if (list->version != WL_BSS_INFO_VERSION) {
+		WL_ERROR(("%s : list->version %d != WL_BSS_INFO_VERSION\n",
+			  __func__, list->version));
+		kfree(list);
+		return -EINVAL;
+	}
+
+	for (i = 0, dwrq->length = 0;
+	     i < list->count && dwrq->length < IW_MAX_AP; i++) {
+		bi = bi ? (wl_bss_info_t *) ((unsigned long)bi +
+					     dtoh32(bi->length)) : list->
+		    bss_info;
+		ASSERT(((unsigned long)bi + dtoh32(bi->length)) <=
+		       ((unsigned long)list + buflen));
+
+		if (!(dtoh16(bi->capability) & DOT11_CAP_ESS))
+			continue;
+
+		memcpy(addr[dwrq->length].sa_data, &bi->BSSID, ETHER_ADDR_LEN);
+		addr[dwrq->length].sa_family = ARPHRD_ETHER;
+		qual[dwrq->length].qual = rssi_to_qual(dtoh16(bi->RSSI));
+		qual[dwrq->length].level = 0x100 + dtoh16(bi->RSSI);
+		qual[dwrq->length].noise = 0x100 + bi->phy_noise;
+
+#if WIRELESS_EXT > 18
+		qual[dwrq->length].updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
+#else
+		qual[dwrq->length].updated = 7;
+#endif
+		dwrq->length++;
+	}
+
+	kfree(list);
+
+	if (dwrq->length) {
+		memcpy(&addr[dwrq->length], qual,
+		       sizeof(struct iw_quality) * dwrq->length);
+		dwrq->flags = 1;
+	}
+
+	return 0;
+}
+#endif				/* WL_IW_USE_ISCAN */
+
+#ifdef WL_IW_USE_ISCAN
+static int
+wl_iw_iscan_get_aplist(struct net_device *dev,
+		       struct iw_request_info *info,
+		       struct iw_point *dwrq, char *extra)
+{
+	wl_scan_results_t *list;
+	iscan_buf_t *buf;
+	iscan_info_t *iscan = g_iscan;
+
+	struct sockaddr *addr = (struct sockaddr *)extra;
+	struct iw_quality qual[IW_MAX_AP];
+	wl_bss_info_t *bi = NULL;
+	int i;
+
+	WL_TRACE(("%s: SIOCGIWAPLIST\n", dev->name));
+
+	if (!extra)
+		return -EINVAL;
+
+	if ((!iscan) || (!iscan->sysioc_tsk)) {
+		WL_ERROR(("%s error\n", __func__));
+		return 0;
+	}
+
+	buf = iscan->list_hdr;
+	while (buf) {
+		list = &((wl_iscan_results_t *) buf->iscan_buf)->results;
+		if (list->version != WL_BSS_INFO_VERSION) {
+			WL_ERROR(("%s : list->version %d != "
+				"WL_BSS_INFO_VERSION\n",
+				__func__, list->version));
+			return -EINVAL;
+		}
+
+		bi = NULL;
+		for (i = 0, dwrq->length = 0;
+		     i < list->count && dwrq->length < IW_MAX_AP; i++) {
+			bi = bi ? (wl_bss_info_t *) ((unsigned long)bi +
+						     dtoh32(bi->length)) :
+			    list->bss_info;
+			ASSERT(((unsigned long)bi + dtoh32(bi->length)) <=
+			       ((unsigned long)list + WLC_IW_ISCAN_MAXLEN));
+
+			if (!(dtoh16(bi->capability) & DOT11_CAP_ESS))
+				continue;
+
+			memcpy(addr[dwrq->length].sa_data, &bi->BSSID,
+			       ETHER_ADDR_LEN);
+			addr[dwrq->length].sa_family = ARPHRD_ETHER;
+			qual[dwrq->length].qual =
+			    rssi_to_qual(dtoh16(bi->RSSI));
+			qual[dwrq->length].level = 0x100 + dtoh16(bi->RSSI);
+			qual[dwrq->length].noise = 0x100 + bi->phy_noise;
+
+#if WIRELESS_EXT > 18
+			qual[dwrq->length].updated =
+			    IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
+#else
+			qual[dwrq->length].updated = 7;
+#endif
+
+			dwrq->length++;
+		}
+		buf = buf->next;
+	}
+	if (dwrq->length) {
+		memcpy(&addr[dwrq->length], qual,
+		       sizeof(struct iw_quality) * dwrq->length);
+		dwrq->flags = 1;
+	}
+
+	return 0;
+}
+
+static int wl_iw_iscan_prep(wl_scan_params_t *params, wlc_ssid_t *ssid)
+{
+	int err = 0;
+
+	memcpy(&params->bssid, &ether_bcast, ETHER_ADDR_LEN);
+	params->bss_type = DOT11_BSSTYPE_ANY;
+	params->scan_type = 0;
+	params->nprobes = -1;
+	params->active_time = -1;
+	params->passive_time = -1;
+	params->home_time = -1;
+	params->channel_num = 0;
+
+	params->nprobes = htod32(params->nprobes);
+	params->active_time = htod32(params->active_time);
+	params->passive_time = htod32(params->passive_time);
+	params->home_time = htod32(params->home_time);
+	if (ssid && ssid->SSID_len)
+		memcpy(&params->ssid, ssid, sizeof(wlc_ssid_t));
+
+	return err;
+}
+
+static int wl_iw_iscan(iscan_info_t *iscan, wlc_ssid_t *ssid, u16 action)
+{
+	int err = 0;
+
+	iscan->iscan_ex_params_p->version = htod32(ISCAN_REQ_VERSION);
+	iscan->iscan_ex_params_p->action = htod16(action);
+	iscan->iscan_ex_params_p->scan_duration = htod16(0);
+
+	WL_SCAN(("%s : nprobes=%d\n", __func__,
+		 iscan->iscan_ex_params_p->params.nprobes));
+	WL_SCAN(("active_time=%d\n",
+		 iscan->iscan_ex_params_p->params.active_time));
+	WL_SCAN(("passive_time=%d\n",
+		 iscan->iscan_ex_params_p->params.passive_time));
+	WL_SCAN(("home_time=%d\n", iscan->iscan_ex_params_p->params.home_time));
+	WL_SCAN(("scan_type=%d\n", iscan->iscan_ex_params_p->params.scan_type));
+	WL_SCAN(("bss_type=%d\n", iscan->iscan_ex_params_p->params.bss_type));
+
+	(void)dev_iw_iovar_setbuf(iscan->dev, "iscan", iscan->iscan_ex_params_p,
+				  iscan->iscan_ex_param_size, iscan->ioctlbuf,
+				  sizeof(iscan->ioctlbuf));
+
+	return err;
+}
+
+static void wl_iw_timerfunc(unsigned long data)
+{
+	iscan_info_t *iscan = (iscan_info_t *) data;
+	if (iscan) {
+		iscan->timer_on = 0;
+		if (iscan->iscan_state != ISCAN_STATE_IDLE) {
+			WL_TRACE(("timer trigger\n"));
+			up(&iscan->sysioc_sem);
+		}
+	}
+}
+
+static void wl_iw_set_event_mask(struct net_device *dev)
+{
+	char eventmask[WL_EVENTING_MASK_LEN];
+	char iovbuf[WL_EVENTING_MASK_LEN + 12];
+
+	dev_iw_iovar_getbuf(dev, "event_msgs", "", 0, iovbuf, sizeof(iovbuf));
+	bcopy(iovbuf, eventmask, WL_EVENTING_MASK_LEN);
+	setbit(eventmask, WLC_E_SCAN_COMPLETE);
+	dev_iw_iovar_setbuf(dev, "event_msgs", eventmask, WL_EVENTING_MASK_LEN,
+			    iovbuf, sizeof(iovbuf));
+}
+
+static u32 wl_iw_iscan_get(iscan_info_t *iscan)
+{
+	iscan_buf_t *buf;
+	iscan_buf_t *ptr;
+	wl_iscan_results_t *list_buf;
+	wl_iscan_results_t list;
+	wl_scan_results_t *results;
+	u32 status;
+	int res = 0;
+
+	MUTEX_LOCK_WL_SCAN_SET();
+	if (iscan->list_cur) {
+		buf = iscan->list_cur;
+		iscan->list_cur = buf->next;
+	} else {
+		buf = kmalloc(sizeof(iscan_buf_t), GFP_KERNEL);
+		if (!buf) {
+			WL_ERROR(("%s can't alloc iscan_buf_t : going to abort "
+				"currect iscan\n", __func__));
+			MUTEX_UNLOCK_WL_SCAN_SET();
+			return WL_SCAN_RESULTS_NO_MEM;
+		}
+		buf->next = NULL;
+		if (!iscan->list_hdr)
+			iscan->list_hdr = buf;
+		else {
+			ptr = iscan->list_hdr;
+			while (ptr->next) {
+				ptr = ptr->next;
+			}
+			ptr->next = buf;
+		}
+	}
+	memset(buf->iscan_buf, 0, WLC_IW_ISCAN_MAXLEN);
+	list_buf = (wl_iscan_results_t *) buf->iscan_buf;
+	results = &list_buf->results;
+	results->buflen = WL_ISCAN_RESULTS_FIXED_SIZE;
+	results->version = 0;
+	results->count = 0;
+
+	memset(&list, 0, sizeof(list));
+	list.results.buflen = htod32(WLC_IW_ISCAN_MAXLEN);
+	res = dev_iw_iovar_getbuf(iscan->dev,
+				  "iscanresults",
+				  &list,
+				  WL_ISCAN_RESULTS_FIXED_SIZE,
+				  buf->iscan_buf, WLC_IW_ISCAN_MAXLEN);
+	if (res == 0) {
+		results->buflen = dtoh32(results->buflen);
+		results->version = dtoh32(results->version);
+		results->count = dtoh32(results->count);
+		WL_TRACE(("results->count = %d\n", results->count));
+		WL_TRACE(("results->buflen = %d\n", results->buflen));
+		status = dtoh32(list_buf->status);
+	} else {
+		WL_ERROR(("%s returns error %d\n", __func__, res));
+		status = WL_SCAN_RESULTS_NO_MEM;
+	}
+	MUTEX_UNLOCK_WL_SCAN_SET();
+	return status;
+}
+
+static void wl_iw_force_specific_scan(iscan_info_t *iscan)
+{
+	WL_TRACE(("%s force Specific SCAN for %s\n", __func__,
+		  g_specific_ssid.SSID));
+	rtnl_lock();
+
+	(void)dev_wlc_ioctl(iscan->dev, WLC_SCAN, &g_specific_ssid,
+			    sizeof(g_specific_ssid));
+
+	rtnl_unlock();
+}
+
+static void wl_iw_send_scan_complete(iscan_info_t *iscan)
+{
+#ifndef SANDGATE2G
+	union iwreq_data wrqu;
+
+	memset(&wrqu, 0, sizeof(wrqu));
+
+	wireless_send_event(iscan->dev, SIOCGIWSCAN, &wrqu, NULL);
+	WL_TRACE(("Send Event ISCAN complete\n"));
+#endif
+}
+
+static int _iscan_sysioc_thread(void *data)
+{
+	u32 status;
+	iscan_info_t *iscan = (iscan_info_t *) data;
+	static bool iscan_pass_abort = false;
+
+	allow_signal(SIGTERM);
+	status = WL_SCAN_RESULTS_PARTIAL;
+	while (down_interruptible(&iscan->sysioc_sem) == 0) {
+		if (kthread_should_stop())
+			break;
+
+		if (iscan->timer_on) {
+			del_timer_sync(&iscan->timer);
+			iscan->timer_on = 0;
+		}
+		rtnl_lock();
+		status = wl_iw_iscan_get(iscan);
+		rtnl_unlock();
+		if (g_scan_specified_ssid && (iscan_pass_abort == true)) {
+			WL_TRACE(("%s Get results from specific scan "
+				"status = %d\n", __func__, status));
+			wl_iw_send_scan_complete(iscan);
+			iscan_pass_abort = false;
+			status = -1;
+		}
+
+		switch (status) {
+		case WL_SCAN_RESULTS_PARTIAL:
+			WL_TRACE(("iscanresults incomplete\n"));
+			rtnl_lock();
+			wl_iw_iscan(iscan, NULL, WL_SCAN_ACTION_CONTINUE);
+			rtnl_unlock();
+			mod_timer(&iscan->timer,
+				  jiffies + iscan->timer_ms * HZ / 1000);
+			iscan->timer_on = 1;
+			break;
+		case WL_SCAN_RESULTS_SUCCESS:
+			WL_TRACE(("iscanresults complete\n"));
+			iscan->iscan_state = ISCAN_STATE_IDLE;
+			wl_iw_send_scan_complete(iscan);
+			break;
+		case WL_SCAN_RESULTS_PENDING:
+			WL_TRACE(("iscanresults pending\n"));
+			mod_timer(&iscan->timer,
+				  jiffies + iscan->timer_ms * HZ / 1000);
+			iscan->timer_on = 1;
+			break;
+		case WL_SCAN_RESULTS_ABORTED:
+			WL_TRACE(("iscanresults aborted\n"));
+			iscan->iscan_state = ISCAN_STATE_IDLE;
+			if (g_scan_specified_ssid == 0)
+				wl_iw_send_scan_complete(iscan);
+			else {
+				iscan_pass_abort = true;
+				wl_iw_force_specific_scan(iscan);
+			}
+			break;
+		case WL_SCAN_RESULTS_NO_MEM:
+			WL_TRACE(("iscanresults can't alloc memory: skip\n"));
+			iscan->iscan_state = ISCAN_STATE_IDLE;
+			break;
+		default:
+			WL_TRACE(("iscanresults returned unknown status %d\n",
+				  status));
+			break;
+		}
+	}
+
+	if (iscan->timer_on) {
+		del_timer_sync(&iscan->timer);
+		iscan->timer_on = 0;
+	}
+	return 0;
+}
+#endif				/* WL_IW_USE_ISCAN */
+
+static int
+wl_iw_set_scan(struct net_device *dev,
+	       struct iw_request_info *info,
+	       union iwreq_data *wrqu, char *extra)
+{
+	int error;
+	WL_TRACE(("\n:%s dev:%s: SIOCSIWSCAN : SCAN\n", __func__, dev->name));
+
+	g_set_essid_before_scan = false;
+#if defined(CSCAN)
+	WL_ERROR(("%s: Scan from SIOCGIWSCAN not supported\n", __func__));
+	return -EINVAL;
+#endif
+
+	if (g_onoff == G_WLAN_SET_OFF)
+		return 0;
+
+	memset(&g_specific_ssid, 0, sizeof(g_specific_ssid));
+#ifndef WL_IW_USE_ISCAN
+	g_scan_specified_ssid = 0;
+#endif
+
+#if WIRELESS_EXT > 17
+	if (wrqu->data.length == sizeof(struct iw_scan_req)) {
+		if (wrqu->data.flags & IW_SCAN_THIS_ESSID) {
+			struct iw_scan_req *req = (struct iw_scan_req *)extra;
+			if (g_scan_specified_ssid) {
+				WL_TRACE(("%s Specific SCAN is not done ignore "
+					"scan for = %s\n",
+					__func__, req->essid));
+				return -EBUSY;
+			} else {
+				g_specific_ssid.SSID_len = min_t(size_t,
+						sizeof(g_specific_ssid.SSID),
+						req->essid_len);
+				memcpy(g_specific_ssid.SSID, req->essid,
+				       g_specific_ssid.SSID_len);
+				g_specific_ssid.SSID_len =
+				    htod32(g_specific_ssid.SSID_len);
+				g_scan_specified_ssid = 1;
+				WL_TRACE(("### Specific scan ssid=%s len=%d\n",
+					  g_specific_ssid.SSID,
+					  g_specific_ssid.SSID_len));
+			}
+		}
+	}
+#endif				/* WIRELESS_EXT > 17 */
+	error = dev_wlc_ioctl(dev, WLC_SCAN, &g_specific_ssid,
+				sizeof(g_specific_ssid));
+	if (error) {
+		WL_TRACE(("#### Set SCAN for %s failed with %d\n",
+			  g_specific_ssid.SSID, error));
+		g_scan_specified_ssid = 0;
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+#ifdef WL_IW_USE_ISCAN
+int wl_iw_iscan_set_scan_broadcast_prep(struct net_device *dev, uint flag)
+{
+	wlc_ssid_t ssid;
+	iscan_info_t *iscan = g_iscan;
+
+	if (flag)
+		rtnl_lock();
+
+	wl_iw_set_event_mask(dev);
+
+	WL_TRACE(("+++: Set Broadcast ISCAN\n"));
+	memset(&ssid, 0, sizeof(ssid));
+
+	iscan->list_cur = iscan->list_hdr;
+	iscan->iscan_state = ISCAN_STATE_SCANING;
+
+	memset(&iscan->iscan_ex_params_p->params, 0,
+	       iscan->iscan_ex_param_size);
+	wl_iw_iscan_prep(&iscan->iscan_ex_params_p->params, &ssid);
+	wl_iw_iscan(iscan, &ssid, WL_SCAN_ACTION_START);
+
+	if (flag)
+		rtnl_unlock();
+
+	mod_timer(&iscan->timer, jiffies + iscan->timer_ms * HZ / 1000);
+
+	iscan->timer_on = 1;
+
+	return 0;
+}
+
+static int
+wl_iw_iscan_set_scan(struct net_device *dev,
+		     struct iw_request_info *info,
+		     union iwreq_data *wrqu, char *extra)
+{
+	wlc_ssid_t ssid;
+	iscan_info_t *iscan = g_iscan;
+
+	WL_TRACE(("%s: SIOCSIWSCAN : ISCAN\n", dev->name));
+
+#if defined(CSCAN)
+	WL_ERROR(("%s: Scan from SIOCGIWSCAN not supported\n", __func__));
+	return -EINVAL;
+#endif
+
+	if (g_onoff == G_WLAN_SET_OFF) {
+		WL_TRACE(("%s: driver is not up yet after START\n", __func__));
+		return 0;
+	}
+#ifdef PNO_SUPPORT
+	if (dhd_dev_get_pno_status(dev)) {
+		WL_ERROR(("%s: Scan called when PNO is active\n", __func__));
+	}
+#endif
+
+	if ((!iscan) || (!iscan->sysioc_tsk))
+		return wl_iw_set_scan(dev, info, wrqu, extra);
+
+	if (g_scan_specified_ssid) {
+		WL_TRACE(("%s Specific SCAN already running ignoring BC scan\n",
+			  __func__));
+		return EBUSY;
+	}
+
+	memset(&ssid, 0, sizeof(ssid));
+
+#if WIRELESS_EXT > 17
+	if (wrqu->data.length == sizeof(struct iw_scan_req)) {
+		if (wrqu->data.flags & IW_SCAN_THIS_ESSID) {
+			struct iw_scan_req *req = (struct iw_scan_req *)extra;
+			ssid.SSID_len = min_t(size_t, sizeof(ssid.SSID),
+						req->essid_len);
+			memcpy(ssid.SSID, req->essid, ssid.SSID_len);
+			ssid.SSID_len = htod32(ssid.SSID_len);
+		} else {
+			g_scan_specified_ssid = 0;
+
+			if (iscan->iscan_state == ISCAN_STATE_SCANING) {
+				WL_TRACE(("%s ISCAN already in progress \n",
+					  __func__));
+				return 0;
+			}
+		}
+	}
+#endif				/* WIRELESS_EXT > 17 */
+	wl_iw_iscan_set_scan_broadcast_prep(dev, 0);
+
+	return 0;
+}
+#endif				/* WL_IW_USE_ISCAN */
+
+#if WIRELESS_EXT > 17
+static bool ie_is_wpa_ie(u8 **wpaie, u8 **tlvs, int *tlvs_len)
+{
+
+	u8 *ie = *wpaie;
+
+	if ((ie[1] >= 6) &&
+	    !bcmp((const void *)&ie[2], (const void *)(WPA_OUI "\x01"), 4)) {
+		return true;
+	}
+
+	ie += ie[1] + 2;
+	*tlvs_len -= (int)(ie - *tlvs);
+	*tlvs = ie;
+	return false;
+}
+
+static bool ie_is_wps_ie(u8 **wpsie, u8 **tlvs, int *tlvs_len)
+{
+
+	u8 *ie = *wpsie;
+
+	if ((ie[1] >= 4) &&
+	    !bcmp((const void *)&ie[2], (const void *)(WPA_OUI "\x04"), 4)) {
+		return true;
+	}
+
+	ie += ie[1] + 2;
+	*tlvs_len -= (int)(ie - *tlvs);
+	*tlvs = ie;
+	return false;
+}
+#endif				/* WIRELESS_EXT > 17 */
+
+static int
+wl_iw_handle_scanresults_ies(char **event_p, char *end,
+			     struct iw_request_info *info, wl_bss_info_t *bi)
+{
+#if WIRELESS_EXT > 17
+	struct iw_event iwe;
+	char *event;
+
+	event = *event_p;
+	if (bi->ie_length) {
+		bcm_tlv_t *ie;
+		u8 *ptr = ((u8 *) bi) + sizeof(wl_bss_info_t);
+		int ptr_len = bi->ie_length;
+
+		ie = bcm_parse_tlvs(ptr, ptr_len, DOT11_MNG_RSN_ID);
+		if (ie) {
+			iwe.cmd = IWEVGENIE;
+			iwe.u.data.length = ie->len + 2;
+			event =
+			    IWE_STREAM_ADD_POINT(info, event, end, &iwe,
+						 (char *)ie);
+		}
+		ptr = ((u8 *) bi) + sizeof(wl_bss_info_t);
+
+		while ((ie = bcm_parse_tlvs(ptr, ptr_len, DOT11_MNG_WPA_ID))) {
+			if (ie_is_wps_ie(((u8 **)&ie), &ptr, &ptr_len)) {
+				iwe.cmd = IWEVGENIE;
+				iwe.u.data.length = ie->len + 2;
+				event =
+				    IWE_STREAM_ADD_POINT(info, event, end, &iwe,
+							 (char *)ie);
+				break;
+			}
+		}
+
+		ptr = ((u8 *) bi) + sizeof(wl_bss_info_t);
+		ptr_len = bi->ie_length;
+		while ((ie = bcm_parse_tlvs(ptr, ptr_len, DOT11_MNG_WPA_ID))) {
+			if (ie_is_wpa_ie(((u8 **)&ie), &ptr, &ptr_len)) {
+				iwe.cmd = IWEVGENIE;
+				iwe.u.data.length = ie->len + 2;
+				event =
+				    IWE_STREAM_ADD_POINT(info, event, end, &iwe,
+							 (char *)ie);
+				break;
+			}
+		}
+
+		*event_p = event;
+	}
+#endif		/* WIRELESS_EXT > 17 */
+	return 0;
+}
+
+static uint
+wl_iw_get_scan_prep(wl_scan_results_t *list,
+		    struct iw_request_info *info, char *extra, short max_size)
+{
+	int i, j;
+	struct iw_event iwe;
+	wl_bss_info_t *bi = NULL;
+	char *event = extra, *end = extra + max_size - WE_ADD_EVENT_FIX, *value;
+	int ret = 0;
+
+	ASSERT(list);
+
+	for (i = 0; i < list->count && i < IW_MAX_AP; i++) {
+		if (list->version != WL_BSS_INFO_VERSION) {
+			WL_ERROR(("%s : list->version %d != "
+				"WL_BSS_INFO_VERSION\n",
+				__func__, list->version));
+			return ret;
+		}
+
+		bi = bi ? (wl_bss_info_t *)((unsigned long)bi +
+					     dtoh32(bi->length)) : list->
+		    bss_info;
+
+		WL_TRACE(("%s : %s\n", __func__, bi->SSID));
+
+		iwe.cmd = SIOCGIWAP;
+		iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+		memcpy(iwe.u.ap_addr.sa_data, &bi->BSSID, ETHER_ADDR_LEN);
+		event =
+		    IWE_STREAM_ADD_EVENT(info, event, end, &iwe,
+					 IW_EV_ADDR_LEN);
+		iwe.u.data.length = dtoh32(bi->SSID_len);
+		iwe.cmd = SIOCGIWESSID;
+		iwe.u.data.flags = 1;
+		event = IWE_STREAM_ADD_POINT(info, event, end, &iwe, bi->SSID);
+
+		if (dtoh16(bi->capability) & (DOT11_CAP_ESS | DOT11_CAP_IBSS)) {
+			iwe.cmd = SIOCGIWMODE;
+			if (dtoh16(bi->capability) & DOT11_CAP_ESS)
+				iwe.u.mode = IW_MODE_INFRA;
+			else
+				iwe.u.mode = IW_MODE_ADHOC;
+			event =
+			    IWE_STREAM_ADD_EVENT(info, event, end, &iwe,
+						 IW_EV_UINT_LEN);
+		}
+
+		iwe.cmd = SIOCGIWFREQ;
+		iwe.u.freq.m = wf_channel2mhz(CHSPEC_CHANNEL(bi->chanspec),
+					      CHSPEC_CHANNEL(bi->chanspec) <=
+					      CH_MAX_2G_CHANNEL ?
+					      WF_CHAN_FACTOR_2_4_G :
+					      WF_CHAN_FACTOR_5_G);
+		iwe.u.freq.e = 6;
+		event =
+		    IWE_STREAM_ADD_EVENT(info, event, end, &iwe,
+					 IW_EV_FREQ_LEN);
+
+		iwe.cmd = IWEVQUAL;
+		iwe.u.qual.qual = rssi_to_qual(dtoh16(bi->RSSI));
+		iwe.u.qual.level = 0x100 + dtoh16(bi->RSSI);
+		iwe.u.qual.noise = 0x100 + bi->phy_noise;
+		event =
+		    IWE_STREAM_ADD_EVENT(info, event, end, &iwe,
+					 IW_EV_QUAL_LEN);
+
+		wl_iw_handle_scanresults_ies(&event, end, info, bi);
+
+		iwe.cmd = SIOCGIWENCODE;
+		if (dtoh16(bi->capability) & DOT11_CAP_PRIVACY)
+			iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+		else
+			iwe.u.data.flags = IW_ENCODE_DISABLED;
+		iwe.u.data.length = 0;
+		event =
+		    IWE_STREAM_ADD_POINT(info, event, end, &iwe, (char *)event);
+
+		if (bi->rateset.count) {
+			if (((event - extra) +
+				IW_EV_LCP_LEN) <= (unsigned long)end) {
+				value = event + IW_EV_LCP_LEN;
+				iwe.cmd = SIOCGIWRATE;
+				iwe.u.bitrate.fixed = iwe.u.bitrate.disabled =
+				    0;
+				for (j = 0;
+				     j < bi->rateset.count
+				     && j < IW_MAX_BITRATES; j++) {
+					iwe.u.bitrate.value =
+					    (bi->rateset.rates[j] & 0x7f) *
+					    500000;
+					value =
+					    IWE_STREAM_ADD_VALUE(info, event,
+						 value, end, &iwe,
+						 IW_EV_PARAM_LEN);
+				}
+				event = value;
+			}
+		}
+	}
+
+	ret = event - extra;
+	if (ret < 0) {
+		WL_ERROR(("==> Wrong size\n"));
+		ret = 0;
+	}
+	WL_TRACE(("%s: size=%d bytes prepared\n", __func__,
+		  (unsigned int)(event - extra)));
+	return (uint)ret;
+}
+
+static int
+wl_iw_get_scan(struct net_device *dev,
+	       struct iw_request_info *info, struct iw_point *dwrq, char *extra)
+{
+	channel_info_t ci;
+	wl_scan_results_t *list_merge;
+	wl_scan_results_t *list = (wl_scan_results_t *) g_scan;
+	int error;
+	uint buflen_from_user = dwrq->length;
+	uint len = G_SCAN_RESULTS;
+	__u16 len_ret = 0;
+#if defined(WL_IW_USE_ISCAN)
+	iscan_info_t *iscan = g_iscan;
+	iscan_buf_t *p_buf;
+#endif
+
+	WL_TRACE(("%s: buflen_from_user %d: \n", dev->name, buflen_from_user));
+
+	if (!extra) {
+		WL_TRACE(("%s: wl_iw_get_scan return -EINVAL\n", dev->name));
+		return -EINVAL;
+	}
+
+	error = dev_wlc_ioctl(dev, WLC_GET_CHANNEL, &ci, sizeof(ci));
+	if (error)
+		return error;
+	ci.scan_channel = dtoh32(ci.scan_channel);
+	if (ci.scan_channel)
+		return -EAGAIN;
+
+	if (g_scan_specified_ssid) {
+		list = kmalloc(len, GFP_KERNEL);
+		if (!list) {
+			WL_TRACE(("%s: wl_iw_get_scan return -ENOMEM\n",
+				  dev->name));
+			g_scan_specified_ssid = 0;
+			return -ENOMEM;
+		}
+	}
+
+	memset(list, 0, len);
+	list->buflen = htod32(len);
+	error = dev_wlc_ioctl(dev, WLC_SCAN_RESULTS, list, len);
+	if (error) {
+		WL_ERROR(("%s: %s : Scan_results ERROR %d\n", dev->name,
+			  __func__, error));
+		dwrq->length = len;
+		if (g_scan_specified_ssid) {
+			g_scan_specified_ssid = 0;
+			kfree(list);
+		}
+		return 0;
+	}
+	list->buflen = dtoh32(list->buflen);
+	list->version = dtoh32(list->version);
+	list->count = dtoh32(list->count);
+
+	if (list->version != WL_BSS_INFO_VERSION) {
+		WL_ERROR(("%s : list->version %d != WL_BSS_INFO_VERSION\n",
+			  __func__, list->version));
+		if (g_scan_specified_ssid) {
+			g_scan_specified_ssid = 0;
+			kfree(list);
+		}
+		return -EINVAL;
+	}
+
+	if (g_scan_specified_ssid) {
+		WL_TRACE(("%s: Specified scan APs in the list =%d\n",
+			  __func__, list->count));
+		len_ret =
+		    (__u16) wl_iw_get_scan_prep(list, info, extra,
+						buflen_from_user);
+		kfree(list);
+
+#if defined(WL_IW_USE_ISCAN)
+		p_buf = iscan->list_hdr;
+		while (p_buf != iscan->list_cur) {
+			list_merge =
+			    &((wl_iscan_results_t *) p_buf->iscan_buf)->results;
+			WL_TRACE(("%s: Bcast APs list=%d\n", __func__,
+				  list_merge->count));
+			if (list_merge->count > 0)
+				len_ret +=
+				    (__u16) wl_iw_get_scan_prep(list_merge,
+					info, extra + len_ret,
+					buflen_from_user - len_ret);
+			p_buf = p_buf->next;
+		}
+#else
+		list_merge = (wl_scan_results_t *) g_scan;
+		WL_TRACE(("%s: Bcast APs list=%d\n", __func__,
+			  list_merge->count));
+		if (list_merge->count > 0)
+			len_ret +=
+			    (__u16) wl_iw_get_scan_prep(list_merge, info,
+							extra + len_ret,
+							buflen_from_user -
+							len_ret);
+#endif				/* defined(WL_IW_USE_ISCAN) */
+	} else {
+		list = (wl_scan_results_t *) g_scan;
+		len_ret =
+		    (__u16) wl_iw_get_scan_prep(list, info, extra,
+						buflen_from_user);
+	}
+
+#if defined(WL_IW_USE_ISCAN)
+	g_scan_specified_ssid = 0;
+#endif
+	if ((len_ret + WE_ADD_EVENT_FIX) < buflen_from_user)
+		len = len_ret;
+
+	dwrq->length = len;
+	dwrq->flags = 0;
+
+	WL_TRACE(("%s return to WE %d bytes APs=%d\n", __func__,
+		  dwrq->length, list->count));
+	return 0;
+}
+
+#if defined(WL_IW_USE_ISCAN)
+static int
+wl_iw_iscan_get_scan(struct net_device *dev,
+		     struct iw_request_info *info,
+		     struct iw_point *dwrq, char *extra)
+{
+	wl_scan_results_t *list;
+	struct iw_event iwe;
+	wl_bss_info_t *bi = NULL;
+	int ii, j;
+	int apcnt;
+	char *event = extra, *end = extra + dwrq->length, *value;
+	iscan_info_t *iscan = g_iscan;
+	iscan_buf_t *p_buf;
+	u32 counter = 0;
+	u8 channel;
+
+	WL_TRACE(("%s %s buflen_from_user %d:\n", dev->name, __func__,
+		  dwrq->length));
+
+	if (!extra) {
+		WL_TRACE(("%s: INVALID SIOCGIWSCAN GET bad parameter\n",
+			  dev->name));
+		return -EINVAL;
+	}
+
+	if ((!iscan) || (!iscan->sysioc_tsk)) {
+		WL_ERROR(("%ssysioc_tsk\n", __func__));
+		return wl_iw_get_scan(dev, info, dwrq, extra);
+	}
+
+	if (iscan->iscan_state == ISCAN_STATE_SCANING) {
+		WL_TRACE(("%s: SIOCGIWSCAN GET still scanning\n", dev->name));
+		return -EAGAIN;
+	}
+
+	WL_TRACE(("%s: SIOCGIWSCAN GET broadcast results\n", dev->name));
+	apcnt = 0;
+	p_buf = iscan->list_hdr;
+	while (p_buf != iscan->list_cur) {
+		list = &((wl_iscan_results_t *) p_buf->iscan_buf)->results;
+
+		counter += list->count;
+
+		if (list->version != WL_BSS_INFO_VERSION) {
+			WL_ERROR(("%s : list->version %d != "
+				"WL_BSS_INFO_VERSION\n",
+				__func__, list->version));
+			return -EINVAL;
+		}
+
+		bi = NULL;
+		for (ii = 0; ii < list->count && apcnt < IW_MAX_AP;
+		     apcnt++, ii++) {
+			bi = bi ? (wl_bss_info_t *)((unsigned long)bi +
+						     dtoh32(bi->length)) :
+			    list->bss_info;
+			ASSERT(((unsigned long)bi + dtoh32(bi->length)) <=
+			       ((unsigned long)list + WLC_IW_ISCAN_MAXLEN));
+
+			if (event + ETHER_ADDR_LEN + bi->SSID_len +
+			    IW_EV_UINT_LEN + IW_EV_FREQ_LEN + IW_EV_QUAL_LEN >=
+			    end)
+				return -E2BIG;
+			iwe.cmd = SIOCGIWAP;
+			iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+			memcpy(iwe.u.ap_addr.sa_data, &bi->BSSID,
+			       ETHER_ADDR_LEN);
+			event =
+			    IWE_STREAM_ADD_EVENT(info, event, end, &iwe,
+						 IW_EV_ADDR_LEN);
+
+			iwe.u.data.length = dtoh32(bi->SSID_len);
+			iwe.cmd = SIOCGIWESSID;
+			iwe.u.data.flags = 1;
+			event =
+			    IWE_STREAM_ADD_POINT(info, event, end, &iwe,
+						 bi->SSID);
+
+			if (dtoh16(bi->capability) &
+			    (DOT11_CAP_ESS | DOT11_CAP_IBSS)) {
+				iwe.cmd = SIOCGIWMODE;
+				if (dtoh16(bi->capability) & DOT11_CAP_ESS)
+					iwe.u.mode = IW_MODE_INFRA;
+				else
+					iwe.u.mode = IW_MODE_ADHOC;
+				event =
+				    IWE_STREAM_ADD_EVENT(info, event, end, &iwe,
+							 IW_EV_UINT_LEN);
+			}
+
+			iwe.cmd = SIOCGIWFREQ;
+			channel =
+			    (bi->ctl_ch ==
+			     0) ? CHSPEC_CHANNEL(bi->chanspec) : bi->ctl_ch;
+			iwe.u.freq.m =
+			    wf_channel2mhz(channel,
+					   channel <=
+					   CH_MAX_2G_CHANNEL ?
+					   WF_CHAN_FACTOR_2_4_G :
+					   WF_CHAN_FACTOR_5_G);
+			iwe.u.freq.e = 6;
+			event =
+			    IWE_STREAM_ADD_EVENT(info, event, end, &iwe,
+						 IW_EV_FREQ_LEN);
+
+			iwe.cmd = IWEVQUAL;
+			iwe.u.qual.qual = rssi_to_qual(dtoh16(bi->RSSI));
+			iwe.u.qual.level = 0x100 + dtoh16(bi->RSSI);
+			iwe.u.qual.noise = 0x100 + bi->phy_noise;
+			event =
+			    IWE_STREAM_ADD_EVENT(info, event, end, &iwe,
+						 IW_EV_QUAL_LEN);
+
+			wl_iw_handle_scanresults_ies(&event, end, info, bi);
+
+			iwe.cmd = SIOCGIWENCODE;
+			if (dtoh16(bi->capability) & DOT11_CAP_PRIVACY)
+				iwe.u.data.flags =
+				    IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+			else
+				iwe.u.data.flags = IW_ENCODE_DISABLED;
+			iwe.u.data.length = 0;
+			event =
+			    IWE_STREAM_ADD_POINT(info, event, end, &iwe,
+						 (char *)event);
+
+			if (bi->rateset.count) {
+				if (event + IW_MAX_BITRATES * IW_EV_PARAM_LEN >=
+				    end)
+					return -E2BIG;
+
+				value = event + IW_EV_LCP_LEN;
+				iwe.cmd = SIOCGIWRATE;
+				iwe.u.bitrate.fixed = iwe.u.bitrate.disabled =
+				    0;
+				for (j = 0;
+				     j < bi->rateset.count
+				     && j < IW_MAX_BITRATES; j++) {
+					iwe.u.bitrate.value =
+					    (bi->rateset.rates[j] & 0x7f) *
+					    500000;
+					value =
+					    IWE_STREAM_ADD_VALUE(info, event,
+						 value, end,
+						 &iwe,
+						 IW_EV_PARAM_LEN);
+				}
+				event = value;
+			}
+		}
+		p_buf = p_buf->next;
+	}
+
+	dwrq->length = event - extra;
+	dwrq->flags = 0;
+
+	WL_TRACE(("%s return to WE %d bytes APs=%d\n", __func__,
+		  dwrq->length, counter));
+
+	if (!dwrq->length)
+		return -EAGAIN;
+
+	return 0;
+}
+#endif				/* defined(WL_IW_USE_ISCAN) */
+
+static int
+wl_iw_set_essid(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *dwrq, char *extra)
+{
+	int error;
+	wl_join_params_t join_params;
+	int join_params_size;
+
+	WL_TRACE(("%s: SIOCSIWESSID\n", dev->name));
+
+	if (g_set_essid_before_scan)
+		return -EAGAIN;
+
+	memset(&g_ssid, 0, sizeof(g_ssid));
+
+	CHECK_EXTRA_FOR_NULL(extra);
+
+	if (dwrq->length && extra) {
+#if WIRELESS_EXT > 20
+		g_ssid.SSID_len = min_t(size_t, sizeof(g_ssid.SSID),
+					dwrq->length);
+#else
+		g_ssid.SSID_len = min_t(size_t, sizeof(g_ssid.SSID),
+					dwrq->length - 1);
+#endif
+		memcpy(g_ssid.SSID, extra, g_ssid.SSID_len);
+	} else {
+		g_ssid.SSID_len = 0;
+	}
+	g_ssid.SSID_len = htod32(g_ssid.SSID_len);
+
+	memset(&join_params, 0, sizeof(join_params));
+	join_params_size = sizeof(join_params.ssid);
+
+	memcpy(&join_params.ssid.SSID, g_ssid.SSID, g_ssid.SSID_len);
+	join_params.ssid.SSID_len = htod32(g_ssid.SSID_len);
+	memcpy(&join_params.params.bssid, &ether_bcast, ETHER_ADDR_LEN);
+
+	wl_iw_ch_to_chanspec(g_wl_iw_params.target_channel, &join_params,
+			     &join_params_size);
+
+	error = dev_wlc_ioctl(dev, WLC_SET_SSID, &join_params,
+				join_params_size);
+	if (error)
+		WL_ERROR(("Invalid ioctl data=%d\n", error));
+
+	if (g_ssid.SSID_len) {
+		WL_TRACE(("%s: join SSID=%s ch=%d\n", __func__,
+			  g_ssid.SSID, g_wl_iw_params.target_channel));
+	}
+	return 0;
+}
+
+static int
+wl_iw_get_essid(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *dwrq, char *extra)
+{
+	wlc_ssid_t ssid;
+	int error;
+
+	WL_TRACE(("%s: SIOCGIWESSID\n", dev->name));
+
+	if (!extra)
+		return -EINVAL;
+
+	error = dev_wlc_ioctl(dev, WLC_GET_SSID, &ssid, sizeof(ssid));
+	if (error) {
+		WL_ERROR(("Error getting the SSID\n"));
+		return error;
+	}
+
+	ssid.SSID_len = dtoh32(ssid.SSID_len);
+
+	memcpy(extra, ssid.SSID, ssid.SSID_len);
+
+	dwrq->length = ssid.SSID_len;
+
+	dwrq->flags = 1;
+
+	return 0;
+}
+
+static int
+wl_iw_set_nick(struct net_device *dev,
+	       struct iw_request_info *info, struct iw_point *dwrq, char *extra)
+{
+	wl_iw_t *iw = *(wl_iw_t **) netdev_priv(dev);
+
+	WL_TRACE(("%s: SIOCSIWNICKN\n", dev->name));
+
+	if (!extra)
+		return -EINVAL;
+
+	if (dwrq->length > sizeof(iw->nickname))
+		return -E2BIG;
+
+	memcpy(iw->nickname, extra, dwrq->length);
+	iw->nickname[dwrq->length - 1] = '\0';
+
+	return 0;
+}
+
+static int
+wl_iw_get_nick(struct net_device *dev,
+	       struct iw_request_info *info, struct iw_point *dwrq, char *extra)
+{
+	wl_iw_t *iw = *(wl_iw_t **) netdev_priv(dev);
+
+	WL_TRACE(("%s: SIOCGIWNICKN\n", dev->name));
+
+	if (!extra)
+		return -EINVAL;
+
+	strcpy(extra, iw->nickname);
+	dwrq->length = strlen(extra) + 1;
+
+	return 0;
+}
+
+static int
+wl_iw_set_rate(struct net_device *dev,
+	       struct iw_request_info *info, struct iw_param *vwrq, char *extra)
+{
+	wl_rateset_t rateset;
+	int error, rate, i, error_bg, error_a;
+
+	WL_TRACE(("%s: SIOCSIWRATE\n", dev->name));
+
+	error = dev_wlc_ioctl(dev, WLC_GET_CURR_RATESET, &rateset,
+				sizeof(rateset));
+	if (error)
+		return error;
+
+	rateset.count = dtoh32(rateset.count);
+
+	if (vwrq->value < 0)
+		rate = rateset.rates[rateset.count - 1] & 0x7f;
+	else if (vwrq->value < rateset.count)
+		rate = rateset.rates[vwrq->value] & 0x7f;
+	else
+		rate = vwrq->value / 500000;
+
+	if (vwrq->fixed) {
+		error_bg = dev_wlc_intvar_set(dev, "bg_rate", rate);
+		error_a = dev_wlc_intvar_set(dev, "a_rate", rate);
+
+		if (error_bg && error_a)
+			return error_bg | error_a;
+	} else {
+		error_bg = dev_wlc_intvar_set(dev, "bg_rate", 0);
+		error_a = dev_wlc_intvar_set(dev, "a_rate", 0);
+
+		if (error_bg && error_a)
+			return error_bg | error_a;
+
+		for (i = 0; i < rateset.count; i++)
+			if ((rateset.rates[i] & 0x7f) > rate)
+				break;
+		rateset.count = htod32(i);
+
+		error = dev_wlc_ioctl(dev, WLC_SET_RATESET, &rateset,
+					sizeof(rateset));
+		if (error)
+			return error;
+	}
+
+	return 0;
+}
+
+static int
+wl_iw_get_rate(struct net_device *dev,
+	       struct iw_request_info *info, struct iw_param *vwrq, char *extra)
+{
+	int error, rate;
+
+	WL_TRACE(("%s: SIOCGIWRATE\n", dev->name));
+
+	error = dev_wlc_ioctl(dev, WLC_GET_RATE, &rate, sizeof(rate));
+	if (error)
+		return error;
+	rate = dtoh32(rate);
+	vwrq->value = rate * 500000;
+
+	return 0;
+}
+
+static int
+wl_iw_set_rts(struct net_device *dev,
+	      struct iw_request_info *info, struct iw_param *vwrq, char *extra)
+{
+	int error, rts;
+
+	WL_TRACE(("%s: SIOCSIWRTS\n", dev->name));
+
+	if (vwrq->disabled)
+		rts = DOT11_DEFAULT_RTS_LEN;
+	else if (vwrq->value < 0 || vwrq->value > DOT11_DEFAULT_RTS_LEN)
+		return -EINVAL;
+	else
+		rts = vwrq->value;
+
+	error = dev_wlc_intvar_set(dev, "rtsthresh", rts);
+	if (error)
+		return error;
+
+	return 0;
+}
+
+static int
+wl_iw_get_rts(struct net_device *dev,
+	      struct iw_request_info *info, struct iw_param *vwrq, char *extra)
+{
+	int error, rts;
+
+	WL_TRACE(("%s: SIOCGIWRTS\n", dev->name));
+
+	error = dev_wlc_intvar_get(dev, "rtsthresh", &rts);
+	if (error)
+		return error;
+
+	vwrq->value = rts;
+	vwrq->disabled = (rts >= DOT11_DEFAULT_RTS_LEN);
+	vwrq->fixed = 1;
+
+	return 0;
+}
+
+static int
+wl_iw_set_frag(struct net_device *dev,
+	       struct iw_request_info *info, struct iw_param *vwrq, char *extra)
+{
+	int error, frag;
+
+	WL_TRACE(("%s: SIOCSIWFRAG\n", dev->name));
+
+	if (vwrq->disabled)
+		frag = DOT11_DEFAULT_FRAG_LEN;
+	else if (vwrq->value < 0 || vwrq->value > DOT11_DEFAULT_FRAG_LEN)
+		return -EINVAL;
+	else
+		frag = vwrq->value;
+
+	error = dev_wlc_intvar_set(dev, "fragthresh", frag);
+	if (error)
+		return error;
+
+	return 0;
+}
+
+static int
+wl_iw_get_frag(struct net_device *dev,
+	       struct iw_request_info *info, struct iw_param *vwrq, char *extra)
+{
+	int error, fragthreshold;
+
+	WL_TRACE(("%s: SIOCGIWFRAG\n", dev->name));
+
+	error = dev_wlc_intvar_get(dev, "fragthresh", &fragthreshold);
+	if (error)
+		return error;
+
+	vwrq->value = fragthreshold;
+	vwrq->disabled = (fragthreshold >= DOT11_DEFAULT_FRAG_LEN);
+	vwrq->fixed = 1;
+
+	return 0;
+}
+
+static int
+wl_iw_set_txpow(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_param *vwrq, char *extra)
+{
+	int error, disable;
+	u16 txpwrmw;
+	WL_TRACE(("%s: SIOCSIWTXPOW\n", dev->name));
+
+	disable = vwrq->disabled ? WL_RADIO_SW_DISABLE : 0;
+	disable += WL_RADIO_SW_DISABLE << 16;
+
+	disable = htod32(disable);
+	error = dev_wlc_ioctl(dev, WLC_SET_RADIO, &disable, sizeof(disable));
+	if (error)
+		return error;
+
+	if (disable & WL_RADIO_SW_DISABLE)
+		return 0;
+
+	if (!(vwrq->flags & IW_TXPOW_MWATT))
+		return -EINVAL;
+
+	if (vwrq->value < 0)
+		return 0;
+
+	if (vwrq->value > 0xffff)
+		txpwrmw = 0xffff;
+	else
+		txpwrmw = (u16) vwrq->value;
+
+	error =
+	    dev_wlc_intvar_set(dev, "qtxpower", (int)(bcm_mw_to_qdbm(txpwrmw)));
+	return error;
+}
+
+static int
+wl_iw_get_txpow(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_param *vwrq, char *extra)
+{
+	int error, disable, txpwrdbm;
+	u8 result;
+
+	WL_TRACE(("%s: SIOCGIWTXPOW\n", dev->name));
+
+	error = dev_wlc_ioctl(dev, WLC_GET_RADIO, &disable, sizeof(disable));
+	if (error)
+		return error;
+
+	error = dev_wlc_intvar_get(dev, "qtxpower", &txpwrdbm);
+	if (error)
+		return error;
+
+	disable = dtoh32(disable);
+	result = (u8) (txpwrdbm & ~WL_TXPWR_OVERRIDE);
+	vwrq->value = (s32) bcm_qdbm_to_mw(result);
+	vwrq->fixed = 0;
+	vwrq->disabled =
+	    (disable & (WL_RADIO_SW_DISABLE | WL_RADIO_HW_DISABLE)) ? 1 : 0;
+	vwrq->flags = IW_TXPOW_MWATT;
+
+	return 0;
+}
+
+#if WIRELESS_EXT > 10
+static int
+wl_iw_set_retry(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_param *vwrq, char *extra)
+{
+	int error, lrl, srl;
+
+	WL_TRACE(("%s: SIOCSIWRETRY\n", dev->name));
+
+	if (vwrq->disabled || (vwrq->flags & IW_RETRY_LIFETIME))
+		return -EINVAL;
+
+	if (vwrq->flags & IW_RETRY_LIMIT) {
+
+#if WIRELESS_EXT > 20
+		if ((vwrq->flags & IW_RETRY_LONG)
+		    || (vwrq->flags & IW_RETRY_MAX)
+		    || !((vwrq->flags & IW_RETRY_SHORT)
+			 || (vwrq->flags & IW_RETRY_MIN))) {
+#else
+		if ((vwrq->flags & IW_RETRY_MAX)
+		    || !(vwrq->flags & IW_RETRY_MIN)) {
+#endif
+			lrl = htod32(vwrq->value);
+			error = dev_wlc_ioctl(dev, WLC_SET_LRL, &lrl,
+						sizeof(lrl));
+			if (error)
+				return error;
+		}
+#if WIRELESS_EXT > 20
+		if ((vwrq->flags & IW_RETRY_SHORT)
+		    || (vwrq->flags & IW_RETRY_MIN)
+		    || !((vwrq->flags & IW_RETRY_LONG)
+			 || (vwrq->flags & IW_RETRY_MAX))) {
+#else
+		if ((vwrq->flags & IW_RETRY_MIN)
+		    || !(vwrq->flags & IW_RETRY_MAX)) {
+#endif
+			srl = htod32(vwrq->value);
+			error = dev_wlc_ioctl(dev, WLC_SET_SRL, &srl,
+						sizeof(srl));
+			if (error)
+				return error;
+		}
+	}
+	return 0;
+}
+
+static int
+wl_iw_get_retry(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_param *vwrq, char *extra)
+{
+	int error, lrl, srl;
+
+	WL_TRACE(("%s: SIOCGIWRETRY\n", dev->name));
+
+	vwrq->disabled = 0;
+
+	if ((vwrq->flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME)
+		return -EINVAL;
+
+	error = dev_wlc_ioctl(dev, WLC_GET_LRL, &lrl, sizeof(lrl));
+	if (error)
+		return error;
+
+	error = dev_wlc_ioctl(dev, WLC_GET_SRL, &srl, sizeof(srl));
+	if (error)
+		return error;
+
+	lrl = dtoh32(lrl);
+	srl = dtoh32(srl);
+
+	if (vwrq->flags & IW_RETRY_MAX) {
+		vwrq->flags = IW_RETRY_LIMIT | IW_RETRY_MAX;
+		vwrq->value = lrl;
+	} else {
+		vwrq->flags = IW_RETRY_LIMIT;
+		vwrq->value = srl;
+		if (srl != lrl)
+			vwrq->flags |= IW_RETRY_MIN;
+	}
+
+	return 0;
+}
+#endif				/* WIRELESS_EXT > 10 */
+
+static int
+wl_iw_set_encode(struct net_device *dev,
+		 struct iw_request_info *info,
+		 struct iw_point *dwrq, char *extra)
+{
+	wl_wsec_key_t key;
+	int error, val, wsec;
+
+	WL_TRACE(("%s: SIOCSIWENCODE\n", dev->name));
+
+	memset(&key, 0, sizeof(key));
+
+	if ((dwrq->flags & IW_ENCODE_INDEX) == 0) {
+		for (key.index = 0; key.index < DOT11_MAX_DEFAULT_KEYS;
+		     key.index++) {
+			val = htod32(key.index);
+			error = dev_wlc_ioctl(dev, WLC_GET_KEY_PRIMARY, &val,
+						sizeof(val));
+			if (error)
+				return error;
+			val = dtoh32(val);
+			if (val)
+				break;
+		}
+		if (key.index == DOT11_MAX_DEFAULT_KEYS)
+			key.index = 0;
+	} else {
+		key.index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
+		if (key.index >= DOT11_MAX_DEFAULT_KEYS)
+			return -EINVAL;
+	}
+
+	if (!extra || !dwrq->length || (dwrq->flags & IW_ENCODE_NOKEY)) {
+		val = htod32(key.index);
+		error = dev_wlc_ioctl(dev, WLC_SET_KEY_PRIMARY, &val,
+					sizeof(val));
+		if (error)
+			return error;
+	} else {
+		key.len = dwrq->length;
+
+		if (dwrq->length > sizeof(key.data))
+			return -EINVAL;
+
+		memcpy(key.data, extra, dwrq->length);
+
+		key.flags = WL_PRIMARY_KEY;
+		switch (key.len) {
+		case WEP1_KEY_SIZE:
+			key.algo = CRYPTO_ALGO_WEP1;
+			break;
+		case WEP128_KEY_SIZE:
+			key.algo = CRYPTO_ALGO_WEP128;
+			break;
+		case TKIP_KEY_SIZE:
+			key.algo = CRYPTO_ALGO_TKIP;
+			break;
+		case AES_KEY_SIZE:
+			key.algo = CRYPTO_ALGO_AES_CCM;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		swap_key_from_BE(&key);
+		error = dev_wlc_ioctl(dev, WLC_SET_KEY, &key, sizeof(key));
+		if (error)
+			return error;
+	}
+
+	val = (dwrq->flags & IW_ENCODE_DISABLED) ? 0 : WEP_ENABLED;
+
+	error = dev_wlc_intvar_get(dev, "wsec", &wsec);
+	if (error)
+		return error;
+
+	wsec &= ~(WEP_ENABLED);
+	wsec |= val;
+
+	error = dev_wlc_intvar_set(dev, "wsec", wsec);
+	if (error)
+		return error;
+
+	val = (dwrq->flags & IW_ENCODE_RESTRICTED) ? 1 : 0;
+	val = htod32(val);
+	error = dev_wlc_ioctl(dev, WLC_SET_AUTH, &val, sizeof(val));
+	if (error)
+		return error;
+
+	return 0;
+}
+
+static int
+wl_iw_get_encode(struct net_device *dev,
+		 struct iw_request_info *info,
+		 struct iw_point *dwrq, char *extra)
+{
+	wl_wsec_key_t key;
+	int error, val, wsec, auth;
+
+	WL_TRACE(("%s: SIOCGIWENCODE\n", dev->name));
+
+	bzero(&key, sizeof(wl_wsec_key_t));
+
+	if ((dwrq->flags & IW_ENCODE_INDEX) == 0) {
+		for (key.index = 0; key.index < DOT11_MAX_DEFAULT_KEYS;
+		     key.index++) {
+			val = key.index;
+			error = dev_wlc_ioctl(dev, WLC_GET_KEY_PRIMARY, &val,
+						sizeof(val));
+			if (error)
+				return error;
+			val = dtoh32(val);
+			if (val)
+				break;
+		}
+	} else
+		key.index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
+
+	if (key.index >= DOT11_MAX_DEFAULT_KEYS)
+		key.index = 0;
+
+	error = dev_wlc_ioctl(dev, WLC_GET_WSEC, &wsec, sizeof(wsec));
+	if (error)
+		return error;
+
+	error = dev_wlc_ioctl(dev, WLC_GET_AUTH, &auth, sizeof(auth));
+	if (error)
+		return error;
+
+	swap_key_to_BE(&key);
+
+	wsec = dtoh32(wsec);
+	auth = dtoh32(auth);
+	dwrq->length = min_t(u16, DOT11_MAX_KEY_SIZE, key.len);
+
+	dwrq->flags = key.index + 1;
+	if (!(wsec & (WEP_ENABLED | TKIP_ENABLED | AES_ENABLED)))
+		dwrq->flags |= IW_ENCODE_DISABLED;
+
+	if (auth)
+		dwrq->flags |= IW_ENCODE_RESTRICTED;
+
+	if (dwrq->length && extra)
+		memcpy(extra, key.data, dwrq->length);
+
+	return 0;
+}
+
+static int
+wl_iw_set_power(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_param *vwrq, char *extra)
+{
+	int error, pm;
+
+	WL_TRACE(("%s: SIOCSIWPOWER\n", dev->name));
+
+	pm = vwrq->disabled ? PM_OFF : PM_MAX;
+
+	pm = htod32(pm);
+	error = dev_wlc_ioctl(dev, WLC_SET_PM, &pm, sizeof(pm));
+	if (error)
+		return error;
+
+	return 0;
+}
+
+static int
+wl_iw_get_power(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_param *vwrq, char *extra)
+{
+	int error, pm;
+
+	WL_TRACE(("%s: SIOCGIWPOWER\n", dev->name));
+
+	error = dev_wlc_ioctl(dev, WLC_GET_PM, &pm, sizeof(pm));
+	if (error)
+		return error;
+
+	pm = dtoh32(pm);
+	vwrq->disabled = pm ? 0 : 1;
+	vwrq->flags = IW_POWER_ALL_R;
+
+	return 0;
+}
+
+#if WIRELESS_EXT > 17
+static int
+wl_iw_set_wpaie(struct net_device *dev,
+		struct iw_request_info *info, struct iw_point *iwp, char *extra)
+{
+
+	WL_TRACE(("%s: SIOCSIWGENIE\n", dev->name));
+
+	CHECK_EXTRA_FOR_NULL(extra);
+
+	dev_wlc_bufvar_set(dev, "wpaie", extra, iwp->length);
+
+	return 0;
+}
+
+static int
+wl_iw_get_wpaie(struct net_device *dev,
+		struct iw_request_info *info, struct iw_point *iwp, char *extra)
+{
+	WL_TRACE(("%s: SIOCGIWGENIE\n", dev->name));
+	iwp->length = 64;
+	dev_wlc_bufvar_get(dev, "wpaie", extra, iwp->length);
+	return 0;
+}
+
+static int
+wl_iw_set_encodeext(struct net_device *dev,
+		    struct iw_request_info *info,
+		    struct iw_point *dwrq, char *extra)
+{
+	wl_wsec_key_t key;
+	int error;
+	struct iw_encode_ext *iwe;
+
+	WL_TRACE(("%s: SIOCSIWENCODEEXT\n", dev->name));
+
+	CHECK_EXTRA_FOR_NULL(extra);
+
+	memset(&key, 0, sizeof(key));
+	iwe = (struct iw_encode_ext *)extra;
+
+	if (dwrq->flags & IW_ENCODE_DISABLED) {
+
+	}
+
+	key.index = 0;
+	if (dwrq->flags & IW_ENCODE_INDEX)
+		key.index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
+
+	key.len = iwe->key_len;
+
+	if (!ETHER_ISMULTI(iwe->addr.sa_data))
+		bcopy((void *)&iwe->addr.sa_data, (char *)&key.ea,
+		      ETHER_ADDR_LEN);
+
+	if (key.len == 0) {
+		if (iwe->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+			WL_WSEC(("Changing the the primary Key to %d\n",
+				 key.index));
+			key.index = htod32(key.index);
+			error = dev_wlc_ioctl(dev, WLC_SET_KEY_PRIMARY,
+					      &key.index, sizeof(key.index));
+			if (error)
+				return error;
+		} else {
+			swap_key_from_BE(&key);
+			dev_wlc_ioctl(dev, WLC_SET_KEY, &key, sizeof(key));
+		}
+	} else {
+		if (iwe->key_len > sizeof(key.data))
+			return -EINVAL;
+
+		WL_WSEC(("Setting the key index %d\n", key.index));
+		if (iwe->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+			WL_WSEC(("key is a Primary Key\n"));
+			key.flags = WL_PRIMARY_KEY;
+		}
+
+		bcopy((void *)iwe->key, key.data, iwe->key_len);
+
+		if (iwe->alg == IW_ENCODE_ALG_TKIP) {
+			u8 keybuf[8];
+			bcopy(&key.data[24], keybuf, sizeof(keybuf));
+			bcopy(&key.data[16], &key.data[24], sizeof(keybuf));
+			bcopy(keybuf, &key.data[16], sizeof(keybuf));
+		}
+
+		if (iwe->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) {
+			unsigned char *ivptr;
+			ivptr = (unsigned char *) iwe->rx_seq;
+			key.rxiv.hi = (ivptr[5] << 24) | (ivptr[4] << 16) |
+			    (ivptr[3] << 8) | ivptr[2];
+			key.rxiv.lo = (ivptr[1] << 8) | ivptr[0];
+			key.iv_initialized = true;
+		}
+
+		switch (iwe->alg) {
+		case IW_ENCODE_ALG_NONE:
+			key.algo = CRYPTO_ALGO_OFF;
+			break;
+		case IW_ENCODE_ALG_WEP:
+			if (iwe->key_len == WEP1_KEY_SIZE)
+				key.algo = CRYPTO_ALGO_WEP1;
+			else
+				key.algo = CRYPTO_ALGO_WEP128;
+			break;
+		case IW_ENCODE_ALG_TKIP:
+			key.algo = CRYPTO_ALGO_TKIP;
+			break;
+		case IW_ENCODE_ALG_CCMP:
+			key.algo = CRYPTO_ALGO_AES_CCM;
+			break;
+		default:
+			break;
+		}
+		swap_key_from_BE(&key);
+
+		dhd_wait_pend8021x(dev);
+
+		error = dev_wlc_ioctl(dev, WLC_SET_KEY, &key, sizeof(key));
+		if (error)
+			return error;
+	}
+	return 0;
+}
+
+#if WIRELESS_EXT > 17
+struct {
+	pmkid_list_t pmkids;
+	pmkid_t foo[MAXPMKID - 1];
+} pmkid_list;
+
+static int
+wl_iw_set_pmksa(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_param *vwrq, char *extra)
+{
+	struct iw_pmksa *iwpmksa;
+	uint i;
+	int ret = 0;
+
+	WL_WSEC(("%s: SIOCSIWPMKSA\n", dev->name));
+
+	CHECK_EXTRA_FOR_NULL(extra);
+
+	iwpmksa = (struct iw_pmksa *)extra;
+
+	if (iwpmksa->cmd == IW_PMKSA_FLUSH) {
+		WL_WSEC(("wl_iw_set_pmksa - IW_PMKSA_FLUSH\n"));
+		bzero((char *)&pmkid_list, sizeof(pmkid_list));
+	}
+
+	else if (iwpmksa->cmd == IW_PMKSA_REMOVE) {
+		{
+			pmkid_list_t pmkid, *pmkidptr;
+			uint j;
+			pmkidptr = &pmkid;
+
+			bcopy(&iwpmksa->bssid.sa_data[0],
+			      &pmkidptr->pmkid[0].BSSID, ETHER_ADDR_LEN);
+			bcopy(&iwpmksa->pmkid[0], &pmkidptr->pmkid[0].PMKID,
+			      WPA2_PMKID_LEN);
+
+			WL_WSEC(("wl_iw_set_pmksa:IW_PMKSA_REMOVE:PMKID: "
+				"%pM = ", &pmkidptr->pmkid[0].BSSID));
+			for (j = 0; j < WPA2_PMKID_LEN; j++)
+				WL_WSEC(("%02x ", pmkidptr->pmkid[0].PMKID[j]));
+			WL_WSEC(("\n"));
+		}
+
+		for (i = 0; i < pmkid_list.pmkids.npmkid; i++)
+			if (!bcmp
+			    (&iwpmksa->bssid.sa_data[0],
+			     &pmkid_list.pmkids.pmkid[i].BSSID, ETHER_ADDR_LEN))
+				break;
+
+		if ((pmkid_list.pmkids.npmkid > 0)
+		    && (i < pmkid_list.pmkids.npmkid)) {
+			bzero(&pmkid_list.pmkids.pmkid[i], sizeof(pmkid_t));
+			for (; i < (pmkid_list.pmkids.npmkid - 1); i++) {
+				bcopy(&pmkid_list.pmkids.pmkid[i + 1].BSSID,
+				      &pmkid_list.pmkids.pmkid[i].BSSID,
+				      ETHER_ADDR_LEN);
+				bcopy(&pmkid_list.pmkids.pmkid[i + 1].PMKID,
+				      &pmkid_list.pmkids.pmkid[i].PMKID,
+				      WPA2_PMKID_LEN);
+			}
+			pmkid_list.pmkids.npmkid--;
+		} else
+			ret = -EINVAL;
+	}
+
+	else if (iwpmksa->cmd == IW_PMKSA_ADD) {
+		for (i = 0; i < pmkid_list.pmkids.npmkid; i++)
+			if (!bcmp
+			    (&iwpmksa->bssid.sa_data[0],
+			     &pmkid_list.pmkids.pmkid[i].BSSID, ETHER_ADDR_LEN))
+				break;
+		if (i < MAXPMKID) {
+			bcopy(&iwpmksa->bssid.sa_data[0],
+			      &pmkid_list.pmkids.pmkid[i].BSSID,
+			      ETHER_ADDR_LEN);
+			bcopy(&iwpmksa->pmkid[0],
+			      &pmkid_list.pmkids.pmkid[i].PMKID,
+			      WPA2_PMKID_LEN);
+			if (i == pmkid_list.pmkids.npmkid)
+				pmkid_list.pmkids.npmkid++;
+		} else
+			ret = -EINVAL;
+		{
+			uint j;
+			uint k;
+			k = pmkid_list.pmkids.npmkid;
+			WL_WSEC(("wl_iw_set_pmksa,IW_PMKSA_ADD - PMKID: %pM = ",
+				&pmkid_list.pmkids.pmkid[k].BSSID));
+			for (j = 0; j < WPA2_PMKID_LEN; j++)
+				WL_WSEC(("%02x ",
+					 pmkid_list.pmkids.pmkid[k].PMKID[j]));
+			WL_WSEC(("\n"));
+		}
+	}
+	WL_WSEC(("PRINTING pmkid LIST - No of elements %d\n",
+		 pmkid_list.pmkids.npmkid));
+	for (i = 0; i < pmkid_list.pmkids.npmkid; i++) {
+		uint j;
+		WL_WSEC(("PMKID[%d]: %pM = ", i,
+			&pmkid_list.pmkids.pmkid[i].BSSID));
+		for (j = 0; j < WPA2_PMKID_LEN; j++)
+			WL_WSEC(("%02x ", pmkid_list.pmkids.pmkid[i].PMKID[j]));
+		WL_WSEC(("\n"));
+	}
+	WL_WSEC(("\n"));
+
+	if (!ret)
+		ret = dev_wlc_bufvar_set(dev, "pmkid_info", (char *)&pmkid_list,
+					 sizeof(pmkid_list));
+	return ret;
+}
+#endif				/* WIRELESS_EXT > 17 */
+
+static int
+wl_iw_get_encodeext(struct net_device *dev,
+		    struct iw_request_info *info,
+		    struct iw_param *vwrq, char *extra)
+{
+	WL_TRACE(("%s: SIOCGIWENCODEEXT\n", dev->name));
+	return 0;
+}
+
+static int
+wl_iw_set_wpaauth(struct net_device *dev,
+		  struct iw_request_info *info,
+		  struct iw_param *vwrq, char *extra)
+{
+	int error = 0;
+	int paramid;
+	int paramval;
+	int val = 0;
+	wl_iw_t *iw = *(wl_iw_t **) netdev_priv(dev);
+
+	WL_TRACE(("%s: SIOCSIWAUTH\n", dev->name));
+
+	paramid = vwrq->flags & IW_AUTH_INDEX;
+	paramval = vwrq->value;
+
+	WL_TRACE(("%s: SIOCSIWAUTH, paramid = 0x%0x, paramval = 0x%0x\n",
+		  dev->name, paramid, paramval));
+
+	switch (paramid) {
+	case IW_AUTH_WPA_VERSION:
+		if (paramval & IW_AUTH_WPA_VERSION_DISABLED)
+			val = WPA_AUTH_DISABLED;
+		else if (paramval & (IW_AUTH_WPA_VERSION_WPA))
+			val = WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED;
+		else if (paramval & IW_AUTH_WPA_VERSION_WPA2)
+			val = WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED;
+		WL_INFORM(("%s: %d: setting wpa_auth to 0x%0x\n", __func__,
+			   __LINE__, val));
+		error = dev_wlc_intvar_set(dev, "wpa_auth", val);
+		if (error)
+			return error;
+		break;
+	case IW_AUTH_CIPHER_PAIRWISE:
+	case IW_AUTH_CIPHER_GROUP:
+		if (paramval & (IW_AUTH_CIPHER_WEP40 | IW_AUTH_CIPHER_WEP104))
+			val = WEP_ENABLED;
+		if (paramval & IW_AUTH_CIPHER_TKIP)
+			val = TKIP_ENABLED;
+		if (paramval & IW_AUTH_CIPHER_CCMP)
+			val = AES_ENABLED;
+
+		if (paramid == IW_AUTH_CIPHER_PAIRWISE) {
+			iw->pwsec = val;
+			val |= iw->gwsec;
+		} else {
+			iw->gwsec = val;
+			val |= iw->pwsec;
+		}
+
+		if (iw->privacy_invoked && !val) {
+			WL_WSEC(("%s: %s: 'Privacy invoked' true but clearing "
+				"wsec, assuming " "we're a WPS enrollee\n",
+				dev->name, __func__));
+			error = dev_wlc_intvar_set(dev, "is_WPS_enrollee",
+							true);
+			if (error) {
+				WL_WSEC(("Failed to set is_WPS_enrollee\n"));
+				return error;
+			}
+		} else if (val) {
+			error = dev_wlc_intvar_set(dev, "is_WPS_enrollee",
+							false);
+			if (error) {
+				WL_WSEC(("Failed to clear is_WPS_enrollee\n"));
+				return error;
+			}
+		}
+
+		error = dev_wlc_intvar_set(dev, "wsec", val);
+		if (error)
+			return error;
+
+		break;
+
+	case IW_AUTH_KEY_MGMT:
+		error = dev_wlc_intvar_get(dev, "wpa_auth", &val);
+		if (error)
+			return error;
+
+		if (val & (WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED)) {
+			if (paramval & IW_AUTH_KEY_MGMT_PSK)
+				val = WPA_AUTH_PSK;
+			else
+				val = WPA_AUTH_UNSPECIFIED;
+		} else if (val & (WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED)) {
+			if (paramval & IW_AUTH_KEY_MGMT_PSK)
+				val = WPA2_AUTH_PSK;
+			else
+				val = WPA2_AUTH_UNSPECIFIED;
+		}
+		WL_INFORM(("%s: %d: setting wpa_auth to %d\n", __func__,
+			   __LINE__, val));
+		error = dev_wlc_intvar_set(dev, "wpa_auth", val);
+		if (error)
+			return error;
+
+		break;
+	case IW_AUTH_TKIP_COUNTERMEASURES:
+		dev_wlc_bufvar_set(dev, "tkip_countermeasures",
+				   (char *)&paramval, 1);
+		break;
+
+	case IW_AUTH_80211_AUTH_ALG:
+		WL_INFORM(("Setting the D11auth %d\n", paramval));
+		if (paramval == IW_AUTH_ALG_OPEN_SYSTEM)
+			val = 0;
+		else if (paramval == IW_AUTH_ALG_SHARED_KEY)
+			val = 1;
+		else if (paramval ==
+			 (IW_AUTH_ALG_OPEN_SYSTEM | IW_AUTH_ALG_SHARED_KEY))
+			val = 2;
+		else
+			error = 1;
+		if (!error) {
+			error = dev_wlc_intvar_set(dev, "auth", val);
+			if (error)
+				return error;
+		}
+		break;
+
+	case IW_AUTH_WPA_ENABLED:
+		if (paramval == 0) {
+			iw->pwsec = 0;
+			iw->gwsec = 0;
+			error = dev_wlc_intvar_get(dev, "wsec", &val);
+			if (error)
+				return error;
+			if (val & (TKIP_ENABLED | AES_ENABLED)) {
+				val &= ~(TKIP_ENABLED | AES_ENABLED);
+				dev_wlc_intvar_set(dev, "wsec", val);
+			}
+			val = 0;
+			WL_INFORM(("%s: %d: setting wpa_auth to %d\n",
+				   __func__, __LINE__, val));
+			dev_wlc_intvar_set(dev, "wpa_auth", 0);
+			return error;
+		}
+		break;
+
+	case IW_AUTH_DROP_UNENCRYPTED:
+		dev_wlc_bufvar_set(dev, "wsec_restrict", (char *)&paramval, 1);
+		break;
+
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+		dev_wlc_bufvar_set(dev, "rx_unencrypted_eapol",
+				   (char *)&paramval, 1);
+		break;
+
+#if WIRELESS_EXT > 17
+	case IW_AUTH_ROAMING_CONTROL:
+		WL_INFORM(("%s: IW_AUTH_ROAMING_CONTROL\n", __func__));
+		break;
+	case IW_AUTH_PRIVACY_INVOKED:
+		{
+			int wsec;
+
+			if (paramval == 0) {
+				iw->privacy_invoked = false;
+				error = dev_wlc_intvar_set(dev,
+						"is_WPS_enrollee", false);
+				if (error) {
+					WL_WSEC(("Failed to clear iovar "
+						"is_WPS_enrollee\n"));
+					return error;
+				}
+			} else {
+				iw->privacy_invoked = true;
+				error = dev_wlc_intvar_get(dev, "wsec", &wsec);
+				if (error)
+					return error;
+
+				if (!(IW_WSEC_ENABLED(wsec))) {
+					error = dev_wlc_intvar_set(dev,
+							"is_WPS_enrollee",
+							true);
+					if (error) {
+						WL_WSEC(("Failed to set iovar "
+						"is_WPS_enrollee\n"));
+						return error;
+					}
+				} else {
+					error = dev_wlc_intvar_set(dev,
+							"is_WPS_enrollee",
+							false);
+					if (error) {
+						WL_WSEC(("Failed to clear "
+							"is_WPS_enrollee\n"));
+						return error;
+					}
+				}
+			}
+			break;
+		}
+#endif				/* WIRELESS_EXT > 17 */
+	default:
+		break;
+	}
+	return 0;
+}
+
+#define VAL_PSK(_val) (((_val) & WPA_AUTH_PSK) || ((_val) & WPA2_AUTH_PSK))
+
+static int
+wl_iw_get_wpaauth(struct net_device *dev,
+		  struct iw_request_info *info,
+		  struct iw_param *vwrq, char *extra)
+{
+	int error;
+	int paramid;
+	int paramval = 0;
+	int val;
+	wl_iw_t *iw = *(wl_iw_t **) netdev_priv(dev);
+
+	WL_TRACE(("%s: SIOCGIWAUTH\n", dev->name));
+
+	paramid = vwrq->flags & IW_AUTH_INDEX;
+
+	switch (paramid) {
+	case IW_AUTH_WPA_VERSION:
+		error = dev_wlc_intvar_get(dev, "wpa_auth", &val);
+		if (error)
+			return error;
+		if (val & (WPA_AUTH_NONE | WPA_AUTH_DISABLED))
+			paramval = IW_AUTH_WPA_VERSION_DISABLED;
+		else if (val & (WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED))
+			paramval = IW_AUTH_WPA_VERSION_WPA;
+		else if (val & (WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED))
+			paramval = IW_AUTH_WPA_VERSION_WPA2;
+		break;
+	case IW_AUTH_CIPHER_PAIRWISE:
+	case IW_AUTH_CIPHER_GROUP:
+		if (paramid == IW_AUTH_CIPHER_PAIRWISE)
+			val = iw->pwsec;
+		else
+			val = iw->gwsec;
+
+		paramval = 0;
+		if (val) {
+			if (val & WEP_ENABLED)
+				paramval |=
+				    (IW_AUTH_CIPHER_WEP40 |
+				     IW_AUTH_CIPHER_WEP104);
+			if (val & TKIP_ENABLED)
+				paramval |= (IW_AUTH_CIPHER_TKIP);
+			if (val & AES_ENABLED)
+				paramval |= (IW_AUTH_CIPHER_CCMP);
+		} else
+			paramval = IW_AUTH_CIPHER_NONE;
+		break;
+	case IW_AUTH_KEY_MGMT:
+		error = dev_wlc_intvar_get(dev, "wpa_auth", &val);
+		if (error)
+			return error;
+		if (VAL_PSK(val))
+			paramval = IW_AUTH_KEY_MGMT_PSK;
+		else
+			paramval = IW_AUTH_KEY_MGMT_802_1X;
+
+		break;
+	case IW_AUTH_TKIP_COUNTERMEASURES:
+		dev_wlc_bufvar_get(dev, "tkip_countermeasures",
+				   (char *)&paramval, 1);
+		break;
+
+	case IW_AUTH_DROP_UNENCRYPTED:
+		dev_wlc_bufvar_get(dev, "wsec_restrict", (char *)&paramval, 1);
+		break;
+
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+		dev_wlc_bufvar_get(dev, "rx_unencrypted_eapol",
+				   (char *)&paramval, 1);
+		break;
+
+	case IW_AUTH_80211_AUTH_ALG:
+		error = dev_wlc_intvar_get(dev, "auth", &val);
+		if (error)
+			return error;
+		if (!val)
+			paramval = IW_AUTH_ALG_OPEN_SYSTEM;
+		else
+			paramval = IW_AUTH_ALG_SHARED_KEY;
+		break;
+	case IW_AUTH_WPA_ENABLED:
+		error = dev_wlc_intvar_get(dev, "wpa_auth", &val);
+		if (error)
+			return error;
+		if (val)
+			paramval = true;
+		else
+			paramval = false;
+		break;
+#if WIRELESS_EXT > 17
+	case IW_AUTH_ROAMING_CONTROL:
+		WL_ERROR(("%s: IW_AUTH_ROAMING_CONTROL\n", __func__));
+		break;
+	case IW_AUTH_PRIVACY_INVOKED:
+		paramval = iw->privacy_invoked;
+		break;
+
+#endif
+	}
+	vwrq->value = paramval;
+	return 0;
+}
+#endif				/* WIRELESS_EXT > 17 */
+
+static const iw_handler wl_iw_handler[] = {
+	(iw_handler) wl_iw_config_commit,
+	(iw_handler) wl_iw_get_name,
+	(iw_handler) NULL,
+	(iw_handler) NULL,
+	(iw_handler) wl_iw_set_freq,
+	(iw_handler) wl_iw_get_freq,
+	(iw_handler) wl_iw_set_mode,
+	(iw_handler) wl_iw_get_mode,
+	(iw_handler) NULL,
+	(iw_handler) NULL,
+	(iw_handler) NULL,
+	(iw_handler) wl_iw_get_range,
+	(iw_handler) NULL,
+	(iw_handler) NULL,
+	(iw_handler) NULL,
+	(iw_handler) NULL,
+	(iw_handler) wl_iw_set_spy,
+	(iw_handler) wl_iw_get_spy,
+	(iw_handler) NULL,
+	(iw_handler) NULL,
+	(iw_handler) wl_iw_set_wap,
+	(iw_handler) wl_iw_get_wap,
+#if WIRELESS_EXT > 17
+	(iw_handler) wl_iw_mlme,
+#else
+	(iw_handler) NULL,
+#endif
+#if defined(WL_IW_USE_ISCAN)
+	(iw_handler) wl_iw_iscan_get_aplist,
+#else
+	(iw_handler) wl_iw_get_aplist,
+#endif
+#if WIRELESS_EXT > 13
+#if defined(WL_IW_USE_ISCAN)
+	(iw_handler) wl_iw_iscan_set_scan,
+	(iw_handler) wl_iw_iscan_get_scan,
+#else
+	(iw_handler) wl_iw_set_scan,
+	(iw_handler) wl_iw_get_scan,
+#endif
+#else
+	(iw_handler) NULL,
+	(iw_handler) NULL,
+#endif				/* WIRELESS_EXT > 13 */
+	(iw_handler) wl_iw_set_essid,
+	(iw_handler) wl_iw_get_essid,
+	(iw_handler) wl_iw_set_nick,
+	(iw_handler) wl_iw_get_nick,
+	(iw_handler) NULL,
+	(iw_handler) NULL,
+	(iw_handler) wl_iw_set_rate,
+	(iw_handler) wl_iw_get_rate,
+	(iw_handler) wl_iw_set_rts,
+	(iw_handler) wl_iw_get_rts,
+	(iw_handler) wl_iw_set_frag,
+	(iw_handler) wl_iw_get_frag,
+	(iw_handler) wl_iw_set_txpow,
+	(iw_handler) wl_iw_get_txpow,
+#if WIRELESS_EXT > 10
+	(iw_handler) wl_iw_set_retry,
+	(iw_handler) wl_iw_get_retry,
+#endif
+	(iw_handler) wl_iw_set_encode,
+	(iw_handler) wl_iw_get_encode,
+	(iw_handler) wl_iw_set_power,
+	(iw_handler) wl_iw_get_power,
+#if WIRELESS_EXT > 17
+	(iw_handler) NULL,
+	(iw_handler) NULL,
+	(iw_handler) wl_iw_set_wpaie,
+	(iw_handler) wl_iw_get_wpaie,
+	(iw_handler) wl_iw_set_wpaauth,
+	(iw_handler) wl_iw_get_wpaauth,
+	(iw_handler) wl_iw_set_encodeext,
+	(iw_handler) wl_iw_get_encodeext,
+	(iw_handler) wl_iw_set_pmksa,
+#endif				/* WIRELESS_EXT > 17 */
+};
+
+#if WIRELESS_EXT > 12
+
+const struct iw_handler_def wl_iw_handler_def = {
+	.num_standard = ARRAY_SIZE(wl_iw_handler),
+	.standard = (iw_handler *) wl_iw_handler,
+	.num_private = 0,
+	.num_private_args = 0,
+	.private = 0,
+	.private_args = 0,
+
+#if WIRELESS_EXT >= 19
+	.get_wireless_stats = dhd_get_wireless_stats,
+#endif
+};
+#endif				/* WIRELESS_EXT > 12 */
+
+int wl_iw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct iwreq *wrq = (struct iwreq *)rq;
+	struct iw_request_info info;
+	iw_handler handler;
+	char *extra = NULL;
+	int token_size = 1, max_tokens = 0, ret = 0;
+
+	WL_TRACE(("\n%s, cmd:%x alled via dhd->do_ioctl()entry point\n",
+		  __func__, cmd));
+	if (cmd < SIOCIWFIRST ||
+		IW_IOCTL_IDX(cmd) >= ARRAY_SIZE(wl_iw_handler)) {
+		WL_ERROR(("%s: error in cmd=%x : out of range\n", __func__,
+			cmd));
+		return -EOPNOTSUPP;
+	}
+
+	handler = wl_iw_handler[IW_IOCTL_IDX(cmd)];
+	if (!handler) {
+		WL_ERROR(("%s: error in cmd=%x : not supported\n",
+			__func__, cmd));
+		return -EOPNOTSUPP;
+	}
+
+	switch (cmd) {
+
+	case SIOCSIWESSID:
+	case SIOCGIWESSID:
+	case SIOCSIWNICKN:
+	case SIOCGIWNICKN:
+		max_tokens = IW_ESSID_MAX_SIZE + 1;
+		break;
+
+	case SIOCSIWENCODE:
+	case SIOCGIWENCODE:
+#if WIRELESS_EXT > 17
+	case SIOCSIWENCODEEXT:
+	case SIOCGIWENCODEEXT:
+#endif
+		max_tokens = wrq->u.data.length;
+		break;
+
+	case SIOCGIWRANGE:
+		max_tokens = sizeof(struct iw_range) + 500;
+		break;
+
+	case SIOCGIWAPLIST:
+		token_size =
+		    sizeof(struct sockaddr) + sizeof(struct iw_quality);
+		max_tokens = IW_MAX_AP;
+		break;
+
+#if WIRELESS_EXT > 13
+	case SIOCGIWSCAN:
+#if defined(WL_IW_USE_ISCAN)
+		if (g_iscan)
+			max_tokens = wrq->u.data.length;
+		else
+#endif
+			max_tokens = IW_SCAN_MAX_DATA;
+		break;
+#endif				/* WIRELESS_EXT > 13 */
+
+	case SIOCSIWSPY:
+		token_size = sizeof(struct sockaddr);
+		max_tokens = IW_MAX_SPY;
+		break;
+
+	case SIOCGIWSPY:
+		token_size =
+		    sizeof(struct sockaddr) + sizeof(struct iw_quality);
+		max_tokens = IW_MAX_SPY;
+		break;
+
+#if WIRELESS_EXT > 17
+	case SIOCSIWPMKSA:
+	case SIOCSIWGENIE:
+#endif
+	case SIOCSIWPRIV:
+		max_tokens = wrq->u.data.length;
+		break;
+	}
+
+	if (max_tokens && wrq->u.data.pointer) {
+		if (wrq->u.data.length > max_tokens) {
+			WL_ERROR(("%s: error in cmd=%x wrq->u.data.length=%d "
+			"> max_tokens=%d\n",
+			__func__, cmd, wrq->u.data.length, max_tokens));
+			return -E2BIG;
+		}
+		extra = kmalloc(max_tokens * token_size, GFP_KERNEL);
+		if (!extra)
+			return -ENOMEM;
+
+		if (copy_from_user
+		    (extra, wrq->u.data.pointer,
+		     wrq->u.data.length * token_size)) {
+			kfree(extra);
+			return -EFAULT;
+		}
+	}
+
+	info.cmd = cmd;
+	info.flags = 0;
+
+	ret = handler(dev, &info, &wrq->u, extra);
+
+	if (extra) {
+		if (copy_to_user
+		    (wrq->u.data.pointer, extra,
+		     wrq->u.data.length * token_size)) {
+			kfree(extra);
+			return -EFAULT;
+		}
+
+		kfree(extra);
+	}
+
+	return ret;
+}
+
+bool
+wl_iw_conn_status_str(u32 event_type, u32 status, u32 reason,
+		      char *stringBuf, uint buflen)
+{
+	typedef struct conn_fail_event_map_t {
+		u32 inEvent;
+		u32 inStatus;
+		u32 inReason;
+		const char *outName;
+		const char *outCause;
+	} conn_fail_event_map_t;
+
+#define WL_IW_DONT_CARE	9999
+	const conn_fail_event_map_t event_map[] = {
+		{WLC_E_SET_SSID, WLC_E_STATUS_SUCCESS, WL_IW_DONT_CARE,
+		 "Conn", "Success"},
+		{WLC_E_SET_SSID, WLC_E_STATUS_NO_NETWORKS, WL_IW_DONT_CARE,
+		 "Conn", "NoNetworks"},
+		{WLC_E_SET_SSID, WLC_E_STATUS_FAIL, WL_IW_DONT_CARE,
+		 "Conn", "ConfigMismatch"},
+		{WLC_E_PRUNE, WL_IW_DONT_CARE, WLC_E_PRUNE_ENCR_MISMATCH,
+		 "Conn", "EncrypMismatch"},
+		{WLC_E_PRUNE, WL_IW_DONT_CARE, WLC_E_RSN_MISMATCH,
+		 "Conn", "RsnMismatch"},
+		{WLC_E_AUTH, WLC_E_STATUS_TIMEOUT, WL_IW_DONT_CARE,
+		 "Conn", "AuthTimeout"},
+		{WLC_E_AUTH, WLC_E_STATUS_FAIL, WL_IW_DONT_CARE,
+		 "Conn", "AuthFail"},
+		{WLC_E_AUTH, WLC_E_STATUS_NO_ACK, WL_IW_DONT_CARE,
+		 "Conn", "AuthNoAck"},
+		{WLC_E_REASSOC, WLC_E_STATUS_FAIL, WL_IW_DONT_CARE,
+		 "Conn", "ReassocFail"},
+		{WLC_E_REASSOC, WLC_E_STATUS_TIMEOUT, WL_IW_DONT_CARE,
+		 "Conn", "ReassocTimeout"},
+		{WLC_E_REASSOC, WLC_E_STATUS_ABORT, WL_IW_DONT_CARE,
+		 "Conn", "ReassocAbort"},
+		{WLC_E_PSK_SUP, WLC_SUP_KEYED, WL_IW_DONT_CARE,
+		 "Sup", "ConnSuccess"},
+		{WLC_E_PSK_SUP, WL_IW_DONT_CARE, WL_IW_DONT_CARE,
+		 "Sup", "WpaHandshakeFail"},
+		{WLC_E_DEAUTH_IND, WL_IW_DONT_CARE, WL_IW_DONT_CARE,
+		 "Conn", "Deauth"},
+		{WLC_E_DISASSOC_IND, WL_IW_DONT_CARE, WL_IW_DONT_CARE,
+		 "Conn", "DisassocInd"},
+		{WLC_E_DISASSOC, WL_IW_DONT_CARE, WL_IW_DONT_CARE,
+		 "Conn", "Disassoc"}
+	};
+
+	const char *name = "";
+	const char *cause = NULL;
+	int i;
+
+	for (i = 0; i < sizeof(event_map) / sizeof(event_map[0]); i++) {
+		const conn_fail_event_map_t *row = &event_map[i];
+		if (row->inEvent == event_type &&
+		    (row->inStatus == status
+		     || row->inStatus == WL_IW_DONT_CARE)
+		    && (row->inReason == reason
+			|| row->inReason == WL_IW_DONT_CARE)) {
+			name = row->outName;
+			cause = row->outCause;
+			break;
+		}
+	}
+
+	if (cause) {
+		memset(stringBuf, 0, buflen);
+		snprintf(stringBuf, buflen, "%s %s %02d %02d",
+			 name, cause, status, reason);
+		WL_INFORM(("Connection status: %s\n", stringBuf));
+		return true;
+	} else {
+		return false;
+	}
+}
+
+#if WIRELESS_EXT > 14
+
+static bool
+wl_iw_check_conn_fail(wl_event_msg_t *e, char *stringBuf, uint buflen)
+{
+	u32 event = ntoh32(e->event_type);
+	u32 status = ntoh32(e->status);
+	u32 reason = ntoh32(e->reason);
+
+	if (wl_iw_conn_status_str(event, status, reason, stringBuf, buflen)) {
+		return true;
+	} else
+		return false;
+}
+#endif
+
+#ifndef IW_CUSTOM_MAX
+#define IW_CUSTOM_MAX 256
+#endif
+
+void wl_iw_event(struct net_device *dev, wl_event_msg_t *e, void *data)
+{
+#if WIRELESS_EXT > 13
+	union iwreq_data wrqu;
+	char extra[IW_CUSTOM_MAX + 1];
+	int cmd = 0;
+	u32 event_type = ntoh32(e->event_type);
+	u16 flags = ntoh16(e->flags);
+	u32 datalen = ntoh32(e->datalen);
+	u32 status = ntoh32(e->status);
+	wl_iw_t *iw;
+	u32 toto;
+	memset(&wrqu, 0, sizeof(wrqu));
+	memset(extra, 0, sizeof(extra));
+	iw = 0;
+
+	if (!dev) {
+		WL_ERROR(("%s: dev is null\n", __func__));
+		return;
+	}
+
+	iw = *(wl_iw_t **) netdev_priv(dev);
+
+	WL_TRACE(("%s: dev=%s event=%d\n", __func__, dev->name, event_type));
+
+	switch (event_type) {
+	case WLC_E_TXFAIL:
+		cmd = IWEVTXDROP;
+		memcpy(wrqu.addr.sa_data, &e->addr, ETHER_ADDR_LEN);
+		wrqu.addr.sa_family = ARPHRD_ETHER;
+		break;
+#if WIRELESS_EXT > 14
+	case WLC_E_JOIN:
+	case WLC_E_ASSOC_IND:
+	case WLC_E_REASSOC_IND:
+		memcpy(wrqu.addr.sa_data, &e->addr, ETHER_ADDR_LEN);
+		wrqu.addr.sa_family = ARPHRD_ETHER;
+		cmd = IWEVREGISTERED;
+		break;
+	case WLC_E_DEAUTH_IND:
+	case WLC_E_DISASSOC_IND:
+		cmd = SIOCGIWAP;
+		bzero(wrqu.addr.sa_data, ETHER_ADDR_LEN);
+		wrqu.addr.sa_family = ARPHRD_ETHER;
+		bzero(&extra, ETHER_ADDR_LEN);
+		break;
+	case WLC_E_LINK:
+	case WLC_E_NDIS_LINK:
+		cmd = SIOCGIWAP;
+		if (!(flags & WLC_EVENT_MSG_LINK)) {
+			bzero(wrqu.addr.sa_data, ETHER_ADDR_LEN);
+			bzero(&extra, ETHER_ADDR_LEN);
+			WAKE_LOCK_TIMEOUT(iw->pub, WAKE_LOCK_LINK_DOWN_TMOUT,
+					  20 * HZ);
+		} else {
+			memcpy(wrqu.addr.sa_data, &e->addr, ETHER_ADDR_LEN);
+			WL_TRACE(("Link UP\n"));
+
+		}
+		wrqu.addr.sa_family = ARPHRD_ETHER;
+		break;
+	case WLC_E_ACTION_FRAME:
+		cmd = IWEVCUSTOM;
+		if (datalen + 1 <= sizeof(extra)) {
+			wrqu.data.length = datalen + 1;
+			extra[0] = WLC_E_ACTION_FRAME;
+			memcpy(&extra[1], data, datalen);
+			WL_TRACE(("WLC_E_ACTION_FRAME len %d \n",
+				  wrqu.data.length));
+		}
+		break;
+
+	case WLC_E_ACTION_FRAME_COMPLETE:
+		cmd = IWEVCUSTOM;
+		memcpy(&toto, data, 4);
+		if (sizeof(status) + 1 <= sizeof(extra)) {
+			wrqu.data.length = sizeof(status) + 1;
+			extra[0] = WLC_E_ACTION_FRAME_COMPLETE;
+			memcpy(&extra[1], &status, sizeof(status));
+			printf("wl_iw_event status %d PacketId %d\n", status,
+			       toto);
+			printf("WLC_E_ACTION_FRAME_COMPLETE len %d\n",
+			       wrqu.data.length);
+		}
+		break;
+#endif				/* WIRELESS_EXT > 14 */
+#if WIRELESS_EXT > 17
+	case WLC_E_MIC_ERROR:
+		{
+			struct iw_michaelmicfailure *micerrevt =
+			    (struct iw_michaelmicfailure *)&extra;
+			cmd = IWEVMICHAELMICFAILURE;
+			wrqu.data.length = sizeof(struct iw_michaelmicfailure);
+			if (flags & WLC_EVENT_MSG_GROUP)
+				micerrevt->flags |= IW_MICFAILURE_GROUP;
+			else
+				micerrevt->flags |= IW_MICFAILURE_PAIRWISE;
+			memcpy(micerrevt->src_addr.sa_data, &e->addr,
+			       ETHER_ADDR_LEN);
+			micerrevt->src_addr.sa_family = ARPHRD_ETHER;
+
+			break;
+		}
+	case WLC_E_PMKID_CACHE:
+		{
+			if (data) {
+				struct iw_pmkid_cand *iwpmkidcand =
+				    (struct iw_pmkid_cand *)&extra;
+				pmkid_cand_list_t *pmkcandlist;
+				pmkid_cand_t *pmkidcand;
+				int count;
+
+				cmd = IWEVPMKIDCAND;
+				pmkcandlist = data;
+				count =
+				    ntoh32_ua((u8 *) &
+					      pmkcandlist->npmkid_cand);
+				ASSERT(count >= 0);
+				wrqu.data.length = sizeof(struct iw_pmkid_cand);
+				pmkidcand = pmkcandlist->pmkid_cand;
+				while (count) {
+					bzero(iwpmkidcand,
+					      sizeof(struct iw_pmkid_cand));
+					if (pmkidcand->preauth)
+						iwpmkidcand->flags |=
+						    IW_PMKID_CAND_PREAUTH;
+					bcopy(&pmkidcand->BSSID,
+					      &iwpmkidcand->bssid.sa_data,
+					      ETHER_ADDR_LEN);
+#ifndef SANDGATE2G
+					wireless_send_event(dev, cmd, &wrqu,
+							    extra);
+#endif
+					pmkidcand++;
+					count--;
+				}
+			}
+			return;
+		}
+#endif				/* WIRELESS_EXT > 17 */
+
+	case WLC_E_SCAN_COMPLETE:
+#if defined(WL_IW_USE_ISCAN)
+		if ((g_iscan) && (g_iscan->sysioc_tsk) &&
+		    (g_iscan->iscan_state != ISCAN_STATE_IDLE)) {
+			up(&g_iscan->sysioc_sem);
+		} else {
+			cmd = SIOCGIWSCAN;
+			wrqu.data.length = strlen(extra);
+			WL_TRACE(("Event WLC_E_SCAN_COMPLETE from specific "
+				"scan %d\n", g_iscan->iscan_state));
+		}
+#else
+		cmd = SIOCGIWSCAN;
+		wrqu.data.length = strlen(extra);
+		WL_TRACE(("Event WLC_E_SCAN_COMPLETE\n"));
+#endif
+		break;
+
+	case WLC_E_PFN_NET_FOUND:
+		{
+			wlc_ssid_t *ssid;
+			ssid = (wlc_ssid_t *) data;
+			WL_ERROR(("%s Event WLC_E_PFN_NET_FOUND, send %s up : "
+				"find %s len=%d\n", __func__, PNO_EVENT_UP,
+				ssid->SSID, ssid->SSID_len));
+			WAKE_LOCK_TIMEOUT(iw->pub, WAKE_LOCK_PNO_FIND_TMOUT,
+					  20 * HZ);
+			cmd = IWEVCUSTOM;
+			memset(&wrqu, 0, sizeof(wrqu));
+			strcpy(extra, PNO_EVENT_UP);
+			wrqu.data.length = strlen(extra);
+		}
+		break;
+
+	default:
+		WL_TRACE(("Unknown Event %d: ignoring\n", event_type));
+		break;
+	}
+#ifndef SANDGATE2G
+	if (cmd) {
+		if (cmd == SIOCGIWSCAN)
+			wireless_send_event(dev, cmd, &wrqu, NULL);
+		else
+			wireless_send_event(dev, cmd, &wrqu, extra);
+	}
+#endif
+
+#if WIRELESS_EXT > 14
+	memset(extra, 0, sizeof(extra));
+	if (wl_iw_check_conn_fail(e, extra, sizeof(extra))) {
+		cmd = IWEVCUSTOM;
+		wrqu.data.length = strlen(extra);
+#ifndef SANDGATE2G
+		wireless_send_event(dev, cmd, &wrqu, extra);
+#endif
+	}
+#endif				/* WIRELESS_EXT > 14 */
+#endif				/* WIRELESS_EXT > 13 */
+}
+
+int
+wl_iw_get_wireless_stats(struct net_device *dev, struct iw_statistics *wstats)
+{
+	int res = 0;
+	wl_cnt_t cnt;
+	int phy_noise;
+	int rssi;
+	scb_val_t scb_val;
+
+	phy_noise = 0;
+	res = dev_wlc_ioctl(dev, WLC_GET_PHY_NOISE, &phy_noise,
+				sizeof(phy_noise));
+	if (res)
+		goto done;
+
+	phy_noise = dtoh32(phy_noise);
+	WL_TRACE(("wl_iw_get_wireless_stats phy noise=%d\n", phy_noise));
+
+	bzero(&scb_val, sizeof(scb_val_t));
+	res = dev_wlc_ioctl(dev, WLC_GET_RSSI, &scb_val, sizeof(scb_val_t));
+	if (res)
+		goto done;
+
+	rssi = dtoh32(scb_val.val);
+	WL_TRACE(("wl_iw_get_wireless_stats rssi=%d\n", rssi));
+	if (rssi <= WL_IW_RSSI_NO_SIGNAL)
+		wstats->qual.qual = 0;
+	else if (rssi <= WL_IW_RSSI_VERY_LOW)
+		wstats->qual.qual = 1;
+	else if (rssi <= WL_IW_RSSI_LOW)
+		wstats->qual.qual = 2;
+	else if (rssi <= WL_IW_RSSI_GOOD)
+		wstats->qual.qual = 3;
+	else if (rssi <= WL_IW_RSSI_VERY_GOOD)
+		wstats->qual.qual = 4;
+	else
+		wstats->qual.qual = 5;
+
+	wstats->qual.level = 0x100 + rssi;
+	wstats->qual.noise = 0x100 + phy_noise;
+#if WIRELESS_EXT > 18
+	wstats->qual.updated |= (IW_QUAL_ALL_UPDATED | IW_QUAL_DBM);
+#else
+	wstats->qual.updated |= 7;
+#endif
+
+#if WIRELESS_EXT > 11
+	WL_TRACE(("wl_iw_get_wireless_stats counters=%d\n",
+		  (int)sizeof(wl_cnt_t)));
+
+	memset(&cnt, 0, sizeof(wl_cnt_t));
+	res =
+	    dev_wlc_bufvar_get(dev, "counters", (char *)&cnt, sizeof(wl_cnt_t));
+	if (res) {
+		WL_ERROR(("wl_iw_get_wireless_stats counters failed error=%d\n",
+			  res));
+		goto done;
+	}
+
+	cnt.version = dtoh16(cnt.version);
+	if (cnt.version != WL_CNT_T_VERSION) {
+		WL_TRACE(("\tIncorrect version of counters struct: expected "
+			"%d; got %d\n",
+			WL_CNT_T_VERSION, cnt.version));
+		goto done;
+	}
+
+	wstats->discard.nwid = 0;
+	wstats->discard.code = dtoh32(cnt.rxundec);
+	wstats->discard.fragment = dtoh32(cnt.rxfragerr);
+	wstats->discard.retries = dtoh32(cnt.txfail);
+	wstats->discard.misc = dtoh32(cnt.rxrunt) + dtoh32(cnt.rxgiant);
+	wstats->miss.beacon = 0;
+
+	WL_TRACE(("wl_iw_get_wireless_stats counters txframe=%d txbyte=%d\n",
+		  dtoh32(cnt.txframe), dtoh32(cnt.txbyte)));
+	WL_TRACE(("wl_iw_get_wireless_stats counters rxfrmtoolong=%d\n",
+		  dtoh32(cnt.rxfrmtoolong)));
+	WL_TRACE(("wl_iw_get_wireless_stats counters rxbadplcp=%d\n",
+		  dtoh32(cnt.rxbadplcp)));
+	WL_TRACE(("wl_iw_get_wireless_stats counters rxundec=%d\n",
+		  dtoh32(cnt.rxundec)));
+	WL_TRACE(("wl_iw_get_wireless_stats counters rxfragerr=%d\n",
+		  dtoh32(cnt.rxfragerr)));
+	WL_TRACE(("wl_iw_get_wireless_stats counters txfail=%d\n",
+		  dtoh32(cnt.txfail)));
+	WL_TRACE(("wl_iw_get_wireless_stats counters rxrunt=%d\n",
+		  dtoh32(cnt.rxrunt)));
+	WL_TRACE(("wl_iw_get_wireless_stats counters rxgiant=%d\n",
+		  dtoh32(cnt.rxgiant)));
+#endif				/* WIRELESS_EXT > 11 */
+
+done:
+	return res;
+}
+
+int wl_iw_attach(struct net_device *dev, void *dhdp)
+{
+	int params_size;
+	wl_iw_t *iw;
+#if defined(WL_IW_USE_ISCAN)
+	iscan_info_t *iscan = NULL;
+
+	if (!dev)
+		return 0;
+
+	memset(&g_wl_iw_params, 0, sizeof(wl_iw_extra_params_t));
+
+#ifdef CSCAN
+	params_size =
+	    (WL_SCAN_PARAMS_FIXED_SIZE + offsetof(wl_iscan_params_t, params)) +
+	    (WL_NUMCHANNELS * sizeof(u16)) +
+	    WL_SCAN_PARAMS_SSID_MAX * sizeof(wlc_ssid_t);
+#else
+	params_size =
+	    (WL_SCAN_PARAMS_FIXED_SIZE + offsetof(wl_iscan_params_t, params));
+#endif
+	iscan = kmalloc(sizeof(iscan_info_t), GFP_KERNEL);
+
+	if (!iscan)
+		return -ENOMEM;
+	memset(iscan, 0, sizeof(iscan_info_t));
+
+	iscan->iscan_ex_params_p =
+	    (wl_iscan_params_t *) kmalloc(params_size, GFP_KERNEL);
+	if (!iscan->iscan_ex_params_p)
+		return -ENOMEM;
+	iscan->iscan_ex_param_size = params_size;
+	iscan->sysioc_tsk = NULL;
+
+	g_iscan = iscan;
+	iscan->dev = dev;
+	iscan->iscan_state = ISCAN_STATE_IDLE;
+
+	iscan->timer_ms = 3000;
+	init_timer(&iscan->timer);
+	iscan->timer.data = (unsigned long) iscan;
+	iscan->timer.function = wl_iw_timerfunc;
+
+	sema_init(&iscan->sysioc_sem, 0);
+	iscan->sysioc_tsk = kthread_run(_iscan_sysioc_thread, iscan,
+					"_iscan_sysioc");
+	if (IS_ERR(iscan->sysioc_tsk)) {
+		iscan->sysioc_tsk = NULL;
+		return -ENOMEM;
+	}
+#endif				/* defined(WL_IW_USE_ISCAN) */
+
+	iw = *(wl_iw_t **) netdev_priv(dev);
+	iw->pub = (dhd_pub_t *) dhdp;
+	MUTEX_LOCK_INIT(iw->pub);
+	MUTEX_LOCK_WL_SCAN_SET_INIT();
+#ifdef SOFTAP
+	priv_dev = dev;
+	MUTEX_LOCK_SOFTAP_SET_INIT(iw->pub);
+#endif
+	g_scan = NULL;
+
+	g_scan = (void *)kmalloc(G_SCAN_RESULTS, GFP_KERNEL);
+	if (!g_scan)
+		return -ENOMEM;
+
+	memset(g_scan, 0, G_SCAN_RESULTS);
+	g_scan_specified_ssid = 0;
+
+	return 0;
+}
+
+void wl_iw_detach(void)
+{
+#if defined(WL_IW_USE_ISCAN)
+	iscan_buf_t *buf;
+	iscan_info_t *iscan = g_iscan;
+
+	if (!iscan)
+		return;
+	if (iscan->sysioc_tsk) {
+		send_sig(SIGTERM, iscan->sysioc_tsk, 1);
+		kthread_stop(iscan->sysioc_tsk);
+		iscan->sysioc_tsk = NULL;
+	}
+
+	MUTEX_LOCK_WL_SCAN_SET();
+	while (iscan->list_hdr) {
+		buf = iscan->list_hdr->next;
+		kfree(iscan->list_hdr);
+		iscan->list_hdr = buf;
+	}
+	MUTEX_UNLOCK_WL_SCAN_SET();
+	kfree(iscan->iscan_ex_params_p);
+	kfree(iscan);
+	g_iscan = NULL;
+#endif				/* WL_IW_USE_ISCAN */
+
+	kfree(g_scan);
+
+	g_scan = NULL;
+}
diff --git a/drivers/staging/brcm80211/brcmfmac/wl_iw.h b/drivers/staging/brcm80211/brcmfmac/wl_iw.h
new file mode 100644
index 0000000..edbf61f
--- /dev/null
+++ b/drivers/staging/brcm80211/brcmfmac/wl_iw.h
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wl_iw_h_
+#define _wl_iw_h_
+
+#include <linux/wireless.h>
+
+#include <proto/ethernet.h>
+#include <wlioctl.h>
+
+#define WL_SCAN_PARAMS_SSID_MAX	10
+#define GET_SSID	"SSID="
+#define GET_CHANNEL	"CH="
+#define GET_NPROBE 			"NPROBE="
+#define GET_ACTIVE_ASSOC_DWELL  	"ACTIVE="
+#define GET_PASSIVE_ASSOC_DWELL	"PASSIVE="
+#define GET_HOME_DWELL		"HOME="
+#define GET_SCAN_TYPE			"TYPE="
+
+#define BAND_GET_CMD				"BANDGET"
+#define BAND_SET_CMD				"BANDSET"
+#define DTIM_SKIP_GET_CMD			"DTIMSKIPGET"
+#define DTIM_SKIP_SET_CMD			"DTIMSKIPSET"
+#define SETSUSPEND_CMD				"SETSUSPENDOPT"
+#define PNOSSIDCLR_SET_CMD			"PNOSSIDCLR"
+#define PNOSETUP_SET_CMD			"PNOSETUP"
+#define PNOENABLE_SET_CMD			"PNOFORCE"
+#define PNODEBUG_SET_CMD			"PNODEBUG"
+
+typedef struct wl_iw_extra_params {
+	int target_channel;
+} wl_iw_extra_params_t;
+
+#define	WL_IW_RSSI_MINVAL		-200
+#define	WL_IW_RSSI_NO_SIGNAL	-91
+#define	WL_IW_RSSI_VERY_LOW	-80
+#define	WL_IW_RSSI_LOW		-70
+#define	WL_IW_RSSI_GOOD		-68
+#define	WL_IW_RSSI_VERY_GOOD	-58
+#define	WL_IW_RSSI_EXCELLENT	-57
+#define	WL_IW_RSSI_INVALID	 0
+#define MAX_WX_STRING 80
+#define WL_IW_SET_ACTIVE_SCAN	(SIOCIWFIRSTPRIV+1)
+#define WL_IW_GET_RSSI			(SIOCIWFIRSTPRIV+3)
+#define WL_IW_SET_PASSIVE_SCAN	(SIOCIWFIRSTPRIV+5)
+#define WL_IW_GET_LINK_SPEED	(SIOCIWFIRSTPRIV+7)
+#define WL_IW_GET_CURR_MACADDR	(SIOCIWFIRSTPRIV+9)
+#define WL_IW_SET_STOP				(SIOCIWFIRSTPRIV+11)
+#define WL_IW_SET_START			(SIOCIWFIRSTPRIV+13)
+
+#define WL_SET_AP_CFG           (SIOCIWFIRSTPRIV+15)
+#define WL_AP_STA_LIST          (SIOCIWFIRSTPRIV+17)
+#define WL_AP_MAC_FLTR	        (SIOCIWFIRSTPRIV+19)
+#define WL_AP_BSS_START         (SIOCIWFIRSTPRIV+21)
+#define AP_LPB_CMD              (SIOCIWFIRSTPRIV+23)
+#define WL_AP_STOP              (SIOCIWFIRSTPRIV+25)
+#define WL_FW_RELOAD            (SIOCIWFIRSTPRIV+27)
+#define WL_COMBO_SCAN            (SIOCIWFIRSTPRIV+29)
+#define WL_AP_SPARE3            (SIOCIWFIRSTPRIV+31)
+#define G_SCAN_RESULTS		(8*1024)
+#define	WE_ADD_EVENT_FIX	0x80
+#define          G_WLAN_SET_ON	0
+#define          G_WLAN_SET_OFF	1
+
+#define CHECK_EXTRA_FOR_NULL(extra) \
+if (!extra) { \
+	WL_ERROR(("%s: error : extra is null pointer\n", __func__)); \
+	return -EINVAL; \
+}
+
+typedef struct wl_iw {
+	char nickname[IW_ESSID_MAX_SIZE];
+
+	struct iw_statistics wstats;
+
+	int spy_num;
+	u32 pwsec;
+	u32 gwsec;
+	bool privacy_invoked;
+
+	struct ether_addr spy_addr[IW_MAX_SPY];
+	struct iw_quality spy_qual[IW_MAX_SPY];
+	void *wlinfo;
+	dhd_pub_t *pub;
+} wl_iw_t;
+
+#if WIRELESS_EXT > 12
+#include <net/iw_handler.h>
+extern const struct iw_handler_def wl_iw_handler_def;
+#endif
+
+extern int wl_iw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+extern void wl_iw_event(struct net_device *dev, wl_event_msg_t *e, void *data);
+extern int wl_iw_get_wireless_stats(struct net_device *dev,
+				    struct iw_statistics *wstats);
+int wl_iw_attach(struct net_device *dev, void *dhdp);
+void wl_iw_detach(void);
+extern int net_os_set_suspend_disable(struct net_device *dev, int val);
+extern int net_os_set_suspend(struct net_device *dev, int val);
+extern int net_os_set_dtim_skip(struct net_device *dev, int val);
+extern int net_os_set_packet_filter(struct net_device *dev, int val);
+
+#define IWE_STREAM_ADD_EVENT(info, stream, ends, iwe, extra) \
+	iwe_stream_add_event(info, stream, ends, iwe, extra)
+#define IWE_STREAM_ADD_VALUE(info, event, value, ends, iwe, event_len) \
+	iwe_stream_add_value(info, event, value, ends, iwe, event_len)
+#define IWE_STREAM_ADD_POINT(info, stream, ends, iwe, extra) \
+	iwe_stream_add_point(info, stream, ends, iwe, extra)
+
+extern int dhd_pno_enable(dhd_pub_t *dhd, int pfn_enabled);
+extern int dhd_pno_clean(dhd_pub_t *dhd);
+extern int dhd_pno_set(dhd_pub_t *dhd, wlc_ssid_t *ssids_local, int nssid,
+		       unsigned char scan_fr);
+extern int dhd_pno_get_status(dhd_pub_t *dhd);
+extern int dhd_dev_pno_reset(struct net_device *dev);
+extern int dhd_dev_pno_set(struct net_device *dev, wlc_ssid_t *ssids_local,
+			   int nssid, unsigned char scan_fr);
+extern int dhd_dev_pno_enable(struct net_device *dev, int pfn_enabled);
+extern int dhd_dev_get_pno_status(struct net_device *dev);
+
+#define PNO_TLV_PREFIX			'S'
+#define PNO_TLV_VERSION			1
+#define PNO_TLV_SUBVERSION		0
+#define PNO_TLV_RESERVED		0
+#define PNO_TLV_TYPE_SSID_IE		'S'
+#define PNO_TLV_TYPE_TIME		'T'
+#define  PNO_EVENT_UP			"PNO_EVENT"
+
+typedef struct cmd_tlv {
+	char prefix;
+	char version;
+	char subver;
+	char reserved;
+} cmd_tlv_t;
+#endif				/* _wl_iw_h_ */
diff --git a/drivers/staging/brcm80211/include/aidmp.h b/drivers/staging/brcm80211/include/aidmp.h
index e64dd03..d33f020 100644
--- a/drivers/staging/brcm80211/include/aidmp.h
+++ b/drivers/staging/brcm80211/include/aidmp.h
@@ -103,121 +103,121 @@
 #ifndef _LANGUAGE_ASSEMBLY
 
 typedef volatile struct _aidmp {
-	uint32 oobselina30;	/* 0x000 */
-	uint32 oobselina74;	/* 0x004 */
-	uint32 PAD[6];
-	uint32 oobselinb30;	/* 0x020 */
-	uint32 oobselinb74;	/* 0x024 */
-	uint32 PAD[6];
-	uint32 oobselinc30;	/* 0x040 */
-	uint32 oobselinc74;	/* 0x044 */
-	uint32 PAD[6];
-	uint32 oobselind30;	/* 0x060 */
-	uint32 oobselind74;	/* 0x064 */
-	uint32 PAD[38];
-	uint32 oobselouta30;	/* 0x100 */
-	uint32 oobselouta74;	/* 0x104 */
-	uint32 PAD[6];
-	uint32 oobseloutb30;	/* 0x120 */
-	uint32 oobseloutb74;	/* 0x124 */
-	uint32 PAD[6];
-	uint32 oobseloutc30;	/* 0x140 */
-	uint32 oobseloutc74;	/* 0x144 */
-	uint32 PAD[6];
-	uint32 oobseloutd30;	/* 0x160 */
-	uint32 oobseloutd74;	/* 0x164 */
-	uint32 PAD[38];
-	uint32 oobsynca;	/* 0x200 */
-	uint32 oobseloutaen;	/* 0x204 */
-	uint32 PAD[6];
-	uint32 oobsyncb;	/* 0x220 */
-	uint32 oobseloutben;	/* 0x224 */
-	uint32 PAD[6];
-	uint32 oobsyncc;	/* 0x240 */
-	uint32 oobseloutcen;	/* 0x244 */
-	uint32 PAD[6];
-	uint32 oobsyncd;	/* 0x260 */
-	uint32 oobseloutden;	/* 0x264 */
-	uint32 PAD[38];
-	uint32 oobaextwidth;	/* 0x300 */
-	uint32 oobainwidth;	/* 0x304 */
-	uint32 oobaoutwidth;	/* 0x308 */
-	uint32 PAD[5];
-	uint32 oobbextwidth;	/* 0x320 */
-	uint32 oobbinwidth;	/* 0x324 */
-	uint32 oobboutwidth;	/* 0x328 */
-	uint32 PAD[5];
-	uint32 oobcextwidth;	/* 0x340 */
-	uint32 oobcinwidth;	/* 0x344 */
-	uint32 oobcoutwidth;	/* 0x348 */
-	uint32 PAD[5];
-	uint32 oobdextwidth;	/* 0x360 */
-	uint32 oobdinwidth;	/* 0x364 */
-	uint32 oobdoutwidth;	/* 0x368 */
-	uint32 PAD[37];
-	uint32 ioctrlset;	/* 0x400 */
-	uint32 ioctrlclear;	/* 0x404 */
-	uint32 ioctrl;		/* 0x408 */
-	uint32 PAD[61];
-	uint32 iostatus;	/* 0x500 */
-	uint32 PAD[127];
-	uint32 ioctrlwidth;	/* 0x700 */
-	uint32 iostatuswidth;	/* 0x704 */
-	uint32 PAD[62];
-	uint32 resetctrl;	/* 0x800 */
-	uint32 resetstatus;	/* 0x804 */
-	uint32 resetreadid;	/* 0x808 */
-	uint32 resetwriteid;	/* 0x80c */
-	uint32 PAD[60];
-	uint32 errlogctrl;	/* 0x900 */
-	uint32 errlogdone;	/* 0x904 */
-	uint32 errlogstatus;	/* 0x908 */
-	uint32 errlogaddrlo;	/* 0x90c */
-	uint32 errlogaddrhi;	/* 0x910 */
-	uint32 errlogid;	/* 0x914 */
-	uint32 errloguser;	/* 0x918 */
-	uint32 errlogflags;	/* 0x91c */
-	uint32 PAD[56];
-	uint32 intstatus;	/* 0xa00 */
-	uint32 PAD[127];
-	uint32 config;		/* 0xe00 */
-	uint32 PAD[63];
-	uint32 itcr;		/* 0xf00 */
-	uint32 PAD[3];
-	uint32 itipooba;	/* 0xf10 */
-	uint32 itipoobb;	/* 0xf14 */
-	uint32 itipoobc;	/* 0xf18 */
-	uint32 itipoobd;	/* 0xf1c */
-	uint32 PAD[4];
-	uint32 itipoobaout;	/* 0xf30 */
-	uint32 itipoobbout;	/* 0xf34 */
-	uint32 itipoobcout;	/* 0xf38 */
-	uint32 itipoobdout;	/* 0xf3c */
-	uint32 PAD[4];
-	uint32 itopooba;	/* 0xf50 */
-	uint32 itopoobb;	/* 0xf54 */
-	uint32 itopoobc;	/* 0xf58 */
-	uint32 itopoobd;	/* 0xf5c */
-	uint32 PAD[4];
-	uint32 itopoobain;	/* 0xf70 */
-	uint32 itopoobbin;	/* 0xf74 */
-	uint32 itopoobcin;	/* 0xf78 */
-	uint32 itopoobdin;	/* 0xf7c */
-	uint32 PAD[4];
-	uint32 itopreset;	/* 0xf90 */
-	uint32 PAD[15];
-	uint32 peripherialid4;	/* 0xfd0 */
-	uint32 peripherialid5;	/* 0xfd4 */
-	uint32 peripherialid6;	/* 0xfd8 */
-	uint32 peripherialid7;	/* 0xfdc */
-	uint32 peripherialid0;	/* 0xfe0 */
-	uint32 peripherialid1;	/* 0xfe4 */
-	uint32 peripherialid2;	/* 0xfe8 */
-	uint32 peripherialid3;	/* 0xfec */
-	uint32 componentid0;	/* 0xff0 */
-	uint32 componentid1;	/* 0xff4 */
-	uint32 componentid2;	/* 0xff8 */
-	uint32 componentid3;	/* 0xffc */
+	u32 oobselina30;	/* 0x000 */
+	u32 oobselina74;	/* 0x004 */
+	u32 PAD[6];
+	u32 oobselinb30;	/* 0x020 */
+	u32 oobselinb74;	/* 0x024 */
+	u32 PAD[6];
+	u32 oobselinc30;	/* 0x040 */
+	u32 oobselinc74;	/* 0x044 */
+	u32 PAD[6];
+	u32 oobselind30;	/* 0x060 */
+	u32 oobselind74;	/* 0x064 */
+	u32 PAD[38];
+	u32 oobselouta30;	/* 0x100 */
+	u32 oobselouta74;	/* 0x104 */
+	u32 PAD[6];
+	u32 oobseloutb30;	/* 0x120 */
+	u32 oobseloutb74;	/* 0x124 */
+	u32 PAD[6];
+	u32 oobseloutc30;	/* 0x140 */
+	u32 oobseloutc74;	/* 0x144 */
+	u32 PAD[6];
+	u32 oobseloutd30;	/* 0x160 */
+	u32 oobseloutd74;	/* 0x164 */
+	u32 PAD[38];
+	u32 oobsynca;	/* 0x200 */
+	u32 oobseloutaen;	/* 0x204 */
+	u32 PAD[6];
+	u32 oobsyncb;	/* 0x220 */
+	u32 oobseloutben;	/* 0x224 */
+	u32 PAD[6];
+	u32 oobsyncc;	/* 0x240 */
+	u32 oobseloutcen;	/* 0x244 */
+	u32 PAD[6];
+	u32 oobsyncd;	/* 0x260 */
+	u32 oobseloutden;	/* 0x264 */
+	u32 PAD[38];
+	u32 oobaextwidth;	/* 0x300 */
+	u32 oobainwidth;	/* 0x304 */
+	u32 oobaoutwidth;	/* 0x308 */
+	u32 PAD[5];
+	u32 oobbextwidth;	/* 0x320 */
+	u32 oobbinwidth;	/* 0x324 */
+	u32 oobboutwidth;	/* 0x328 */
+	u32 PAD[5];
+	u32 oobcextwidth;	/* 0x340 */
+	u32 oobcinwidth;	/* 0x344 */
+	u32 oobcoutwidth;	/* 0x348 */
+	u32 PAD[5];
+	u32 oobdextwidth;	/* 0x360 */
+	u32 oobdinwidth;	/* 0x364 */
+	u32 oobdoutwidth;	/* 0x368 */
+	u32 PAD[37];
+	u32 ioctrlset;	/* 0x400 */
+	u32 ioctrlclear;	/* 0x404 */
+	u32 ioctrl;		/* 0x408 */
+	u32 PAD[61];
+	u32 iostatus;	/* 0x500 */
+	u32 PAD[127];
+	u32 ioctrlwidth;	/* 0x700 */
+	u32 iostatuswidth;	/* 0x704 */
+	u32 PAD[62];
+	u32 resetctrl;	/* 0x800 */
+	u32 resetstatus;	/* 0x804 */
+	u32 resetreadid;	/* 0x808 */
+	u32 resetwriteid;	/* 0x80c */
+	u32 PAD[60];
+	u32 errlogctrl;	/* 0x900 */
+	u32 errlogdone;	/* 0x904 */
+	u32 errlogstatus;	/* 0x908 */
+	u32 errlogaddrlo;	/* 0x90c */
+	u32 errlogaddrhi;	/* 0x910 */
+	u32 errlogid;	/* 0x914 */
+	u32 errloguser;	/* 0x918 */
+	u32 errlogflags;	/* 0x91c */
+	u32 PAD[56];
+	u32 intstatus;	/* 0xa00 */
+	u32 PAD[127];
+	u32 config;		/* 0xe00 */
+	u32 PAD[63];
+	u32 itcr;		/* 0xf00 */
+	u32 PAD[3];
+	u32 itipooba;	/* 0xf10 */
+	u32 itipoobb;	/* 0xf14 */
+	u32 itipoobc;	/* 0xf18 */
+	u32 itipoobd;	/* 0xf1c */
+	u32 PAD[4];
+	u32 itipoobaout;	/* 0xf30 */
+	u32 itipoobbout;	/* 0xf34 */
+	u32 itipoobcout;	/* 0xf38 */
+	u32 itipoobdout;	/* 0xf3c */
+	u32 PAD[4];
+	u32 itopooba;	/* 0xf50 */
+	u32 itopoobb;	/* 0xf54 */
+	u32 itopoobc;	/* 0xf58 */
+	u32 itopoobd;	/* 0xf5c */
+	u32 PAD[4];
+	u32 itopoobain;	/* 0xf70 */
+	u32 itopoobbin;	/* 0xf74 */
+	u32 itopoobcin;	/* 0xf78 */
+	u32 itopoobdin;	/* 0xf7c */
+	u32 PAD[4];
+	u32 itopreset;	/* 0xf90 */
+	u32 PAD[15];
+	u32 peripherialid4;	/* 0xfd0 */
+	u32 peripherialid5;	/* 0xfd4 */
+	u32 peripherialid6;	/* 0xfd8 */
+	u32 peripherialid7;	/* 0xfdc */
+	u32 peripherialid0;	/* 0xfe0 */
+	u32 peripherialid1;	/* 0xfe4 */
+	u32 peripherialid2;	/* 0xfe8 */
+	u32 peripherialid3;	/* 0xfec */
+	u32 componentid0;	/* 0xff0 */
+	u32 componentid1;	/* 0xff4 */
+	u32 componentid2;	/* 0xff8 */
+	u32 componentid3;	/* 0xffc */
 } aidmp_t;
 
 #endif				/* _LANGUAGE_ASSEMBLY */
diff --git a/drivers/staging/brcm80211/include/bcm_rpc.h b/drivers/staging/brcm80211/include/bcm_rpc.h
index 33408fd..77e5d8f 100644
--- a/drivers/staging/brcm80211/include/bcm_rpc.h
+++ b/drivers/staging/brcm80211/include/bcm_rpc.h
@@ -17,17 +17,16 @@
 #ifndef _BCM_RPC_H_
 #define _BCM_RPC_H_
 
-#include <typedefs.h>
 #include <rpc_osl.h>
 
 typedef struct rpc_info rpc_info_t;
 typedef struct rpc_buf rpc_buf_t;
 struct rpc_transport_info;
-typedef void (*rpc_dispatch_cb_t) (void *ctx, struct rpc_buf * buf);
+typedef void (*rpc_dispatch_cb_t) (void *ctx, struct rpc_buf *buf);
 typedef void (*rpc_resync_cb_t) (void *ctx);
 typedef void (*rpc_down_cb_t) (void *ctx);
-typedef void (*rpc_txdone_cb_t) (void *ctx, struct rpc_buf * buf);
-extern struct rpc_info *bcm_rpc_attach(void *pdev, osl_t * osh,
+typedef void (*rpc_txdone_cb_t) (void *ctx, struct rpc_buf *buf);
+extern struct rpc_info *bcm_rpc_attach(void *pdev, osl_t *osh,
 				       struct rpc_transport_info *rpc_th);
 
 extern void bcm_rpc_detach(struct rpc_info *rpc);
@@ -65,16 +64,16 @@ extern uint bcm_rpc_buf_header_len(struct rpc_info *rpci);
 #define RPC_PKTLOG_SIZE		50	/* Depth of the history */
 #define RPC_PKTLOG_RD_LEN	3
 #define RPC_PKTLOG_DUMP_SIZE	150	/* dump size should be more than the product of above two */
-extern int bcm_rpc_pktlog_get(struct rpc_info *rpci, uint32 * buf,
+extern int bcm_rpc_pktlog_get(struct rpc_info *rpci, u32 *buf,
 			      uint buf_size, bool send);
-extern int bcm_rpc_dump(rpc_info_t * rpci, struct bcmstrbuf *b);
+extern int bcm_rpc_dump(rpc_info_t *rpci, struct bcmstrbuf *b);
 
 /* HIGH/BMAC: bit 15-8: RPC module, bit 7-0: TP module */
 #define RPC_ERROR_VAL	0x0001
 #define RPC_TRACE_VAL	0x0002
 #define RPC_PKTTRACE_VAL 0x0004
 #define RPC_PKTLOG_VAL	0x0008
-extern void bcm_rpc_msglevel_set(struct rpc_info *rpci, uint16 msglevel,
+extern void bcm_rpc_msglevel_set(struct rpc_info *rpci, u16 msglevel,
 				 bool high_low);
 
 #endif				/* _BCM_RPC_H_ */
diff --git a/drivers/staging/brcm80211/include/bcm_rpc_tp.h b/drivers/staging/brcm80211/include/bcm_rpc_tp.h
index d52701c..bb8dc6d 100644
--- a/drivers/staging/brcm80211/include/bcm_rpc_tp.h
+++ b/drivers/staging/brcm80211/include/bcm_rpc_tp.h
@@ -57,66 +57,66 @@ typedef void (*rpc_rx_fn_t) (void *, rpc_buf_t *);
 typedef void (*rpc_txflowctl_cb_t) (void *ctx, bool on);
 #endif
 
-extern rpc_tp_info_t *bcm_rpc_tp_attach(osl_t * osh, void *bus);
-extern void bcm_rpc_tp_detach(rpc_tp_info_t * rpcb);
-extern void bcm_rpc_tp_down(rpc_tp_info_t * rpcb);
-extern void bcm_rpc_tp_watchdog(rpc_tp_info_t * rpcb);
+extern rpc_tp_info_t *bcm_rpc_tp_attach(osl_t *osh, void *bus);
+extern void bcm_rpc_tp_detach(rpc_tp_info_t *rpcb);
+extern void bcm_rpc_tp_down(rpc_tp_info_t *rpcb);
+extern void bcm_rpc_tp_watchdog(rpc_tp_info_t *rpcb);
 
-extern int bcm_rpc_tp_buf_send(rpc_tp_info_t * rpcb, rpc_buf_t * buf);
+extern int bcm_rpc_tp_buf_send(rpc_tp_info_t *rpcb, rpc_buf_t *buf);
 
 /* callback for tx_complete, rx_pkt */
-extern void bcm_rpc_tp_register_cb(rpc_tp_info_t * rpcb,
+extern void bcm_rpc_tp_register_cb(rpc_tp_info_t *rpcb,
 				   rpc_tx_complete_fn_t txcmplt,
 				   void *tx_context, rpc_rx_fn_t rxpkt,
-				   void *rx_context, rpc_osl_t * rpc_osh);
-extern void bcm_rpc_tp_deregister_cb(rpc_tp_info_t * rpcb);
+				   void *rx_context, rpc_osl_t *rpc_osh);
+extern void bcm_rpc_tp_deregister_cb(rpc_tp_info_t *rpcb);
 
 /* Buffer manipulation */
-extern uint bcm_rpc_buf_tp_header_len(rpc_tp_info_t * rpcb);
-extern rpc_buf_t *bcm_rpc_tp_buf_alloc(rpc_tp_info_t * rpcb, int len);
-extern void bcm_rpc_tp_buf_free(rpc_tp_info_t * rpcb, rpc_buf_t * buf);
-extern int bcm_rpc_buf_len_get(rpc_tp_info_t * rpcb, rpc_buf_t * b);
-extern int bcm_rpc_buf_len_set(rpc_tp_info_t * rpcb, rpc_buf_t * b, uint len);
-extern rpc_buf_t *bcm_rpc_buf_next_get(rpc_tp_info_t * rpcb, rpc_buf_t * b);
-extern void bcm_rpc_buf_next_set(rpc_tp_info_t * rpcb, rpc_buf_t * b,
-				 rpc_buf_t * nextb);
-extern unsigned char *bcm_rpc_buf_data(rpc_tp_info_t * rpcb, rpc_buf_t * b);
-extern unsigned char *bcm_rpc_buf_push(rpc_tp_info_t * rpcb, rpc_buf_t * b,
+extern uint bcm_rpc_buf_tp_header_len(rpc_tp_info_t *rpcb);
+extern rpc_buf_t *bcm_rpc_tp_buf_alloc(rpc_tp_info_t *rpcb, int len);
+extern void bcm_rpc_tp_buf_free(rpc_tp_info_t *rpcb, rpc_buf_t *buf);
+extern int bcm_rpc_buf_len_get(rpc_tp_info_t *rpcb, rpc_buf_t *b);
+extern int bcm_rpc_buf_len_set(rpc_tp_info_t *rpcb, rpc_buf_t *b, uint len);
+extern rpc_buf_t *bcm_rpc_buf_next_get(rpc_tp_info_t *rpcb, rpc_buf_t *b);
+extern void bcm_rpc_buf_next_set(rpc_tp_info_t *rpcb, rpc_buf_t *b,
+				 rpc_buf_t *nextb);
+extern unsigned char *bcm_rpc_buf_data(rpc_tp_info_t *rpcb, rpc_buf_t *b);
+extern unsigned char *bcm_rpc_buf_push(rpc_tp_info_t *rpcb, rpc_buf_t *b,
 				       uint delta);
-extern unsigned char *bcm_rpc_buf_pull(rpc_tp_info_t * rpcb, rpc_buf_t * b,
+extern unsigned char *bcm_rpc_buf_pull(rpc_tp_info_t *rpcb, rpc_buf_t *b,
 				       uint delta);
-extern void bcm_rpc_tp_buf_release(rpc_tp_info_t * rpcb, rpc_buf_t * buf);
-extern void bcm_rpc_tp_buf_cnt_adjust(rpc_tp_info_t * rpcb, int adjust);
+extern void bcm_rpc_tp_buf_release(rpc_tp_info_t *rpcb, rpc_buf_t *buf);
+extern void bcm_rpc_tp_buf_cnt_adjust(rpc_tp_info_t *rpcb, int adjust);
 /* RPC call_with_return */
-extern int bcm_rpc_tp_recv_rtn(rpc_tp_info_t * rpcb);
-extern int bcm_rpc_tp_get_device_speed(rpc_tp_info_t * rpc_th);
+extern int bcm_rpc_tp_recv_rtn(rpc_tp_info_t *rpcb);
+extern int bcm_rpc_tp_get_device_speed(rpc_tp_info_t *rpc_th);
 #ifdef BCMDBG
-extern int bcm_rpc_tp_dump(rpc_tp_info_t * rpcb, struct bcmstrbuf *b);
+extern int bcm_rpc_tp_dump(rpc_tp_info_t *rpcb, struct bcmstrbuf *b);
 #endif
 
 #ifdef WLC_LOW
 /* intercept USB pkt to parse RPC header: USB driver rx-> wl_send -> this -> wl driver */
-extern void bcm_rpc_tp_rx_from_dnglbus(rpc_tp_info_t * rpc_th, struct lbuf *lb);
+extern void bcm_rpc_tp_rx_from_dnglbus(rpc_tp_info_t *rpc_th, struct lbuf *lb);
 
 /* RPC callreturn pkt, go to USB driver tx */
-extern int bcm_rpc_tp_send_callreturn(rpc_tp_info_t * rpc_th, rpc_buf_t * b);
+extern int bcm_rpc_tp_send_callreturn(rpc_tp_info_t *rpc_th, rpc_buf_t *b);
 
-extern void bcm_rpc_tp_dump(rpc_tp_info_t * rpcb);
-extern void bcm_rpc_tp_txflowctl(rpc_tp_info_t * rpcb, bool state, int prio);
-extern void bcm_rpc_tp_txflowctlcb_init(rpc_tp_info_t * rpc_th, void *ctx,
+extern void bcm_rpc_tp_dump(rpc_tp_info_t *rpcb);
+extern void bcm_rpc_tp_txflowctl(rpc_tp_info_t *rpcb, bool state, int prio);
+extern void bcm_rpc_tp_txflowctlcb_init(rpc_tp_info_t *rpc_th, void *ctx,
 					rpc_txflowctl_cb_t cb);
-extern void bcm_rpc_tp_txflowctlcb_deinit(rpc_tp_info_t * rpc_th);
-extern void bcm_rpc_tp_txq_wm_set(rpc_tp_info_t * rpc_th, uint8 hiwm,
-				  uint8 lowm);
-extern void bcm_rpc_tp_txq_wm_get(rpc_tp_info_t * rpc_th, uint8 * hiwm,
-				  uint8 * lowm);
+extern void bcm_rpc_tp_txflowctlcb_deinit(rpc_tp_info_t *rpc_th);
+extern void bcm_rpc_tp_txq_wm_set(rpc_tp_info_t *rpc_th, u8 hiwm,
+				  u8 lowm);
+extern void bcm_rpc_tp_txq_wm_get(rpc_tp_info_t *rpc_th, u8 *hiwm,
+				  u8 *lowm);
 #endif				/* WLC_LOW */
 
-extern void bcm_rpc_tp_agg_set(rpc_tp_info_t * rpcb, uint32 reason, bool set);
-extern void bcm_rpc_tp_agg_limit_set(rpc_tp_info_t * rpc_th, uint8 sf,
-				     uint16 bytes);
-extern void bcm_rpc_tp_agg_limit_get(rpc_tp_info_t * rpc_th, uint8 * sf,
-				     uint16 * bytes);
+extern void bcm_rpc_tp_agg_set(rpc_tp_info_t *rpcb, u32 reason, bool set);
+extern void bcm_rpc_tp_agg_limit_set(rpc_tp_info_t *rpc_th, u8 sf,
+				     u16 bytes);
+extern void bcm_rpc_tp_agg_limit_get(rpc_tp_info_t *rpc_th, u8 *sf,
+				     u16 *bytes);
 
 #define BCM_RPC_TP_MSG_LEVEL_MASK	0x00ff
 /* dongle msg level */
@@ -131,7 +131,7 @@ extern void bcm_rpc_tp_agg_limit_get(rpc_tp_info_t * rpc_th, uint8 * sf,
 #define RPC_TP_MSG_HOST_AGG_VAL		0x0004	/* DNGL TP agg msg */
 #define RPC_TP_MSG_HOST_DEA_VAL		0x0008	/* DNGL TP deag msg */
 
-extern void bcm_rpc_tp_msglevel_set(rpc_tp_info_t * rpc_th, uint8 msglevel,
+extern void bcm_rpc_tp_msglevel_set(rpc_tp_info_t *rpc_th, u8 msglevel,
 				    bool high_low);
 
 #endif				/* _bcm_rpc_tp_h_ */
diff --git a/drivers/staging/brcm80211/include/bcm_xdr.h b/drivers/staging/brcm80211/include/bcm_xdr.h
index 18a677d..50fbd78 100644
--- a/drivers/staging/brcm80211/include/bcm_xdr.h
+++ b/drivers/staging/brcm80211/include/bcm_xdr.h
@@ -25,36 +25,36 @@
  *
  */
 typedef struct {
-	uint8 *buf;		/* pointer to current position in origbuf */
+	u8 *buf;		/* pointer to current position in origbuf */
 	uint size;		/* current (residual) size in bytes */
-	uint8 *origbuf;		/* unmodified pointer to orignal buffer */
+	u8 *origbuf;		/* unmodified pointer to orignal buffer */
 	uint origsize;		/* unmodified orignal buffer size in bytes */
 } bcm_xdr_buf_t;
 
-void bcm_xdr_buf_init(bcm_xdr_buf_t * b, void *buf, size_t len);
+void bcm_xdr_buf_init(bcm_xdr_buf_t *b, void *buf, size_t len);
 
-int bcm_xdr_pack_uint32(bcm_xdr_buf_t * b, uint32 val);
-int bcm_xdr_unpack_uint32(bcm_xdr_buf_t * b, uint32 * pval);
-int bcm_xdr_pack_int32(bcm_xdr_buf_t * b, int32 val);
-int bcm_xdr_unpack_int32(bcm_xdr_buf_t * b, int32 * pval);
-int bcm_xdr_pack_int8(bcm_xdr_buf_t * b, int8 val);
-int bcm_xdr_unpack_int8(bcm_xdr_buf_t * b, int8 * pval);
-int bcm_xdr_pack_opaque(bcm_xdr_buf_t * b, uint len, void *data);
-int bcm_xdr_unpack_opaque(bcm_xdr_buf_t * b, uint len, void **pdata);
-int bcm_xdr_unpack_opaque_cpy(bcm_xdr_buf_t * b, uint len, void *data);
-int bcm_xdr_pack_opaque_varlen(bcm_xdr_buf_t * b, uint len, void *data);
-int bcm_xdr_unpack_opaque_varlen(bcm_xdr_buf_t * b, uint * plen, void **pdata);
-int bcm_xdr_pack_string(bcm_xdr_buf_t * b, char *str);
-int bcm_xdr_unpack_string(bcm_xdr_buf_t * b, uint * plen, char **pstr);
+int bcm_xdr_pack_u32(bcm_xdr_buf_t *b, u32 val);
+int bcm_xdr_unpack_u32(bcm_xdr_buf_t *b, u32 *pval);
+int bcm_xdr_pack_s32(bcm_xdr_buf_t *b, s32 val);
+int bcm_xdr_unpack_s32(bcm_xdr_buf_t *b, s32 *pval);
+int bcm_xdr_pack_s8(bcm_xdr_buf_t *b, s8 val);
+int bcm_xdr_unpack_s8(bcm_xdr_buf_t *b, s8 *pval);
+int bcm_xdr_pack_opaque(bcm_xdr_buf_t *b, uint len, void *data);
+int bcm_xdr_unpack_opaque(bcm_xdr_buf_t *b, uint len, void **pdata);
+int bcm_xdr_unpack_opaque_cpy(bcm_xdr_buf_t *b, uint len, void *data);
+int bcm_xdr_pack_opaque_varlen(bcm_xdr_buf_t *b, uint len, void *data);
+int bcm_xdr_unpack_opaque_varlen(bcm_xdr_buf_t *b, uint *plen, void **pdata);
+int bcm_xdr_pack_string(bcm_xdr_buf_t *b, char *str);
+int bcm_xdr_unpack_string(bcm_xdr_buf_t *b, uint *plen, char **pstr);
 
-int bcm_xdr_pack_uint8_vec(bcm_xdr_buf_t *, uint8 * vec, uint32 elems);
-int bcm_xdr_unpack_uint8_vec(bcm_xdr_buf_t *, uint8 * vec, uint32 elems);
-int bcm_xdr_pack_uint16_vec(bcm_xdr_buf_t * b, uint len, void *vec);
-int bcm_xdr_unpack_uint16_vec(bcm_xdr_buf_t * b, uint len, void *vec);
-int bcm_xdr_pack_uint32_vec(bcm_xdr_buf_t * b, uint len, void *vec);
-int bcm_xdr_unpack_uint32_vec(bcm_xdr_buf_t * b, uint len, void *vec);
+int bcm_xdr_pack_u8_vec(bcm_xdr_buf_t *, u8 *vec, u32 elems);
+int bcm_xdr_unpack_u8_vec(bcm_xdr_buf_t *, u8 *vec, u32 elems);
+int bcm_xdr_pack_u16_vec(bcm_xdr_buf_t *b, uint len, void *vec);
+int bcm_xdr_unpack_u16_vec(bcm_xdr_buf_t *b, uint len, void *vec);
+int bcm_xdr_pack_u32_vec(bcm_xdr_buf_t *b, uint len, void *vec);
+int bcm_xdr_unpack_u32_vec(bcm_xdr_buf_t *b, uint len, void *vec);
 
-int bcm_xdr_pack_opaque_raw(bcm_xdr_buf_t * b, uint len, void *data);
-int bcm_xdr_pack_opaque_pad(bcm_xdr_buf_t * b);
+int bcm_xdr_pack_opaque_raw(bcm_xdr_buf_t *b, uint len, void *data);
+int bcm_xdr_pack_opaque_pad(bcm_xdr_buf_t *b);
 
 #endif				/* _BCM_XDR_H */
diff --git a/drivers/staging/brcm80211/include/bcmcdc.h b/drivers/staging/brcm80211/include/bcmcdc.h
new file mode 100644
index 0000000..10c1ddc
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcmcdc.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <proto/ethernet.h>
+
+typedef struct cdc_ioctl {
+	u32 cmd;		/* ioctl command value */
+	u32 len;		/* lower 16: output buflen; upper 16:
+				 input buflen (excludes header) */
+	u32 flags;		/* flag defns given below */
+	u32 status;		/* status code returned from the device */
+} cdc_ioctl_t;
+
+/* Max valid buffer size that can be sent to the dongle */
+#define CDC_MAX_MSG_SIZE   ETHER_MAX_LEN
+
+/* len field is divided into input and output buffer lengths */
+#define CDCL_IOC_OUTLEN_MASK   0x0000FFFF	/* maximum or expected
+						 response length, */
+					   /* excluding IOCTL header */
+#define CDCL_IOC_OUTLEN_SHIFT  0
+#define CDCL_IOC_INLEN_MASK    0xFFFF0000	/* input buffer length,
+						 excluding IOCTL header */
+#define CDCL_IOC_INLEN_SHIFT   16
+
+/* CDC flag definitions */
+#define CDCF_IOC_ERROR		0x01	/* 0=success, 1=ioctl cmd failed */
+#define CDCF_IOC_SET		0x02	/* 0=get, 1=set cmd */
+#define CDCF_IOC_IF_MASK	0xF000	/* I/F index */
+#define CDCF_IOC_IF_SHIFT	12
+#define CDCF_IOC_ID_MASK	0xFFFF0000	/* used to uniquely id an ioctl
+						 req/resp pairing */
+#define CDCF_IOC_ID_SHIFT	16	/* # of bits of shift for ID Mask */
+
+#define CDC_IOC_IF_IDX(flags)	\
+	(((flags) & CDCF_IOC_IF_MASK) >> CDCF_IOC_IF_SHIFT)
+#define CDC_IOC_ID(flags)	\
+	(((flags) & CDCF_IOC_ID_MASK) >> CDCF_IOC_ID_SHIFT)
+
+#define CDC_GET_IF_IDX(hdr) \
+	((int)((((hdr)->flags) & CDCF_IOC_IF_MASK) >> CDCF_IOC_IF_SHIFT))
+#define CDC_SET_IF_IDX(hdr, idx) \
+	((hdr)->flags = (((hdr)->flags & ~CDCF_IOC_IF_MASK) | \
+	((idx) << CDCF_IOC_IF_SHIFT)))
+
+/*
+ * BDC header
+ *
+ *   The BDC header is used on data packets to convey priority across USB.
+ */
+
+#define	BDC_HEADER_LEN		4
+
+#define BDC_PROTO_VER		1	/* Protocol version */
+
+#define BDC_FLAG_VER_MASK	0xf0	/* Protocol version mask */
+#define BDC_FLAG_VER_SHIFT	4	/* Protocol version shift */
+
+#define BDC_FLAG__UNUSED	0x03	/* Unassigned */
+#define BDC_FLAG_SUM_GOOD	0x04	/* Dongle has verified good
+					 RX checksums */
+#define BDC_FLAG_SUM_NEEDED	0x08	/* Dongle needs to do TX checksums */
+
+#define BDC_PRIORITY_MASK	0x7
+
+#define BDC_FLAG2_FC_FLAG	0x10	/* flag to indicate if pkt contains */
+						/* FLOW CONTROL info only */
+#define BDC_PRIORITY_FC_SHIFT	4	/* flow control info shift */
+
+#define BDC_FLAG2_IF_MASK	0x0f	/* APSTA: interface on which the
+					 packet was received */
+#define BDC_FLAG2_IF_SHIFT	0
+
+#define BDC_GET_IF_IDX(hdr) \
+	((int)((((hdr)->flags2) & BDC_FLAG2_IF_MASK) >> BDC_FLAG2_IF_SHIFT))
+#define BDC_SET_IF_IDX(hdr, idx) \
+	((hdr)->flags2 = (((hdr)->flags2 & ~BDC_FLAG2_IF_MASK) | \
+	((idx) << BDC_FLAG2_IF_SHIFT)))
+
+struct bdc_header {
+	u8 flags;		/* Flags */
+	u8 priority;		/* 802.1d Priority 0:2 bits, 4:7 flow
+				 control info for usb */
+	u8 flags2;
+	u8 rssi;
+};
diff --git a/drivers/staging/brcm80211/include/bcmdefs.h b/drivers/staging/brcm80211/include/bcmdefs.h
index caa96b1..dc52e9d 100644
--- a/drivers/staging/brcm80211/include/bcmdefs.h
+++ b/drivers/staging/brcm80211/include/bcmdefs.h
@@ -17,39 +17,25 @@
 #ifndef	_bcmdefs_h_
 #define	_bcmdefs_h_
 
-/*
- * One doesn't need to include this file explicitly, gets included automatically if
- * typedefs.h is included.
- */
+#define	SI_BUS			0
+#define	PCI_BUS			1
+#define	PCMCIA_BUS		2
+#define SDIO_BUS		3
+#define JTAG_BUS		4
+#define USB_BUS			5
+#define SPI_BUS			6
 
-/* Use BCM_REFERENCE to suppress warnings about intentionally-unused function
- * arguments or local variables.
- */
-#define BCM_REFERENCE(data)	((void)data)
 
-/* Reclaiming text and data :
- * The following macros specify special linker sections that can be reclaimed
- * after a system is considered 'up'.
- * BCMATTACHFN is also used for detach functions (it's not worth having a BCMDETACHFN,
- * as in most cases, the attach function calls the detach function to clean up on error).
- */
+#ifndef OFF
+#define	OFF	0
+#endif
+
+#ifndef ON
+#define	ON	1		/* ON = 1 */
+#endif
+
+#define	AUTO	(-1)		/* Auto = -1 */
 
-#define bcmreclaimed 		0
-#define BCMATTACHDATA(_data)	_data
-#define BCMATTACHFN(_fn)	_fn
-#define BCMPREATTACHDATA(_data)	_data
-#define BCMPREATTACHFN(_fn)	_fn
-#define BCMINITDATA(_data)	_data
-#define BCMINITFN(_fn)		_fn
-#define BCMUNINITFN(_fn)	_fn
-#define	BCMNMIATTACHFN(_fn)	_fn
-#define	BCMNMIATTACHDATA(_data)	_data
-#define BCMOVERLAY0DATA(_sym)	_sym
-#define BCMOVERLAY0FN(_fn)	_fn
-#define BCMOVERLAY1DATA(_sym)	_sym
-#define BCMOVERLAY1FN(_fn)	_fn
-#define BCMOVERLAYERRFN(_fn)	_fn
-#define CONST	const
 #ifdef mips
 #define BCMFASTPATH		__attribute__ ((__section__(".text.fastpath")))
 #else
@@ -57,15 +43,7 @@
 #endif
 
 /* Put some library data/code into ROM to reduce RAM requirements */
-#define BCMROMDATA(_data)	_data
-#define BCMROMDAT_NAME(_data)	_data
 #define BCMROMFN(_fn)		_fn
-#define BCMROMFN_NAME(_fn)	_fn
-#define STATIC	static
-#define BCMROMDAT_ARYSIZ(data)	ARRAYSIZE(data)
-#define BCMROMDAT_SIZEOF(data)	sizeof(data)
-#define BCMROMDAT_APATCH(data)
-#define BCMROMDAT_SPATCH(data)
 
 /* Bus types */
 #define	SI_BUS			0	/* SOC Interconnect */
@@ -118,8 +96,8 @@
 
 #ifdef BCMDMA64OSL
 typedef struct {
-	uint32 loaddr;
-	uint32 hiaddr;
+	u32 loaddr;
+	u32 hiaddr;
 } dma64addr_t;
 
 typedef dma64addr_t dmaaddr_t;
@@ -148,7 +126,7 @@ typedef unsigned long dmaaddr_t;
 /* One physical DMA segment */
 typedef struct {
 	dmaaddr_t addr;
-	uint32 length;
+	u32 length;
 } hnddma_seg_t;
 
 #define MAX_DMA_SEGS 4
@@ -214,11 +192,9 @@ typedef struct {
 
 /* define BCMSMALL to remove misc features for memory-constrained environments */
 #define	BCMSPACE
-#define bcmspace	TRUE	/* if (bcmspace) code is retained */
+#define bcmspace	true	/* if (bcmspace) code is retained */
 
 /* Max. nvram variable table size */
 #define	MAXSZ_NVRAM_VARS	4096
 
-#define LOCATOR_EXTERN static
-
 #endif				/* _bcmdefs_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmdevs.h b/drivers/staging/brcm80211/include/bcmdevs.h
index 7d3a97a..075883a 100644
--- a/drivers/staging/brcm80211/include/bcmdevs.h
+++ b/drivers/staging/brcm80211/include/bcmdevs.h
@@ -24,9 +24,13 @@
 #define BCM_DNGL_VID		0x0a5c
 #define BCM_DNGL_BDC_PID	0x0bdc
 
+#define	BCM4325_D11DUAL_ID	0x431b
+#define	BCM4325_D11G_ID		0x431c
+#define	BCM4325_D11A_ID		0x431d
 #define BCM4329_D11N_ID		0x432e	/* 4329 802.11n dualband device */
 #define BCM4329_D11N2G_ID	0x432f	/* 4329 802.11n 2.4G device */
 #define BCM4329_D11N5G_ID	0x4330	/* 4329 802.11n 5G device */
+#define BCM4329_D11NDUAL_ID	0x432e
 
 #define BCM4319_D11N_ID		0x4337	/* 4319 802.11n dualband device */
 #define BCM4319_D11N2G_ID	0x4338	/* 4319 802.11n 2.4G device */
@@ -62,6 +66,7 @@
 #define	BCM43236_CHIP_ID	43236	/* 43236 chipcommon chipid */
 #define	BCM43238_CHIP_ID	43238	/* 43238 chipcommon chipid */
 #define	BCM4329_CHIP_ID		0x4329	/* 4329 chipcommon chipid */
+#define	BCM4325_CHIP_ID		0x4325	/* 4325 chipcommon chipid */
 #define	BCM4331_CHIP_ID		0x4331	/* 4331 chipcommon chipid */
 #define BCM4336_CHIP_ID		0x4336	/* 4336 chipcommon chipid */
 #define BCM4330_CHIP_ID		0x4330	/* 4330 chipcommon chipid */
diff --git a/drivers/staging/brcm80211/include/bcmendian.h b/drivers/staging/brcm80211/include/bcmendian.h
index 12c1890..4123aef 100644
--- a/drivers/staging/brcm80211/include/bcmendian.h
+++ b/drivers/staging/brcm80211/include/bcmendian.h
@@ -17,24 +17,22 @@
 #ifndef _BCMENDIAN_H_
 #define _BCMENDIAN_H_
 
-#include <typedefs.h>
-
 /* Reverse the bytes in a 16-bit value */
 #define BCMSWAP16(val) \
-	((uint16)((((uint16)(val) & (uint16)0x00ffU) << 8) | \
-		  (((uint16)(val) & (uint16)0xff00U) >> 8)))
+	((u16)((((u16)(val) & (u16)0x00ffU) << 8) | \
+		  (((u16)(val) & (u16)0xff00U) >> 8)))
 
 /* Reverse the bytes in a 32-bit value */
 #define BCMSWAP32(val) \
-	((uint32)((((uint32)(val) & (uint32)0x000000ffU) << 24) | \
-		  (((uint32)(val) & (uint32)0x0000ff00U) <<  8) | \
-		  (((uint32)(val) & (uint32)0x00ff0000U) >>  8) | \
-		  (((uint32)(val) & (uint32)0xff000000U) >> 24)))
+	((u32)((((u32)(val) & (u32)0x000000ffU) << 24) | \
+		  (((u32)(val) & (u32)0x0000ff00U) <<  8) | \
+		  (((u32)(val) & (u32)0x00ff0000U) >>  8) | \
+		  (((u32)(val) & (u32)0xff000000U) >> 24)))
 
 /* Reverse the two 16-bit halves of a 32-bit value */
 #define BCMSWAP32BY16(val) \
-	((uint32)((((uint32)(val) & (uint32)0x0000ffffU) << 16) | \
-		  (((uint32)(val) & (uint32)0xffff0000U) >> 16)))
+	((u32)((((u32)(val) & (u32)0x0000ffffU) << 16) | \
+		  (((u32)(val) & (u32)0xffff0000U) >> 16)))
 
 /* Byte swapping macros
  *    Host <=> Network (Big Endian) for 16- and 32-bit values
@@ -82,8 +80,8 @@
 #define ltoh16_buf(buf, i)
 #define htol16_buf(buf, i)
 #else
-#define ltoh16_buf(buf, i) bcmswap16_buf((uint16 *)(buf), (i))
-#define htol16_buf(buf, i) bcmswap16_buf((uint16 *)(buf), (i))
+#define ltoh16_buf(buf, i) bcmswap16_buf((u16 *)(buf), (i))
+#define htol16_buf(buf, i) bcmswap16_buf((u16 *)(buf), (i))
 #endif				/* IL_BIGENDIAN */
 
 /* Unaligned loads and stores in host byte order */
@@ -105,16 +103,16 @@
 #define _NTOH32_UA(cp)	(((cp)[0] << 24) | ((cp)[1] << 16) | ((cp)[2] << 8) | (cp)[3])
 
 #define ltoh_ua(ptr) \
-	(sizeof(*(ptr)) == sizeof(uint8) ? *(const uint8 *)(ptr) : \
-	 sizeof(*(ptr)) == sizeof(uint16) ? _LTOH16_UA((const uint8 *)(ptr)) : \
-	 sizeof(*(ptr)) == sizeof(uint32) ? _LTOH32_UA((const uint8 *)(ptr)) : \
-	 *(uint8 *)0)
+	(sizeof(*(ptr)) == sizeof(u8) ? *(const u8 *)(ptr) : \
+	 sizeof(*(ptr)) == sizeof(u16) ? _LTOH16_UA((const u8 *)(ptr)) : \
+	 sizeof(*(ptr)) == sizeof(u32) ? _LTOH32_UA((const u8 *)(ptr)) : \
+	 *(u8 *)0)
 
 #define ntoh_ua(ptr) \
-	(sizeof(*(ptr)) == sizeof(uint8) ? *(const uint8 *)(ptr) : \
-	 sizeof(*(ptr)) == sizeof(uint16) ? _NTOH16_UA((const uint8 *)(ptr)) : \
-	 sizeof(*(ptr)) == sizeof(uint32) ? _NTOH32_UA((const uint8 *)(ptr)) : \
-	 *(uint8 *)0)
+	(sizeof(*(ptr)) == sizeof(u8) ? *(const u8 *)(ptr) : \
+	 sizeof(*(ptr)) == sizeof(u16) ? _NTOH16_UA((const u8 *)(ptr)) : \
+	 sizeof(*(ptr)) == sizeof(u32) ? _NTOH32_UA((const u8 *)(ptr)) : \
+	 *(u8 *)0)
 
 #ifdef __GNUC__
 
@@ -123,22 +121,22 @@
  */
 
 #define bcmswap16(val) ({ \
-	uint16 _val = (val); \
+	u16 _val = (val); \
 	BCMSWAP16(_val); \
 })
 
 #define bcmswap32(val) ({ \
-	uint32 _val = (val); \
+	u32 _val = (val); \
 	BCMSWAP32(_val); \
 })
 
 #define bcmswap32by16(val) ({ \
-	uint32 _val = (val); \
+	u32 _val = (val); \
 	BCMSWAP32BY16(_val); \
 })
 
 #define bcmswap16_buf(buf, len) ({ \
-	uint16 *_buf = (uint16 *)(buf); \
+	u16 *_buf = (u16 *)(buf); \
 	uint _wds = (len) / 2; \
 	while (_wds--) { \
 		*_buf = bcmswap16(*_buf); \
@@ -147,15 +145,15 @@
 })
 
 #define htol16_ua_store(val, bytes) ({ \
-	uint16 _val = (val); \
-	uint8 *_bytes = (uint8 *)(bytes); \
+	u16 _val = (val); \
+	u8 *_bytes = (u8 *)(bytes); \
 	_bytes[0] = _val & 0xff; \
 	_bytes[1] = _val >> 8; \
 })
 
 #define htol32_ua_store(val, bytes) ({ \
-	uint32 _val = (val); \
-	uint8 *_bytes = (uint8 *)(bytes); \
+	u32 _val = (val); \
+	u8 *_bytes = (u8 *)(bytes); \
 	_bytes[0] = _val & 0xff; \
 	_bytes[1] = (_val >> 8) & 0xff; \
 	_bytes[2] = (_val >> 16) & 0xff; \
@@ -163,15 +161,15 @@
 })
 
 #define hton16_ua_store(val, bytes) ({ \
-	uint16 _val = (val); \
-	uint8 *_bytes = (uint8 *)(bytes); \
+	u16 _val = (val); \
+	u8 *_bytes = (u8 *)(bytes); \
 	_bytes[0] = _val >> 8; \
 	_bytes[1] = _val & 0xff; \
 })
 
 #define hton32_ua_store(val, bytes) ({ \
-	uint32 _val = (val); \
-	uint8 *_bytes = (uint8 *)(bytes); \
+	u32 _val = (val); \
+	u8 *_bytes = (u8 *)(bytes); \
 	_bytes[0] = _val >> 24; \
 	_bytes[1] = (_val >> 16) & 0xff; \
 	_bytes[2] = (_val >> 8) & 0xff; \
@@ -179,39 +177,39 @@
 })
 
 #define ltoh16_ua(bytes) ({ \
-	const uint8 *_bytes = (const uint8 *)(bytes); \
+	const u8 *_bytes = (const u8 *)(bytes); \
 	_LTOH16_UA(_bytes); \
 })
 
 #define ltoh32_ua(bytes) ({ \
-	const uint8 *_bytes = (const uint8 *)(bytes); \
+	const u8 *_bytes = (const u8 *)(bytes); \
 	_LTOH32_UA(_bytes); \
 })
 
 #define ntoh16_ua(bytes) ({ \
-	const uint8 *_bytes = (const uint8 *)(bytes); \
+	const u8 *_bytes = (const u8 *)(bytes); \
 	_NTOH16_UA(_bytes); \
 })
 
 #define ntoh32_ua(bytes) ({ \
-	const uint8 *_bytes = (const uint8 *)(bytes); \
+	const u8 *_bytes = (const u8 *)(bytes); \
 	_NTOH32_UA(_bytes); \
 })
 
 #else				/* !__GNUC__ */
 
 /* Inline versions avoid referencing the argument multiple times */
-static INLINE uint16 bcmswap16(uint16 val)
+static inline u16 bcmswap16(u16 val)
 {
 	return BCMSWAP16(val);
 }
 
-static INLINE uint32 bcmswap32(uint32 val)
+static inline u32 bcmswap32(u32 val)
 {
 	return BCMSWAP32(val);
 }
 
-static INLINE uint32 bcmswap32by16(uint32 val)
+static inline u32 bcmswap32by16(u32 val)
 {
 	return BCMSWAP32BY16(val);
 }
@@ -219,7 +217,7 @@ static INLINE uint32 bcmswap32by16(uint32 val)
 /* Reverse pairs of bytes in a buffer (not for high-performance use) */
 /* buf	- start of buffer of shorts to swap */
 /* len  - byte length of buffer */
-static INLINE void bcmswap16_buf(uint16 * buf, uint len)
+static inline void bcmswap16_buf(u16 *buf, uint len)
 {
 	len = len / 2;
 
@@ -232,7 +230,7 @@ static INLINE void bcmswap16_buf(uint16 * buf, uint len)
 /*
  * Store 16-bit value to unaligned little-endian byte array.
  */
-static INLINE void htol16_ua_store(uint16 val, uint8 * bytes)
+static inline void htol16_ua_store(u16 val, u8 *bytes)
 {
 	bytes[0] = val & 0xff;
 	bytes[1] = val >> 8;
@@ -241,7 +239,7 @@ static INLINE void htol16_ua_store(uint16 val, uint8 * bytes)
 /*
  * Store 32-bit value to unaligned little-endian byte array.
  */
-static INLINE void htol32_ua_store(uint32 val, uint8 * bytes)
+static inline void htol32_ua_store(u32 val, u8 *bytes)
 {
 	bytes[0] = val & 0xff;
 	bytes[1] = (val >> 8) & 0xff;
@@ -252,7 +250,7 @@ static INLINE void htol32_ua_store(uint32 val, uint8 * bytes)
 /*
  * Store 16-bit value to unaligned network-(big-)endian byte array.
  */
-static INLINE void hton16_ua_store(uint16 val, uint8 * bytes)
+static inline void hton16_ua_store(u16 val, u8 *bytes)
 {
 	bytes[0] = val >> 8;
 	bytes[1] = val & 0xff;
@@ -261,7 +259,7 @@ static INLINE void hton16_ua_store(uint16 val, uint8 * bytes)
 /*
  * Store 32-bit value to unaligned network-(big-)endian byte array.
  */
-static INLINE void hton32_ua_store(uint32 val, uint8 * bytes)
+static inline void hton32_ua_store(u32 val, u8 *bytes)
 {
 	bytes[0] = val >> 24;
 	bytes[1] = (val >> 16) & 0xff;
@@ -272,33 +270,33 @@ static INLINE void hton32_ua_store(uint32 val, uint8 * bytes)
 /*
  * Load 16-bit value from unaligned little-endian byte array.
  */
-static INLINE uint16 ltoh16_ua(const void *bytes)
+static inline u16 ltoh16_ua(const void *bytes)
 {
-	return _LTOH16_UA((const uint8 *)bytes);
+	return _LTOH16_UA((const u8 *)bytes);
 }
 
 /*
  * Load 32-bit value from unaligned little-endian byte array.
  */
-static INLINE uint32 ltoh32_ua(const void *bytes)
+static inline u32 ltoh32_ua(const void *bytes)
 {
-	return _LTOH32_UA((const uint8 *)bytes);
+	return _LTOH32_UA((const u8 *)bytes);
 }
 
 /*
  * Load 16-bit value from unaligned big-(network-)endian byte array.
  */
-static INLINE uint16 ntoh16_ua(const void *bytes)
+static inline u16 ntoh16_ua(const void *bytes)
 {
-	return _NTOH16_UA((const uint8 *)bytes);
+	return _NTOH16_UA((const u8 *)bytes);
 }
 
 /*
  * Load 32-bit value from unaligned big-(network-)endian byte array.
  */
-static INLINE uint32 ntoh32_ua(const void *bytes)
+static inline u32 ntoh32_ua(const void *bytes)
 {
-	return _NTOH32_UA((const uint8 *)bytes);
+	return _NTOH32_UA((const u8 *)bytes);
 }
 
 #endif				/* !__GNUC__ */
diff --git a/drivers/staging/brcm80211/include/bcmnvram.h b/drivers/staging/brcm80211/include/bcmnvram.h
index 2fe940d..63e31a4 100644
--- a/drivers/staging/brcm80211/include/bcmnvram.h
+++ b/drivers/staging/brcm80211/include/bcmnvram.h
@@ -19,15 +19,14 @@
 
 #ifndef _LANGUAGE_ASSEMBLY
 
-#include <typedefs.h>
 #include <bcmdefs.h>
 
 struct nvram_header {
-	uint32 magic;
-	uint32 len;
-	uint32 crc_ver_init;	/* 0:7 crc, 8:15 ver, 16:31 sdram_init */
-	uint32 config_refresh;	/* 0:15 sdram_config, 16:31 sdram_refresh */
-	uint32 config_ncdl;	/* ncdl values for memc */
+	u32 magic;
+	u32 len;
+	u32 crc_ver_init;	/* 0:7 crc, 8:15 ver, 16:31 sdram_init */
+	u32 config_refresh;	/* 0:15 sdram_config, 16:31 sdram_refresh */
+	u32 config_ncdl;	/* ncdl values for memc */
 };
 
 struct nvram_tuple {
@@ -75,7 +74,7 @@ extern char *nvram_get(const char *name);
  * Read the reset GPIO value from the nvram and set the GPIO
  * as input
  */
-extern int BCMINITFN(nvram_resetgpio_init) (void *sih);
+extern int nvram_resetgpio_init(void *sih);
 
 /*
  * Get the value of an NVRAM variable.
@@ -88,26 +87,26 @@ extern int BCMINITFN(nvram_resetgpio_init) (void *sih);
  * Match an NVRAM variable.
  * @param	name	name of variable to match
  * @param	match	value to compare against value of variable
- * @return	TRUE if variable is defined and its value is string equal
- *		to match or FALSE otherwise
+ * @return	true if variable is defined and its value is string equal
+ *		to match or false otherwise
  */
-static INLINE int nvram_match(char *name, char *match)
+static inline int nvram_match(char *name, char *match)
 {
 	const char *value = nvram_get(name);
-	return (value && !strcmp(value, match));
+	return value && !strcmp(value, match);
 }
 
 /*
  * Inversely match an NVRAM variable.
  * @param	name	name of variable to match
  * @param	match	value to compare against value of variable
- * @return	TRUE if variable is defined and its value is not string
- *		equal to invmatch or FALSE otherwise
+ * @return	true if variable is defined and its value is not string
+ *		equal to invmatch or false otherwise
  */
-static INLINE int nvram_invmatch(char *name, char *invmatch)
+static inline int nvram_invmatch(char *name, char *invmatch)
 {
 	const char *value = nvram_get(name);
-	return (value && strcmp(value, invmatch));
+	return value && strcmp(value, invmatch);
 }
 
 /*
@@ -150,7 +149,7 @@ extern int nvram_getall(char *nvram_buf, int count);
  * returns the crc value of the nvram
  * @param	nvh	nvram header pointer
  */
-uint8 nvram_calc_crc(struct nvram_header *nvh);
+u8 nvram_calc_crc(struct nvram_header *nvh);
 
 #endif				/* _LANGUAGE_ASSEMBLY */
 
diff --git a/drivers/staging/brcm80211/include/bcmotp.h b/drivers/staging/brcm80211/include/bcmotp.h
index 9186878..5803acc 100644
--- a/drivers/staging/brcm80211/include/bcmotp.h
+++ b/drivers/staging/brcm80211/include/bcmotp.h
@@ -36,9 +36,9 @@
 /* Exported functions */
 extern int otp_status(void *oh);
 extern int otp_size(void *oh);
-extern uint16 otp_read_bit(void *oh, uint offset);
-extern void *otp_init(si_t * sih);
-extern int otp_read_region(si_t * sih, int region, uint16 * data, uint * wlen);
-extern int otp_nvread(void *oh, char *data, uint * len);
+extern u16 otp_read_bit(void *oh, uint offset);
+extern void *otp_init(si_t *sih);
+extern int otp_read_region(si_t *sih, int region, u16 *data, uint *wlen);
+extern int otp_nvread(void *oh, char *data, uint *len);
 
 #endif				/* _bcmotp_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmsdbus.h b/drivers/staging/brcm80211/include/bcmsdbus.h
index 36dd3cf..ca99495 100644
--- a/drivers/staging/brcm80211/include/bcmsdbus.h
+++ b/drivers/staging/brcm80211/include/bcmsdbus.h
@@ -46,68 +46,68 @@ typedef void (*sdioh_cb_fn_t) (void *);
  *  The handler shall be provided by all subsequent calls. No local cache
  *  cfghdl points to the starting address of pci device mapped memory
  */
-extern sdioh_info_t *sdioh_attach(osl_t * osh, void *cfghdl, uint irq);
-extern SDIOH_API_RC sdioh_detach(osl_t * osh, sdioh_info_t * si);
-extern SDIOH_API_RC sdioh_interrupt_register(sdioh_info_t * si,
+extern sdioh_info_t *sdioh_attach(osl_t *osh, void *cfghdl, uint irq);
+extern SDIOH_API_RC sdioh_detach(osl_t *osh, sdioh_info_t *si);
+extern SDIOH_API_RC sdioh_interrupt_register(sdioh_info_t *si,
 					     sdioh_cb_fn_t fn, void *argh);
-extern SDIOH_API_RC sdioh_interrupt_deregister(sdioh_info_t * si);
+extern SDIOH_API_RC sdioh_interrupt_deregister(sdioh_info_t *si);
 
 /* query whether SD interrupt is enabled or not */
-extern SDIOH_API_RC sdioh_interrupt_query(sdioh_info_t * si, bool * onoff);
+extern SDIOH_API_RC sdioh_interrupt_query(sdioh_info_t *si, bool *onoff);
 
 /* enable or disable SD interrupt */
-extern SDIOH_API_RC sdioh_interrupt_set(sdioh_info_t * si, bool enable_disable);
+extern SDIOH_API_RC sdioh_interrupt_set(sdioh_info_t *si, bool enable_disable);
 
 #if defined(BCMDBG)
-extern bool sdioh_interrupt_pending(sdioh_info_t * si);
+extern bool sdioh_interrupt_pending(sdioh_info_t *si);
 #endif
 
-extern int sdioh_claim_host_and_lock(sdioh_info_t * si);
-extern int sdioh_release_host_and_unlock(sdioh_info_t * si);
+extern int sdioh_claim_host_and_lock(sdioh_info_t *si);
+extern int sdioh_release_host_and_unlock(sdioh_info_t *si);
 
 /* read or write one byte using cmd52 */
-extern SDIOH_API_RC sdioh_request_byte(sdioh_info_t * si, uint rw, uint fnc,
-				       uint addr, uint8 * byte);
+extern SDIOH_API_RC sdioh_request_byte(sdioh_info_t *si, uint rw, uint fnc,
+				       uint addr, u8 *byte);
 
 /* read or write 2/4 bytes using cmd53 */
-extern SDIOH_API_RC sdioh_request_word(sdioh_info_t * si, uint cmd_type,
+extern SDIOH_API_RC sdioh_request_word(sdioh_info_t *si, uint cmd_type,
 				       uint rw, uint fnc, uint addr,
-				       uint32 * word, uint nbyte);
+				       u32 *word, uint nbyte);
 
 /* read or write any buffer using cmd53 */
-extern SDIOH_API_RC sdioh_request_buffer(sdioh_info_t * si, uint pio_dma,
+extern SDIOH_API_RC sdioh_request_buffer(sdioh_info_t *si, uint pio_dma,
 					 uint fix_inc, uint rw, uint fnc_num,
-					 uint32 addr, uint regwidth,
-					 uint32 buflen, uint8 * buffer,
+					 u32 addr, uint regwidth,
+					 u32 buflen, u8 *buffer,
 					 void *pkt);
 
 /* get cis data */
-extern SDIOH_API_RC sdioh_cis_read(sdioh_info_t * si, uint fuc, uint8 * cis,
-				   uint32 length);
+extern SDIOH_API_RC sdioh_cis_read(sdioh_info_t *si, uint fuc, u8 *cis,
+				   u32 length);
 
-extern SDIOH_API_RC sdioh_cfg_read(sdioh_info_t * si, uint fuc, uint32 addr,
-				   uint8 * data);
-extern SDIOH_API_RC sdioh_cfg_write(sdioh_info_t * si, uint fuc, uint32 addr,
-				    uint8 * data);
+extern SDIOH_API_RC sdioh_cfg_read(sdioh_info_t *si, uint fuc, u32 addr,
+				   u8 *data);
+extern SDIOH_API_RC sdioh_cfg_write(sdioh_info_t *si, uint fuc, u32 addr,
+				    u8 *data);
 
 /* query number of io functions */
-extern uint sdioh_query_iofnum(sdioh_info_t * si);
+extern uint sdioh_query_iofnum(sdioh_info_t *si);
 
 /* handle iovars */
-extern int sdioh_iovar_op(sdioh_info_t * si, const char *name,
+extern int sdioh_iovar_op(sdioh_info_t *si, const char *name,
 			  void *params, int plen, void *arg, int len, bool set);
 
 /* Issue abort to the specified function and clear controller as needed */
-extern int sdioh_abort(sdioh_info_t * si, uint fnc);
+extern int sdioh_abort(sdioh_info_t *si, uint fnc);
 
 /* Start and Stop SDIO without re-enumerating the SD card. */
-extern int sdioh_start(sdioh_info_t * si, int stage);
-extern int sdioh_stop(sdioh_info_t * si);
+extern int sdioh_start(sdioh_info_t *si, int stage);
+extern int sdioh_stop(sdioh_info_t *si);
 
 /* Reset and re-initialize the device */
-extern int sdioh_sdio_reset(sdioh_info_t * si);
+extern int sdioh_sdio_reset(sdioh_info_t *si);
 
 /* Helper function */
-void *bcmsdh_get_sdioh(bcmsdh_info_t * sdh);
+void *bcmsdh_get_sdioh(bcmsdh_info_t *sdh);
 
 #endif				/* _sdio_api_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmsdh.h b/drivers/staging/brcm80211/include/bcmsdh.h
index 551ca57..6b80983 100644
--- a/drivers/staging/brcm80211/include/bcmsdh.h
+++ b/drivers/staging/brcm80211/include/bcmsdh.h
@@ -40,11 +40,11 @@ typedef void (*bcmsdh_cb_fn_t) (void *);
  *    implementation may maintain a single "default" handle (e.g. the first or
  *    most recent one) to enable single-instance implementations to pass NULL.
  */
-extern bcmsdh_info_t *bcmsdh_attach(osl_t * osh, void *cfghdl, void **regsva,
+extern bcmsdh_info_t *bcmsdh_attach(osl_t *osh, void *cfghdl, void **regsva,
 				    uint irq);
 
 /* Detach - freeup resources allocated in attach */
-extern int bcmsdh_detach(osl_t * osh, void *sdh);
+extern int bcmsdh_detach(osl_t *osh, void *sdh);
 
 /* Query if SD device interrupts are enabled */
 extern bool bcmsdh_intr_query(void *sdh);
@@ -75,15 +75,15 @@ extern int bcmsdh_devremove_reg(void *sdh, bcmsdh_cb_fn_t fn, void *argh);
  *   data: data byte to write
  *   err:  pointer to error code (or NULL)
  */
-extern uint8 bcmsdh_cfg_read(void *sdh, uint func, uint32 addr, int *err);
-extern void bcmsdh_cfg_write(void *sdh, uint func, uint32 addr, uint8 data,
+extern u8 bcmsdh_cfg_read(void *sdh, uint func, u32 addr, int *err);
+extern void bcmsdh_cfg_write(void *sdh, uint func, u32 addr, u8 data,
 			     int *err);
 
 /* Read/Write 4bytes from/to cfg space */
-extern uint32 bcmsdh_cfg_read_word(void *sdh, uint fnc_num, uint32 addr,
+extern u32 bcmsdh_cfg_read_word(void *sdh, uint fnc_num, u32 addr,
 				   int *err);
-extern void bcmsdh_cfg_write_word(void *sdh, uint fnc_num, uint32 addr,
-				  uint32 data, int *err);
+extern void bcmsdh_cfg_write_word(void *sdh, uint fnc_num, u32 addr,
+				  u32 data, int *err);
 
 /* Read CIS content for specified function.
  *   fn:     function whose CIS is being requested (0 is common CIS)
@@ -92,15 +92,15 @@ extern void bcmsdh_cfg_write_word(void *sdh, uint fnc_num, uint32 addr,
  * Internally, this routine uses the values from the cis base regs (0x9-0xB)
  * to form an SDIO-space address to read the data from.
  */
-extern int bcmsdh_cis_read(void *sdh, uint func, uint8 * cis, uint length);
+extern int bcmsdh_cis_read(void *sdh, uint func, u8 *cis, uint length);
 
 /* Synchronous access to device (client) core registers via CMD53 to F1.
  *   addr: backplane address (i.e. >= regsva from attach)
  *   size: register width in bytes (2 or 4)
  *   data: data for register write
  */
-extern uint32 bcmsdh_reg_read(void *sdh, uint32 addr, uint size);
-extern uint32 bcmsdh_reg_write(void *sdh, uint32 addr, uint size, uint32 data);
+extern u32 bcmsdh_reg_read(void *sdh, u32 addr, uint size);
+extern u32 bcmsdh_reg_write(void *sdh, u32 addr, uint size, u32 data);
 
 /* Indicate if last reg read/write failed */
 extern bool bcmsdh_regfail(void *sdh);
@@ -118,11 +118,11 @@ extern bool bcmsdh_regfail(void *sdh);
  * NOTE: Async operation is not currently supported.
  */
 typedef void (*bcmsdh_cmplt_fn_t) (void *handle, int status, bool sync_waiting);
-extern int bcmsdh_send_buf(void *sdh, uint32 addr, uint fn, uint flags,
-			   uint8 * buf, uint nbytes, void *pkt,
+extern int bcmsdh_send_buf(void *sdh, u32 addr, uint fn, uint flags,
+			   u8 *buf, uint nbytes, void *pkt,
 			   bcmsdh_cmplt_fn_t complete, void *handle);
-extern int bcmsdh_recv_buf(void *sdh, uint32 addr, uint fn, uint flags,
-			   uint8 * buf, uint nbytes, void *pkt,
+extern int bcmsdh_recv_buf(void *sdh, u32 addr, uint fn, uint flags,
+			   u8 *buf, uint nbytes, void *pkt,
 			   bcmsdh_cmplt_fn_t complete, void *handle);
 
 /* Flags bits */
@@ -140,7 +140,7 @@ extern int bcmsdh_recv_buf(void *sdh, uint32 addr, uint fn, uint flags,
  *   nbytes:   number of bytes to transfer to/from buf
  * Returns 0 or error code.
  */
-extern int bcmsdh_rwdata(void *sdh, uint rw, uint32 addr, uint8 * buf,
+extern int bcmsdh_rwdata(void *sdh, uint rw, u32 addr, u8 *buf,
 			 uint nbytes);
 
 /* Issue an abort to the specified function */
@@ -164,35 +164,35 @@ extern int bcmsdh_iovar_op(void *sdh, const char *name,
 			   bool set);
 
 /* Reset and reinitialize the device */
-extern int bcmsdh_reset(bcmsdh_info_t * sdh);
+extern int bcmsdh_reset(bcmsdh_info_t *sdh);
 
 /* helper functions */
 
-extern void *bcmsdh_get_sdioh(bcmsdh_info_t * sdh);
+extern void *bcmsdh_get_sdioh(bcmsdh_info_t *sdh);
 
 /* callback functions */
 typedef struct {
 	/* attach to device */
-	void *(*attach) (uint16 vend_id, uint16 dev_id, uint16 bus, uint16 slot,
-			 uint16 func, uint bustype, void *regsva, osl_t * osh,
+	void *(*attach) (u16 vend_id, u16 dev_id, u16 bus, u16 slot,
+			 u16 func, uint bustype, void *regsva, osl_t *osh,
 			 void *param);
 	/* detach from device */
 	void (*detach) (void *ch);
 } bcmsdh_driver_t;
 
 /* platform specific/high level functions */
-extern int bcmsdh_register(bcmsdh_driver_t * driver);
+extern int bcmsdh_register(bcmsdh_driver_t *driver);
 extern void bcmsdh_unregister(void);
-extern bool bcmsdh_chipmatch(uint16 vendor, uint16 device);
+extern bool bcmsdh_chipmatch(u16 vendor, u16 device);
 extern void bcmsdh_device_remove(void *sdh);
 
 /* Function to pass device-status bits to DHD. */
-extern uint32 bcmsdh_get_dstatus(void *sdh);
+extern u32 bcmsdh_get_dstatus(void *sdh);
 
 /* Function to return current window addr */
-extern uint32 bcmsdh_cur_sbwad(void *sdh);
+extern u32 bcmsdh_cur_sbwad(void *sdh);
 
 /* Function to pass chipid and rev to lower layers for controlling pr's */
-extern void bcmsdh_chipinfo(void *sdh, uint32 chip, uint32 chiprev);
+extern void bcmsdh_chipinfo(void *sdh, u32 chip, u32 chiprev);
 
 #endif				/* _bcmsdh_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h b/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
index 4f9efd4..7d5aa71 100644
--- a/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
+++ b/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
@@ -34,11 +34,13 @@
 #endif
 
 /* Allocate/init/free per-OS private data */
-extern int sdioh_sdmmc_osinit(sdioh_info_t * sd);
-extern void sdioh_sdmmc_osfree(sdioh_info_t * sd);
+extern int sdioh_sdmmc_osinit(sdioh_info_t *sd);
+extern void sdioh_sdmmc_osfree(sdioh_info_t *sd);
 
 #define BLOCK_SIZE_64 64
 #define BLOCK_SIZE_512 512
+#define BLOCK_SIZE_4318 64
+#define BLOCK_SIZE_4328 512
 
 /* internal return code */
 #define SUCCESS	0
@@ -54,20 +56,20 @@ struct sdioh_info {
 	bool intr_handler_valid;	/* client driver interrupt handler valid */
 	sdioh_cb_fn_t intr_handler;	/* registered interrupt handler */
 	void *intr_handler_arg;	/* argument to call interrupt handler */
-	uint16 intmask;		/* Current active interrupts */
+	u16 intmask;		/* Current active interrupts */
 	void *sdos_info;	/* Pointer to per-OS private data */
 
 	uint irq;		/* Client irq */
 	int intrcount;		/* Client interrupts */
 	bool sd_use_dma;	/* DMA on CMD53 */
-	bool sd_blockmode;	/* sd_blockmode == FALSE => 64 Byte Cmd 53s. */
+	bool sd_blockmode;	/* sd_blockmode == false => 64 Byte Cmd 53s. */
 	/*  Must be on for sd_multiblock to be effective */
 	bool use_client_ints;	/* If this is false, make sure to restore */
 	int sd_mode;		/* SD1/SD4/SPI */
 	int client_block_size[SDIOD_MAX_IOFUNCS];	/* Blocksize */
-	uint8 num_funcs;	/* Supported funcs on client */
-	uint32 com_cis_ptr;
-	uint32 func_cis_ptr[SDIOD_MAX_IOFUNCS];
+	u8 num_funcs;	/* Supported funcs on client */
+	u32 com_cis_ptr;
+	u32 func_cis_ptr[SDIOD_MAX_IOFUNCS];
 	uint max_dma_len;
 	uint max_dma_descriptors;	/* DMA Descriptors supported by this controller. */
 	/*	SDDMA_DESCRIPTOR	SGList[32]; *//* Scatter/Gather DMA List */
@@ -81,28 +83,28 @@ struct sdioh_info {
 extern uint sd_msglevel;
 
 /* OS-independent interrupt handler */
-extern bool check_client_intr(sdioh_info_t * sd);
+extern bool check_client_intr(sdioh_info_t *sd);
 
 /* Core interrupt enable/disable of device interrupts */
-extern void sdioh_sdmmc_devintr_on(sdioh_info_t * sd);
-extern void sdioh_sdmmc_devintr_off(sdioh_info_t * sd);
+extern void sdioh_sdmmc_devintr_on(sdioh_info_t *sd);
+extern void sdioh_sdmmc_devintr_off(sdioh_info_t *sd);
 
 /**************************************************************
  * Internal interfaces: bcmsdh_sdmmc.c references to per-port code
  */
 
 /* Register mapping routines */
-extern uint32 *sdioh_sdmmc_reg_map(osl_t * osh, int32 addr, int size);
-extern void sdioh_sdmmc_reg_unmap(osl_t * osh, int32 addr, int size);
+extern u32 *sdioh_sdmmc_reg_map(osl_t *osh, s32 addr, int size);
+extern void sdioh_sdmmc_reg_unmap(osl_t *osh, s32 addr, int size);
 
 /* Interrupt (de)registration routines */
-extern int sdioh_sdmmc_register_irq(sdioh_info_t * sd, uint irq);
-extern void sdioh_sdmmc_free_irq(uint irq, sdioh_info_t * sd);
+extern int sdioh_sdmmc_register_irq(sdioh_info_t *sd, uint irq);
+extern void sdioh_sdmmc_free_irq(uint irq, sdioh_info_t *sd);
 
 typedef struct _BCMSDH_SDMMC_INSTANCE {
 	sdioh_info_t *sd;
 	struct sdio_func *func[SDIOD_MAX_IOFUNCS];
-	uint32 host_claimed;
+	u32 host_claimed;
 } BCMSDH_SDMMC_INSTANCE, *PBCMSDH_SDMMC_INSTANCE;
 
 #endif				/* __BCMSDH_SDMMC_H__ */
diff --git a/drivers/staging/brcm80211/include/bcmsdpcm.h b/drivers/staging/brcm80211/include/bcmsdpcm.h
index 7937cda..4869947 100644
--- a/drivers/staging/brcm80211/include/bcmsdpcm.h
+++ b/drivers/staging/brcm80211/include/bcmsdpcm.h
@@ -80,36 +80,36 @@
 
 /* SW frame header */
 #define SDPCM_SEQUENCE_MASK		0x000000ff	/* Sequence Number Mask */
-#define SDPCM_PACKET_SEQUENCE(p) (((uint8 *)p)[0] & 0xff)	/* p starts w/SW Header */
+#define SDPCM_PACKET_SEQUENCE(p) (((u8 *)p)[0] & 0xff)	/* p starts w/SW Header */
 
 #define SDPCM_CHANNEL_MASK		0x00000f00	/* Channel Number Mask */
 #define SDPCM_CHANNEL_SHIFT		8	/* Channel Number Shift */
-#define SDPCM_PACKET_CHANNEL(p) (((uint8 *)p)[1] & 0x0f)	/* p starts w/SW Header */
+#define SDPCM_PACKET_CHANNEL(p) (((u8 *)p)[1] & 0x0f)	/* p starts w/SW Header */
 
 #define SDPCM_FLAGS_MASK		0x0000f000	/* Mask of flag bits */
 #define SDPCM_FLAGS_SHIFT		12	/* Flag bits shift */
-#define SDPCM_PACKET_FLAGS(p) ((((uint8 *)p)[1] & 0xf0) >> 4)	/* p starts w/SW Header */
+#define SDPCM_PACKET_FLAGS(p) ((((u8 *)p)[1] & 0xf0) >> 4)	/* p starts w/SW Header */
 
 /* Next Read Len: lookahead length of next frame, in 16-byte units (rounded up) */
 #define SDPCM_NEXTLEN_MASK		0x00ff0000	/* Next Read Len Mask */
 #define SDPCM_NEXTLEN_SHIFT		16	/* Next Read Len Shift */
-#define SDPCM_NEXTLEN_VALUE(p) ((((uint8 *)p)[2] & 0xff) << 4)	/* p starts w/SW Header */
+#define SDPCM_NEXTLEN_VALUE(p) ((((u8 *)p)[2] & 0xff) << 4)	/* p starts w/SW Header */
 #define SDPCM_NEXTLEN_OFFSET		2
 
 /* Data Offset from SOF (HW Tag, SW Tag, Pad) */
 #define SDPCM_DOFFSET_OFFSET		3	/* Data Offset */
-#define SDPCM_DOFFSET_VALUE(p) 		(((uint8 *)p)[SDPCM_DOFFSET_OFFSET] & 0xff)
+#define SDPCM_DOFFSET_VALUE(p) 		(((u8 *)p)[SDPCM_DOFFSET_OFFSET] & 0xff)
 #define SDPCM_DOFFSET_MASK		0xff000000
 #define SDPCM_DOFFSET_SHIFT		24
 
 #define SDPCM_FCMASK_OFFSET		4	/* Flow control */
-#define SDPCM_FCMASK_VALUE(p)		(((uint8 *)p)[SDPCM_FCMASK_OFFSET ] & 0xff)
+#define SDPCM_FCMASK_VALUE(p)		(((u8 *)p)[SDPCM_FCMASK_OFFSET] & 0xff)
 #define SDPCM_WINDOW_OFFSET		5	/* Credit based fc */
-#define SDPCM_WINDOW_VALUE(p)		(((uint8 *)p)[SDPCM_WINDOW_OFFSET] & 0xff)
+#define SDPCM_WINDOW_VALUE(p)		(((u8 *)p)[SDPCM_WINDOW_OFFSET] & 0xff)
 #define SDPCM_VERSION_OFFSET		6	/* Version # */
-#define SDPCM_VERSION_VALUE(p)		(((uint8 *)p)[SDPCM_VERSION_OFFSET] & 0xff)
+#define SDPCM_VERSION_VALUE(p)		(((u8 *)p)[SDPCM_VERSION_OFFSET] & 0xff)
 #define SDPCM_UNUSED_OFFSET		7	/* Spare */
-#define SDPCM_UNUSED_VALUE(p)		(((uint8 *)p)[SDPCM_UNUSED_OFFSET] & 0xff)
+#define SDPCM_UNUSED_VALUE(p)		(((u8 *)p)[SDPCM_UNUSED_OFFSET] & 0xff)
 
 #define SDPCM_SWHEADER_LEN	8	/* SW header is 64 bits */
 
@@ -131,7 +131,7 @@
 /* For GLOM_CHANNEL frames, use a flag to indicate descriptor frame */
 #define SDPCM_GLOMDESC_FLAG	(SDPCM_FLAG_GLOMDESC << SDPCM_FLAGS_SHIFT)
 
-#define SDPCM_GLOMDESC(p)	(((uint8 *)p)[1] & 0x80)
+#define SDPCM_GLOMDESC(p)	(((u8 *)p)[1] & 0x80)
 
 /* For TEST_CHANNEL packets, define another 4-byte header */
 #define SDPCM_TEST_HDRLEN	4	/* Generally: Cmd(1), Ext(1), Len(2);
@@ -146,91 +146,43 @@
 #define SDPCM_TEST_SEND		0x05	/* Receiver sets send mode. Ext is boolean on/off */
 
 /* Handy macro for filling in datagen packets with a pattern */
-#define SDPCM_TEST_FILL(byteno, id)	((uint8)(id + byteno))
+#define SDPCM_TEST_FILL(byteno, id)	((u8)(id + byteno))
 
 /*
  * Software counters (first part matches hardware counters)
  */
 
 typedef volatile struct {
-	uint32 cmd52rd;		/* Cmd52RdCount, SDIO: cmd52 reads */
-	uint32 cmd52wr;		/* Cmd52WrCount, SDIO: cmd52 writes */
-	uint32 cmd53rd;		/* Cmd53RdCount, SDIO: cmd53 reads */
-	uint32 cmd53wr;		/* Cmd53WrCount, SDIO: cmd53 writes */
-	uint32 abort;		/* AbortCount, SDIO: aborts */
-	uint32 datacrcerror;	/* DataCrcErrorCount, SDIO: frames w/CRC error */
-	uint32 rdoutofsync;	/* RdOutOfSyncCount, SDIO/PCMCIA: Rd Frm out of sync */
-	uint32 wroutofsync;	/* RdOutOfSyncCount, SDIO/PCMCIA: Wr Frm out of sync */
-	uint32 writebusy;	/* WriteBusyCount, SDIO: device asserted "busy" */
-	uint32 readwait;	/* ReadWaitCount, SDIO: no data ready for a read cmd */
-	uint32 readterm;	/* ReadTermCount, SDIO: read frame termination cmds */
-	uint32 writeterm;	/* WriteTermCount, SDIO: write frames termination cmds */
-	uint32 rxdescuflo;	/* receive descriptor underflows */
-	uint32 rxfifooflo;	/* receive fifo overflows */
-	uint32 txfifouflo;	/* transmit fifo underflows */
-	uint32 runt;		/* runt (too short) frames recv'd from bus */
-	uint32 badlen;		/* frame's rxh len does not match its hw tag len */
-	uint32 badcksum;	/* frame's hw tag chksum doesn't agree with len value */
-	uint32 seqbreak;	/* break in sequence # space from one rx frame to the next */
-	uint32 rxfcrc;		/* frame rx header indicates crc error */
-	uint32 rxfwoos;		/* frame rx header indicates write out of sync */
-	uint32 rxfwft;		/* frame rx header indicates write frame termination */
-	uint32 rxfabort;	/* frame rx header indicates frame aborted */
-	uint32 woosint;		/* write out of sync interrupt */
-	uint32 roosint;		/* read out of sync interrupt */
-	uint32 rftermint;	/* read frame terminate interrupt */
-	uint32 wftermint;	/* write frame terminate interrupt */
+	u32 cmd52rd;		/* Cmd52RdCount, SDIO: cmd52 reads */
+	u32 cmd52wr;		/* Cmd52WrCount, SDIO: cmd52 writes */
+	u32 cmd53rd;		/* Cmd53RdCount, SDIO: cmd53 reads */
+	u32 cmd53wr;		/* Cmd53WrCount, SDIO: cmd53 writes */
+	u32 abort;		/* AbortCount, SDIO: aborts */
+	u32 datacrcerror;	/* DataCrcErrorCount, SDIO: frames w/CRC error */
+	u32 rdoutofsync;	/* RdOutOfSyncCount, SDIO/PCMCIA: Rd Frm out of sync */
+	u32 wroutofsync;	/* RdOutOfSyncCount, SDIO/PCMCIA: Wr Frm out of sync */
+	u32 writebusy;	/* WriteBusyCount, SDIO: device asserted "busy" */
+	u32 readwait;	/* ReadWaitCount, SDIO: no data ready for a read cmd */
+	u32 readterm;	/* ReadTermCount, SDIO: read frame termination cmds */
+	u32 writeterm;	/* WriteTermCount, SDIO: write frames termination cmds */
+	u32 rxdescuflo;	/* receive descriptor underflows */
+	u32 rxfifooflo;	/* receive fifo overflows */
+	u32 txfifouflo;	/* transmit fifo underflows */
+	u32 runt;		/* runt (too short) frames recv'd from bus */
+	u32 badlen;		/* frame's rxh len does not match its hw tag len */
+	u32 badcksum;	/* frame's hw tag chksum doesn't agree with len value */
+	u32 seqbreak;	/* break in sequence # space from one rx frame to the next */
+	u32 rxfcrc;		/* frame rx header indicates crc error */
+	u32 rxfwoos;		/* frame rx header indicates write out of sync */
+	u32 rxfwft;		/* frame rx header indicates write frame termination */
+	u32 rxfabort;	/* frame rx header indicates frame aborted */
+	u32 woosint;		/* write out of sync interrupt */
+	u32 roosint;		/* read out of sync interrupt */
+	u32 rftermint;	/* read frame terminate interrupt */
+	u32 wftermint;	/* write frame terminate interrupt */
 } sdpcmd_cnt_t;
 
 /*
- * Register Access Macros
- */
-
-#define SDIODREV_IS(var, val)	((var) == (val))
-#define SDIODREV_GE(var, val)	((var) >= (val))
-#define SDIODREV_GT(var, val)	((var) > (val))
-#define SDIODREV_LT(var, val)	((var) < (val))
-#define SDIODREV_LE(var, val)	((var) <= (val))
-
-#define SDIODDMAREG32(h, dir, chnl) \
-	((dir) == DMA_TX ? \
-	 (void *)(uintptr)&((h)->regs->dma.sdiod32.dma32regs[chnl].xmt) : \
-	 (void *)(uintptr)&((h)->regs->dma.sdiod32.dma32regs[chnl].rcv))
-
-#define SDIODDMAREG64(h, dir, chnl) \
-	((dir) == DMA_TX ? \
-	 (void *)(uintptr)&((h)->regs->dma.sdiod64.dma64regs[chnl].xmt) : \
-	 (void *)(uintptr)&((h)->regs->dma.sdiod64.dma64regs[chnl].rcv))
-
-#define SDIODDMAREG(h, dir, chnl) \
-	(SDIODREV_LT((h)->corerev, 1) ? \
-	 SDIODDMAREG32((h), (dir), (chnl)) : \
-	 SDIODDMAREG64((h), (dir), (chnl)))
-
-#define PCMDDMAREG(h, dir, chnl) \
-	((dir) == DMA_TX ? \
-	 (void *)(uintptr)&((h)->regs->dma.pcm32.dmaregs.xmt) : \
-	 (void *)(uintptr)&((h)->regs->dma.pcm32.dmaregs.rcv))
-
-#define SDPCMDMAREG(h, dir, chnl, coreid) \
-	((coreid) == SDIOD_CORE_ID ? \
-	 SDIODDMAREG(h, dir, chnl) : \
-	 PCMDDMAREG(h, dir, chnl))
-
-#define SDIODFIFOREG(h, corerev) \
-	(SDIODREV_LT((corerev), 1) ? \
-	 ((dma32diag_t *)(uintptr)&((h)->regs->dma.sdiod32.dmafifo)) : \
-	 ((dma32diag_t *)(uintptr)&((h)->regs->dma.sdiod64.dmafifo)))
-
-#define PCMDFIFOREG(h) \
-	((dma32diag_t *)(uintptr)&((h)->regs->dma.pcm32.dmafifo))
-
-#define SDPCMFIFOREG(h, coreid, corerev) \
-	((coreid) == SDIOD_CORE_ID ? \
-	 SDIODFIFOREG(h, corerev) : \
-	 PCMDFIFOREG(h))
-
-/*
  * Shared structure between dongle and the host.
  * The structure contains pointers to trap or assert information.
  */
@@ -241,13 +193,13 @@ typedef volatile struct {
 #define SDPCM_SHARED_TRAP          0x0400
 
 typedef struct {
-	uint32 flags;
-	uint32 trap_addr;
-	uint32 assert_exp_addr;
-	uint32 assert_file_addr;
-	uint32 assert_line;
-	uint32 console_addr;	/* Address of hndrte_cons_t */
-	uint32 msgtrace_addr;
+	u32 flags;
+	u32 trap_addr;
+	u32 assert_exp_addr;
+	u32 assert_file_addr;
+	u32 assert_line;
+	u32 console_addr;	/* Address of hndrte_cons_t */
+	u32 msgtrace_addr;
 } sdpcm_shared_t;
 
 extern sdpcm_shared_t sdpcm_shared;
diff --git a/drivers/staging/brcm80211/include/bcmsrom.h b/drivers/staging/brcm80211/include/bcmsrom.h
index dfede70..9d53657 100644
--- a/drivers/staging/brcm80211/include/bcmsrom.h
+++ b/drivers/staging/brcm80211/include/bcmsrom.h
@@ -20,15 +20,15 @@
 #include <bcmsrom_fmt.h>
 
 /* Prototypes */
-extern int srom_var_init(si_t * sih, uint bus, void *curmap, osl_t * osh,
-			 char **vars, uint * count);
+extern int srom_var_init(si_t *sih, uint bus, void *curmap, osl_t *osh,
+			 char **vars, uint *count);
 
-extern int srom_read(si_t * sih, uint bus, void *curmap, osl_t * osh,
-		     uint byteoff, uint nbytes, uint16 * buf, bool check_crc);
+extern int srom_read(si_t *sih, uint bus, void *curmap, osl_t *osh,
+		     uint byteoff, uint nbytes, u16 *buf, bool check_crc);
 
 /* parse standard PCMCIA cis, normally used by SB/PCMCIA/SDIO/SPI/OTP
  *   and extract from it into name=value pairs
  */
-extern int srom_parsecis(osl_t * osh, uint8 ** pcis, uint ciscnt,
-			 char **vars, uint * count);
+extern int srom_parsecis(osl_t *osh, u8 **pcis, uint ciscnt,
+			 char **vars, uint *count);
 #endif				/* _bcmsrom_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmsrom_fmt.h b/drivers/staging/brcm80211/include/bcmsrom_fmt.h
index 5ce6143..ae2bff8 100644
--- a/drivers/staging/brcm80211/include/bcmsrom_fmt.h
+++ b/drivers/staging/brcm80211/include/bcmsrom_fmt.h
@@ -357,11 +357,11 @@
 #define SROM9_REV_CRC		219
 
 typedef struct {
-	uint8 tssipos;		/* TSSI positive slope, 1: positive, 0: negative */
-	uint8 extpagain;	/* Ext PA gain-type: full-gain: 0, pa-lite: 1, no_pa: 2 */
-	uint8 pdetrange;	/* support 32 combinations of different Pdet dynamic ranges */
-	uint8 triso;		/* TR switch isolation */
-	uint8 antswctrllut;	/* antswctrl lookup table configuration: 32 possible choices */
+	u8 tssipos;		/* TSSI positive slope, 1: positive, 0: negative */
+	u8 extpagain;	/* Ext PA gain-type: full-gain: 0, pa-lite: 1, no_pa: 2 */
+	u8 pdetrange;	/* support 32 combinations of different Pdet dynamic ranges */
+	u8 triso;		/* TR switch isolation */
+	u8 antswctrllut;	/* antswctrl lookup table configuration: 32 possible choices */
 } srom_fem_t;
 
 #endif				/* _bcmsrom_fmt_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmsrom_tbl.h b/drivers/staging/brcm80211/include/bcmsrom_tbl.h
index 646126f..22ae7c1 100644
--- a/drivers/staging/brcm80211/include/bcmsrom_tbl.h
+++ b/drivers/staging/brcm80211/include/bcmsrom_tbl.h
@@ -22,10 +22,10 @@
 
 typedef struct {
 	const char *name;
-	uint32 revmask;
-	uint32 flags;
-	uint16 off;
-	uint16 mask;
+	u32 revmask;
+	u32 flags;
+	u16 off;
+	u16 mask;
 } sromvar_t;
 
 #define SRFL_MORE	1	/* value continues as described by the next entry */
@@ -447,9 +447,9 @@ static const sromvar_t perpath_pci_sromvars[] = {
 #endif				/* !defined(PHY_TYPE_NULL) */
 
 typedef struct {
-	uint16 phy_type;
-	uint16 bandrange;
-	uint16 chain;
+	u16 phy_type;
+	u16 bandrange;
+	u16 chain;
 	const char *vars;
 } pavars_t;
 
@@ -476,8 +476,8 @@ static const pavars_t pavars[] = {
 };
 
 typedef struct {
-	uint16 phy_type;
-	uint16 bandrange;
+	u16 phy_type;
+	u16 bandrange;
 	const char *vars;
 } povars_t;
 
@@ -499,8 +499,8 @@ static const povars_t povars[] = {
 };
 
 typedef struct {
-	uint8 tag;		/* Broadcom subtag name */
-	uint8 len;		/* Length field of the tuple, note that it includes the
+	u8 tag;		/* Broadcom subtag name */
+	u8 len;		/* Length field of the tuple, note that it includes the
 				 * subtag name (1 byte): 1 + tuple content length
 				 */
 	const char *params;
diff --git a/drivers/staging/brcm80211/include/bcmutils.h b/drivers/staging/brcm80211/include/bcmutils.h
index ed1f691..b533159 100644
--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -17,37 +17,6 @@
 #ifndef	_bcmutils_h_
 #define	_bcmutils_h_
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* ctype replacement */
-#define _BCM_U	0x01		/* upper */
-#define _BCM_L	0x02		/* lower */
-#define _BCM_D	0x04		/* digit */
-#define _BCM_C	0x08		/* cntrl */
-#define _BCM_P	0x10		/* punct */
-#define _BCM_S	0x20		/* white space (space/lf/tab) */
-#define _BCM_X	0x40		/* hex digit */
-#define _BCM_SP	0x80		/* hard space (0x20) */
-
-	extern const unsigned char bcm_ctype[];
-#define bcm_ismask(x)	(bcm_ctype[(int)(unsigned char)(x)])
-
-#define bcm_isalnum(c)	((bcm_ismask(c)&(_BCM_U|_BCM_L|_BCM_D)) != 0)
-#define bcm_isalpha(c)	((bcm_ismask(c)&(_BCM_U|_BCM_L)) != 0)
-#define bcm_iscntrl(c)	((bcm_ismask(c)&(_BCM_C)) != 0)
-#define bcm_isdigit(c)	((bcm_ismask(c)&(_BCM_D)) != 0)
-#define bcm_isgraph(c)	((bcm_ismask(c)&(_BCM_P|_BCM_U|_BCM_L|_BCM_D)) != 0)
-#define bcm_islower(c)	((bcm_ismask(c)&(_BCM_L)) != 0)
-#define bcm_isprint(c)	((bcm_ismask(c)&(_BCM_P|_BCM_U|_BCM_L|_BCM_D|_BCM_SP)) != 0)
-#define bcm_ispunct(c)	((bcm_ismask(c)&(_BCM_P)) != 0)
-#define bcm_isspace(c)	((bcm_ismask(c)&(_BCM_S)) != 0)
-#define bcm_isupper(c)	((bcm_ismask(c)&(_BCM_U)) != 0)
-#define bcm_isxdigit(c)	((bcm_ismask(c)&(_BCM_D|_BCM_X)) != 0)
-#define bcm_tolower(c)	(bcm_isupper((c)) ? ((c) + 'a' - 'A') : (c))
-#define bcm_toupper(c)	(bcm_islower((c)) ? ((c) + 'A' - 'a') : (c))
-
 /* Buffer structure for collecting string-formatted data
 * using bcm_bprintf() API.
 * Use bcm_binit() to initialize before use
@@ -73,7 +42,7 @@ extern "C" {
 #define SPINWAIT(exp, us) { \
 	uint countdown = (us) + 9; \
 	while ((exp) && (countdown >= 10)) {\
-		OSL_DELAY(10); \
+		udelay(10); \
 		countdown -= 10; \
 	} \
 }
@@ -89,26 +58,26 @@ extern "C" {
 	typedef struct pktq_prec {
 		void *head;	/* first packet to dequeue */
 		void *tail;	/* last packet to dequeue */
-		uint16 len;	/* number of queued packets */
-		uint16 max;	/* maximum number of queued packets */
+		u16 len;	/* number of queued packets */
+		u16 max;	/* maximum number of queued packets */
 	} pktq_prec_t;
 
 /* multi-priority pkt queue */
 	struct pktq {
-		uint16 num_prec;	/* number of precedences in use */
-		uint16 hi_prec;	/* rapid dequeue hint (>= highest non-empty prec) */
-		uint16 max;	/* total max packets */
-		uint16 len;	/* total number of packets */
+		u16 num_prec;	/* number of precedences in use */
+		u16 hi_prec;	/* rapid dequeue hint (>= highest non-empty prec) */
+		u16 max;	/* total max packets */
+		u16 len;	/* total number of packets */
 		/* q array must be last since # of elements can be either PKTQ_MAX_PREC or 1 */
 		struct pktq_prec q[PKTQ_MAX_PREC];
 	};
 
 /* simple, non-priority pkt queue */
 	struct spktq {
-		uint16 num_prec;	/* number of precedences in use (always 1) */
-		uint16 hi_prec;	/* rapid dequeue hint (>= highest non-empty prec) */
-		uint16 max;	/* total max packets */
-		uint16 len;	/* total number of packets */
+		u16 num_prec;	/* number of precedences in use (always 1) */
+		u16 hi_prec;	/* rapid dequeue hint (>= highest non-empty prec) */
+		u16 max;	/* total max packets */
+		u16 len;	/* total number of packets */
 		/* q array must be last since # of elements can be either PKTQ_MAX_PREC or 1 */
 		struct pktq_prec q[1];
 	};
@@ -141,10 +110,13 @@ extern "C" {
 	extern void *pktq_pdeq(struct pktq *pq, int prec);
 	extern void *pktq_pdeq_tail(struct pktq *pq, int prec);
 /* Empty the queue at particular precedence level */
-	extern void pktq_pflush(osl_t * osh, struct pktq *pq, int prec,
-				bool dir, ifpkt_cb_t fn, int arg);
-/* Remove a specified packet from its queue */
-	extern bool pktq_pdel(struct pktq *pq, void *p, int prec);
+#ifdef BRCM_FULLMAC
+	extern void pktq_pflush(osl_t *osh, struct pktq *pq, int prec,
+		bool dir);
+#else
+	extern void pktq_pflush(osl_t *osh, struct pktq *pq, int prec,
+		bool dir, ifpkt_cb_t fn, int arg);
+#endif /* BRCM_FULLMAC */
 
 /* operations on a set of precedences in packet queue */
 
@@ -168,74 +140,44 @@ extern "C" {
 
 	extern void pktq_init(struct pktq *pq, int num_prec, int max_len);
 /* prec_out may be NULL if caller is not interested in return value */
-	extern void *pktq_deq(struct pktq *pq, int *prec_out);
-	extern void *pktq_deq_tail(struct pktq *pq, int *prec_out);
-	extern void *pktq_peek(struct pktq *pq, int *prec_out);
 	extern void *pktq_peek_tail(struct pktq *pq, int *prec_out);
-	extern void pktq_flush(osl_t * osh, struct pktq *pq, bool dir,
-			       ifpkt_cb_t fn, int arg);
+#ifdef BRCM_FULLMAC
+	extern void pktq_flush(osl_t *osh, struct pktq *pq, bool dir);
+#else
+	extern void pktq_flush(osl_t *osh, struct pktq *pq, bool dir,
+		ifpkt_cb_t fn, int arg);
+#endif
 
 /* externs */
 /* packet */
-	extern uint pktcopy(osl_t * osh, void *p, uint offset, int len,
-			    uchar * buf);
-	extern uint pktfrombuf(osl_t * osh, void *p, uint offset, int len,
-			       uchar * buf);
-	extern uint pkttotlen(osl_t * osh, void *p);
-	extern void *pktlast(osl_t * osh, void *p);
-	extern uint pktsegcnt(osl_t * osh, void *p);
-
-/* Get priority from a packet and pass it back in scb (or equiv) */
-	extern uint pktsetprio(void *pkt, bool update_vtag);
-#define	PKTPRIO_VDSCP	0x100	/* DSCP prio found after VLAN tag */
-#define	PKTPRIO_VLAN	0x200	/* VLAN prio found */
-#define	PKTPRIO_UPD	0x400	/* DSCP used to update VLAN prio */
-#define	PKTPRIO_DSCP	0x800	/* DSCP prio found */
-
-/* string */
-	extern int BCMROMFN(bcm_atoi) (char *s);
-	extern ulong BCMROMFN(bcm_strtoul) (char *cp, char **endp, uint base);
-	extern char *BCMROMFN(bcmstrstr) (char *haystack, char *needle);
-	extern char *BCMROMFN(bcmstrcat) (char *dest, const char *src);
-	extern char *BCMROMFN(bcmstrncat) (char *dest, const char *src,
-					   uint size);
-	extern ulong wchar2ascii(char *abuf, ushort * wbuf, ushort wbuflen,
-				 ulong abuflen);
-	char *bcmstrtok(char **string, const char *delimiters, char *tokdelim);
-	int bcmstricmp(const char *s1, const char *s2);
-	int bcmstrnicmp(const char *s1, const char *s2, int cnt);
+	extern uint pktfrombuf(osl_t *osh, void *p, uint offset, int len,
+			       unsigned char *buf);
+	extern uint pktsegcnt(osl_t *osh, void *p);
+	extern uint pkttotlen(osl_t *osh, void *p);
 
 /* ethernet address */
-	extern char *bcm_ether_ntoa(const struct ether_addr *ea, char *buf);
-	extern int BCMROMFN(bcm_ether_atoe) (char *p, struct ether_addr * ea);
+	extern int bcm_ether_atoe(char *p, struct ether_addr *ea);
 
 /* ip address */
 	struct ipv4_addr;
 	extern char *bcm_ip_ntoa(struct ipv4_addr *ia, char *buf);
 
-/* delay */
-	extern void bcm_mdelay(uint ms);
 /* variable access */
 	extern char *getvar(char *vars, const char *name);
 	extern int getintvar(char *vars, const char *name);
-	extern int getintvararray(char *vars, const char *name, uint8 index);
-	extern uint getgpiopin(char *vars, char *pin_name, uint def_pin);
 #ifdef BCMDBG
-	extern void prpkt(const char *msg, osl_t * osh, void *p0);
+	extern void prpkt(const char *msg, osl_t *osh, void *p0);
 #endif				/* BCMDBG */
 #define bcm_perf_enable()
 #define bcmstats(fmt)
 #define	bcmlog(fmt, a1, a2)
-#define	bcmdumplog(buf, size)	*buf = '\0'
+#define	bcmdumplog(buf, size)	(*buf = '\0')
 #define	bcmdumplogent(buf, idx)	-1
 
 #define bcmtslog(tstamp, fmt, a1, a2)
 #define bcmprinttslogs()
 #define bcmprinttstamp(us)
 
-	extern char *bcm_nvram_vars(uint * length);
-	extern int bcm_nvram_cache(void *sih);
-
 /* Support for sharing code across in-driver iovar implementations.
  * The intent is that a driver use this structure to map iovar names
  * to its (private) iovar identifiers, and the lookup function to
@@ -246,10 +188,10 @@ extern "C" {
 /* iovar structure */
 	typedef struct bcm_iovar {
 		const char *name;	/* name for lookup and display */
-		uint16 varid;	/* id for switch */
-		uint16 flags;	/* driver-specific flag bits */
-		uint16 type;	/* base type of argument */
-		uint16 minlen;	/* min length for buffer vars */
+		u16 varid;	/* id for switch */
+		u16 flags;	/* driver-specific flag bits */
+		u16 type;	/* base type of argument */
+		u16 minlen;	/* min length for buffer vars */
 	} bcm_iovar_t;
 
 /* varid definitions are per-driver, may use these get/set bits */
@@ -266,14 +208,10 @@ extern "C" {
 
 /* flags are per-driver based on driver attributes */
 
-	extern const bcm_iovar_t *bcm_iovar_lookup(const bcm_iovar_t * table,
+	extern const bcm_iovar_t *bcm_iovar_lookup(const bcm_iovar_t *table,
 						   const char *name);
-	extern int bcm_iovar_lencheck(const bcm_iovar_t * table, void *arg,
+	extern int bcm_iovar_lencheck(const bcm_iovar_t *table, void *arg,
 				      int len, bool set);
-#if defined(BCMDBG)
-	extern int bcm_format_ssid(char *buf, const uchar ssid[],
-				   uint ssid_len);
-#endif
 
 /* Base type definitions */
 #define IOVT_VOID	0	/* no value (implictly set only) */
@@ -291,12 +229,12 @@ extern "C" {
 #define BCM_IOV_TYPE_INIT { \
 	"void", \
 	"bool", \
-	"int8", \
-	"uint8", \
-	"int16", \
-	"uint16", \
-	"int32", \
-	"uint32", \
+	"s8", \
+	"u8", \
+	"s16", \
+	"u16", \
+	"s32", \
+	"u32", \
 	"buffer", \
 	"" }
 
@@ -415,40 +353,21 @@ extern "C" {
 }
 
 #ifndef ABS
-#define	ABS(a)			(((a) < 0)?-(a):(a))
+#define	ABS(a)			(((a) < 0) ? -(a) : (a))
 #endif				/* ABS */
 
-#ifndef MIN
-#define	MIN(a, b)		(((a) < (b))?(a):(b))
-#endif				/* MIN */
-
-#ifndef MAX
-#define	MAX(a, b)		(((a) > (b))?(a):(b))
-#endif				/* MAX */
-
 #define CEIL(x, y)		(((x) + ((y)-1)) / (y))
-#define	ROUNDUP(x, y)		((((x)+((y)-1))/(y))*(y))
-#define	ISALIGNED(a, x)		(((a) & ((x)-1)) == 0)
-#define ALIGN_ADDR(addr, boundary) (void *)(((uintptr)(addr) + (boundary) - 1) \
-	& ~((boundary) - 1))
 #define	ISPOWEROF2(x)		((((x)-1)&(x)) == 0)
-#define VALID_MASK(mask)	!((mask) & ((mask) + 1))
-#ifndef OFFSETOF
-#define	OFFSETOF(type, member)	((uint)(uintptr)&((type *)0)->member)
-#endif				/* OFFSETOF */
-#ifndef ARRAYSIZE
-#define ARRAYSIZE(a)		(sizeof(a)/sizeof(a[0]))
-#endif
 
 /* bit map related macros */
 #ifndef setbit
 #ifndef NBBY			/* the BSD family defines NBBY */
 #define	NBBY	8		/* 8 bits per byte */
 #endif				/* #ifndef NBBY */
-#define	setbit(a, i)	(((uint8 *)a)[(i)/NBBY] |= 1<<((i)%NBBY))
-#define	clrbit(a, i)	(((uint8 *)a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
-#define	isset(a, i)	(((const uint8 *)a)[(i)/NBBY] & (1<<((i)%NBBY)))
-#define	isclr(a, i)	((((const uint8 *)a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+#define	setbit(a, i)	(((u8 *)a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define	clrbit(a, i)	(((u8 *)a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define	isset(a, i)	(((const u8 *)a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define	isclr(a, i)	((((const u8 *)a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
 #endif				/* setbit */
 
 #define	NBITS(type)	(sizeof(type) * 8)
@@ -486,46 +405,45 @@ extern "C" {
 
 /* bcm_format_flags() bit description structure */
 	typedef struct bcm_bit_desc {
-		uint32 bit;
+		u32 bit;
 		const char *name;
 	} bcm_bit_desc_t;
 
 /* tag_ID/length/value_buffer tuple */
 	typedef struct bcm_tlv {
-		uint8 id;
-		uint8 len;
-		uint8 data[1];
+		u8 id;
+		u8 len;
+		u8 data[1];
 	} bcm_tlv_t;
 
 /* Check that bcm_tlv_t fits into the given buflen */
 #define bcm_valid_tlv(elt, buflen) ((buflen) >= 2 && (int)(buflen) >= (int)(2 + (elt)->len))
 
-/* buffer length for ethernet address from bcm_ether_ntoa() */
 #define ETHER_ADDR_STR_LEN	18	/* 18-bytes of Ethernet address buffer length */
 
 /* crypto utility function */
 /* 128-bit xor: *dst = *src1 xor *src2. dst1, src1 and src2 may have any alignment */
-	static INLINE void
-	 xor_128bit_block(const uint8 * src1, const uint8 * src2, uint8 * dst) {
+	static inline void
+	 xor_128bit_block(const u8 *src1, const u8 *src2, u8 *dst) {
 		if (
 #ifdef __i386__
 			   1 ||
 #endif
-			   (((uintptr) src1 | (uintptr) src2 | (uintptr) dst) &
+			   (((unsigned long) src1 | (unsigned long) src2 | (unsigned long) dst) &
 			    3) == 0) {
 			/* ARM CM3 rel time: 1229 (727 if alignment check could be omitted) */
 			/* x86 supports unaligned.  This version runs 6x-9x faster on x86. */
-			((uint32 *) dst)[0] =
-			    ((const uint32 *)src1)[0] ^ ((const uint32 *)
+			((u32 *) dst)[0] =
+			    ((const u32 *)src1)[0] ^ ((const u32 *)
 							 src2)[0];
-			((uint32 *) dst)[1] =
-			    ((const uint32 *)src1)[1] ^ ((const uint32 *)
+			((u32 *) dst)[1] =
+			    ((const u32 *)src1)[1] ^ ((const u32 *)
 							 src2)[1];
-			((uint32 *) dst)[2] =
-			    ((const uint32 *)src1)[2] ^ ((const uint32 *)
+			((u32 *) dst)[2] =
+			    ((const u32 *)src1)[2] ^ ((const u32 *)
 							 src2)[2];
-			((uint32 *) dst)[3] =
-			    ((const uint32 *)src1)[3] ^ ((const uint32 *)
+			((u32 *) dst)[3] =
+			    ((const u32 *)src1)[3] ^ ((const u32 *)
 							 src2)[3];
 		} else {
 			/* ARM CM3 rel time: 4668 (4191 if alignment check could be omitted) */
@@ -537,70 +455,48 @@ extern "C" {
 
 /* externs */
 /* crc */
-	extern uint8 BCMROMFN(hndcrc8) (uint8 * p, uint nbytes, uint8 crc);
-	extern uint16 BCMROMFN(hndcrc16) (uint8 * p, uint nbytes, uint16 crc);
+	extern u8 hndcrc8(u8 *p, uint nbytes, u8 crc);
+	extern u16 hndcrc16(u8 *p, uint nbytes, u16 crc);
 /* format/print */
 #if defined(BCMDBG)
-	extern int bcm_format_flags(const bcm_bit_desc_t * bd, uint32 flags,
+	extern int bcm_format_flags(const bcm_bit_desc_t *bd, u32 flags,
 				    char *buf, int len);
 	extern int bcm_format_hex(char *str, const void *bytes, int len);
 #endif
-#ifdef BCMDBG
-	extern void deadbeef(void *p, uint len);
-#endif
-	extern const char *bcm_crypto_algo_name(uint algo);
 	extern char *bcm_chipname(uint chipid, char *buf, uint len);
-	extern char *bcm_brev_str(uint32 brev, char *buf);
-	extern void printbig(char *buf);
-	extern void prhex(const char *msg, uchar * buf, uint len);
+	extern void prhex(const char *msg, unsigned char *buf, uint len);
 
-/* IE parsing */
-	extern bcm_tlv_t *BCMROMFN(bcm_next_tlv) (bcm_tlv_t * elt, int *buflen);
-	extern bcm_tlv_t *BCMROMFN(bcm_parse_tlvs) (void *buf, int buflen,
+	extern bcm_tlv_t *bcm_parse_tlvs(void *buf, int buflen,
 						    uint key);
-	extern bcm_tlv_t *BCMROMFN(bcm_parse_ordered_tlvs) (void *buf,
-							    int buflen,
-							    uint key);
-
 /* bcmerror */
 	extern const char *bcmerrorstr(int bcmerror);
 
 /* multi-bool data type: set of bools, mbool is true if any is set */
-	typedef uint32 mbool;
+	typedef u32 mbool;
 #define mboolset(mb, bit)		((mb) |= (bit))	/* set one bool */
 #define mboolclr(mb, bit)		((mb) &= ~(bit))	/* clear one bool */
-#define mboolisset(mb, bit)		(((mb) & (bit)) != 0)	/* TRUE if one bool is set */
+#define mboolisset(mb, bit)		(((mb) & (bit)) != 0)	/* true if one bool is set */
 #define	mboolmaskset(mb, mask, val)	((mb) = (((mb) & ~(mask)) | (val)))
 
 /* power conversion */
-	extern uint16 BCMROMFN(bcm_qdbm_to_mw) (uint8 qdbm);
-	extern uint8 BCMROMFN(bcm_mw_to_qdbm) (uint16 mw);
+	extern u16 bcm_qdbm_to_mw(u8 qdbm);
+	extern u8 bcm_mw_to_qdbm(u16 mw);
 
 /* generic datastruct to help dump routines */
 	struct fielddesc {
 		const char *nameandfmt;
-		uint32 offset;
-		uint32 len;
+		u32 offset;
+		u32 len;
 	};
 
 	extern void bcm_binit(struct bcmstrbuf *b, char *buf, uint size);
 	extern int bcm_bprintf(struct bcmstrbuf *b, const char *fmt, ...);
-	extern void bcm_inc_bytes(uchar * num, int num_bytes, uint8 amount);
-	extern int bcm_cmp_bytes(uchar * arg1, uchar * arg2, uint8 nbytes);
-	extern void bcm_print_bytes(char *name, const uchar * cdata, int len);
 
-	typedef uint32(*bcmutl_rdreg_rtn) (void *arg0, uint arg1,
-					   uint32 offset);
-	extern uint bcmdumpfields(bcmutl_rdreg_rtn func_ptr, void *arg0,
-				  uint arg1, struct fielddesc *str, char *buf,
-				  uint32 bufsize);
+	typedef u32(*bcmutl_rdreg_rtn) (void *arg0, uint arg1,
+					   u32 offset);
 
 	extern uint bcm_mkiovar(char *name, char *data, uint datalen, char *buf,
 				uint len);
-	extern uint BCMROMFN(bcm_bitcount) (uint8 * bitmap, uint bytelength);
-
-#ifdef __cplusplus
-}
-#endif
+	extern uint bcm_bitcount(u8 *bitmap, uint bytelength);
 
 #endif				/* _bcmutils_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmwifi.h b/drivers/staging/brcm80211/include/bcmwifi.h
index 80c48f6..4067fba 100644
--- a/drivers/staging/brcm80211/include/bcmwifi.h
+++ b/drivers/staging/brcm80211/include/bcmwifi.h
@@ -18,7 +18,7 @@
 #define	_bcmwifi_h_
 
 /* A chanspec holds the channel number, band, bandwidth and control sideband */
-typedef uint16 chanspec_t;
+typedef u16 chanspec_t;
 
 /* channel defines */
 #define CH_UPPER_SB			0x01
@@ -31,7 +31,7 @@ typedef uint16 chanspec_t;
 #define WLC_MAX_2G_CHANNEL		CH_MAX_2G_CHANNEL	/* legacy define */
 #define	MAXCHANNEL		224	/* max # supported channels. The max channel no is 216,
 					 * this is that + 1 rounded up to a multiple of NBBY (8).
-					 * DO NOT MAKE it > 255: channels are uint8's all over
+					 * DO NOT MAKE it > 255: channels are u8's all over
 					 */
 
 #define WL_CHANSPEC_CHAN_MASK		0x00ff
@@ -74,7 +74,7 @@ typedef uint16 chanspec_t;
 					((channel) | (ctlsb) | WL_CHANSPEC_BW_40 | \
 					((channel) <= CH_MAX_2G_CHANNEL ? WL_CHANSPEC_BAND_2G : \
 					WL_CHANSPEC_BAND_5G))
-#define CHSPEC_CHANNEL(chspec)	((uint8)((chspec) & WL_CHANSPEC_CHAN_MASK))
+#define CHSPEC_CHANNEL(chspec)	((u8)((chspec) & WL_CHANSPEC_CHAN_MASK))
 #define CHSPEC_BAND(chspec)	((chspec) & WL_CHANSPEC_BAND_MASK)
 
 #ifdef WL11N_20MHZONLY
@@ -129,25 +129,10 @@ typedef uint16 chanspec_t;
 #define WLC_2G_25MHZ_OFFSET		5	/* 2.4GHz band channel offset */
 
 /*
- * Convert chanspec to ascii string
- * @param	chspec		chanspec format
- * @param	buf		ascii string of chanspec
- * @return	pointer to buf with room for at least CHANSPEC_STR_LEN bytes
- */
-extern char *wf_chspec_ntoa(chanspec_t chspec, char *buf);
-
-/*
- * Convert ascii string to chanspec
- * @param	a		pointer to input string
- * @return	>= 0 if successful or 0 otherwise
- */
-extern chanspec_t wf_chspec_aton(char *a);
-
-/*
  * Verify the chanspec is using a legal set of parameters, i.e. that the
  * chanspec specified a band, bw, ctl_sb and channel and that the
  * combination could be legal given any set of circumstances.
- * RETURNS: TRUE is the chanspec is malformed, false if it looks good.
+ * RETURNS: true is the chanspec is malformed, false if it looks good.
  */
 extern bool wf_chspec_malformed(chanspec_t chanspec);
 
@@ -156,7 +141,7 @@ extern bool wf_chspec_malformed(chanspec_t chanspec);
  * channels this is just the channel number, for 40MHZ channels it is the upper or lowre 20MHZ
  * sideband depending on the chanspec selected
  */
-extern uint8 wf_chspec_ctlchan(chanspec_t chspec);
+extern u8 wf_chspec_ctlchan(chanspec_t chspec);
 
 /*
  * This function returns the chanspec that control traffic is being sent on, for legacy
diff --git a/drivers/staging/brcm80211/include/bcmwpa.h b/drivers/staging/brcm80211/include/bcmwpa.h
deleted file mode 100644
index 11af58b..0000000
--- a/drivers/staging/brcm80211/include/bcmwpa.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (c) 2010 Broadcom Corporation
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#ifndef _BCMWPA_H_
-#define _BCMWPA_H_
-
-#include <proto/wpa.h>
-#include <proto/802.11.h>
-#include <wlioctl.h>
-
-/* Field sizes for WPA key hierarchy */
-#define WPA_MIC_KEY_LEN		16
-#define WPA_ENCR_KEY_LEN	16
-#define WPA_TEMP_ENCR_KEY_LEN	16
-#define WPA_TEMP_TX_KEY_LEN	8
-#define WPA_TEMP_RX_KEY_LEN	8
-
-#define PMK_LEN			32
-#define TKIP_PTK_LEN		64
-#define TKIP_TK_LEN		32
-#define AES_PTK_LEN		48
-#define AES_TK_LEN		16
-
-/* limits for pre-shared key lengths */
-#define WPA_MIN_PSK_LEN		8
-#define WPA_MAX_PSK_LEN		64
-
-#define WLC_SW_KEYS(wlc, bsscfg) ((((wlc)->wsec_swkeys) || \
-	((bsscfg)->wsec & WSEC_SWFLAG)))
-
-#define WSEC_WEP_ENABLED(wsec)	((wsec) & WEP_ENABLED)
-#define WSEC_TKIP_ENABLED(wsec)	((wsec) & TKIP_ENABLED)
-#define WSEC_AES_ENABLED(wsec)	((wsec) & AES_ENABLED)
-#define WSEC_ENABLED(wsec)	((wsec) & (WEP_ENABLED | TKIP_ENABLED | AES_ENABLED))
-#define WSEC_SES_OW_ENABLED(wsec)	((wsec) & SES_OW_ENABLED)
-#define IS_WPA_AUTH(auth)	((auth) == WPA_AUTH_NONE || \
-				 (auth) == WPA_AUTH_UNSPECIFIED || \
-				 (auth) == WPA_AUTH_PSK)
-#define INCLUDES_WPA_AUTH(auth)	\
-			((auth) & (WPA_AUTH_NONE | WPA_AUTH_UNSPECIFIED | WPA_AUTH_PSK))
-
-#define IS_WPA2_AUTH(auth)	((auth) == WPA2_AUTH_UNSPECIFIED || \
-				 (auth) == WPA2_AUTH_PSK)(
-#define INCLUDES_WPA2_AUTH(auth) \
-			((auth) & (WPA2_AUTH_UNSPECIFIED | \
-				   WPA2_AUTH_PSK))
-
-#define IS_WPA_AKM(akm)	((akm) == RSN_AKM_NONE || \
-				 (akm) == RSN_AKM_UNSPECIFIED || \
-				 (akm) == RSN_AKM_PSK)
-#define IS_WPA2_AKM(akm)	((akm) == RSN_AKM_UNSPECIFIED || \
-				 (akm) == RSN_AKM_PSK)
-
-#define MAX_ARRAY 1
-#define MIN_ARRAY 0
-
-/* convert wsec to WPA mcast cipher. algo is needed only when WEP is enabled. */
-#define WPA_MCAST_CIPHER(wsec, algo)	(WSEC_WEP_ENABLED(wsec) ? \
-		((algo) == CRYPTO_ALGO_WEP128 ? WPA_CIPHER_WEP_104 : WPA_CIPHER_WEP_40) : \
-			WSEC_TKIP_ENABLED(wsec) ? WPA_CIPHER_TKIP : \
-			WSEC_AES_ENABLED(wsec) ? WPA_CIPHER_AES_CCM : \
-			WPA_CIPHER_NONE)
-
-/* Look for a WPA IE; return it's address if found, NULL otherwise */
-extern wpa_ie_fixed_t *BCMROMFN(bcm_find_wpaie) (uint8 * parse, uint len);
-
-/* Check whether the given IE looks like WFA IE with the specific type. */
-extern bool bcm_is_wfa_ie(uint8 * ie, uint8 ** tlvs, uint * tlvs_len,
-			  uint8 type);
-/* Check whether pointed-to IE looks like WPA. */
-#define bcm_is_wpa_ie(ie, tlvs, len)	bcm_is_wfa_ie(ie, tlvs, len, WFA_OUI_TYPE_WPA)
-
-#endif				/* _BCMWPA_H_ */
diff --git a/drivers/staging/brcm80211/include/bitfuncs.h b/drivers/staging/brcm80211/include/bitfuncs.h
deleted file mode 100644
index 18842ef..0000000
--- a/drivers/staging/brcm80211/include/bitfuncs.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (c) 2010 Broadcom Corporation
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#ifndef _BITFUNCS_H
-#define _BITFUNCS_H
-
-#include <typedefs.h>
-
-/* local prototypes */
-static INLINE uint32 find_msbit(uint32 x);
-
-/*
- * find_msbit: returns index of most significant set bit in x, with index
- *   range defined as 0-31.  NOTE: returns zero if input is zero.
- */
-
-#if defined(USE_PENTIUM_BSR) && defined(__GNUC__)
-
-/*
- * Implementation for Pentium processors and gcc.  Note that this
- * instruction is actually very slow on some processors (e.g., family 5,
- * model 2, stepping 12, "Pentium 75 - 200"), so we use the generic
- * implementation instead.
- */
-static INLINE uint32 find_msbit(uint32 x)
-{
-	uint msbit;
- __asm__("bsrl %1,%0":"=r"(msbit)
- :		"r"(x));
-	return msbit;
-}
-
-#else				/* !USE_PENTIUM_BSR || !__GNUC__ */
-
-/*
- * Generic Implementation
- */
-
-#define DB_POW_MASK16	0xffff0000
-#define DB_POW_MASK8	0x0000ff00
-#define DB_POW_MASK4	0x000000f0
-#define DB_POW_MASK2	0x0000000c
-#define DB_POW_MASK1	0x00000002
-
-static INLINE uint32 find_msbit(uint32 x)
-{
-	uint32 temp_x = x;
-	uint msbit = 0;
-	if (temp_x & DB_POW_MASK16) {
-		temp_x >>= 16;
-		msbit = 16;
-	}
-	if (temp_x & DB_POW_MASK8) {
-		temp_x >>= 8;
-		msbit += 8;
-	}
-	if (temp_x & DB_POW_MASK4) {
-		temp_x >>= 4;
-		msbit += 4;
-	}
-	if (temp_x & DB_POW_MASK2) {
-		temp_x >>= 2;
-		msbit += 2;
-	}
-	if (temp_x & DB_POW_MASK1) {
-		msbit += 1;
-	}
-	return (msbit);
-}
-
-#endif				/* USE_PENTIUM_BSR && __GNUC__ */
-
-#endif				/* _BITFUNCS_H */
diff --git a/drivers/staging/brcm80211/include/d11.h b/drivers/staging/brcm80211/include/d11.h
index 378832c..c07548c 100644
--- a/drivers/staging/brcm80211/include/d11.h
+++ b/drivers/staging/brcm80211/include/d11.h
@@ -17,7 +17,7 @@
 #ifndef	_D11_H
 #define	_D11_H
 
-#include <typedefs.h>
+#include <bcmdefs.h>
 #include <bcmdevs.h>
 #include <hndsoc.h>
 #include <sbhndpio.h>
@@ -65,18 +65,18 @@
 #define	TX_CTL_FIFO		TX_AC_VO_FIFO
 
 typedef volatile struct {
-	uint32 intstatus;
-	uint32 intmask;
+	u32 intstatus;
+	u32 intmask;
 } intctrlregs_t;
 
 /* read: 32-bit register that can be read as 32-bit or as 2 16-bit
  * write: only low 16b-it half can be written
  */
 typedef volatile union {
-	uint32 pmqhostdata;	/* read only! */
+	u32 pmqhostdata;	/* read only! */
 	struct {
-		uint16 pmqctrlstatus;	/* read/write */
-		uint16 PAD;
+		u16 pmqctrlstatus;	/* read/write */
+		u16 PAD;
 	} w;
 } pmqreg_t;
 
@@ -107,74 +107,74 @@ typedef volatile struct {
  */
 typedef volatile struct _d11regs {
 	/* Device Control ("semi-standard host registers") */
-	uint32 PAD[3];		/* 0x0 - 0x8 */
-	uint32 biststatus;	/* 0xC */
-	uint32 biststatus2;	/* 0x10 */
-	uint32 PAD;		/* 0x14 */
-	uint32 gptimer;		/* 0x18 *//* for corerev >= 3 */
-	uint32 usectimer;	/* 0x1c *//* for corerev >= 26 */
+	u32 PAD[3];		/* 0x0 - 0x8 */
+	u32 biststatus;	/* 0xC */
+	u32 biststatus2;	/* 0x10 */
+	u32 PAD;		/* 0x14 */
+	u32 gptimer;		/* 0x18 *//* for corerev >= 3 */
+	u32 usectimer;	/* 0x1c *//* for corerev >= 26 */
 
 	/* Interrupt Control *//* 0x20 */
 	intctrlregs_t intctrlregs[8];
 
-	uint32 PAD[40];		/* 0x60 - 0xFC */
+	u32 PAD[40];		/* 0x60 - 0xFC */
 
 	/* tx fifos 6-7 and rx fifos 1-3 removed in corerev 5 */
-	uint32 intrcvlazy[4];	/* 0x100 - 0x10C */
+	u32 intrcvlazy[4];	/* 0x100 - 0x10C */
 
-	uint32 PAD[4];		/* 0x110 - 0x11c */
+	u32 PAD[4];		/* 0x110 - 0x11c */
 
-	uint32 maccontrol;	/* 0x120 */
-	uint32 maccommand;	/* 0x124 */
-	uint32 macintstatus;	/* 0x128 */
-	uint32 macintmask;	/* 0x12C */
+	u32 maccontrol;	/* 0x120 */
+	u32 maccommand;	/* 0x124 */
+	u32 macintstatus;	/* 0x128 */
+	u32 macintmask;	/* 0x12C */
 
 	/* Transmit Template Access */
-	uint32 tplatewrptr;	/* 0x130 */
-	uint32 tplatewrdata;	/* 0x134 */
-	uint32 PAD[2];		/* 0x138 - 0x13C */
+	u32 tplatewrptr;	/* 0x130 */
+	u32 tplatewrdata;	/* 0x134 */
+	u32 PAD[2];		/* 0x138 - 0x13C */
 
 	/* PMQ registers */
 	pmqreg_t pmqreg;	/* 0x140 */
-	uint32 pmqpatl;		/* 0x144 */
-	uint32 pmqpath;		/* 0x148 */
-	uint32 PAD;		/* 0x14C */
+	u32 pmqpatl;		/* 0x144 */
+	u32 pmqpath;		/* 0x148 */
+	u32 PAD;		/* 0x14C */
 
-	uint32 chnstatus;	/* 0x150 */
-	uint32 psmdebug;	/* 0x154 *//* for corerev >= 3 */
-	uint32 phydebug;	/* 0x158 *//* for corerev >= 3 */
-	uint32 machwcap;	/* 0x15C *//* Corerev >= 13 */
+	u32 chnstatus;	/* 0x150 */
+	u32 psmdebug;	/* 0x154 *//* for corerev >= 3 */
+	u32 phydebug;	/* 0x158 *//* for corerev >= 3 */
+	u32 machwcap;	/* 0x15C *//* Corerev >= 13 */
 
 	/* Extended Internal Objects */
-	uint32 objaddr;		/* 0x160 */
-	uint32 objdata;		/* 0x164 */
-	uint32 PAD[2];		/* 0x168 - 0x16c */
+	u32 objaddr;		/* 0x160 */
+	u32 objdata;		/* 0x164 */
+	u32 PAD[2];		/* 0x168 - 0x16c */
 
 	/* New txstatus registers on corerev >= 5 */
-	uint32 frmtxstatus;	/* 0x170 */
-	uint32 frmtxstatus2;	/* 0x174 */
-	uint32 PAD[2];		/* 0x178 - 0x17c */
+	u32 frmtxstatus;	/* 0x170 */
+	u32 frmtxstatus2;	/* 0x174 */
+	u32 PAD[2];		/* 0x178 - 0x17c */
 
 	/* New TSF host access on corerev >= 3 */
 
-	uint32 tsf_timerlow;	/* 0x180 */
-	uint32 tsf_timerhigh;	/* 0x184 */
-	uint32 tsf_cfprep;	/* 0x188 */
-	uint32 tsf_cfpstart;	/* 0x18c */
-	uint32 tsf_cfpmaxdur32;	/* 0x190 */
-	uint32 PAD[3];		/* 0x194 - 0x19c */
+	u32 tsf_timerlow;	/* 0x180 */
+	u32 tsf_timerhigh;	/* 0x184 */
+	u32 tsf_cfprep;	/* 0x188 */
+	u32 tsf_cfpstart;	/* 0x18c */
+	u32 tsf_cfpmaxdur32;	/* 0x190 */
+	u32 PAD[3];		/* 0x194 - 0x19c */
 
-	uint32 maccontrol1;	/* 0x1a0 */
-	uint32 machwcap1;	/* 0x1a4 */
-	uint32 PAD[14];		/* 0x1a8 - 0x1dc */
+	u32 maccontrol1;	/* 0x1a0 */
+	u32 machwcap1;	/* 0x1a4 */
+	u32 PAD[14];		/* 0x1a8 - 0x1dc */
 
 	/* Clock control and hardware workarounds (corerev >= 13) */
-	uint32 clk_ctl_st;	/* 0x1e0 */
-	uint32 hw_war;
-	uint32 d11_phypllctl;	/* 0x1e8 (corerev == 16), the phypll request/avail bits are
+	u32 clk_ctl_st;	/* 0x1e0 */
+	u32 hw_war;
+	u32 d11_phypllctl;	/* 0x1e8 (corerev == 16), the phypll request/avail bits are
 				 *   moved to clk_ctl_st for corerev >= 17
 				 */
-	uint32 PAD[5];		/* 0x1ec - 0x1fc */
+	u32 PAD[5];		/* 0x1ec - 0x1fc */
 
 	/* 0x200-0x37F dma/pio registers */
 	volatile union {
@@ -185,253 +185,253 @@ typedef volatile struct _d11regs {
 	/* FIFO diagnostic port access */
 	dma32diag_t dmafifo;	/* 0x380 - 0x38C */
 
-	uint32 aggfifocnt;	/* 0x390 */
-	uint32 aggfifodata;	/* 0x394 */
-	uint32 PAD[16];		/* 0x398 - 0x3d4 */
-	uint16 radioregaddr;	/* 0x3d8 */
-	uint16 radioregdata;	/* 0x3da */
+	u32 aggfifocnt;	/* 0x390 */
+	u32 aggfifodata;	/* 0x394 */
+	u32 PAD[16];		/* 0x398 - 0x3d4 */
+	u16 radioregaddr;	/* 0x3d8 */
+	u16 radioregdata;	/* 0x3da */
 
 	/* time delay between the change on rf disable input and radio shutdown corerev 10 */
-	uint32 rfdisabledly;	/* 0x3DC */
+	u32 rfdisabledly;	/* 0x3DC */
 
 	/* PHY register access */
-	uint16 phyversion;	/* 0x3e0 - 0x0 */
-	uint16 phybbconfig;	/* 0x3e2 - 0x1 */
-	uint16 phyadcbias;	/* 0x3e4 - 0x2  Bphy only */
-	uint16 phyanacore;	/* 0x3e6 - 0x3  pwwrdwn on aphy */
-	uint16 phyrxstatus0;	/* 0x3e8 - 0x4 */
-	uint16 phyrxstatus1;	/* 0x3ea - 0x5 */
-	uint16 phycrsth;	/* 0x3ec - 0x6 */
-	uint16 phytxerror;	/* 0x3ee - 0x7 */
-	uint16 phychannel;	/* 0x3f0 - 0x8 */
-	uint16 PAD[1];		/* 0x3f2 - 0x9 */
-	uint16 phytest;		/* 0x3f4 - 0xa */
-	uint16 phy4waddr;	/* 0x3f6 - 0xb */
-	uint16 phy4wdatahi;	/* 0x3f8 - 0xc */
-	uint16 phy4wdatalo;	/* 0x3fa - 0xd */
-	uint16 phyregaddr;	/* 0x3fc - 0xe */
-	uint16 phyregdata;	/* 0x3fe - 0xf */
+	u16 phyversion;	/* 0x3e0 - 0x0 */
+	u16 phybbconfig;	/* 0x3e2 - 0x1 */
+	u16 phyadcbias;	/* 0x3e4 - 0x2  Bphy only */
+	u16 phyanacore;	/* 0x3e6 - 0x3  pwwrdwn on aphy */
+	u16 phyrxstatus0;	/* 0x3e8 - 0x4 */
+	u16 phyrxstatus1;	/* 0x3ea - 0x5 */
+	u16 phycrsth;	/* 0x3ec - 0x6 */
+	u16 phytxerror;	/* 0x3ee - 0x7 */
+	u16 phychannel;	/* 0x3f0 - 0x8 */
+	u16 PAD[1];		/* 0x3f2 - 0x9 */
+	u16 phytest;		/* 0x3f4 - 0xa */
+	u16 phy4waddr;	/* 0x3f6 - 0xb */
+	u16 phy4wdatahi;	/* 0x3f8 - 0xc */
+	u16 phy4wdatalo;	/* 0x3fa - 0xd */
+	u16 phyregaddr;	/* 0x3fc - 0xe */
+	u16 phyregdata;	/* 0x3fe - 0xf */
 
 	/* IHR *//* 0x400 - 0x7FE */
 
 	/* RXE Block */
-	uint16 PAD[3];		/* 0x400 - 0x406 */
-	uint16 rcv_fifo_ctl;	/* 0x406 */
-	uint16 PAD;		/* 0x408 - 0x40a */
-	uint16 rcv_frm_cnt;	/* 0x40a */
-	uint16 PAD[4];		/* 0x40a - 0x414 */
-	uint16 rssi;		/* 0x414 */
-	uint16 PAD[5];		/* 0x414 - 0x420 */
-	uint16 rcm_ctl;		/* 0x420 */
-	uint16 rcm_mat_data;	/* 0x422 */
-	uint16 rcm_mat_mask;	/* 0x424 */
-	uint16 rcm_mat_dly;	/* 0x426 */
-	uint16 rcm_cond_mask_l;	/* 0x428 */
-	uint16 rcm_cond_mask_h;	/* 0x42A */
-	uint16 rcm_cond_dly;	/* 0x42C */
-	uint16 PAD[1];		/* 0x42E */
-	uint16 ext_ihr_addr;	/* 0x430 */
-	uint16 ext_ihr_data;	/* 0x432 */
-	uint16 rxe_phyrs_2;	/* 0x434 */
-	uint16 rxe_phyrs_3;	/* 0x436 */
-	uint16 phy_mode;	/* 0x438 */
-	uint16 rcmta_ctl;	/* 0x43a */
-	uint16 rcmta_size;	/* 0x43c */
-	uint16 rcmta_addr0;	/* 0x43e */
-	uint16 rcmta_addr1;	/* 0x440 */
-	uint16 rcmta_addr2;	/* 0x442 */
-	uint16 PAD[30];		/* 0x444 - 0x480 */
+	u16 PAD[3];		/* 0x400 - 0x406 */
+	u16 rcv_fifo_ctl;	/* 0x406 */
+	u16 PAD;		/* 0x408 - 0x40a */
+	u16 rcv_frm_cnt;	/* 0x40a */
+	u16 PAD[4];		/* 0x40a - 0x414 */
+	u16 rssi;		/* 0x414 */
+	u16 PAD[5];		/* 0x414 - 0x420 */
+	u16 rcm_ctl;		/* 0x420 */
+	u16 rcm_mat_data;	/* 0x422 */
+	u16 rcm_mat_mask;	/* 0x424 */
+	u16 rcm_mat_dly;	/* 0x426 */
+	u16 rcm_cond_mask_l;	/* 0x428 */
+	u16 rcm_cond_mask_h;	/* 0x42A */
+	u16 rcm_cond_dly;	/* 0x42C */
+	u16 PAD[1];		/* 0x42E */
+	u16 ext_ihr_addr;	/* 0x430 */
+	u16 ext_ihr_data;	/* 0x432 */
+	u16 rxe_phyrs_2;	/* 0x434 */
+	u16 rxe_phyrs_3;	/* 0x436 */
+	u16 phy_mode;	/* 0x438 */
+	u16 rcmta_ctl;	/* 0x43a */
+	u16 rcmta_size;	/* 0x43c */
+	u16 rcmta_addr0;	/* 0x43e */
+	u16 rcmta_addr1;	/* 0x440 */
+	u16 rcmta_addr2;	/* 0x442 */
+	u16 PAD[30];		/* 0x444 - 0x480 */
 
 	/* PSM Block *//* 0x480 - 0x500 */
 
-	uint16 PAD;		/* 0x480 */
-	uint16 psm_maccontrol_h;	/* 0x482 */
-	uint16 psm_macintstatus_l;	/* 0x484 */
-	uint16 psm_macintstatus_h;	/* 0x486 */
-	uint16 psm_macintmask_l;	/* 0x488 */
-	uint16 psm_macintmask_h;	/* 0x48A */
-	uint16 PAD;		/* 0x48C */
-	uint16 psm_maccommand;	/* 0x48E */
-	uint16 psm_brc;		/* 0x490 */
-	uint16 psm_phy_hdr_param;	/* 0x492 */
-	uint16 psm_postcard;	/* 0x494 */
-	uint16 psm_pcard_loc_l;	/* 0x496 */
-	uint16 psm_pcard_loc_h;	/* 0x498 */
-	uint16 psm_gpio_in;	/* 0x49A */
-	uint16 psm_gpio_out;	/* 0x49C */
-	uint16 psm_gpio_oe;	/* 0x49E */
-
-	uint16 psm_bred_0;	/* 0x4A0 */
-	uint16 psm_bred_1;	/* 0x4A2 */
-	uint16 psm_bred_2;	/* 0x4A4 */
-	uint16 psm_bred_3;	/* 0x4A6 */
-	uint16 psm_brcl_0;	/* 0x4A8 */
-	uint16 psm_brcl_1;	/* 0x4AA */
-	uint16 psm_brcl_2;	/* 0x4AC */
-	uint16 psm_brcl_3;	/* 0x4AE */
-	uint16 psm_brpo_0;	/* 0x4B0 */
-	uint16 psm_brpo_1;	/* 0x4B2 */
-	uint16 psm_brpo_2;	/* 0x4B4 */
-	uint16 psm_brpo_3;	/* 0x4B6 */
-	uint16 psm_brwk_0;	/* 0x4B8 */
-	uint16 psm_brwk_1;	/* 0x4BA */
-	uint16 psm_brwk_2;	/* 0x4BC */
-	uint16 psm_brwk_3;	/* 0x4BE */
-
-	uint16 psm_base_0;	/* 0x4C0 */
-	uint16 psm_base_1;	/* 0x4C2 */
-	uint16 psm_base_2;	/* 0x4C4 */
-	uint16 psm_base_3;	/* 0x4C6 */
-	uint16 psm_base_4;	/* 0x4C8 */
-	uint16 psm_base_5;	/* 0x4CA */
-	uint16 psm_base_6;	/* 0x4CC */
-	uint16 psm_pc_reg_0;	/* 0x4CE */
-	uint16 psm_pc_reg_1;	/* 0x4D0 */
-	uint16 psm_pc_reg_2;	/* 0x4D2 */
-	uint16 psm_pc_reg_3;	/* 0x4D4 */
-	uint16 PAD[0xD];	/* 0x4D6 - 0x4DE */
-	uint16 psm_corectlsts;	/* 0x4f0 *//* Corerev >= 13 */
-	uint16 PAD[0x7];	/* 0x4f2 - 0x4fE */
+	u16 PAD;		/* 0x480 */
+	u16 psm_maccontrol_h;	/* 0x482 */
+	u16 psm_macintstatus_l;	/* 0x484 */
+	u16 psm_macintstatus_h;	/* 0x486 */
+	u16 psm_macintmask_l;	/* 0x488 */
+	u16 psm_macintmask_h;	/* 0x48A */
+	u16 PAD;		/* 0x48C */
+	u16 psm_maccommand;	/* 0x48E */
+	u16 psm_brc;		/* 0x490 */
+	u16 psm_phy_hdr_param;	/* 0x492 */
+	u16 psm_postcard;	/* 0x494 */
+	u16 psm_pcard_loc_l;	/* 0x496 */
+	u16 psm_pcard_loc_h;	/* 0x498 */
+	u16 psm_gpio_in;	/* 0x49A */
+	u16 psm_gpio_out;	/* 0x49C */
+	u16 psm_gpio_oe;	/* 0x49E */
+
+	u16 psm_bred_0;	/* 0x4A0 */
+	u16 psm_bred_1;	/* 0x4A2 */
+	u16 psm_bred_2;	/* 0x4A4 */
+	u16 psm_bred_3;	/* 0x4A6 */
+	u16 psm_brcl_0;	/* 0x4A8 */
+	u16 psm_brcl_1;	/* 0x4AA */
+	u16 psm_brcl_2;	/* 0x4AC */
+	u16 psm_brcl_3;	/* 0x4AE */
+	u16 psm_brpo_0;	/* 0x4B0 */
+	u16 psm_brpo_1;	/* 0x4B2 */
+	u16 psm_brpo_2;	/* 0x4B4 */
+	u16 psm_brpo_3;	/* 0x4B6 */
+	u16 psm_brwk_0;	/* 0x4B8 */
+	u16 psm_brwk_1;	/* 0x4BA */
+	u16 psm_brwk_2;	/* 0x4BC */
+	u16 psm_brwk_3;	/* 0x4BE */
+
+	u16 psm_base_0;	/* 0x4C0 */
+	u16 psm_base_1;	/* 0x4C2 */
+	u16 psm_base_2;	/* 0x4C4 */
+	u16 psm_base_3;	/* 0x4C6 */
+	u16 psm_base_4;	/* 0x4C8 */
+	u16 psm_base_5;	/* 0x4CA */
+	u16 psm_base_6;	/* 0x4CC */
+	u16 psm_pc_reg_0;	/* 0x4CE */
+	u16 psm_pc_reg_1;	/* 0x4D0 */
+	u16 psm_pc_reg_2;	/* 0x4D2 */
+	u16 psm_pc_reg_3;	/* 0x4D4 */
+	u16 PAD[0xD];	/* 0x4D6 - 0x4DE */
+	u16 psm_corectlsts;	/* 0x4f0 *//* Corerev >= 13 */
+	u16 PAD[0x7];	/* 0x4f2 - 0x4fE */
 
 	/* TXE0 Block *//* 0x500 - 0x580 */
-	uint16 txe_ctl;		/* 0x500 */
-	uint16 txe_aux;		/* 0x502 */
-	uint16 txe_ts_loc;	/* 0x504 */
-	uint16 txe_time_out;	/* 0x506 */
-	uint16 txe_wm_0;	/* 0x508 */
-	uint16 txe_wm_1;	/* 0x50A */
-	uint16 txe_phyctl;	/* 0x50C */
-	uint16 txe_status;	/* 0x50E */
-	uint16 txe_mmplcp0;	/* 0x510 */
-	uint16 txe_mmplcp1;	/* 0x512 */
-	uint16 txe_phyctl1;	/* 0x514 */
-
-	uint16 PAD[0x05];	/* 0x510 - 0x51E */
+	u16 txe_ctl;		/* 0x500 */
+	u16 txe_aux;		/* 0x502 */
+	u16 txe_ts_loc;	/* 0x504 */
+	u16 txe_time_out;	/* 0x506 */
+	u16 txe_wm_0;	/* 0x508 */
+	u16 txe_wm_1;	/* 0x50A */
+	u16 txe_phyctl;	/* 0x50C */
+	u16 txe_status;	/* 0x50E */
+	u16 txe_mmplcp0;	/* 0x510 */
+	u16 txe_mmplcp1;	/* 0x512 */
+	u16 txe_phyctl1;	/* 0x514 */
+
+	u16 PAD[0x05];	/* 0x510 - 0x51E */
 
 	/* Transmit control */
-	uint16 xmtfifodef;	/* 0x520 */
-	uint16 xmtfifo_frame_cnt;	/* 0x522 *//* Corerev >= 16 */
-	uint16 xmtfifo_byte_cnt;	/* 0x524 *//* Corerev >= 16 */
-	uint16 xmtfifo_head;	/* 0x526 *//* Corerev >= 16 */
-	uint16 xmtfifo_rd_ptr;	/* 0x528 *//* Corerev >= 16 */
-	uint16 xmtfifo_wr_ptr;	/* 0x52A *//* Corerev >= 16 */
-	uint16 xmtfifodef1;	/* 0x52C *//* Corerev >= 16 */
-
-	uint16 PAD[0x09];	/* 0x52E - 0x53E */
-
-	uint16 xmtfifocmd;	/* 0x540 */
-	uint16 xmtfifoflush;	/* 0x542 */
-	uint16 xmtfifothresh;	/* 0x544 */
-	uint16 xmtfifordy;	/* 0x546 */
-	uint16 xmtfifoprirdy;	/* 0x548 */
-	uint16 xmtfiforqpri;	/* 0x54A */
-	uint16 xmttplatetxptr;	/* 0x54C */
-	uint16 PAD;		/* 0x54E */
-	uint16 xmttplateptr;	/* 0x550 */
-	uint16 smpl_clct_strptr;	/* 0x552 *//* Corerev >= 22 */
-	uint16 smpl_clct_stpptr;	/* 0x554 *//* Corerev >= 22 */
-	uint16 smpl_clct_curptr;	/* 0x556 *//* Corerev >= 22 */
-	uint16 PAD[0x04];	/* 0x558 - 0x55E */
-	uint16 xmttplatedatalo;	/* 0x560 */
-	uint16 xmttplatedatahi;	/* 0x562 */
-
-	uint16 PAD[2];		/* 0x564 - 0x566 */
-
-	uint16 xmtsel;		/* 0x568 */
-	uint16 xmttxcnt;	/* 0x56A */
-	uint16 xmttxshmaddr;	/* 0x56C */
-
-	uint16 PAD[0x09];	/* 0x56E - 0x57E */
+	u16 xmtfifodef;	/* 0x520 */
+	u16 xmtfifo_frame_cnt;	/* 0x522 *//* Corerev >= 16 */
+	u16 xmtfifo_byte_cnt;	/* 0x524 *//* Corerev >= 16 */
+	u16 xmtfifo_head;	/* 0x526 *//* Corerev >= 16 */
+	u16 xmtfifo_rd_ptr;	/* 0x528 *//* Corerev >= 16 */
+	u16 xmtfifo_wr_ptr;	/* 0x52A *//* Corerev >= 16 */
+	u16 xmtfifodef1;	/* 0x52C *//* Corerev >= 16 */
+
+	u16 PAD[0x09];	/* 0x52E - 0x53E */
+
+	u16 xmtfifocmd;	/* 0x540 */
+	u16 xmtfifoflush;	/* 0x542 */
+	u16 xmtfifothresh;	/* 0x544 */
+	u16 xmtfifordy;	/* 0x546 */
+	u16 xmtfifoprirdy;	/* 0x548 */
+	u16 xmtfiforqpri;	/* 0x54A */
+	u16 xmttplatetxptr;	/* 0x54C */
+	u16 PAD;		/* 0x54E */
+	u16 xmttplateptr;	/* 0x550 */
+	u16 smpl_clct_strptr;	/* 0x552 *//* Corerev >= 22 */
+	u16 smpl_clct_stpptr;	/* 0x554 *//* Corerev >= 22 */
+	u16 smpl_clct_curptr;	/* 0x556 *//* Corerev >= 22 */
+	u16 PAD[0x04];	/* 0x558 - 0x55E */
+	u16 xmttplatedatalo;	/* 0x560 */
+	u16 xmttplatedatahi;	/* 0x562 */
+
+	u16 PAD[2];		/* 0x564 - 0x566 */
+
+	u16 xmtsel;		/* 0x568 */
+	u16 xmttxcnt;	/* 0x56A */
+	u16 xmttxshmaddr;	/* 0x56C */
+
+	u16 PAD[0x09];	/* 0x56E - 0x57E */
 
 	/* TXE1 Block */
-	uint16 PAD[0x40];	/* 0x580 - 0x5FE */
+	u16 PAD[0x40];	/* 0x580 - 0x5FE */
 
 	/* TSF Block */
-	uint16 PAD[0X02];	/* 0x600 - 0x602 */
-	uint16 tsf_cfpstrt_l;	/* 0x604 */
-	uint16 tsf_cfpstrt_h;	/* 0x606 */
-	uint16 PAD[0X05];	/* 0x608 - 0x610 */
-	uint16 tsf_cfppretbtt;	/* 0x612 */
-	uint16 PAD[0XD];	/* 0x614 - 0x62C */
-	uint16 tsf_clk_frac_l;	/* 0x62E */
-	uint16 tsf_clk_frac_h;	/* 0x630 */
-	uint16 PAD[0X14];	/* 0x632 - 0x658 */
-	uint16 tsf_random;	/* 0x65A */
-	uint16 PAD[0x05];	/* 0x65C - 0x664 */
+	u16 PAD[0X02];	/* 0x600 - 0x602 */
+	u16 tsf_cfpstrt_l;	/* 0x604 */
+	u16 tsf_cfpstrt_h;	/* 0x606 */
+	u16 PAD[0X05];	/* 0x608 - 0x610 */
+	u16 tsf_cfppretbtt;	/* 0x612 */
+	u16 PAD[0XD];	/* 0x614 - 0x62C */
+	u16 tsf_clk_frac_l;	/* 0x62E */
+	u16 tsf_clk_frac_h;	/* 0x630 */
+	u16 PAD[0X14];	/* 0x632 - 0x658 */
+	u16 tsf_random;	/* 0x65A */
+	u16 PAD[0x05];	/* 0x65C - 0x664 */
 	/* GPTimer 2 registers are corerev >= 3 */
-	uint16 tsf_gpt2_stat;	/* 0x666 */
-	uint16 tsf_gpt2_ctr_l;	/* 0x668 */
-	uint16 tsf_gpt2_ctr_h;	/* 0x66A */
-	uint16 tsf_gpt2_val_l;	/* 0x66C */
-	uint16 tsf_gpt2_val_h;	/* 0x66E */
-	uint16 tsf_gptall_stat;	/* 0x670 */
-	uint16 PAD[0x07];	/* 0x672 - 0x67E */
+	u16 tsf_gpt2_stat;	/* 0x666 */
+	u16 tsf_gpt2_ctr_l;	/* 0x668 */
+	u16 tsf_gpt2_ctr_h;	/* 0x66A */
+	u16 tsf_gpt2_val_l;	/* 0x66C */
+	u16 tsf_gpt2_val_h;	/* 0x66E */
+	u16 tsf_gptall_stat;	/* 0x670 */
+	u16 PAD[0x07];	/* 0x672 - 0x67E */
 
 	/* IFS Block */
-	uint16 ifs_sifs_rx_tx_tx;	/* 0x680 */
-	uint16 ifs_sifs_nav_tx;	/* 0x682 */
-	uint16 ifs_slot;	/* 0x684 */
-	uint16 PAD;		/* 0x686 */
-	uint16 ifs_ctl;		/* 0x688 */
-	uint16 PAD[0x3];	/* 0x68a - 0x68F */
-	uint16 ifsstat;		/* 0x690 */
-	uint16 ifsmedbusyctl;	/* 0x692 */
-	uint16 iftxdur;		/* 0x694 */
-	uint16 PAD[0x3];	/* 0x696 - 0x69b */
+	u16 ifs_sifs_rx_tx_tx;	/* 0x680 */
+	u16 ifs_sifs_nav_tx;	/* 0x682 */
+	u16 ifs_slot;	/* 0x684 */
+	u16 PAD;		/* 0x686 */
+	u16 ifs_ctl;		/* 0x688 */
+	u16 PAD[0x3];	/* 0x68a - 0x68F */
+	u16 ifsstat;		/* 0x690 */
+	u16 ifsmedbusyctl;	/* 0x692 */
+	u16 iftxdur;		/* 0x694 */
+	u16 PAD[0x3];	/* 0x696 - 0x69b */
 	/* EDCF support in dot11macs with corerevs >= 16 */
-	uint16 ifs_aifsn;	/* 0x69c */
-	uint16 ifs_ctl1;	/* 0x69e */
+	u16 ifs_aifsn;	/* 0x69c */
+	u16 ifs_ctl1;	/* 0x69e */
 
 	/* New slow clock registers on corerev >= 5 */
-	uint16 scc_ctl;		/* 0x6a0 */
-	uint16 scc_timer_l;	/* 0x6a2 */
-	uint16 scc_timer_h;	/* 0x6a4 */
-	uint16 scc_frac;	/* 0x6a6 */
-	uint16 scc_fastpwrup_dly;	/* 0x6a8 */
-	uint16 scc_per;		/* 0x6aa */
-	uint16 scc_per_frac;	/* 0x6ac */
-	uint16 scc_cal_timer_l;	/* 0x6ae */
-	uint16 scc_cal_timer_h;	/* 0x6b0 */
-	uint16 PAD;		/* 0x6b2 */
-
-	uint16 PAD[0x26];
+	u16 scc_ctl;		/* 0x6a0 */
+	u16 scc_timer_l;	/* 0x6a2 */
+	u16 scc_timer_h;	/* 0x6a4 */
+	u16 scc_frac;	/* 0x6a6 */
+	u16 scc_fastpwrup_dly;	/* 0x6a8 */
+	u16 scc_per;		/* 0x6aa */
+	u16 scc_per_frac;	/* 0x6ac */
+	u16 scc_cal_timer_l;	/* 0x6ae */
+	u16 scc_cal_timer_h;	/* 0x6b0 */
+	u16 PAD;		/* 0x6b2 */
+
+	u16 PAD[0x26];
 
 	/* NAV Block */
-	uint16 nav_ctl;		/* 0x700 */
-	uint16 navstat;		/* 0x702 */
-	uint16 PAD[0x3e];	/* 0x702 - 0x77E */
+	u16 nav_ctl;		/* 0x700 */
+	u16 navstat;		/* 0x702 */
+	u16 PAD[0x3e];	/* 0x702 - 0x77E */
 
 	/* WEP/PMQ Block *//* 0x780 - 0x7FE */
-	uint16 PAD[0x20];	/* 0x780 - 0x7BE */
-
-	uint16 wepctl;		/* 0x7C0 */
-	uint16 wepivloc;	/* 0x7C2 */
-	uint16 wepivkey;	/* 0x7C4 */
-	uint16 wepwkey;		/* 0x7C6 */
-
-	uint16 PAD[4];		/* 0x7C8 - 0x7CE */
-	uint16 pcmctl;		/* 0X7D0 */
-	uint16 pcmstat;		/* 0X7D2 */
-	uint16 PAD[6];		/* 0x7D4 - 0x7DE */
-
-	uint16 pmqctl;		/* 0x7E0 */
-	uint16 pmqstatus;	/* 0x7E2 */
-	uint16 pmqpat0;		/* 0x7E4 */
-	uint16 pmqpat1;		/* 0x7E6 */
-	uint16 pmqpat2;		/* 0x7E8 */
-
-	uint16 pmqdat;		/* 0x7EA */
-	uint16 pmqdator;	/* 0x7EC */
-	uint16 pmqhst;		/* 0x7EE */
-	uint16 pmqpath0;	/* 0x7F0 */
-	uint16 pmqpath1;	/* 0x7F2 */
-	uint16 pmqpath2;	/* 0x7F4 */
-	uint16 pmqdath;		/* 0x7F6 */
-
-	uint16 PAD[0x04];	/* 0x7F8 - 0x7FE */
+	u16 PAD[0x20];	/* 0x780 - 0x7BE */
+
+	u16 wepctl;		/* 0x7C0 */
+	u16 wepivloc;	/* 0x7C2 */
+	u16 wepivkey;	/* 0x7C4 */
+	u16 wepwkey;		/* 0x7C6 */
+
+	u16 PAD[4];		/* 0x7C8 - 0x7CE */
+	u16 pcmctl;		/* 0X7D0 */
+	u16 pcmstat;		/* 0X7D2 */
+	u16 PAD[6];		/* 0x7D4 - 0x7DE */
+
+	u16 pmqctl;		/* 0x7E0 */
+	u16 pmqstatus;	/* 0x7E2 */
+	u16 pmqpat0;		/* 0x7E4 */
+	u16 pmqpat1;		/* 0x7E6 */
+	u16 pmqpat2;		/* 0x7E8 */
+
+	u16 pmqdat;		/* 0x7EA */
+	u16 pmqdator;	/* 0x7EC */
+	u16 pmqhst;		/* 0x7EE */
+	u16 pmqpath0;	/* 0x7F0 */
+	u16 pmqpath1;	/* 0x7F2 */
+	u16 pmqpath2;	/* 0x7F4 */
+	u16 pmqdath;		/* 0x7F6 */
+
+	u16 PAD[0x04];	/* 0x7F8 - 0x7FE */
 
 	/* SHM *//* 0x800 - 0xEFE */
-	uint16 PAD[0x380];	/* 0x800 - 0xEFE */
+	u16 PAD[0x380];	/* 0x800 - 0xEFE */
 
 	/* SB configuration registers: 0xF00 */
 	sbconfig_t sbconfig;	/* sb config regs occupy top 256 bytes */
@@ -633,14 +633,14 @@ typedef volatile struct _d11regs {
 /* 802.11a PLCP header def */
 typedef struct ofdm_phy_hdr ofdm_phy_hdr_t;
 BWL_PRE_PACKED_STRUCT struct ofdm_phy_hdr {
-	uint8 rlpt[3];		/* rate, length, parity, tail */
-	uint16 service;
-	uint8 pad;
+	u8 rlpt[3];		/* rate, length, parity, tail */
+	u16 service;
+	u8 pad;
 } BWL_POST_PACKED_STRUCT;
 
 #define	D11A_PHY_HDR_GRATE(phdr)	((phdr)->rlpt[0] & 0x0f)
 #define	D11A_PHY_HDR_GRES(phdr)		(((phdr)->rlpt[0] >> 4) & 0x01)
-#define	D11A_PHY_HDR_GLENGTH(phdr)	(((uint32 *)((phdr)->rlpt) >> 5) & 0x0fff)
+#define	D11A_PHY_HDR_GLENGTH(phdr)	(((u32 *)((phdr)->rlpt) >> 5) & 0x0fff)
 #define	D11A_PHY_HDR_GPARITY(phdr)	(((phdr)->rlpt[3] >> 1) & 0x01)
 #define	D11A_PHY_HDR_GTAIL(phdr)	(((phdr)->rlpt[3] >> 2) & 0x3f)
 
@@ -651,7 +651,7 @@ BWL_PRE_PACKED_STRUCT struct ofdm_phy_hdr {
 #define	D11A_PHY_HDR_SRES(phdr)		((phdr)->rlpt[0] &= 0xef)
 /* length is number of octets in PSDU */
 #define	D11A_PHY_HDR_SLENGTH(phdr, length)	\
-	(*(uint32 *)((phdr)->rlpt) = *(uint32 *)((phdr)->rlpt) | \
+	(*(u32 *)((phdr)->rlpt) = *(u32 *)((phdr)->rlpt) | \
 	(((length) & 0x0fff) << 5))
 /* set the tail to all zeros */
 #define	D11A_PHY_HDR_STAIL(phdr)	((phdr)->rlpt[3] &= 0x03)
@@ -668,10 +668,10 @@ BWL_PRE_PACKED_STRUCT struct ofdm_phy_hdr {
 /* 802.11b PLCP header def */
 typedef struct cck_phy_hdr cck_phy_hdr_t;
 BWL_PRE_PACKED_STRUCT struct cck_phy_hdr {
-	uint8 signal;
-	uint8 service;
-	uint16 length;
-	uint16 crc;
+	u8 signal;
+	u8 service;
+	u16 length;
+	u16 crc;
 } BWL_POST_PACKED_STRUCT;
 
 #define	D11B_PHY_HDR_LEN	6
@@ -696,7 +696,10 @@ BWL_PRE_PACKED_STRUCT struct cck_phy_hdr {
 #define WLC_GET_CCK_PLCP_LEN(plcp) (plcp[4] + (plcp[5] << 8))
 #define WLC_GET_MIMO_PLCP_LEN(plcp) (plcp[1] + (plcp[2] << 8))
 #define WLC_SET_MIMO_PLCP_LEN(plcp, len) \
-	plcp[1] = len & 0xff; plcp[2] = ((len >> 8) & 0xff);
+	do { \
+		plcp[1] = len & 0xff; \
+		plcp[2] = ((len >> 8) & 0xff); \
+	} while (0);
 
 #define WLC_SET_MIMO_PLCP_AMPDU(plcp) (plcp[3] |= MIMO_PLCP_AMPDU)
 #define WLC_CLR_MIMO_PLCP_AMPDU(plcp) (plcp[3] &= ~MIMO_PLCP_AMPDU)
@@ -711,40 +714,40 @@ BWL_PRE_PACKED_STRUCT struct cck_phy_hdr {
 /* TX DMA buffer header */
 typedef struct d11txh d11txh_t;
 BWL_PRE_PACKED_STRUCT struct d11txh {
-	uint16 MacTxControlLow;	/* 0x0 */
-	uint16 MacTxControlHigh;	/* 0x1 */
-	uint16 MacFrameControl;	/* 0x2 */
-	uint16 TxFesTimeNormal;	/* 0x3 */
-	uint16 PhyTxControlWord;	/* 0x4 */
-	uint16 PhyTxControlWord_1;	/* 0x5 */
-	uint16 PhyTxControlWord_1_Fbr;	/* 0x6 */
-	uint16 PhyTxControlWord_1_Rts;	/* 0x7 */
-	uint16 PhyTxControlWord_1_FbrRts;	/* 0x8 */
-	uint16 MainRates;	/* 0x9 */
-	uint16 XtraFrameTypes;	/* 0xa */
-	uint8 IV[16];		/* 0x0b - 0x12 */
-	uint8 TxFrameRA[6];	/* 0x13 - 0x15 */
-	uint16 TxFesTimeFallback;	/* 0x16 */
-	uint8 RTSPLCPFallback[6];	/* 0x17 - 0x19 */
-	uint16 RTSDurFallback;	/* 0x1a */
-	uint8 FragPLCPFallback[6];	/* 0x1b - 1d */
-	uint16 FragDurFallback;	/* 0x1e */
-	uint16 MModeLen;	/* 0x1f */
-	uint16 MModeFbrLen;	/* 0x20 */
-	uint16 TstampLow;	/* 0x21 */
-	uint16 TstampHigh;	/* 0x22 */
-	uint16 ABI_MimoAntSel;	/* 0x23 */
-	uint16 PreloadSize;	/* 0x24 */
-	uint16 AmpduSeqCtl;	/* 0x25 */
-	uint16 TxFrameID;	/* 0x26 */
-	uint16 TxStatus;	/* 0x27 */
-	uint16 MaxNMpdus;	/* 0x28 corerev >=16 */
-	uint16 MaxABytes_MRT;	/* 0x29 corerev >=16 */
-	uint16 MaxABytes_FBR;	/* 0x2a corerev >=16 */
-	uint16 MinMBytes;	/* 0x2b corerev >=16 */
-	uint8 RTSPhyHeader[D11_PHY_HDR_LEN];	/* 0x2c - 0x2e */
+	u16 MacTxControlLow;	/* 0x0 */
+	u16 MacTxControlHigh;	/* 0x1 */
+	u16 MacFrameControl;	/* 0x2 */
+	u16 TxFesTimeNormal;	/* 0x3 */
+	u16 PhyTxControlWord;	/* 0x4 */
+	u16 PhyTxControlWord_1;	/* 0x5 */
+	u16 PhyTxControlWord_1_Fbr;	/* 0x6 */
+	u16 PhyTxControlWord_1_Rts;	/* 0x7 */
+	u16 PhyTxControlWord_1_FbrRts;	/* 0x8 */
+	u16 MainRates;	/* 0x9 */
+	u16 XtraFrameTypes;	/* 0xa */
+	u8 IV[16];		/* 0x0b - 0x12 */
+	u8 TxFrameRA[6];	/* 0x13 - 0x15 */
+	u16 TxFesTimeFallback;	/* 0x16 */
+	u8 RTSPLCPFallback[6];	/* 0x17 - 0x19 */
+	u16 RTSDurFallback;	/* 0x1a */
+	u8 FragPLCPFallback[6];	/* 0x1b - 1d */
+	u16 FragDurFallback;	/* 0x1e */
+	u16 MModeLen;	/* 0x1f */
+	u16 MModeFbrLen;	/* 0x20 */
+	u16 TstampLow;	/* 0x21 */
+	u16 TstampHigh;	/* 0x22 */
+	u16 ABI_MimoAntSel;	/* 0x23 */
+	u16 PreloadSize;	/* 0x24 */
+	u16 AmpduSeqCtl;	/* 0x25 */
+	u16 TxFrameID;	/* 0x26 */
+	u16 TxStatus;	/* 0x27 */
+	u16 MaxNMpdus;	/* 0x28 corerev >=16 */
+	u16 MaxABytes_MRT;	/* 0x29 corerev >=16 */
+	u16 MaxABytes_FBR;	/* 0x2a corerev >=16 */
+	u16 MinMBytes;	/* 0x2b corerev >=16 */
+	u8 RTSPhyHeader[D11_PHY_HDR_LEN];	/* 0x2c - 0x2e */
 	struct dot11_rts_frame rts_frame;	/* 0x2f - 0x36 */
-	uint16 PAD;		/* 0x37 */
+	u16 PAD;		/* 0x37 */
 } BWL_POST_PACKED_STRUCT;
 
 #define	D11_TXH_LEN		112	/* bytes */
@@ -855,14 +858,14 @@ BWL_PRE_PACKED_STRUCT struct d11txh {
 /* tx status packet */
 typedef struct tx_status tx_status_t;
 BWL_PRE_PACKED_STRUCT struct tx_status {
-	uint16 framelen;
-	uint16 PAD;
-	uint16 frameid;
-	uint16 status;
-	uint16 lasttxtime;
-	uint16 sequence;
-	uint16 phyerr;
-	uint16 ackphyrxsh;
+	u16 framelen;
+	u16 PAD;
+	u16 frameid;
+	u16 status;
+	u16 lasttxtime;
+	u16 sequence;
+	u16 phyerr;
+	u16 ackphyrxsh;
 } BWL_POST_PACKED_STRUCT;
 
 #define	TXSTATUS_LEN	16
@@ -1198,8 +1201,8 @@ BWL_PRE_PACKED_STRUCT struct tx_status {
 #define M_20IN40_IQ			(0x380 * 2)
 
 /* SHM locations where ucode stores the current power index */
-#define M_CURR_IDX1		(0x384 *2)
-#define M_CURR_IDX2		(0x387 *2)
+#define M_CURR_IDX1		(0x384 * 2)
+#define M_CURR_IDX2		(0x387 * 2)
 
 #define M_BSCALE_ANT0	(0x5e * 2)
 #define M_BSCALE_ANT1	(0x5f * 2)
@@ -1248,22 +1251,22 @@ BWL_PRE_PACKED_STRUCT struct tx_status {
 
 typedef struct shm_acparams shm_acparams_t;
 BWL_PRE_PACKED_STRUCT struct shm_acparams {
-	uint16 txop;
-	uint16 cwmin;
-	uint16 cwmax;
-	uint16 cwcur;
-	uint16 aifs;
-	uint16 bslots;
-	uint16 reggap;
-	uint16 status;
-	uint16 rsvd[8];
+	u16 txop;
+	u16 cwmin;
+	u16 cwmax;
+	u16 cwcur;
+	u16 aifs;
+	u16 bslots;
+	u16 reggap;
+	u16 status;
+	u16 rsvd[8];
 } BWL_POST_PACKED_STRUCT;
 #define M_EDCF_QLEN	(16 * 2)
 
 #define WME_STATUS_NEWAC	(1 << 8)
 
 /* M_HOST_FLAGS */
-#define MHFMAX		5	/* Number of valid hostflag half-word (uint16) */
+#define MHFMAX		5	/* Number of valid hostflag half-word (u16) */
 #define MHF1		0	/* Hostflag 1 index */
 #define MHF2		1	/* Hostflag 2 index */
 #define MHF3		2	/* Hostflag 3 index */
@@ -1307,18 +1310,18 @@ BWL_PRE_PACKED_STRUCT struct shm_acparams {
 /* Receive Frame Data Header for 802.11b DCF-only frames */
 typedef struct d11rxhdr d11rxhdr_t;
 BWL_PRE_PACKED_STRUCT struct d11rxhdr {
-	uint16 RxFrameSize;	/* Actual byte length of the frame data received */
-	uint16 PAD;
-	uint16 PhyRxStatus_0;	/* PhyRxStatus 15:0 */
-	uint16 PhyRxStatus_1;	/* PhyRxStatus 31:16 */
-	uint16 PhyRxStatus_2;	/* PhyRxStatus 47:32 */
-	uint16 PhyRxStatus_3;	/* PhyRxStatus 63:48 */
-	uint16 PhyRxStatus_4;	/* PhyRxStatus 79:64 */
-	uint16 PhyRxStatus_5;	/* PhyRxStatus 95:80 */
-	uint16 RxStatus1;	/* MAC Rx Status */
-	uint16 RxStatus2;	/* extended MAC Rx status */
-	uint16 RxTSFTime;	/* RxTSFTime time of first MAC symbol + M_PHY_PLCPRX_DLY */
-	uint16 RxChan;		/* gain code, channel radio code, and phy type */
+	u16 RxFrameSize;	/* Actual byte length of the frame data received */
+	u16 PAD;
+	u16 PhyRxStatus_0;	/* PhyRxStatus 15:0 */
+	u16 PhyRxStatus_1;	/* PhyRxStatus 31:16 */
+	u16 PhyRxStatus_2;	/* PhyRxStatus 47:32 */
+	u16 PhyRxStatus_3;	/* PhyRxStatus 63:48 */
+	u16 PhyRxStatus_4;	/* PhyRxStatus 79:64 */
+	u16 PhyRxStatus_5;	/* PhyRxStatus 95:80 */
+	u16 RxStatus1;	/* MAC Rx Status */
+	u16 RxStatus2;	/* extended MAC Rx status */
+	u16 RxTSFTime;	/* RxTSFTime time of first MAC symbol + M_PHY_PLCPRX_DLY */
+	u16 RxChan;		/* gain code, channel radio code, and phy type */
 } BWL_POST_PACKED_STRUCT;
 
 #define	RXHDR_LEN		24	/* sizeof d11rxhdr_t */
@@ -1327,12 +1330,12 @@ BWL_PRE_PACKED_STRUCT struct d11rxhdr {
 typedef struct wlc_d11rxhdr wlc_d11rxhdr_t;
 BWL_PRE_PACKED_STRUCT struct wlc_d11rxhdr {
 	d11rxhdr_t rxhdr;
-	uint32 tsf_l;		/* TSF_L reading */
-	int8 rssi;		/* computed instanteneous rssi in BMAC */
-	int8 rxpwr0;		/* obsoleted, place holder for legacy ROM code. use rxpwr[] */
-	int8 rxpwr1;		/* obsoleted, place holder for legacy ROM code. use rxpwr[] */
-	int8 do_rssi_ma;	/* do per-pkt sampling for per-antenna ma in HIGH */
-	int8 rxpwr[WL_RSSI_ANT_MAX];	/* rssi for supported antennas */
+	u32 tsf_l;		/* TSF_L reading */
+	s8 rssi;		/* computed instanteneous rssi in BMAC */
+	s8 rxpwr0;		/* obsoleted, place holder for legacy ROM code. use rxpwr[] */
+	s8 rxpwr1;		/* obsoleted, place holder for legacy ROM code. use rxpwr[] */
+	s8 do_rssi_ma;	/* do per-pkt sampling for per-antenna ma in HIGH */
+	s8 rxpwr[WL_RSSI_ANT_MAX];	/* rssi for supported antennas */
 } BWL_POST_PACKED_STRUCT;
 
 /* PhyRxStatus_0: */
@@ -1563,63 +1566,63 @@ typedef enum {
 
 /* ucode mac statistic counters in shared memory */
 typedef struct macstat {
-	uint16 txallfrm;	/* 0x80 */
-	uint16 txrtsfrm;	/* 0x82 */
-	uint16 txctsfrm;	/* 0x84 */
-	uint16 txackfrm;	/* 0x86 */
-	uint16 txdnlfrm;	/* 0x88 */
-	uint16 txbcnfrm;	/* 0x8a */
-	uint16 txfunfl[8];	/* 0x8c - 0x9b */
-	uint16 txtplunfl;	/* 0x9c */
-	uint16 txphyerr;	/* 0x9e */
-	uint16 pktengrxducast;	/* 0xa0 */
-	uint16 pktengrxdmcast;	/* 0xa2 */
-	uint16 rxfrmtoolong;	/* 0xa4 */
-	uint16 rxfrmtooshrt;	/* 0xa6 */
-	uint16 rxinvmachdr;	/* 0xa8 */
-	uint16 rxbadfcs;	/* 0xaa */
-	uint16 rxbadplcp;	/* 0xac */
-	uint16 rxcrsglitch;	/* 0xae */
-	uint16 rxstrt;		/* 0xb0 */
-	uint16 rxdfrmucastmbss;	/* 0xb2 */
-	uint16 rxmfrmucastmbss;	/* 0xb4 */
-	uint16 rxcfrmucast;	/* 0xb6 */
-	uint16 rxrtsucast;	/* 0xb8 */
-	uint16 rxctsucast;	/* 0xba */
-	uint16 rxackucast;	/* 0xbc */
-	uint16 rxdfrmocast;	/* 0xbe */
-	uint16 rxmfrmocast;	/* 0xc0 */
-	uint16 rxcfrmocast;	/* 0xc2 */
-	uint16 rxrtsocast;	/* 0xc4 */
-	uint16 rxctsocast;	/* 0xc6 */
-	uint16 rxdfrmmcast;	/* 0xc8 */
-	uint16 rxmfrmmcast;	/* 0xca */
-	uint16 rxcfrmmcast;	/* 0xcc */
-	uint16 rxbeaconmbss;	/* 0xce */
-	uint16 rxdfrmucastobss;	/* 0xd0 */
-	uint16 rxbeaconobss;	/* 0xd2 */
-	uint16 rxrsptmout;	/* 0xd4 */
-	uint16 bcntxcancl;	/* 0xd6 */
-	uint16 PAD;
-	uint16 rxf0ovfl;	/* 0xda */
-	uint16 rxf1ovfl;	/* 0xdc */
-	uint16 rxf2ovfl;	/* 0xde */
-	uint16 txsfovfl;	/* 0xe0 */
-	uint16 pmqovfl;		/* 0xe2 */
-	uint16 rxcgprqfrm;	/* 0xe4 */
-	uint16 rxcgprsqovfl;	/* 0xe6 */
-	uint16 txcgprsfail;	/* 0xe8 */
-	uint16 txcgprssuc;	/* 0xea */
-	uint16 prs_timeout;	/* 0xec */
-	uint16 rxnack;
-	uint16 frmscons;
-	uint16 txnack;
-	uint16 txglitch_nack;
-	uint16 txburst;		/* 0xf6 # tx bursts */
-	uint16 bphy_rxcrsglitch;	/* bphy rx crs glitch */
-	uint16 phywatchdog;	/* 0xfa # of phy watchdog events */
-	uint16 PAD;
-	uint16 bphy_badplcp;	/* bphy bad plcp */
+	u16 txallfrm;	/* 0x80 */
+	u16 txrtsfrm;	/* 0x82 */
+	u16 txctsfrm;	/* 0x84 */
+	u16 txackfrm;	/* 0x86 */
+	u16 txdnlfrm;	/* 0x88 */
+	u16 txbcnfrm;	/* 0x8a */
+	u16 txfunfl[8];	/* 0x8c - 0x9b */
+	u16 txtplunfl;	/* 0x9c */
+	u16 txphyerr;	/* 0x9e */
+	u16 pktengrxducast;	/* 0xa0 */
+	u16 pktengrxdmcast;	/* 0xa2 */
+	u16 rxfrmtoolong;	/* 0xa4 */
+	u16 rxfrmtooshrt;	/* 0xa6 */
+	u16 rxinvmachdr;	/* 0xa8 */
+	u16 rxbadfcs;	/* 0xaa */
+	u16 rxbadplcp;	/* 0xac */
+	u16 rxcrsglitch;	/* 0xae */
+	u16 rxstrt;		/* 0xb0 */
+	u16 rxdfrmucastmbss;	/* 0xb2 */
+	u16 rxmfrmucastmbss;	/* 0xb4 */
+	u16 rxcfrmucast;	/* 0xb6 */
+	u16 rxrtsucast;	/* 0xb8 */
+	u16 rxctsucast;	/* 0xba */
+	u16 rxackucast;	/* 0xbc */
+	u16 rxdfrmocast;	/* 0xbe */
+	u16 rxmfrmocast;	/* 0xc0 */
+	u16 rxcfrmocast;	/* 0xc2 */
+	u16 rxrtsocast;	/* 0xc4 */
+	u16 rxctsocast;	/* 0xc6 */
+	u16 rxdfrmmcast;	/* 0xc8 */
+	u16 rxmfrmmcast;	/* 0xca */
+	u16 rxcfrmmcast;	/* 0xcc */
+	u16 rxbeaconmbss;	/* 0xce */
+	u16 rxdfrmucastobss;	/* 0xd0 */
+	u16 rxbeaconobss;	/* 0xd2 */
+	u16 rxrsptmout;	/* 0xd4 */
+	u16 bcntxcancl;	/* 0xd6 */
+	u16 PAD;
+	u16 rxf0ovfl;	/* 0xda */
+	u16 rxf1ovfl;	/* 0xdc */
+	u16 rxf2ovfl;	/* 0xde */
+	u16 txsfovfl;	/* 0xe0 */
+	u16 pmqovfl;		/* 0xe2 */
+	u16 rxcgprqfrm;	/* 0xe4 */
+	u16 rxcgprsqovfl;	/* 0xe6 */
+	u16 txcgprsfail;	/* 0xe8 */
+	u16 txcgprssuc;	/* 0xea */
+	u16 prs_timeout;	/* 0xec */
+	u16 rxnack;
+	u16 frmscons;
+	u16 txnack;
+	u16 txglitch_nack;
+	u16 txburst;		/* 0xf6 # tx bursts */
+	u16 bphy_rxcrsglitch;	/* bphy rx crs glitch */
+	u16 phywatchdog;	/* 0xfa # of phy watchdog events */
+	u16 PAD;
+	u16 bphy_badplcp;	/* bphy bad plcp */
 } macstat_t;
 
 /* dot11 core-specific control flags */
diff --git a/drivers/staging/brcm80211/include/dbus.h b/drivers/staging/brcm80211/include/dbus.h
index fc8e298..81ffea7 100644
--- a/drivers/staging/brcm80211/include/dbus.h
+++ b/drivers/staging/brcm80211/include/dbus.h
@@ -17,8 +17,6 @@
 #ifndef __DBUS_H__
 #define __DBUS_H__
 
-#include "typedefs.h"
-
 #ifdef BCMDBG
 #define DBUSERR(args)        do { if (net_ratelimit()) printf args; } while (0)
 #define DBUSTRACE(args)
@@ -111,10 +109,10 @@ typedef struct {
  * Let upper layer account for packets/bytes
  */
 typedef struct {
-	uint32 rx_errors;
-	uint32 tx_errors;
-	uint32 rx_dropped;
-	uint32 tx_dropped;
+	u32 rx_errors;
+	u32 tx_errors;
+	u32 rx_dropped;
+	u32 tx_dropped;
 } dbus_stats_t;
 
 /*
@@ -127,15 +125,15 @@ typedef struct {
 struct dbus_callbacks;
 struct exec_parms;
 
-typedef void *(*probe_cb_t) (void *arg, const char *desc, uint32 bustype,
-			     uint32 hdrlen);
+typedef void *(*probe_cb_t) (void *arg, const char *desc, u32 bustype,
+			     u32 hdrlen);
 typedef void (*disconnect_cb_t) (void *arg);
-typedef void *(*exec_cb_t) (struct exec_parms * args);
+typedef void *(*exec_cb_t) (struct exec_parms *args);
 
 /* Client callbacks registered during dbus_attach() */
 typedef struct dbus_callbacks {
 	void (*send_complete) (void *cbarg, void *info, int status);
-	void (*recv_buf) (void *cbarg, uint8 * buf, int len);
+	void (*recv_buf) (void *cbarg, u8 *buf, int len);
 	void (*recv_pkt) (void *cbarg, void *pkt);
 	void (*txflowcontrol) (void *cbarg, bool onoff);
 	void (*errhandler) (void *cbarg, int err);
@@ -153,19 +151,19 @@ struct dbus_irb_tx;
 struct dbus_intf_callbacks;
 
 typedef struct {
-	void *(*attach) (struct dbus_pub * pub, void *cbarg,
-			 struct dbus_intf_callbacks * cbs);
-	void (*detach) (struct dbus_pub * pub, void *bus);
+	void *(*attach) (struct dbus_pub *pub, void *cbarg,
+			 struct dbus_intf_callbacks *cbs);
+	void (*detach) (struct dbus_pub *pub, void *bus);
 
 	int (*up) (void *bus);
 	int (*down) (void *bus);
-	int (*send_irb) (void *bus, struct dbus_irb_tx * txirb);
-	int (*recv_irb) (void *bus, struct dbus_irb_rx * rxirb);
-	int (*cancel_irb) (void *bus, struct dbus_irb_tx * txirb);
-	int (*send_ctl) (void *bus, uint8 * buf, int len);
-	int (*recv_ctl) (void *bus, uint8 * buf, int len);
-	int (*get_stats) (void *bus, dbus_stats_t * stats);
-	int (*get_attrib) (void *bus, dbus_attrib_t * attrib);
+	int (*send_irb) (void *bus, struct dbus_irb_tx *txirb);
+	int (*recv_irb) (void *bus, struct dbus_irb_rx *rxirb);
+	int (*cancel_irb) (void *bus, struct dbus_irb_tx *txirb);
+	int (*send_ctl) (void *bus, u8 *buf, int len);
+	int (*recv_ctl) (void *bus, u8 *buf, int len);
+	int (*get_stats) (void *bus, dbus_stats_t *stats);
+	int (*get_attrib) (void *bus, dbus_attrib_t *attrib);
 
 	int (*pnp) (void *bus, int event);
 	int (*remove) (void *bus);
@@ -180,20 +178,20 @@ typedef struct {
 
 	int (*iovar_op) (void *bus, const char *name, void *params, int plen,
 			 void *arg, int len, bool set);
-	void (*dump) (void *bus, struct bcmstrbuf * strbuf);
-	int (*set_config) (void *bus, dbus_config_t * config);
-	int (*get_config) (void *bus, dbus_config_t * config);
+	void (*dump) (void *bus, struct bcmstrbuf *strbuf);
+	int (*set_config) (void *bus, dbus_config_t *config);
+	int (*get_config) (void *bus, dbus_config_t *config);
 
 	 bool(*device_exists) (void *bus);
 	 bool(*dlneeded) (void *bus);
-	int (*dlstart) (void *bus, uint8 * fw, int len);
+	int (*dlstart) (void *bus, u8 *fw, int len);
 	int (*dlrun) (void *bus);
 	 bool(*recv_needed) (void *bus);
 
 	void *(*exec_rxlock) (void *bus, exec_cb_t func,
-			      struct exec_parms * args);
+			      struct exec_parms *args);
 	void *(*exec_txlock) (void *bus, exec_cb_t func,
-			      struct exec_parms * args);
+			      struct exec_parms *args);
 
 	int (*tx_timer_init) (void *bus);
 	int (*tx_timer_start) (void *bus, uint timeout);
@@ -235,40 +233,40 @@ extern int dbus_deregister(void);
 
 extern const dbus_pub_t *dbus_attach(struct osl_info *osh, int rxsize, int nrxq,
 				     int ntxq, void *cbarg,
-				     dbus_callbacks_t * cbs,
+				     dbus_callbacks_t *cbs,
 				     struct shared_info *sh);
-extern void dbus_detach(const dbus_pub_t * pub);
+extern void dbus_detach(const dbus_pub_t *pub);
 
-extern int dbus_up(const dbus_pub_t * pub);
-extern int dbus_down(const dbus_pub_t * pub);
-extern int dbus_stop(const dbus_pub_t * pub);
-extern int dbus_shutdown(const dbus_pub_t * pub);
-extern void dbus_flowctrl_rx(const dbus_pub_t * pub, bool on);
+extern int dbus_up(const dbus_pub_t *pub);
+extern int dbus_down(const dbus_pub_t *pub);
+extern int dbus_stop(const dbus_pub_t *pub);
+extern int dbus_shutdown(const dbus_pub_t *pub);
+extern void dbus_flowctrl_rx(const dbus_pub_t *pub, bool on);
 
-extern int dbus_send_buf(const dbus_pub_t * pub, uint8 * buf, int len,
+extern int dbus_send_buf(const dbus_pub_t *pub, u8 *buf, int len,
 			 void *info);
-extern int dbus_send_pkt(const dbus_pub_t * pub, void *pkt, void *info);
-extern int dbus_send_ctl(const dbus_pub_t * pub, uint8 * buf, int len);
-extern int dbus_recv_ctl(const dbus_pub_t * pub, uint8 * buf, int len);
+extern int dbus_send_pkt(const dbus_pub_t *pub, void *pkt, void *info);
+extern int dbus_send_ctl(const dbus_pub_t *pub, u8 *buf, int len);
+extern int dbus_recv_ctl(const dbus_pub_t *pub, u8 *buf, int len);
 
-extern int dbus_get_stats(const dbus_pub_t * pub, dbus_stats_t * stats);
-extern int dbus_get_attrib(const dbus_pub_t * pub, dbus_attrib_t * attrib);
-extern int dbus_get_device_speed(const dbus_pub_t * pub);
-extern int dbus_set_config(const dbus_pub_t * pub, dbus_config_t * config);
-extern int dbus_get_config(const dbus_pub_t * pub, dbus_config_t * config);
+extern int dbus_get_stats(const dbus_pub_t *pub, dbus_stats_t *stats);
+extern int dbus_get_attrib(const dbus_pub_t *pub, dbus_attrib_t *attrib);
+extern int dbus_get_device_speed(const dbus_pub_t *pub);
+extern int dbus_set_config(const dbus_pub_t *pub, dbus_config_t *config);
+extern int dbus_get_config(const dbus_pub_t *pub, dbus_config_t *config);
 
-extern void *dbus_pktget(const dbus_pub_t * pub, int len);
-extern void dbus_pktfree(const dbus_pub_t * pub, void *pkt);
+extern void *dbus_pktget(const dbus_pub_t *pub, int len);
+extern void dbus_pktfree(const dbus_pub_t *pub, void *pkt);
 
-extern int dbus_set_errmask(const dbus_pub_t * pub, uint32 mask);
-extern int dbus_pnp_sleep(const dbus_pub_t * pub);
-extern int dbus_pnp_resume(const dbus_pub_t * pub, int *fw_reload);
-extern int dbus_pnp_disconnect(const dbus_pub_t * pub);
+extern int dbus_set_errmask(const dbus_pub_t *pub, u32 mask);
+extern int dbus_pnp_sleep(const dbus_pub_t *pub);
+extern int dbus_pnp_resume(const dbus_pub_t *pub, int *fw_reload);
+extern int dbus_pnp_disconnect(const dbus_pub_t *pub);
 
-extern int dbus_iovar_op(const dbus_pub_t * pub, const char *name,
+extern int dbus_iovar_op(const dbus_pub_t *pub, const char *name,
 			 void *params, int plen, void *arg, int len, bool set);
 #ifdef BCMDBG
-extern void dbus_hist_dump(const dbus_pub_t * pub, struct bcmstrbuf *b);
+extern void dbus_hist_dump(const dbus_pub_t *pub, struct bcmstrbuf *b);
 #endif				/* BCMDBG */
 /*
  * Private Common Bus Interface
@@ -281,7 +279,7 @@ typedef struct dbus_irb {
 
 typedef struct dbus_irb_rx {
 	struct dbus_irb irb;	/* Must be first */
-	uint8 *buf;
+	u8 *buf;
 	int buf_len;
 	int actual_len;
 	void *pkt;
@@ -291,7 +289,7 @@ typedef struct dbus_irb_rx {
 
 typedef struct dbus_irb_tx {
 	struct dbus_irb irb;	/* Must be first */
-	uint8 *buf;
+	u8 *buf;
 	int len;
 	void *pkt;
 	int retry_count;
@@ -303,15 +301,15 @@ typedef struct dbus_irb_tx {
  * so, internally, different info can be passed to upper layer
  */
 typedef struct dbus_intf_callbacks {
-	void (*send_irb_timeout) (void *cbarg, dbus_irb_tx_t * txirb);
-	void (*send_irb_complete) (void *cbarg, dbus_irb_tx_t * txirb,
+	void (*send_irb_timeout) (void *cbarg, dbus_irb_tx_t *txirb);
+	void (*send_irb_complete) (void *cbarg, dbus_irb_tx_t *txirb,
 				   int status);
-	void (*recv_irb_complete) (void *cbarg, dbus_irb_rx_t * rxirb,
+	void (*recv_irb_complete) (void *cbarg, dbus_irb_rx_t *rxirb,
 				   int status);
 	void (*errhandler) (void *cbarg, int err);
 	void (*ctl_complete) (void *cbarg, int type, int status);
 	void (*state_change) (void *cbarg, int state);
-	 bool(*isr) (void *cbarg, bool * wantdpc);
+	 bool(*isr) (void *cbarg, bool *wantdpc);
 	 bool(*dpc) (void *cbarg, bool bounded);
 	void (*watchdog) (void *cbarg);
 	void *(*pktget) (void *cbarg, uint len, bool send);
@@ -330,7 +328,7 @@ typedef struct dbus_intf_callbacks {
  */
 extern int dbus_bus_register(int vid, int pid, probe_cb_t prcb,
 			     disconnect_cb_t discb, void *prarg,
-			     dbus_intf_t ** intf, void *param1, void *param2);
+			     dbus_intf_t **intf, void *param1, void *param2);
 extern int dbus_bus_deregister(void);
 
 /*
@@ -339,7 +337,7 @@ extern int dbus_bus_deregister(void);
  */
 extern int dbus_bus_osl_register(int vid, int pid, probe_cb_t prcb,
 				 disconnect_cb_t discb, void *prarg,
-				 dbus_intf_t ** intf, void *param1,
+				 dbus_intf_t **intf, void *param1,
 				 void *param2);
 extern int dbus_bus_osl_deregister(void);
 
@@ -349,7 +347,7 @@ extern int dbus_bus_osl_deregister(void);
  */
 extern int dbus_bus_osl_hw_register(int vid, int pid, probe_cb_t prcb,
 				    disconnect_cb_t discb, void *prarg,
-				    dbus_intf_t ** intf);
+				    dbus_intf_t **intf);
 extern int dbus_bus_osl_hw_deregister(void);
 
 #endif				/* __DBUS_H__ */
diff --git a/drivers/staging/brcm80211/include/dhdioctl.h b/drivers/staging/brcm80211/include/dhdioctl.h
new file mode 100644
index 0000000..4d06e50
--- /dev/null
+++ b/drivers/staging/brcm80211/include/dhdioctl.h
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _dhdioctl_h_
+#define	_dhdioctl_h_
+
+/* require default structure packing */
+#define BWL_DEFAULT_PACKING
+#include <packed_section_start.h>
+
+/* Linux network driver ioctl encoding */
+typedef struct dhd_ioctl {
+	uint cmd;		/* common ioctl definition */
+	void *buf;		/* pointer to user buffer */
+	uint len;		/* length of user buffer */
+	bool set;		/* get or set request (optional) */
+	uint used;		/* bytes read or written (optional) */
+	uint needed;		/* bytes needed (optional) */
+	uint driver;		/* to identify target driver */
+} dhd_ioctl_t;
+
+/* per-driver magic numbers */
+#define DHD_IOCTL_MAGIC		0x00444944
+
+/* bump this number if you change the ioctl interface */
+#define DHD_IOCTL_VERSION	1
+
+#define	DHD_IOCTL_MAXLEN	8192	/* max length ioctl buffer required */
+#define	DHD_IOCTL_SMLEN	256	/* "small" length ioctl buffer required */
+
+/* common ioctl definitions */
+#define DHD_GET_MAGIC				0
+#define DHD_GET_VERSION				1
+#define DHD_GET_VAR				2
+#define DHD_SET_VAR				3
+
+/* message levels */
+#define DHD_ERROR_VAL	0x0001
+#define DHD_TRACE_VAL	0x0002
+#define DHD_INFO_VAL	0x0004
+#define DHD_DATA_VAL	0x0008
+#define DHD_CTL_VAL	0x0010
+#define DHD_TIMER_VAL	0x0020
+#define DHD_HDRS_VAL	0x0040
+#define DHD_BYTES_VAL	0x0080
+#define DHD_INTR_VAL	0x0100
+#define DHD_LOG_VAL	0x0200
+#define DHD_GLOM_VAL	0x0400
+#define DHD_EVENT_VAL	0x0800
+#define DHD_BTA_VAL	0x1000
+#define DHD_ISCAN_VAL 0x2000
+
+#ifdef SDTEST
+/* For pktgen iovar */
+typedef struct dhd_pktgen {
+	uint version;		/* To allow structure change tracking */
+	uint freq;		/* Max ticks between tx/rx attempts */
+	uint count;		/* Test packets to send/rcv each attempt */
+	uint print;		/* Print counts every <print> attempts */
+	uint total;		/* Total packets (or bursts) */
+	uint minlen;		/* Minimum length of packets to send */
+	uint maxlen;		/* Maximum length of packets to send */
+	uint numsent;		/* Count of test packets sent */
+	uint numrcvd;		/* Count of test packets received */
+	uint numfail;		/* Count of test send failures */
+	uint mode;		/* Test mode (type of test packets) */
+	uint stop;		/* Stop after this many tx failures */
+} dhd_pktgen_t;
+
+/* Version in case structure changes */
+#define DHD_PKTGEN_VERSION 2
+
+/* Type of test packets to use */
+#define DHD_PKTGEN_ECHO		1	/* Send echo requests */
+#define DHD_PKTGEN_SEND		2	/* Send discard packets */
+#define DHD_PKTGEN_RXBURST	3	/* Request dongle send N packets */
+#define DHD_PKTGEN_RECV		4	/* Continuous rx from continuous
+					 tx dongle */
+#endif				/* SDTEST */
+
+/* Enter idle immediately (no timeout) */
+#define DHD_IDLE_IMMEDIATE	(-1)
+
+/* Values for idleclock iovar: other values are the sd_divisor to use
+	 when idle */
+#define DHD_IDLE_ACTIVE	0	/* Do not request any SD clock change
+				 when idle */
+#define DHD_IDLE_STOP   (-1)	/* Request SD clock be stopped
+				 (and use SD1 mode) */
+
+/* require default structure packing */
+#include <packed_section_end.h>
+
+#endif				/* _dhdioctl_h_ */
diff --git a/drivers/staging/brcm80211/include/epivers.h b/drivers/staging/brcm80211/include/epivers.h
index dc9b8a2..2e6b519 100644
--- a/drivers/staging/brcm80211/include/epivers.h
+++ b/drivers/staging/brcm80211/include/epivers.h
@@ -27,7 +27,7 @@
 
 #define EPI_BUILD_NUMBER	1
 
-#define	EPI_VERSION		5, 75, 11, 0
+#define	EPI_VERSION		{ 5, 75, 11, 0 }
 
 #ifdef BCMSDIO
 /* EPI_VERSION_NUM must match FW version */
diff --git a/drivers/staging/brcm80211/include/hnddma.h b/drivers/staging/brcm80211/include/hnddma.h
index 747acf4..bee4c89 100644
--- a/drivers/staging/brcm80211/include/hnddma.h
+++ b/drivers/staging/brcm80211/include/hnddma.h
@@ -30,52 +30,52 @@ typedef enum txd_range {
 } txd_range_t;
 
 /* dma function type */
-typedef void (*di_detach_t) (hnddma_t * dmah);
-typedef bool(*di_txreset_t) (hnddma_t * dmah);
-typedef bool(*di_rxreset_t) (hnddma_t * dmah);
-typedef bool(*di_rxidle_t) (hnddma_t * dmah);
-typedef void (*di_txinit_t) (hnddma_t * dmah);
-typedef bool(*di_txenabled_t) (hnddma_t * dmah);
-typedef void (*di_rxinit_t) (hnddma_t * dmah);
-typedef void (*di_txsuspend_t) (hnddma_t * dmah);
-typedef void (*di_txresume_t) (hnddma_t * dmah);
-typedef bool(*di_txsuspended_t) (hnddma_t * dmah);
-typedef bool(*di_txsuspendedidle_t) (hnddma_t * dmah);
-typedef int (*di_txfast_t) (hnddma_t * dmah, void *p, bool commit);
-typedef int (*di_txunframed_t) (hnddma_t * dmah, void *p, uint len,
+typedef void (*di_detach_t) (hnddma_t *dmah);
+typedef bool(*di_txreset_t) (hnddma_t *dmah);
+typedef bool(*di_rxreset_t) (hnddma_t *dmah);
+typedef bool(*di_rxidle_t) (hnddma_t *dmah);
+typedef void (*di_txinit_t) (hnddma_t *dmah);
+typedef bool(*di_txenabled_t) (hnddma_t *dmah);
+typedef void (*di_rxinit_t) (hnddma_t *dmah);
+typedef void (*di_txsuspend_t) (hnddma_t *dmah);
+typedef void (*di_txresume_t) (hnddma_t *dmah);
+typedef bool(*di_txsuspended_t) (hnddma_t *dmah);
+typedef bool(*di_txsuspendedidle_t) (hnddma_t *dmah);
+typedef int (*di_txfast_t) (hnddma_t *dmah, void *p, bool commit);
+typedef int (*di_txunframed_t) (hnddma_t *dmah, void *p, uint len,
 				bool commit);
-typedef void *(*di_getpos_t) (hnddma_t * di, bool direction);
-typedef void (*di_fifoloopbackenable_t) (hnddma_t * dmah);
-typedef bool(*di_txstopped_t) (hnddma_t * dmah);
-typedef bool(*di_rxstopped_t) (hnddma_t * dmah);
-typedef bool(*di_rxenable_t) (hnddma_t * dmah);
-typedef bool(*di_rxenabled_t) (hnddma_t * dmah);
-typedef void *(*di_rx_t) (hnddma_t * dmah);
-typedef bool(*di_rxfill_t) (hnddma_t * dmah);
-typedef void (*di_txreclaim_t) (hnddma_t * dmah, txd_range_t range);
-typedef void (*di_rxreclaim_t) (hnddma_t * dmah);
-typedef uintptr(*di_getvar_t) (hnddma_t * dmah, const char *name);
-typedef void *(*di_getnexttxp_t) (hnddma_t * dmah, txd_range_t range);
-typedef void *(*di_getnextrxp_t) (hnddma_t * dmah, bool forceall);
-typedef void *(*di_peeknexttxp_t) (hnddma_t * dmah);
-typedef void *(*di_peeknextrxp_t) (hnddma_t * dmah);
-typedef void (*di_rxparam_get_t) (hnddma_t * dmah, uint16 * rxoffset,
-				  uint16 * rxbufsize);
-typedef void (*di_txblock_t) (hnddma_t * dmah);
-typedef void (*di_txunblock_t) (hnddma_t * dmah);
-typedef uint(*di_txactive_t) (hnddma_t * dmah);
-typedef void (*di_txrotate_t) (hnddma_t * dmah);
-typedef void (*di_counterreset_t) (hnddma_t * dmah);
-typedef uint(*di_ctrlflags_t) (hnddma_t * dmah, uint mask, uint flags);
-typedef char *(*di_dump_t) (hnddma_t * dmah, struct bcmstrbuf * b,
+typedef void *(*di_getpos_t) (hnddma_t *di, bool direction);
+typedef void (*di_fifoloopbackenable_t) (hnddma_t *dmah);
+typedef bool(*di_txstopped_t) (hnddma_t *dmah);
+typedef bool(*di_rxstopped_t) (hnddma_t *dmah);
+typedef bool(*di_rxenable_t) (hnddma_t *dmah);
+typedef bool(*di_rxenabled_t) (hnddma_t *dmah);
+typedef void *(*di_rx_t) (hnddma_t *dmah);
+typedef bool(*di_rxfill_t) (hnddma_t *dmah);
+typedef void (*di_txreclaim_t) (hnddma_t *dmah, txd_range_t range);
+typedef void (*di_rxreclaim_t) (hnddma_t *dmah);
+typedef unsigned long (*di_getvar_t) (hnddma_t *dmah, const char *name);
+typedef void *(*di_getnexttxp_t) (hnddma_t *dmah, txd_range_t range);
+typedef void *(*di_getnextrxp_t) (hnddma_t *dmah, bool forceall);
+typedef void *(*di_peeknexttxp_t) (hnddma_t *dmah);
+typedef void *(*di_peeknextrxp_t) (hnddma_t *dmah);
+typedef void (*di_rxparam_get_t) (hnddma_t *dmah, u16 *rxoffset,
+				  u16 *rxbufsize);
+typedef void (*di_txblock_t) (hnddma_t *dmah);
+typedef void (*di_txunblock_t) (hnddma_t *dmah);
+typedef uint(*di_txactive_t) (hnddma_t *dmah);
+typedef void (*di_txrotate_t) (hnddma_t *dmah);
+typedef void (*di_counterreset_t) (hnddma_t *dmah);
+typedef uint(*di_ctrlflags_t) (hnddma_t *dmah, uint mask, uint flags);
+typedef char *(*di_dump_t) (hnddma_t *dmah, struct bcmstrbuf *b,
 			    bool dumpring);
-typedef char *(*di_dumptx_t) (hnddma_t * dmah, struct bcmstrbuf * b,
+typedef char *(*di_dumptx_t) (hnddma_t *dmah, struct bcmstrbuf *b,
 			      bool dumpring);
-typedef char *(*di_dumprx_t) (hnddma_t * dmah, struct bcmstrbuf * b,
+typedef char *(*di_dumprx_t) (hnddma_t *dmah, struct bcmstrbuf *b,
 			      bool dumpring);
-typedef uint(*di_rxactive_t) (hnddma_t * dmah);
-typedef uint(*di_txpending_t) (hnddma_t * dmah);
-typedef uint(*di_txcommitted_t) (hnddma_t * dmah);
+typedef uint(*di_rxactive_t) (hnddma_t *dmah);
+typedef uint(*di_txpending_t) (hnddma_t *dmah);
+typedef uint(*di_txcommitted_t) (hnddma_t *dmah);
 
 /* dma opsvec */
 typedef struct di_fcn_s {
@@ -141,10 +141,10 @@ struct hnddma_pub {
 	uint txnobuf;		/* tx out of dma descriptors */
 };
 
-extern hnddma_t *dma_attach(osl_t * osh, char *name, si_t * sih,
+extern hnddma_t *dma_attach(osl_t *osh, char *name, si_t *sih,
 			    void *dmaregstx, void *dmaregsrx, uint ntxd,
 			    uint nrxd, uint rxbufsize, int rxextheadroom,
-			    uint nrxpost, uint rxoffset, uint * msg_level);
+			    uint nrxpost, uint rxoffset, uint *msg_level);
 #ifdef BCMDMA32
 
 #define dma_detach(di)			((di)->di_fn->detach(di))
@@ -235,9 +235,9 @@ extern const di_fcn_t dma64proc;
  * SB attach provides ability to probe backplane and dma core capabilities
  * This info is needed by DMA_ALLOC_CONSISTENT in dma attach
  */
-extern uint dma_addrwidth(si_t * sih, void *dmaregs);
+extern uint dma_addrwidth(si_t *sih, void *dmaregs);
 
 /* pio helpers */
-extern void dma_txpioloopback(osl_t * osh, dma32regs_t *);
+extern void dma_txpioloopback(osl_t *osh, dma32regs_t *);
 
 #endif				/* _hnddma_h_ */
diff --git a/drivers/staging/brcm80211/include/hndpmu.h b/drivers/staging/brcm80211/include/hndpmu.h
index 57bf0c4..bbcf0ee 100644
--- a/drivers/staging/brcm80211/include/hndpmu.h
+++ b/drivers/staging/brcm80211/include/hndpmu.h
@@ -28,44 +28,44 @@
 #define SET_LDO_VOLTAGE_LNLDO1	9
 #define SET_LDO_VOLTAGE_LNLDO2_SEL	10
 
-extern void si_pmu_init(si_t * sih, osl_t * osh);
-extern void si_pmu_chip_init(si_t * sih, osl_t * osh);
-extern void si_pmu_pll_init(si_t * sih, osl_t * osh, uint32 xtalfreq);
-extern void si_pmu_res_init(si_t * sih, osl_t * osh);
-extern void si_pmu_swreg_init(si_t * sih, osl_t * osh);
+extern void si_pmu_init(si_t *sih, osl_t *osh);
+extern void si_pmu_chip_init(si_t *sih, osl_t *osh);
+extern void si_pmu_pll_init(si_t *sih, osl_t *osh, u32 xtalfreq);
+extern void si_pmu_res_init(si_t *sih, osl_t *osh);
+extern void si_pmu_swreg_init(si_t *sih, osl_t *osh);
 
-extern uint32 si_pmu_force_ilp(si_t * sih, osl_t * osh, bool force);
+extern u32 si_pmu_force_ilp(si_t *sih, osl_t *osh, bool force);
 
-extern uint32 si_pmu_si_clock(si_t * sih, osl_t * osh);
-extern uint32 si_pmu_cpu_clock(si_t * sih, osl_t * osh);
-extern uint32 si_pmu_mem_clock(si_t * sih, osl_t * osh);
-extern uint32 si_pmu_alp_clock(si_t * sih, osl_t * osh);
-extern uint32 si_pmu_ilp_clock(si_t * sih, osl_t * osh);
+extern u32 si_pmu_si_clock(si_t *sih, osl_t *osh);
+extern u32 si_pmu_cpu_clock(si_t *sih, osl_t *osh);
+extern u32 si_pmu_mem_clock(si_t *sih, osl_t *osh);
+extern u32 si_pmu_alp_clock(si_t *sih, osl_t *osh);
+extern u32 si_pmu_ilp_clock(si_t *sih, osl_t *osh);
 
-extern void si_pmu_set_switcher_voltage(si_t * sih, osl_t * osh,
-					uint8 bb_voltage, uint8 rf_voltage);
-extern void si_pmu_set_ldo_voltage(si_t * sih, osl_t * osh, uint8 ldo,
-				   uint8 voltage);
-extern uint16 si_pmu_fast_pwrup_delay(si_t * sih, osl_t * osh);
-extern void si_pmu_rcal(si_t * sih, osl_t * osh);
-extern void si_pmu_pllupd(si_t * sih);
-extern void si_pmu_spuravoid(si_t * sih, osl_t * osh, uint8 spuravoid);
+extern void si_pmu_set_switcher_voltage(si_t *sih, osl_t *osh,
+					u8 bb_voltage, u8 rf_voltage);
+extern void si_pmu_set_ldo_voltage(si_t *sih, osl_t *osh, u8 ldo,
+				   u8 voltage);
+extern u16 si_pmu_fast_pwrup_delay(si_t *sih, osl_t *osh);
+extern void si_pmu_rcal(si_t *sih, osl_t *osh);
+extern void si_pmu_pllupd(si_t *sih);
+extern void si_pmu_spuravoid(si_t *sih, osl_t *osh, u8 spuravoid);
 
-extern bool si_pmu_is_otp_powered(si_t * sih, osl_t * osh);
-extern uint32 si_pmu_measure_alpclk(si_t * sih, osl_t * osh);
+extern bool si_pmu_is_otp_powered(si_t *sih, osl_t *osh);
+extern u32 si_pmu_measure_alpclk(si_t *sih, osl_t *osh);
 
-extern uint32 si_pmu_chipcontrol(si_t * sih, uint reg, uint32 mask, uint32 val);
-extern uint32 si_pmu_regcontrol(si_t * sih, uint reg, uint32 mask, uint32 val);
-extern uint32 si_pmu_pllcontrol(si_t * sih, uint reg, uint32 mask, uint32 val);
-extern void si_pmu_pllupd(si_t * sih);
-extern void si_pmu_sprom_enable(si_t * sih, osl_t * osh, bool enable);
+extern u32 si_pmu_chipcontrol(si_t *sih, uint reg, u32 mask, u32 val);
+extern u32 si_pmu_regcontrol(si_t *sih, uint reg, u32 mask, u32 val);
+extern u32 si_pmu_pllcontrol(si_t *sih, uint reg, u32 mask, u32 val);
+extern void si_pmu_pllupd(si_t *sih);
+extern void si_pmu_sprom_enable(si_t *sih, osl_t *osh, bool enable);
 
-extern void si_pmu_radio_enable(si_t * sih, bool enable);
-extern uint32 si_pmu_waitforclk_on_backplane(si_t * sih, osl_t * osh,
-					     uint32 clk, uint32 delay);
+extern void si_pmu_radio_enable(si_t *sih, bool enable);
+extern u32 si_pmu_waitforclk_on_backplane(si_t *sih, osl_t *osh,
+					     u32 clk, u32 delay);
 
-extern void si_pmu_otp_power(si_t * sih, osl_t * osh, bool on);
-extern void si_sdiod_drive_strength_init(si_t * sih, osl_t * osh,
-					 uint32 drivestrength);
+extern void si_pmu_otp_power(si_t *sih, osl_t *osh, bool on);
+extern void si_sdiod_drive_strength_init(si_t *sih, osl_t *osh,
+					 u32 drivestrength);
 
 #endif				/* _hndpmu_h_ */
diff --git a/drivers/staging/brcm80211/include/hndrte_armtrap.h b/drivers/staging/brcm80211/include/hndrte_armtrap.h
new file mode 100644
index 0000000..28f092c
--- /dev/null
+++ b/drivers/staging/brcm80211/include/hndrte_armtrap.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_hndrte_armtrap_h
+#define	_hndrte_armtrap_h
+
+/* ARM trap handling */
+
+/* Trap types defined by ARM (see arminc.h) */
+
+/* Trap locations in lo memory */
+#define	TRAP_STRIDE	4
+#define FIRST_TRAP	TR_RST
+#define LAST_TRAP	(TR_FIQ * TRAP_STRIDE)
+
+#if defined(__ARM_ARCH_4T__)
+#define	MAX_TRAP_TYPE	(TR_FIQ + 1)
+#elif defined(__ARM_ARCH_7M__)
+#define	MAX_TRAP_TYPE	(TR_ISR + ARMCM3_NUMINTS)
+#endif				/* __ARM_ARCH_7M__ */
+
+/* The trap structure is defined here as offsets for assembly */
+#define	TR_TYPE		0x00
+#define	TR_EPC		0x04
+#define	TR_CPSR		0x08
+#define	TR_SPSR		0x0c
+#define	TR_REGS		0x10
+#define	TR_REG(n)	(TR_REGS + (n) * 4)
+#define	TR_SP		TR_REG(13)
+#define	TR_LR		TR_REG(14)
+#define	TR_PC		TR_REG(15)
+
+#define	TRAP_T_SIZE	80
+
+#ifndef	_LANGUAGE_ASSEMBLY
+
+typedef struct _trap_struct {
+	u32 type;
+	u32 epc;
+	u32 cpsr;
+	u32 spsr;
+	u32 r0;
+	u32 r1;
+	u32 r2;
+	u32 r3;
+	u32 r4;
+	u32 r5;
+	u32 r6;
+	u32 r7;
+	u32 r8;
+	u32 r9;
+	u32 r10;
+	u32 r11;
+	u32 r12;
+	u32 r13;
+	u32 r14;
+	u32 pc;
+} trap_t;
+
+#endif				/* !_LANGUAGE_ASSEMBLY */
+
+#endif				/* _hndrte_armtrap_h */
diff --git a/drivers/staging/brcm80211/include/hndrte_cons.h b/drivers/staging/brcm80211/include/hndrte_cons.h
new file mode 100644
index 0000000..5caa53f
--- /dev/null
+++ b/drivers/staging/brcm80211/include/hndrte_cons.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#define CBUF_LEN	(128)
+
+#define LOG_BUF_LEN	1024
+
+typedef struct {
+	u32 buf;		/* Can't be pointer on (64-bit) hosts */
+	uint buf_size;
+	uint idx;
+	char *_buf_compat;	/* Redundant pointer for backward compat. */
+} hndrte_log_t;
+
+typedef struct {
+	/* Virtual UART
+	 * When there is no UART (e.g. Quickturn),
+	 * the host should write a complete
+	 * input line directly into cbuf and then write
+	 * the length into vcons_in.
+	 * This may also be used when there is a real UART
+	 * (at risk of conflicting with
+	 * the real UART).  vcons_out is currently unused.
+	 */
+	volatile uint vcons_in;
+	volatile uint vcons_out;
+
+	/* Output (logging) buffer
+	 * Console output is written to a ring buffer log_buf at index log_idx.
+	 * The host may read the output when it sees log_idx advance.
+	 * Output will be lost if the output wraps around faster than the host
+	 * polls.
+	 */
+	hndrte_log_t log;
+
+	/* Console input line buffer
+	 * Characters are read one at a time into cbuf
+	 * until <CR> is received, then
+	 * the buffer is processed as a command line.
+	 * Also used for virtual UART.
+	 */
+	uint cbuf_idx;
+	char cbuf[CBUF_LEN];
+} hndrte_cons_t;
diff --git a/drivers/staging/brcm80211/include/hndtcam.h b/drivers/staging/brcm80211/include/hndtcam.h
deleted file mode 100644
index 575456e..0000000
--- a/drivers/staging/brcm80211/include/hndtcam.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (c) 2010 Broadcom Corporation
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#ifndef _hndtcam_h_
-#define _hndtcam_h_
-
-/*
- * 0 - 1
- * 1 - 2 Consecutive locations are patched
- * 2 - 4 Consecutive locations are patched
- * 3 - 8 Consecutive locations are patched
- * 4 - 16 Consecutive locations are patched
- * Define default to patch 2 locations
- */
-
-#define PATCHCOUNT 0
-#define SRPC_PATCHCOUNT PATCHCOUNT
-
-/* N Consecutive location to patch */
-#define SRPC_PATCHNLOC (1 << (SRPC_PATCHCOUNT))
-
-/* patch values and address structure */
-typedef struct patchaddrvalue {
-	uint32 addr;
-	uint32 value;
-} patchaddrvalue_t;
-
-extern void hnd_patch_init(void *srp);
-extern void hnd_tcam_write(void *srp, uint16 index, uint32 data);
-extern void hnd_tcam_read(void *srp, uint16 index, uint32 * content);
-void *hnd_tcam_init(void *srp, uint no_addrs);
-extern void hnd_tcam_disablepatch(void *srp);
-extern void hnd_tcam_enablepatch(void *srp);
-extern void hnd_tcam_load(void *srp, const patchaddrvalue_t * patchtbl);
-#endif				/* _hndtcam_h_ */
diff --git a/drivers/staging/brcm80211/include/linux_osl.h b/drivers/staging/brcm80211/include/linux_osl.h
index bec6616..c9c860b 100644
--- a/drivers/staging/brcm80211/include/linux_osl.h
+++ b/drivers/staging/brcm80211/include/linux_osl.h
@@ -17,7 +17,6 @@
 #ifndef _linux_osl_h_
 #define _linux_osl_h_
 
-#include <typedefs.h>
 
 /* Linux Kernel: File Operations: start */
 extern void *osl_os_open_image(char *filename);
@@ -26,9 +25,9 @@ extern void osl_os_close_image(void *image);
 /* Linux Kernel: File Operations: end */
 
 extern osl_t *osl_attach(void *pdev, uint bustype, bool pkttag);
-extern void osl_detach(osl_t * osh);
+extern void osl_detach(osl_t *osh);
 
-extern uint32 g_assert_type;
+extern u32 g_assert_type;
 
 #if defined(BCMDBG_ASSERT)
 #define ASSERT(exp) \
@@ -47,30 +46,19 @@ extern void osl_assert(char *exp, char *file, int line);
 #endif				/* __GNUC__ */
 #endif				/* defined(BCMDBG_ASSERT) */
 
-#define	OSL_DELAY(usec)		osl_delay(usec)
-extern void osl_delay(uint usec);
-
-#define	OSL_PCMCIA_READ_ATTR(osh, offset, buf, size) \
-	osl_pcmcia_read_attr((osh), (offset), (buf), (size))
-#define	OSL_PCMCIA_WRITE_ATTR(osh, offset, buf, size) \
-	osl_pcmcia_write_attr((osh), (offset), (buf), (size))
-extern void osl_pcmcia_read_attr(osl_t * osh, uint offset, void *buf, int size);
-extern void osl_pcmcia_write_attr(osl_t * osh, uint offset, void *buf,
-				  int size);
-
 /* PCI configuration space access macros */
 #define	OSL_PCI_READ_CONFIG(osh, offset, size) \
 	osl_pci_read_config((osh), (offset), (size))
 #define	OSL_PCI_WRITE_CONFIG(osh, offset, size, val) \
 	osl_pci_write_config((osh), (offset), (size), (val))
-extern uint32 osl_pci_read_config(osl_t * osh, uint offset, uint size);
-extern void osl_pci_write_config(osl_t * osh, uint offset, uint size, uint val);
+extern u32 osl_pci_read_config(osl_t *osh, uint offset, uint size);
+extern void osl_pci_write_config(osl_t *osh, uint offset, uint size, uint val);
 
 /* PCI device bus # and slot # */
 #define OSL_PCI_BUS(osh)	osl_pci_bus(osh)
 #define OSL_PCI_SLOT(osh)	osl_pci_slot(osh)
-extern uint osl_pci_bus(osl_t * osh);
-extern uint osl_pci_slot(osl_t * osh);
+extern uint osl_pci_bus(osl_t *osh);
+extern uint osl_pci_slot(osl_t *osh);
 
 /* Pkttag flag should be part of public information */
 typedef struct {
@@ -79,7 +67,7 @@ typedef struct {
 	bool mmbus;		/* Bus supports memory-mapped register accesses */
 	pktfree_cb_fn_t tx_fn;	/* Callback function for PKTFREE */
 	void *tx_ctx;		/* Context to the callback function */
-#ifdef BCMSDIO
+#if defined(BCMSDIO) && !defined(BRCM_FULLMAC)
 	osl_rreg_fn_t rreg_fn;	/* Read Register function */
 	osl_wreg_fn_t wreg_fn;	/* Write Register function */
 	void *reg_ctx;		/* Context to the reg callback functions */
@@ -88,43 +76,37 @@ typedef struct {
 
 #define PKTFREESETCB(osh, _tx_fn, _tx_ctx)			\
 	do {							\
-		((osl_pubinfo_t*)osh)->tx_fn = _tx_fn;		\
-		((osl_pubinfo_t*)osh)->tx_ctx = _tx_ctx;	\
+		((osl_pubinfo_t *)osh)->tx_fn = _tx_fn;		\
+		((osl_pubinfo_t *)osh)->tx_ctx = _tx_ctx;	\
 	} while (0)
 
-#ifdef BCMSDIO
+#if defined(BCMSDIO) && !defined(BRCM_FULLMAC)
 #define REGOPSSET(osh, rreg, wreg, ctx)			\
 	do {						\
-		((osl_pubinfo_t*)osh)->rreg_fn = rreg;	\
-		((osl_pubinfo_t*)osh)->wreg_fn = wreg;	\
-		((osl_pubinfo_t*)osh)->reg_ctx = ctx;	\
+		((osl_pubinfo_t *)osh)->rreg_fn = rreg;	\
+		((osl_pubinfo_t *)osh)->wreg_fn = wreg;	\
+		((osl_pubinfo_t *)osh)->reg_ctx = ctx;	\
 	} while (0)
 #endif
 
 #define BUS_SWAP32(v)		(v)
 
-#define MALLOC(osh, size)	osl_malloc((osh), (size))
-#define MFREE(osh, addr, size)	osl_mfree((osh), (addr), (size))
-#define MALLOCED(osh)		osl_malloced((osh))
-extern void *osl_malloc(osl_t * osh, uint size);
-extern void osl_mfree(osl_t * osh, void *addr, uint size);
-extern uint osl_malloced(osl_t * osh);
-
-#define NATIVE_MALLOC(osh, size)	kmalloc(size, GFP_ATOMIC)
-#define NATIVE_MFREE(osh, addr, size)	kfree(addr)
-#define	MALLOC_FAILED(osh)		osl_malloc_failed((osh))
-extern uint osl_malloc_failed(osl_t * osh);
-
-/* allocate/free shared (dma-able) consistent memory */
 #define	DMA_CONSISTENT_ALIGN	osl_dma_consistent_align()
+extern uint osl_dma_consistent_align(void);
+extern void *osl_dma_alloc_consistent(osl_t *osh, uint size, u16 align,
+				      uint *tot, unsigned long *pap);
+
+#ifdef BRCM_FULLMAC
+#define	DMA_ALLOC_CONSISTENT(osh, size, pap, dmah, alignbits) \
+	osl_dma_alloc_consistent((osh), (size), (0), (tot), (pap))
+#else
 #define	DMA_ALLOC_CONSISTENT(osh, size, align, tot, pap, dmah) \
 	osl_dma_alloc_consistent((osh), (size), (align), (tot), (pap))
+#endif /* BRCM_FULLMAC */
+
 #define	DMA_FREE_CONSISTENT(osh, va, size, pa, dmah) \
-	osl_dma_free_consistent((osh), (void*)(va), (size), (pa))
-extern uint osl_dma_consistent_align(void);
-extern void *osl_dma_alloc_consistent(osl_t * osh, uint size, uint16 align,
-				      uint * tot, ulong * pap);
-extern void osl_dma_free_consistent(osl_t * osh, void *va, uint size, ulong pa);
+	osl_dma_free_consistent((osh), (void *)(va), (size), (pa))
+extern void osl_dma_free_consistent(osl_t *osh, void *va, uint size, unsigned long pa);
 
 /* map/unmap direction */
 #define	DMA_TX	1		/* TX direction for DMA */
@@ -135,23 +117,25 @@ extern void osl_dma_free_consistent(osl_t * osh, void *va, uint size, ulong pa);
 	osl_dma_map((osh), (va), (size), (direction))
 #define	DMA_UNMAP(osh, pa, size, direction, p, dmah) \
 	osl_dma_unmap((osh), (pa), (size), (direction))
-extern uint osl_dma_map(osl_t * osh, void *va, uint size, int direction);
-extern void osl_dma_unmap(osl_t * osh, uint pa, uint size, int direction);
+extern uint osl_dma_map(osl_t *osh, void *va, uint size, int direction);
+extern void osl_dma_unmap(osl_t *osh, uint pa, uint size, int direction);
 
 /* API for DMA addressing capability */
 #define OSL_DMADDRWIDTH(osh, addrwidth) do {} while (0)
 
 /* register access macros */
 #if defined(BCMSDIO)
+#ifdef BRCM_FULLMAC
 #include <bcmsdh.h>
-#define OSL_WRITE_REG(osh, r, v) (bcmsdh_reg_write(NULL, (uintptr)(r), sizeof(*(r)), (v)))
-#define OSL_READ_REG(osh, r) (bcmsdh_reg_read(NULL, (uintptr)(r), sizeof(*(r))))
+#endif
+#define OSL_WRITE_REG(osh, r, v) (bcmsdh_reg_write(NULL, (unsigned long)(r), sizeof(*(r)), (v)))
+#define OSL_READ_REG(osh, r) (bcmsdh_reg_read(NULL, (unsigned long)(r), sizeof(*(r))))
 #endif
 
 #if defined(BCMSDIO)
-#define SELECT_BUS_WRITE(osh, mmap_op, bus_op) if (((osl_pubinfo_t*)(osh))->mmbus) \
+#define SELECT_BUS_WRITE(osh, mmap_op, bus_op) if (((osl_pubinfo_t *)(osh))->mmbus) \
 		mmap_op else bus_op
-#define SELECT_BUS_READ(osh, mmap_op, bus_op) (((osl_pubinfo_t*)(osh))->mmbus) ? \
+#define SELECT_BUS_READ(osh, mmap_op, bus_op) (((osl_pubinfo_t *)(osh))->mmbus) ? \
 		mmap_op : bus_op
 #else
 #define SELECT_BUS_WRITE(osh, mmap_op, bus_op) mmap_op
@@ -164,10 +148,12 @@ extern int osl_error(int bcmerror);
 /* the largest reasonable packet buffer driver uses for ethernet MTU in bytes */
 #define	PKTBUFSZ	2048	/* largest reasonable packet buffer, driver uses for ethernet MTU */
 
-#define OSL_SYSUPTIME()		((uint32)jiffies * (1000 / HZ))
+#define OSL_SYSUPTIME()		((u32)jiffies * (1000 / HZ))
 #define	printf(fmt, args...)	printk(fmt , ## args)
+#ifdef BRCM_FULLMAC
 #include <linux/kernel.h>	/* for vsn/printf's */
 #include <linux/string.h>	/* for mem*, str* */
+#endif
 /* bcopy's: Linux kernel doesn't provide these (anymore) */
 #define	bcopy(src, dst, len)	memcpy((dst), (src), (len))
 #define	bcmp(b1, b2, len)	memcmp((b1), (b2), (len))
@@ -179,9 +165,9 @@ extern int osl_error(int bcmerror);
 #ifndef IL_BIGENDIAN
 #ifndef __mips__
 #define R_REG(osh, r) (\
-	SELECT_BUS_READ(osh, sizeof(*(r)) == sizeof(uint8) ? readb((volatile uint8*)(r)) : \
-	sizeof(*(r)) == sizeof(uint16) ? readw((volatile uint16*)(r)) : \
-	readl((volatile uint32*)(r)), OSL_READ_REG(osh, r)) \
+	SELECT_BUS_READ(osh, sizeof(*(r)) == sizeof(u8) ? readb((volatile u8*)(r)) : \
+	sizeof(*(r)) == sizeof(u16) ? readw((volatile u16*)(r)) : \
+	readl((volatile u32*)(r)), OSL_READ_REG(osh, r)) \
 )
 #else				/* __mips__ */
 #define R_REG(osh, r) (\
@@ -190,12 +176,16 @@ extern int osl_error(int bcmerror);
 			__typeof(*(r)) __osl_v; \
 			__asm__ __volatile__("sync"); \
 			switch (sizeof(*(r))) { \
-			case sizeof(uint8):	__osl_v = \
-				readb((volatile uint8*)(r)); break; \
-			case sizeof(uint16):	__osl_v = \
-				readw((volatile uint16*)(r)); break; \
-			case sizeof(uint32):	__osl_v = \
-				readl((volatile uint32*)(r)); break; \
+			case sizeof(u8): \
+				__osl_v = readb((volatile u8*)(r)); \
+				break; \
+			case sizeof(u16): \
+				__osl_v = readw((volatile u16*)(r)); \
+				break; \
+			case sizeof(u32): \
+				__osl_v = \
+				readl((volatile u32*)(r)); \
+				break; \
 			} \
 			__asm__ __volatile__("sync"); \
 			__osl_v; \
@@ -213,12 +203,12 @@ extern int osl_error(int bcmerror);
 #define W_REG(osh, r, v) do { \
 	SELECT_BUS_WRITE(osh,  \
 		switch (sizeof(*(r))) { \
-		case sizeof(uint8): \
-			writeb((uint8)(v), (volatile uint8*)(r)); break; \
-		case sizeof(uint16): \
-			writew((uint16)(v), (volatile uint16*)(r)); break; \
-		case sizeof(uint32): \
-			writel((uint32)(v), (volatile uint32*)(r)); break; \
+		case sizeof(u8): \
+			writeb((u8)(v), (volatile u8*)(r)); break; \
+		case sizeof(u16): \
+			writew((u16)(v), (volatile u16*)(r)); break; \
+		case sizeof(u32): \
+			writel((u32)(v), (volatile u32*)(r)); break; \
 		}, \
 		(OSL_WRITE_REG(osh, r, v))); \
 	} while (0)
@@ -228,12 +218,17 @@ extern int osl_error(int bcmerror);
 		({ \
 			__typeof(*(r)) __osl_v; \
 			switch (sizeof(*(r))) { \
-			case sizeof(uint8):	__osl_v = \
-				readb((volatile uint8*)((uintptr)(r)^3)); break; \
-			case sizeof(uint16):	__osl_v = \
-				readw((volatile uint16*)((uintptr)(r)^2)); break; \
-			case sizeof(uint32):	__osl_v = \
-				readl((volatile uint32*)(r)); break; \
+			case sizeof(u8): \
+				__osl_v = \
+				readb((volatile u8*)((r)^3)); \
+				break; \
+			case sizeof(u16): \
+				__osl_v = \
+				readw((volatile u16*)((r)^2)); \
+				break; \
+			case sizeof(u32): \
+				__osl_v = readl((volatile u32*)(r)); \
+				break; \
 			} \
 			__osl_v; \
 		}), \
@@ -242,15 +237,15 @@ extern int osl_error(int bcmerror);
 #define W_REG(osh, r, v) do { \
 	SELECT_BUS_WRITE(osh,  \
 		switch (sizeof(*(r))) { \
-		case sizeof(uint8):	\
-			writeb((uint8)(v), \
-			(volatile uint8*)((uintptr)(r)^3)); break; \
-		case sizeof(uint16):	\
-			writew((uint16)(v), \
-			(volatile uint16*)((uintptr)(r)^2)); break; \
-		case sizeof(uint32):	\
-			writel((uint32)(v), \
-			(volatile uint32*)(r)); break; \
+		case sizeof(u8):	\
+			writeb((u8)(v), \
+			(volatile u8*)((r)^3)); break; \
+		case sizeof(u16):	\
+			writew((u16)(v), \
+			(volatile u16*)((r)^2)); break; \
+		case sizeof(u32):	\
+			writel((u32)(v), \
+			(volatile u32*)(r)); break; \
 		}, \
 		(OSL_WRITE_REG(osh, r, v))); \
 	} while (0)
@@ -300,71 +295,113 @@ extern int osl_error(int bcmerror);
 #endif				/* !defined(CONFIG_MMC_MSM7X00A */
 #define	REG_UNMAP(va)		iounmap((va))
 
-#define	R_SM(r)			*(r)
+#define	R_SM(r)			(*(r))
 #define	W_SM(r, v)		(*(r) = (v))
 #define	BZERO_SM(r, len)	memset((r), '\0', (len))
 
+#ifdef BRCM_FULLMAC
 #include <linuxver.h>		/* use current 2.4.x calling conventions */
+#endif
 
 /* packet primitives */
 #define	PKTGET(osh, len, send)		osl_pktget((osh), (len))
-#define	PKTDUP(osh, skb)		osl_pktdup((osh), (skb))
 #define	PKTFREE(osh, skb, send)		osl_pktfree((osh), (skb), (send))
-#define	PKTDATA(skb)			(((struct sk_buff*)(skb))->data)
-#define	PKTLEN(skb)			(((struct sk_buff*)(skb))->len)
-#define PKTHEADROOM(skb)		(PKTDATA(skb)-(((struct sk_buff*)(skb))->head))
-#define PKTTAILROOM(skb) ((((struct sk_buff*)(skb))->end)-(((struct sk_buff*)(skb))->tail))
-#define	PKTNEXT(skb)			(((struct sk_buff*)(skb))->next)
-#define	PKTSETNEXT(skb, x)		(((struct sk_buff*)(skb))->next = (struct sk_buff*)(x))
-#define	PKTSETLEN(skb, len)		__skb_trim((struct sk_buff*)(skb), (len))
-#define	PKTPUSH(skb, bytes)		skb_push((struct sk_buff*)(skb), (bytes))
-#define	PKTPULL(skb, bytes)		skb_pull((struct sk_buff*)(skb), (bytes))
-#define	PKTTAG(skb)			((void*)(((struct sk_buff*)(skb))->cb))
-#define PKTALLOCED(osh)			((osl_pubinfo_t *)(osh))->pktalloced
+#define	PKTDATA(skb)		(((struct sk_buff *)(skb))->data)
+#define	PKTLEN(skb)		(((struct sk_buff *)(skb))->len)
+#define PKTHEADROOM(skb)		(PKTDATA(skb)-(((struct sk_buff *)(skb))->head))
+#define PKTTAILROOM(skb) ((((struct sk_buff *)(skb))->end)-(((struct sk_buff *)(skb))->tail))
+#define	PKTNEXT(skb)		(((struct sk_buff *)(skb))->next)
+#define	PKTSETNEXT(skb, x)	\
+	(((struct sk_buff *)(skb))->next = (struct sk_buff *)(x))
+#define	PKTSETLEN(skb, len)	__skb_trim((struct sk_buff *)(skb), (len))
+#define	PKTPUSH(skb, bytes)	skb_push((struct sk_buff *)(skb), (bytes))
+#define	PKTPULL(skb, bytes)	skb_pull((struct sk_buff *)(skb), (bytes))
+#define	PKTTAG(skb)		((void *)(((struct sk_buff *)(skb))->cb))
+#define PKTALLOCED(osh)		(((osl_pubinfo_t *)(osh))->pktalloced)
 #define PKTSETPOOL(osh, skb, x, y)	do {} while (0)
-#define PKTPOOL(osh, skb)		FALSE
+#define PKTPOOL(osh, skb)		false
+extern void *osl_pktget(osl_t *osh, uint len);
+extern void osl_pktfree(osl_t *osh, void *skb, bool send);
 
-#define PKTUNALLOC(osh)			((osl_pubinfo_t *)(osh))->pktalloced--
+#ifdef BRCM_FULLMAC
+extern void *osl_pktget_static(osl_t *osh, uint len);
+extern void osl_pktfree_static(osl_t *osh, void *skb, bool send);
 
-#define	PKTSETSKIPCT(osh, skb)
-#define	PKTCLRSKIPCT(osh, skb)
-#define	PKTSKIPCT(osh, skb)
+static inline void *
+osl_pkt_frmnative(osl_pubinfo_t *osh, struct sk_buff *skb)
+{
+	struct sk_buff *nskb;
+
+	if (osh->pkttag)
+		bzero((void *)skb->cb, OSL_PKTTAG_SZ);
+
+	for (nskb = skb; nskb; nskb = nskb->next)
+		osh->pktalloced++;
+
+	return (void *)skb;
+}
+#define PKTFRMNATIVE(osh, skb)	\
+	osl_pkt_frmnative(((osl_pubinfo_t *)osh), (struct sk_buff*)(skb))
 
-extern void osl_pktfree(osl_t * osh, void *skb, bool send);
+static inline struct sk_buff *
+osl_pkt_tonative(osl_pubinfo_t *osh, void *pkt)
+{
+	struct sk_buff *nskb;
 
-extern void *osl_pktget(osl_t * osh, uint len);
-extern void *osl_pktdup(osl_t * osh, void *skb);
+	if (osh->pkttag)
+		bzero(((struct sk_buff *)pkt)->cb, OSL_PKTTAG_SZ);
 
-#define	PKTLINK(skb)			(((struct sk_buff*)(skb))->prev)
-#define	PKTSETLINK(skb, x)		(((struct sk_buff*)(skb))->prev = (struct sk_buff*)(x))
-#define	PKTPRIO(skb)			(((struct sk_buff*)(skb))->priority)
-#define	PKTSETPRIO(skb, x)		(((struct sk_buff*)(skb))->priority = (x))
-#define PKTSUMNEEDED(skb)		(((struct sk_buff*)(skb))->ip_summed == CHECKSUM_HW)
-#define PKTSETSUMGOOD(skb, x)		(((struct sk_buff*)(skb))->ip_summed = \
+	for (nskb = (struct sk_buff *)pkt; nskb; nskb = nskb->next)
+		osh->pktalloced--;
+
+	return (struct sk_buff *)pkt;
+}
+#define PKTTONATIVE(osh, pkt)	\
+	osl_pkt_tonative((osl_pubinfo_t *)(osh), (pkt))
+#else /* !BRCM_FULLMAC */
+#define PKTUNALLOC(osh)			(((osl_pubinfo_t *)(osh))->pktalloced--)
+
+#define	PKTSETSKIPCT(osh, skb)
+#define	PKTCLRSKIPCT(osh, skb)
+#define	PKTSKIPCT(osh, skb)
+#endif	/* BRCM_FULLMAC */
+
+#define	PKTLINK(skb)			(((struct sk_buff *)(skb))->prev)
+#define	PKTSETLINK(skb, x)		(((struct sk_buff *)(skb))->prev = (struct sk_buff*)(x))
+#define	PKTPRIO(skb)			(((struct sk_buff *)(skb))->priority)
+#define	PKTSETPRIO(skb, x)		(((struct sk_buff *)(skb))->priority = (x))
+#define PKTSUMNEEDED(skb)		(((struct sk_buff *)(skb))->ip_summed == CHECKSUM_PARTIAL)
+#define PKTSETSUMGOOD(skb, x)		(((struct sk_buff *)(skb))->ip_summed = \
 						((x) ? CHECKSUM_UNNECESSARY : CHECKSUM_NONE))
 /* PKTSETSUMNEEDED and PKTSUMGOOD are not possible because skb->ip_summed is overloaded */
-#define PKTSHARED(skb)                  (((struct sk_buff*)(skb))->cloned)
+#define PKTSHARED(skb)                  (((struct sk_buff *)(skb))->cloned)
 
-#ifdef BCMSDIO
+#if defined(BCMSDIO) && !defined(BRCM_FULLMAC)
 #define RPC_READ_REG(osh, r) (\
-	sizeof(*(r)) == sizeof(uint8) ? osl_readb((osh), (volatile uint8*)(r)) : \
-	sizeof(*(r)) == sizeof(uint16) ? osl_readw((osh), (volatile uint16*)(r)) : \
-	osl_readl((osh), (volatile uint32*)(r)) \
+	sizeof(*(r)) == sizeof(u8) ? osl_readb((osh), (volatile u8*)(r)) : \
+	sizeof(*(r)) == sizeof(u16) ? osl_readw((osh), (volatile u16*)(r)) : \
+	osl_readl((osh), (volatile u32*)(r)) \
 )
 #define RPC_WRITE_REG(osh, r, v) do { \
 	switch (sizeof(*(r))) { \
-	case sizeof(uint8):	osl_writeb((osh), (volatile uint8*)(r), (uint8)(v)); break; \
-	case sizeof(uint16):	osl_writew((osh), (volatile uint16*)(r), (uint16)(v)); break; \
-	case sizeof(uint32):	osl_writel((osh), (volatile uint32*)(r), (uint32)(v)); break; \
+	case sizeof(u8): \
+		osl_writeb((osh), (volatile u8*)(r), (u8)(v)); \
+		break; \
+	case sizeof(u16): \
+		osl_writew((osh), (volatile u16*)(r), (u16)(v)); \
+		break; \
+	case sizeof(u32): \
+		osl_writel((osh), (volatile u32*)(r), (u32)(v)); \
+		break; \
 	} \
 } while (0)
 
-extern uint8 osl_readb(osl_t * osh, volatile uint8 * r);
-extern uint16 osl_readw(osl_t * osh, volatile uint16 * r);
-extern uint32 osl_readl(osl_t * osh, volatile uint32 * r);
-extern void osl_writeb(osl_t * osh, volatile uint8 * r, uint8 v);
-extern void osl_writew(osl_t * osh, volatile uint16 * r, uint16 v);
-extern void osl_writel(osl_t * osh, volatile uint32 * r, uint32 v);
+extern u8 osl_readb(osl_t *osh, volatile u8 *r);
+extern u16 osl_readw(osl_t *osh, volatile u16 *r);
+extern u32 osl_readl(osl_t *osh, volatile u32 *r);
+extern void osl_writeb(osl_t *osh, volatile u8 *r, u8 v);
+extern void osl_writew(osl_t *osh, volatile u16 *r, u16 v);
+extern void osl_writel(osl_t *osh, volatile u32 *r, u32 v);
 #endif				/* BCMSDIO */
 
 #endif				/* _linux_osl_h_ */
diff --git a/drivers/staging/brcm80211/include/linuxver.h b/drivers/staging/brcm80211/include/linuxver.h
index 740c3fa..dc72141 100644
--- a/drivers/staging/brcm80211/include/linuxver.h
+++ b/drivers/staging/brcm80211/include/linuxver.h
@@ -17,11 +17,8 @@
 #ifndef _linuxver_h_
 #define _linuxver_h_
 
-#include <linux/version.h>
 #include <linux/module.h>
-
 #include <linux/slab.h>
-
 #include <linux/types.h>
 #include <linux/init.h>
 #include <linux/mm.h>
@@ -29,80 +26,13 @@
 #include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/netdevice.h>
-#undef IP_TOS
-#include <asm/io.h>
-
 #include <linux/workqueue.h>
-
-#define	MY_INIT_WORK(_work, _func)	INIT_WORK(_work, _func)
-
-typedef irqreturn_t(*FN_ISR) (int irq, void *dev_id, struct pt_regs * ptregs);
-
 #include <linux/sched.h>
 #include <linux/ieee80211.h>
-
-#ifndef __exit
-#define __exit
-#endif
-#ifndef __devexit
-#define __devexit
-#endif
-#ifndef __devinit
-#define __devinit	__init
-#endif
-#ifndef __devinitdata
-#define __devinitdata
-#endif
-#ifndef __devexit_p
-#define __devexit_p(x)	x
-#endif
-
-#define pci_module_init pci_register_driver
-
-#define netif_down(dev)
-
-/* Power management related macro & routines */
-#define	PCI_SAVE_STATE(a, b)	pci_save_state(a)
-#define	PCI_RESTORE_STATE(a, b)	pci_restore_state(a)
-
-/* Module refcount handled internally in 2.6.x */
-#ifndef SET_MODULE_OWNER
-#define SET_MODULE_OWNER(dev)		do {} while (0)
-#endif
-#ifndef MOD_INC_USE_COUNT
-#define MOD_INC_USE_COUNT			do {} while (0)
-#endif
-#ifndef MOD_DEC_USE_COUNT
-#define MOD_DEC_USE_COUNT			do {} while (0)
-#endif
-#define OLD_MOD_INC_USE_COUNT		MOD_INC_USE_COUNT
-#define OLD_MOD_DEC_USE_COUNT		MOD_DEC_USE_COUNT
-
-#ifndef SET_NETDEV_DEV
-#define SET_NETDEV_DEV(net, pdev)	do {} while (0)
-#endif
-
-#ifndef HAVE_FREE_NETDEV
-#define free_netdev(dev)		kfree(dev)
-#endif
-
-/* suspend args */
-#define DRV_SUSPEND_STATE_TYPE pm_message_t
-
-#define CHECKSUM_HW	CHECKSUM_PARTIAL
-
 #include <linux/time.h>
 #include <linux/wait.h>
 
-#define KILL_PROC(nr, sig) \
-	do { \
-		struct task_struct *tsk; \
-		struct pid *pid;    \
-		pid = find_get_pid((pid_t)nr);    \
-		tsk = pid_task(pid, PIDTYPE_PID);    \
-		if (tsk) send_sig(sig, tsk, 1); \
-	} while (0)
-
-#define WL_DEV_IF(dev)          ((wl_if_t*)netdev_priv(dev))
+#undef IP_TOS
+#include <asm/io.h>
 
 #endif				/* _linuxver_h_ */
diff --git a/drivers/staging/brcm80211/include/msgtrace.h b/drivers/staging/brcm80211/include/msgtrace.h
new file mode 100644
index 0000000..9d9e53d
--- /dev/null
+++ b/drivers/staging/brcm80211/include/msgtrace.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_MSGTRACE_H
+#define	_MSGTRACE_H
+
+/* This marks the start of a packed structure section. */
+#include <packed_section_start.h>
+
+#define MSGTRACE_VERSION 1
+
+/* Message trace header */
+typedef BWL_PRE_PACKED_STRUCT struct msgtrace_hdr {
+	u8 version;
+	u8 spare;
+	u16 len;		/* Len of the trace */
+	u32 seqnum;		/* Sequence number of message. Useful
+				 * if the messsage has been lost
+				 * because of DMA error or a bus reset
+				 * (ex: SDIO Func2)
+				 */
+	u32 discarded_bytes;	/* Number of discarded bytes because of
+				 trace overflow  */
+	u32 discarded_printf;	/* Number of discarded printf
+				 because of trace overflow */
+} BWL_POST_PACKED_STRUCT msgtrace_hdr_t;
+
+#define MSGTRACE_HDRLEN		sizeof(msgtrace_hdr_t)
+
+/* The hbus driver generates traces when sending a trace message.
+ * This causes endless traces.
+ * This flag must be set to true in any hbus traces.
+ * The flag is reset in the function msgtrace_put.
+ * This prevents endless traces but generates hasardous
+ * lost of traces only in bus device code.
+ * It is recommendat to set this flag in macro SD_TRACE
+ * but not in SD_ERROR for avoiding missing
+ * hbus error traces. hbus error trace should not generates endless traces.
+ */
+extern bool msgtrace_hbus_trace;
+
+typedef void (*msgtrace_func_send_t) (void *hdl1, void *hdl2, u8 *hdr,
+				      u16 hdrlen, u8 *buf,
+				      u16 buflen);
+
+extern void msgtrace_sent(void);
+extern void msgtrace_put(char *buf, int count);
+extern void msgtrace_init(void *hdl1, void *hdl2,
+			  msgtrace_func_send_t func_send);
+
+/* This marks the end of a packed structure section. */
+#include <packed_section_end.h>
+
+#endif				/* _MSGTRACE_H */
diff --git a/drivers/staging/brcm80211/include/nicpci.h b/drivers/staging/brcm80211/include/nicpci.h
index 1623c57..ce146e8 100644
--- a/drivers/staging/brcm80211/include/nicpci.h
+++ b/drivers/staging/brcm80211/include/nicpci.h
@@ -38,24 +38,24 @@
 #define pcicore_pcieserdesreg(a, b, c, d, e) (0)
 #define pcicore_pciereg(a, b, c, d, e) (0)
 
-#define pcicore_pmecap_fast(a)	(FALSE)
+#define pcicore_pmecap_fast(a)	(false)
 #define pcicore_pmeen(a)	do { } while (0)
 #define pcicore_pmeclr(a)	do { } while (0)
-#define pcicore_pmestat(a)	(FALSE)
+#define pcicore_pmestat(a)	(false)
 #else
 struct sbpcieregs;
 
-extern uint8 pcicore_find_pci_capability(osl_t * osh, uint8 req_cap_id,
-					 uchar * buf, uint32 * buflen);
-extern uint pcie_readreg(osl_t * osh, struct sbpcieregs *pcieregs,
+extern u8 pcicore_find_pci_capability(osl_t *osh, u8 req_cap_id,
+					 unsigned char *buf, u32 *buflen);
+extern uint pcie_readreg(osl_t *osh, struct sbpcieregs *pcieregs,
 			 uint addrtype, uint offset);
-extern uint pcie_writereg(osl_t * osh, struct sbpcieregs *pcieregs,
+extern uint pcie_writereg(osl_t *osh, struct sbpcieregs *pcieregs,
 			  uint addrtype, uint offset, uint val);
 
-extern uint8 pcie_clkreq(void *pch, uint32 mask, uint32 val);
-extern uint32 pcie_lcreg(void *pch, uint32 mask, uint32 val);
+extern u8 pcie_clkreq(void *pch, u32 mask, u32 val);
+extern u32 pcie_lcreg(void *pch, u32 mask, u32 val);
 
-extern void *pcicore_init(si_t * sih, osl_t * osh, void *regs);
+extern void *pcicore_init(si_t *sih, osl_t *osh, void *regs);
 extern void pcicore_deinit(void *pch);
 extern void pcicore_attach(void *pch, char *pvars, int state);
 extern void pcicore_hwup(void *pch);
@@ -63,14 +63,14 @@ extern void pcicore_up(void *pch, int state);
 extern void pcicore_sleep(void *pch);
 extern void pcicore_down(void *pch, int state);
 
-extern void pcie_war_ovr_aspm_update(void *pch, uint8 aspm);
-extern uint32 pcicore_pcieserdesreg(void *pch, uint32 mdioslave, uint32 offset,
-				    uint32 mask, uint32 val);
+extern void pcie_war_ovr_aspm_update(void *pch, u8 aspm);
+extern u32 pcicore_pcieserdesreg(void *pch, u32 mdioslave, u32 offset,
+				    u32 mask, u32 val);
 
-extern uint32 pcicore_pciereg(void *pch, uint32 offset, uint32 mask,
-			      uint32 val, uint type);
+extern u32 pcicore_pciereg(void *pch, u32 offset, u32 mask,
+			      u32 val, uint type);
 
-extern bool pcicore_pmecap_fast(osl_t * osh);
+extern bool pcicore_pmecap_fast(osl_t *osh);
 extern void pcicore_pmeen(void *pch);
 extern void pcicore_pmeclr(void *pch);
 extern bool pcicore_pmestat(void *pch);
diff --git a/drivers/staging/brcm80211/include/osl.h b/drivers/staging/brcm80211/include/osl.h
index cd09f3c..c0ebb3d 100644
--- a/drivers/staging/brcm80211/include/osl.h
+++ b/drivers/staging/brcm80211/include/osl.h
@@ -51,9 +51,9 @@ typedef void (*osl_wreg_fn_t) (void *ctx, void *reg, unsigned int val,
 
 #if !defined(OSL_SYSUPTIME)
 #define OSL_SYSUPTIME() (0)
-#define OSL_SYSUPTIME_SUPPORT FALSE
+#define OSL_SYSUPTIME_SUPPORT false
 #else
-#define OSL_SYSUPTIME_SUPPORT TRUE
+#define OSL_SYSUPTIME_SUPPORT true
 #endif				/* OSL_SYSUPTIME */
 
 #endif				/* _osl_h_ */
diff --git a/drivers/staging/brcm80211/include/pci_core.h b/drivers/staging/brcm80211/include/pci_core.h
index d0fe4c3..9153dcb 100644
--- a/drivers/staging/brcm80211/include/pci_core.h
+++ b/drivers/staging/brcm80211/include/pci_core.h
@@ -27,32 +27,32 @@
 #endif
 
 /* Sonics side: PCI core and host control registers */
-typedef struct sbpciregs {
-	uint32 control;		/* PCI control */
-	uint32 PAD[3];
-	uint32 arbcontrol;	/* PCI arbiter control */
-	uint32 clkrun;		/* Clkrun Control (>=rev11) */
-	uint32 PAD[2];
-	uint32 intstatus;	/* Interrupt status */
-	uint32 intmask;		/* Interrupt mask */
-	uint32 sbtopcimailbox;	/* Sonics to PCI mailbox */
-	uint32 PAD[9];
-	uint32 bcastaddr;	/* Sonics broadcast address */
-	uint32 bcastdata;	/* Sonics broadcast data */
-	uint32 PAD[2];
-	uint32 gpioin;		/* ro: gpio input (>=rev2) */
-	uint32 gpioout;		/* rw: gpio output (>=rev2) */
-	uint32 gpioouten;	/* rw: gpio output enable (>= rev2) */
-	uint32 gpiocontrol;	/* rw: gpio control (>= rev2) */
-	uint32 PAD[36];
-	uint32 sbtopci0;	/* Sonics to PCI translation 0 */
-	uint32 sbtopci1;	/* Sonics to PCI translation 1 */
-	uint32 sbtopci2;	/* Sonics to PCI translation 2 */
-	uint32 PAD[189];
-	uint32 pcicfg[4][64];	/* 0x400 - 0x7FF, PCI Cfg Space (>=rev8) */
-	uint16 sprom[36];	/* SPROM shadow Area */
-	uint32 PAD[46];
-} sbpciregs_t;
+struct sbpciregs {
+	u32 control;		/* PCI control */
+	u32 PAD[3];
+	u32 arbcontrol;	/* PCI arbiter control */
+	u32 clkrun;		/* Clkrun Control (>=rev11) */
+	u32 PAD[2];
+	u32 intstatus;	/* Interrupt status */
+	u32 intmask;		/* Interrupt mask */
+	u32 sbtopcimailbox;	/* Sonics to PCI mailbox */
+	u32 PAD[9];
+	u32 bcastaddr;	/* Sonics broadcast address */
+	u32 bcastdata;	/* Sonics broadcast data */
+	u32 PAD[2];
+	u32 gpioin;		/* ro: gpio input (>=rev2) */
+	u32 gpioout;		/* rw: gpio output (>=rev2) */
+	u32 gpioouten;	/* rw: gpio output enable (>= rev2) */
+	u32 gpiocontrol;	/* rw: gpio control (>= rev2) */
+	u32 PAD[36];
+	u32 sbtopci0;	/* Sonics to PCI translation 0 */
+	u32 sbtopci1;	/* Sonics to PCI translation 1 */
+	u32 sbtopci2;	/* Sonics to PCI translation 2 */
+	u32 PAD[189];
+	u32 pcicfg[4][64];	/* 0x400 - 0x7FF, PCI Cfg Space (>=rev8) */
+	u16 sprom[36];	/* SPROM shadow Area */
+	u32 PAD[46];
+};
 
 #endif				/* _LANGUAGE_ASSEMBLY */
 
diff --git a/drivers/staging/brcm80211/include/pcicfg.h b/drivers/staging/brcm80211/include/pcicfg.h
index caddca5..3a19e1d 100644
--- a/drivers/staging/brcm80211/include/pcicfg.h
+++ b/drivers/staging/brcm80211/include/pcicfg.h
@@ -103,29 +103,29 @@
 #define PCI_CAPPTR_PRESENT	0x0010
 
 typedef struct _pci_config_regs {
-	uint16 vendor;
-	uint16 device;
-	uint16 command;
-	uint16 status;
-	uint8 rev_id;
-	uint8 prog_if;
-	uint8 sub_class;
-	uint8 base_class;
-	uint8 cache_line_size;
-	uint8 latency_timer;
-	uint8 header_type;
-	uint8 bist;
-	uint32 base[PCI_BAR_MAX];
-	uint32 cardbus_cis;
-	uint16 subsys_vendor;
-	uint16 subsys_id;
-	uint32 baserom;
-	uint32 rsvd_a[PCR_RSVDA_MAX];
-	uint8 int_line;
-	uint8 int_pin;
-	uint8 min_gnt;
-	uint8 max_lat;
-	uint8 dev_dep[192];
+	u16 vendor;
+	u16 device;
+	u16 command;
+	u16 status;
+	u8 rev_id;
+	u8 prog_if;
+	u8 sub_class;
+	u8 base_class;
+	u8 cache_line_size;
+	u8 latency_timer;
+	u8 header_type;
+	u8 bist;
+	u32 base[PCI_BAR_MAX];
+	u32 cardbus_cis;
+	u16 subsys_vendor;
+	u16 subsys_id;
+	u32 baserom;
+	u32 rsvd_a[PCR_RSVDA_MAX];
+	u8 int_line;
+	u8 int_pin;
+	u8 min_gnt;
+	u8 max_lat;
+	u8 dev_dep[192];
 } pci_config_regs;
 
 #define	SZPCR		(sizeof (pci_config_regs))
@@ -331,45 +331,45 @@ typedef enum {
 #define	PPB_RSVDD_MAX		8
 
 typedef struct _ppb_config_regs {
-	uint16 vendor;
-	uint16 device;
-	uint16 command;
-	uint16 status;
-	uint8 rev_id;
-	uint8 prog_if;
-	uint8 sub_class;
-	uint8 base_class;
-	uint8 cache_line_size;
-	uint8 latency_timer;
-	uint8 header_type;
-	uint8 bist;
-	uint32 rsvd_a[PPB_RSVDA_MAX];
-	uint8 prim_bus;
-	uint8 sec_bus;
-	uint8 sub_bus;
-	uint8 sec_lat;
-	uint8 io_base;
-	uint8 io_lim;
-	uint16 sec_status;
-	uint16 mem_base;
-	uint16 mem_lim;
-	uint16 pf_mem_base;
-	uint16 pf_mem_lim;
-	uint32 pf_mem_base_hi;
-	uint32 pf_mem_lim_hi;
-	uint16 io_base_hi;
-	uint16 io_lim_hi;
-	uint16 subsys_vendor;
-	uint16 subsys_id;
-	uint32 rsvd_b;
-	uint8 rsvd_c;
-	uint8 int_pin;
-	uint16 bridge_ctrl;
-	uint8 chip_ctrl;
-	uint8 diag_ctrl;
-	uint16 arb_ctrl;
-	uint32 rsvd_d[PPB_RSVDD_MAX];
-	uint8 dev_dep[192];
+	u16 vendor;
+	u16 device;
+	u16 command;
+	u16 status;
+	u8 rev_id;
+	u8 prog_if;
+	u8 sub_class;
+	u8 base_class;
+	u8 cache_line_size;
+	u8 latency_timer;
+	u8 header_type;
+	u8 bist;
+	u32 rsvd_a[PPB_RSVDA_MAX];
+	u8 prim_bus;
+	u8 sec_bus;
+	u8 sub_bus;
+	u8 sec_lat;
+	u8 io_base;
+	u8 io_lim;
+	u16 sec_status;
+	u16 mem_base;
+	u16 mem_lim;
+	u16 pf_mem_base;
+	u16 pf_mem_lim;
+	u32 pf_mem_base_hi;
+	u32 pf_mem_lim_hi;
+	u16 io_base_hi;
+	u16 io_lim_hi;
+	u16 subsys_vendor;
+	u16 subsys_id;
+	u32 rsvd_b;
+	u8 rsvd_c;
+	u8 int_pin;
+	u16 bridge_ctrl;
+	u8 chip_ctrl;
+	u8 diag_ctrl;
+	u16 arb_ctrl;
+	u32 rsvd_d[PPB_RSVDD_MAX];
+	u8 dev_dep[192];
 } ppb_config_regs;
 
 /* PCI CAPABILITY DEFINES */
@@ -382,22 +382,22 @@ typedef struct _ppb_config_regs {
  * Valid for PCI and PCIE configurations
  */
 typedef struct _pciconfig_cap_msi {
-	uint8 capID;
-	uint8 nextptr;
-	uint16 msgctrl;
-	uint32 msgaddr;
+	u8 capID;
+	u8 nextptr;
+	u16 msgctrl;
+	u32 msgaddr;
 } pciconfig_cap_msi;
 
 /* Data structure to define the Power managment facility
  * Valid for PCI and PCIE configurations
  */
 typedef struct _pciconfig_cap_pwrmgmt {
-	uint8 capID;
-	uint8 nextptr;
-	uint16 pme_cap;
-	uint16 pme_sts_ctrl;
-	uint8 pme_bridge_ext;
-	uint8 data;
+	u8 capID;
+	u8 nextptr;
+	u16 pme_cap;
+	u16 pme_sts_ctrl;
+	u8 pme_bridge_ext;
+	u8 data;
 } pciconfig_cap_pwrmgmt;
 
 #define PME_CAP_PM_STATES (0x1f << 27)	/* Bits 31:27 states that can generate PME */
@@ -407,21 +407,21 @@ typedef struct _pciconfig_cap_pwrmgmt {
 
 /* Data structure to define the PCIE capability */
 typedef struct _pciconfig_cap_pcie {
-	uint8 capID;
-	uint8 nextptr;
-	uint16 pcie_cap;
-	uint32 dev_cap;
-	uint16 dev_ctrl;
-	uint16 dev_status;
-	uint32 link_cap;
-	uint16 link_ctrl;
-	uint16 link_status;
-	uint32 slot_cap;
-	uint16 slot_ctrl;
-	uint16 slot_status;
-	uint16 root_ctrl;
-	uint16 root_cap;
-	uint32 root_status;
+	u8 capID;
+	u8 nextptr;
+	u16 pcie_cap;
+	u32 dev_cap;
+	u16 dev_ctrl;
+	u16 dev_status;
+	u32 link_cap;
+	u16 link_ctrl;
+	u16 link_status;
+	u32 slot_cap;
+	u16 slot_ctrl;
+	u16 slot_status;
+	u16 root_ctrl;
+	u16 root_cap;
+	u32 root_status;
 } pciconfig_cap_pcie;
 
 /* PCIE Enhanced CAPABILITY DEFINES */
@@ -453,9 +453,9 @@ typedef struct _pciconfig_cap_pcie {
 
 /* Header to define the PCIE specific capabilities in the extended config space */
 typedef struct _pcie_enhanced_caphdr {
-	uint16 capID;
-	uint16 cap_ver:4;
-	uint16 next_ptr:12;
+	u16 capID;
+	u16 cap_ver:4;
+	u16 next_ptr:12;
 } pcie_enhanced_caphdr;
 
 /* Everything below is BRCM HND proprietary */
diff --git a/drivers/staging/brcm80211/include/pcie_core.h b/drivers/staging/brcm80211/include/pcie_core.h
index 0f835c1..cd54ddc 100644
--- a/drivers/staging/brcm80211/include/pcie_core.h
+++ b/drivers/staging/brcm80211/include/pcie_core.h
@@ -46,37 +46,37 @@
 
 /* SB side: PCIE core and host control registers */
 typedef struct sbpcieregs {
-	uint32 control;		/* host mode only */
-	uint32 PAD[2];
-	uint32 biststatus;	/* bist Status: 0x00C */
-	uint32 gpiosel;		/* PCIE gpio sel: 0x010 */
-	uint32 gpioouten;	/* PCIE gpio outen: 0x14 */
-	uint32 PAD[2];
-	uint32 intstatus;	/* Interrupt status: 0x20 */
-	uint32 intmask;		/* Interrupt mask: 0x24 */
-	uint32 sbtopcimailbox;	/* sb to pcie mailbox: 0x028 */
-	uint32 PAD[53];
-	uint32 sbtopcie0;	/* sb to pcie translation 0: 0x100 */
-	uint32 sbtopcie1;	/* sb to pcie translation 1: 0x104 */
-	uint32 sbtopcie2;	/* sb to pcie translation 2: 0x108 */
-	uint32 PAD[5];
+	u32 control;		/* host mode only */
+	u32 PAD[2];
+	u32 biststatus;	/* bist Status: 0x00C */
+	u32 gpiosel;		/* PCIE gpio sel: 0x010 */
+	u32 gpioouten;	/* PCIE gpio outen: 0x14 */
+	u32 PAD[2];
+	u32 intstatus;	/* Interrupt status: 0x20 */
+	u32 intmask;		/* Interrupt mask: 0x24 */
+	u32 sbtopcimailbox;	/* sb to pcie mailbox: 0x028 */
+	u32 PAD[53];
+	u32 sbtopcie0;	/* sb to pcie translation 0: 0x100 */
+	u32 sbtopcie1;	/* sb to pcie translation 1: 0x104 */
+	u32 sbtopcie2;	/* sb to pcie translation 2: 0x108 */
+	u32 PAD[5];
 
 	/* pcie core supports in direct access to config space */
-	uint32 configaddr;	/* pcie config space access: Address field: 0x120 */
-	uint32 configdata;	/* pcie config space access: Data field: 0x124 */
+	u32 configaddr;	/* pcie config space access: Address field: 0x120 */
+	u32 configdata;	/* pcie config space access: Data field: 0x124 */
 
 	/* mdio access to serdes */
-	uint32 mdiocontrol;	/* controls the mdio access: 0x128 */
-	uint32 mdiodata;	/* Data to the mdio access: 0x12c */
+	u32 mdiocontrol;	/* controls the mdio access: 0x128 */
+	u32 mdiodata;	/* Data to the mdio access: 0x12c */
 
 	/* pcie protocol phy/dllp/tlp register indirect access mechanism */
-	uint32 pcieindaddr;	/* indirect access to the internal register: 0x130 */
-	uint32 pcieinddata;	/* Data to/from the internal regsiter: 0x134 */
+	u32 pcieindaddr;	/* indirect access to the internal register: 0x130 */
+	u32 pcieinddata;	/* Data to/from the internal regsiter: 0x134 */
 
-	uint32 clkreqenctrl;	/* >= rev 6, Clkreq rdma control : 0x138 */
-	uint32 PAD[177];
-	uint32 pciecfg[4][64];	/* 0x400 - 0x7FF, PCIE Cfg Space */
-	uint16 sprom[64];	/* SPROM shadow Area */
+	u32 clkreqenctrl;	/* >= rev 6, Clkreq rdma control : 0x138 */
+	u32 PAD[177];
+	u32 pciecfg[4][64];	/* 0x400 - 0x7FF, PCIE Cfg Space */
+	u16 sprom[64];	/* SPROM shadow Area */
 } sbpcieregs_t;
 
 /* PCI control */
diff --git a/drivers/staging/brcm80211/include/proto/802.11.h b/drivers/staging/brcm80211/include/proto/802.11.h
index 15a4dbf..ffde19c 100644
--- a/drivers/staging/brcm80211/include/proto/802.11.h
+++ b/drivers/staging/brcm80211/include/proto/802.11.h
@@ -17,49 +17,21 @@
 #ifndef _802_11_H_
 #define _802_11_H_
 
-#ifndef _TYPEDEFS_H_
-#include <typedefs.h>
-#endif
-
-#ifndef _NET_ETHERNET_H_
-#include <proto/ethernet.h>
-#endif
-
 #include <proto/wpa.h>
-
 #include <packed_section_start.h>
 
-#define DOT11_TU_TO_US			1024
-
 #define DOT11_A3_HDR_LEN		24
 #define DOT11_A4_HDR_LEN		30
 #define DOT11_MAC_HDR_LEN		DOT11_A3_HDR_LEN
 #define DOT11_FCS_LEN			4
-#define DOT11_ICV_LEN			4
 #define DOT11_ICV_AES_LEN		8
 #define DOT11_QOS_LEN			2
-#define DOT11_HTC_LEN			4
 
-#define DOT11_KEY_INDEX_SHIFT		6
-#define DOT11_IV_LEN			4
-#define DOT11_IV_TKIP_LEN		8
-#define DOT11_IV_AES_OCB_LEN		4
-#define DOT11_IV_AES_CCM_LEN		8
 #define DOT11_IV_MAX_LEN		8
 
-#define DOT11_MAX_MPDU_BODY_LEN		2304
-
-#define DOT11_MAX_MPDU_LEN		(DOT11_A4_HDR_LEN + \
-					 DOT11_QOS_LEN + \
-					 DOT11_IV_AES_CCM_LEN + \
-					 DOT11_MAX_MPDU_BODY_LEN + \
-					 DOT11_ICV_LEN + \
-					 DOT11_FCS_LEN)
-
 #define DOT11_MAX_SSID_LEN		32
 
 #define DOT11_DEFAULT_RTS_LEN		2347
-#define DOT11_MAX_RTS_LEN		2347
 
 #define DOT11_MIN_FRAG_LEN		256
 #define DOT11_MAX_FRAG_LEN		2346
@@ -71,434 +43,53 @@
 #define DOT11_MIN_DTIM_PERIOD		1
 #define DOT11_MAX_DTIM_PERIOD		0xFF
 
-#define DOT11_LLC_SNAP_HDR_LEN		8
 #define DOT11_OUI_LEN			3
-BWL_PRE_PACKED_STRUCT struct dot11_llc_snap_header {
-	uint8 dsap;
-	uint8 ssap;
-	uint8 ctl;
-	uint8 oui[DOT11_OUI_LEN];
-	uint16 type;
-} BWL_POST_PACKED_STRUCT;
-
-#define RFC1042_HDR_LEN	(ETHER_HDR_LEN + DOT11_LLC_SNAP_HDR_LEN)
 
 BWL_PRE_PACKED_STRUCT struct dot11_header {
-	uint16 fc;
-	uint16 durid;
+	u16 fc;
+	u16 durid;
 	struct ether_addr a1;
 	struct ether_addr a2;
 	struct ether_addr a3;
-	uint16 seq;
+	u16 seq;
 	struct ether_addr a4;
 } BWL_POST_PACKED_STRUCT;
 
 BWL_PRE_PACKED_STRUCT struct dot11_rts_frame {
-	uint16 fc;
-	uint16 durid;
+	u16 fc;
+	u16 durid;
 	struct ether_addr ra;
 	struct ether_addr ta;
 } BWL_POST_PACKED_STRUCT;
-#define	DOT11_RTS_LEN		16
 
-BWL_PRE_PACKED_STRUCT struct dot11_cts_frame {
-	uint16 fc;
-	uint16 durid;
-	struct ether_addr ra;
-} BWL_POST_PACKED_STRUCT;
+#define	DOT11_RTS_LEN		16
 #define	DOT11_CTS_LEN		10
-
-BWL_PRE_PACKED_STRUCT struct dot11_ack_frame {
-	uint16 fc;
-	uint16 durid;
-	struct ether_addr ra;
-} BWL_POST_PACKED_STRUCT;
 #define	DOT11_ACK_LEN		10
 
-BWL_PRE_PACKED_STRUCT struct dot11_ps_poll_frame {
-	uint16 fc;
-	uint16 durid;
-	struct ether_addr bssid;
-	struct ether_addr ta;
-} BWL_POST_PACKED_STRUCT;
-#define	DOT11_PS_POLL_LEN	16
-
-BWL_PRE_PACKED_STRUCT struct dot11_cf_end_frame {
-	uint16 fc;
-	uint16 durid;
-	struct ether_addr ra;
-	struct ether_addr bssid;
-} BWL_POST_PACKED_STRUCT;
-#define	DOT11_CS_END_LEN	16
-
-BWL_PRE_PACKED_STRUCT struct dot11_action_wifi_vendor_specific {
-	uint8 category;
-	uint8 OUI[3];
-	uint8 type;
-	uint8 subtype;
-	uint8 data[1040];
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_action_wifi_vendor_specific
- dot11_action_wifi_vendor_specific_t;
-
-BWL_PRE_PACKED_STRUCT struct dot11_action_vs_frmhdr {
-	uint8 category;
-	uint8 OUI[3];
-	uint8 type;
-	uint8 subtype;
-	uint8 data[1];
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_action_vs_frmhdr dot11_action_vs_frmhdr_t;
-#define DOT11_ACTION_VS_HDR_LEN	6
-
-#define BCM_ACTION_OUI_BYTE0	0x00
-#define BCM_ACTION_OUI_BYTE1	0x90
-#define BCM_ACTION_OUI_BYTE2	0x4c
-
-#define DOT11_BA_CTL_POLICY_NORMAL	0x0000
-#define DOT11_BA_CTL_POLICY_NOACK	0x0001
-#define DOT11_BA_CTL_POLICY_MASK	0x0001
-
-#define DOT11_BA_CTL_MTID		0x0002
-#define DOT11_BA_CTL_COMPRESSED		0x0004
-
-#define DOT11_BA_CTL_NUMMSDU_MASK	0x0FC0
-#define DOT11_BA_CTL_NUMMSDU_SHIFT	6
-
-#define DOT11_BA_CTL_TID_MASK		0xF000
-#define DOT11_BA_CTL_TID_SHIFT		12
-
-BWL_PRE_PACKED_STRUCT struct dot11_ctl_header {
-	uint16 fc;
-	uint16 durid;
-	struct ether_addr ra;
-	struct ether_addr ta;
-} BWL_POST_PACKED_STRUCT;
-#define DOT11_CTL_HDR_LEN	16
-
-BWL_PRE_PACKED_STRUCT struct dot11_bar {
-	uint16 bar_control;
-	uint16 seqnum;
-} BWL_POST_PACKED_STRUCT;
-#define DOT11_BAR_LEN		4
-
-#define DOT11_BA_BITMAP_LEN	128
-#define DOT11_BA_CMP_BITMAP_LEN	8
-
-BWL_PRE_PACKED_STRUCT struct dot11_ba {
-	uint16 ba_control;
-	uint16 seqnum;
-	uint8 bitmap[DOT11_BA_BITMAP_LEN];
-} BWL_POST_PACKED_STRUCT;
+#define DOT11_BA_BITMAP_LEN		128
 #define DOT11_BA_LEN		4
 
 BWL_PRE_PACKED_STRUCT struct dot11_management_header {
-	uint16 fc;
-	uint16 durid;
+	u16 fc;
+	u16 durid;
 	struct ether_addr da;
 	struct ether_addr sa;
 	struct ether_addr bssid;
-	uint16 seq;
+	u16 seq;
 } BWL_POST_PACKED_STRUCT;
 #define	DOT11_MGMT_HDR_LEN	24
 
 BWL_PRE_PACKED_STRUCT struct dot11_bcn_prb {
-	uint32 timestamp[2];
-	uint16 beacon_interval;
-	uint16 capability;
+	u32 timestamp[2];
+	u16 beacon_interval;
+	u16 capability;
 } BWL_POST_PACKED_STRUCT;
 #define	DOT11_BCN_PRB_LEN	12
-#define	DOT11_BCN_PRB_FIXED_LEN	12
-
-BWL_PRE_PACKED_STRUCT struct dot11_auth {
-	uint16 alg;
-	uint16 seq;
-	uint16 status;
-} BWL_POST_PACKED_STRUCT;
-#define DOT11_AUTH_FIXED_LEN	6
-
-BWL_PRE_PACKED_STRUCT struct dot11_assoc_req {
-	uint16 capability;
-	uint16 listen;
-} BWL_POST_PACKED_STRUCT;
-#define DOT11_ASSOC_REQ_FIXED_LEN	4
-
-BWL_PRE_PACKED_STRUCT struct dot11_reassoc_req {
-	uint16 capability;
-	uint16 listen;
-	struct ether_addr ap;
-} BWL_POST_PACKED_STRUCT;
-#define DOT11_REASSOC_REQ_FIXED_LEN	10
-
-BWL_PRE_PACKED_STRUCT struct dot11_assoc_resp {
-	uint16 capability;
-	uint16 status;
-	uint16 aid;
-} BWL_POST_PACKED_STRUCT;
-#define DOT11_ASSOC_RESP_FIXED_LEN	6
-
-BWL_PRE_PACKED_STRUCT struct dot11_action_measure {
-	uint8 category;
-	uint8 action;
-	uint8 token;
-	uint8 data[1];
-} BWL_POST_PACKED_STRUCT;
-#define DOT11_ACTION_MEASURE_LEN	3
-
-BWL_PRE_PACKED_STRUCT struct dot11_action_ht_ch_width {
-	uint8 category;
-	uint8 action;
-	uint8 ch_width;
-} BWL_POST_PACKED_STRUCT;
-
-BWL_PRE_PACKED_STRUCT struct dot11_action_ht_mimops {
-	uint8 category;
-	uint8 action;
-	uint8 control;
-} BWL_POST_PACKED_STRUCT;
-
-#define SM_PWRSAVE_ENABLE	1
-#define SM_PWRSAVE_MODE		2
-
-BWL_PRE_PACKED_STRUCT struct dot11_power_cnst {
-	uint8 id;
-	uint8 len;
-	uint8 power;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_power_cnst dot11_power_cnst_t;
-
-BWL_PRE_PACKED_STRUCT struct dot11_power_cap {
-	uint8 min;
-	uint8 max;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_power_cap dot11_power_cap_t;
-
-BWL_PRE_PACKED_STRUCT struct dot11_tpc_rep {
-	uint8 id;
-	uint8 len;
-	uint8 tx_pwr;
-	uint8 margin;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_tpc_rep dot11_tpc_rep_t;
-#define DOT11_MNG_IE_TPC_REPORT_LEN	2
-
-BWL_PRE_PACKED_STRUCT struct dot11_supp_channels {
-	uint8 id;
-	uint8 len;
-	uint8 first_channel;
-	uint8 num_channels;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_supp_channels dot11_supp_channels_t;
-
-BWL_PRE_PACKED_STRUCT struct dot11_extch {
-	uint8 id;
-	uint8 len;
-	uint8 extch;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_extch dot11_extch_ie_t;
-
-BWL_PRE_PACKED_STRUCT struct dot11_brcm_extch {
-	uint8 id;
-	uint8 len;
-	uint8 oui[3];
-	uint8 type;
-	uint8 extch;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_brcm_extch dot11_brcm_extch_ie_t;
-
-#define DOT11_EXTCH_IE_LEN	1
-#define DOT11_EXT_CH_MASK	0x03
-#define DOT11_EXT_CH_UPPER	0x01
-#define DOT11_EXT_CH_LOWER	0x03
-#define DOT11_EXT_CH_NONE	0x00
-
-BWL_PRE_PACKED_STRUCT struct dot11_action_frmhdr {
-	uint8 category;
-	uint8 action;
-	uint8 data[1];
-} BWL_POST_PACKED_STRUCT;
-#define DOT11_ACTION_FRMHDR_LEN	2
-
-BWL_PRE_PACKED_STRUCT struct dot11_channel_switch {
-	uint8 id;
-	uint8 len;
-	uint8 mode;
-	uint8 channel;
-	uint8 count;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_channel_switch dot11_chan_switch_ie_t;
-
-#define DOT11_SWITCH_IE_LEN	3
-
-#define DOT11_CSA_MODE_ADVISORY		0
-#define DOT11_CSA_MODE_NO_TX		1
-
-BWL_PRE_PACKED_STRUCT struct dot11_action_switch_channel {
-	uint8 category;
-	uint8 action;
-	dot11_chan_switch_ie_t chan_switch_ie;
-	dot11_brcm_extch_ie_t extch_ie;
-} BWL_POST_PACKED_STRUCT;
-
-BWL_PRE_PACKED_STRUCT struct dot11_csa_body {
-	uint8 mode;
-	uint8 reg;
-	uint8 channel;
-	uint8 count;
-} BWL_POST_PACKED_STRUCT;
-
-BWL_PRE_PACKED_STRUCT struct dot11_ext_csa {
-	uint8 id;
-	uint8 len;
-	struct dot11_csa_body b;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_ext_csa dot11_ext_csa_ie_t;
-#define DOT11_EXT_CSA_IE_LEN	4
-
-BWL_PRE_PACKED_STRUCT struct dot11_action_ext_csa {
-	uint8 category;
-	uint8 action;
-	dot11_ext_csa_ie_t chan_switch_ie;
-} BWL_POST_PACKED_STRUCT;
-
-BWL_PRE_PACKED_STRUCT struct dot11y_action_ext_csa {
-	uint8 category;
-	uint8 action;
-	struct dot11_csa_body b;
-} BWL_POST_PACKED_STRUCT;
-
-BWL_PRE_PACKED_STRUCT struct dot11_obss_coex {
-	uint8 id;
-	uint8 len;
-	uint8 info;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_obss_coex dot11_obss_coex_t;
-#define DOT11_OBSS_COEXINFO_LEN	1
-
-#define	DOT11_OBSS_COEX_INFO_REQ		0x01
-#define	DOT11_OBSS_COEX_40MHZ_INTOLERANT	0x02
-#define	DOT11_OBSS_COEX_20MHZ_WIDTH_REQ	0x04
-
-BWL_PRE_PACKED_STRUCT struct dot11_obss_chanlist {
-	uint8 id;
-	uint8 len;
-	uint8 regclass;
-	uint8 chanlist[1];
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_obss_chanlist dot11_obss_chanlist_t;
-#define DOT11_OBSS_CHANLIST_FIXED_LEN	1
-
-BWL_PRE_PACKED_STRUCT struct dot11_extcap_ie {
-	uint8 id;
-	uint8 len;
-	uint8 cap;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_extcap_ie dot11_extcap_ie_t;
-#define DOT11_EXTCAP_LEN	1
-
-#define DOT11_MEASURE_TYPE_BASIC 	0
-#define DOT11_MEASURE_TYPE_CCA 		1
-#define DOT11_MEASURE_TYPE_RPI		2
-#define DOT11_MEASURE_TYPE_CHLOAD		3
-#define DOT11_MEASURE_TYPE_NOISE		4
-#define DOT11_MEASURE_TYPE_BEACON		5
-#define DOT11_MEASURE_TYPE_FRAME	6
-#define DOT11_MEASURE_TYPE_STATS		7
-#define DOT11_MEASURE_TYPE_LCI		8
-#define DOT11_MEASURE_TYPE_TXSTREAM		9
-#define DOT11_MEASURE_TYPE_PAUSE		255
-
-#define DOT11_MEASURE_MODE_PARALLEL 	(1<<0)
-#define DOT11_MEASURE_MODE_ENABLE 	(1<<1)
-#define DOT11_MEASURE_MODE_REQUEST	(1<<2)
-#define DOT11_MEASURE_MODE_REPORT 	(1<<3)
-#define DOT11_MEASURE_MODE_DUR 	(1<<4)
-
-#define DOT11_MEASURE_MODE_LATE 	(1<<0)
-#define DOT11_MEASURE_MODE_INCAPABLE	(1<<1)
-#define DOT11_MEASURE_MODE_REFUSED	(1<<2)
-
-#define DOT11_MEASURE_BASIC_MAP_BSS	((uint8)(1<<0))
-#define DOT11_MEASURE_BASIC_MAP_OFDM	((uint8)(1<<1))
-#define DOT11_MEASURE_BASIC_MAP_UKNOWN	((uint8)(1<<2))
-#define DOT11_MEASURE_BASIC_MAP_RADAR	((uint8)(1<<3))
-#define DOT11_MEASURE_BASIC_MAP_UNMEAS	((uint8)(1<<4))
-
-BWL_PRE_PACKED_STRUCT struct dot11_meas_req {
-	uint8 id;
-	uint8 len;
-	uint8 token;
-	uint8 mode;
-	uint8 type;
-	uint8 channel;
-	uint8 start_time[8];
-	uint16 duration;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_meas_req dot11_meas_req_t;
-#define DOT11_MNG_IE_MREQ_LEN 14
-
-#define DOT11_MNG_IE_MREQ_FIXED_LEN 3
-
-BWL_PRE_PACKED_STRUCT struct dot11_meas_rep {
-	uint8 id;
-	uint8 len;
-	uint8 token;
-	uint8 mode;
-	uint8 type;
-	BWL_PRE_PACKED_STRUCT union {
-		BWL_PRE_PACKED_STRUCT struct {
-			uint8 channel;
-			uint8 start_time[8];
-			uint16 duration;
-			uint8 map;
-		} BWL_POST_PACKED_STRUCT basic;
-		uint8 data[1];
-	} BWL_POST_PACKED_STRUCT rep;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_meas_rep dot11_meas_rep_t;
-
-#define DOT11_MNG_IE_MREP_FIXED_LEN	3
-
-BWL_PRE_PACKED_STRUCT struct dot11_meas_rep_basic {
-	uint8 channel;
-	uint8 start_time[8];
-	uint16 duration;
-	uint8 map;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_meas_rep_basic dot11_meas_rep_basic_t;
-#define DOT11_MEASURE_BASIC_REP_LEN	12
-
-BWL_PRE_PACKED_STRUCT struct dot11_quiet {
-	uint8 id;
-	uint8 len;
-	uint8 count;
-	uint8 period;
-	uint16 duration;
-	uint16 offset;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_quiet dot11_quiet_t;
-
-BWL_PRE_PACKED_STRUCT struct chan_map_tuple {
-	uint8 channel;
-	uint8 map;
-} BWL_POST_PACKED_STRUCT;
-typedef struct chan_map_tuple chan_map_tuple_t;
-
-BWL_PRE_PACKED_STRUCT struct dot11_ibss_dfs {
-	uint8 id;
-	uint8 len;
-	uint8 eaddr[ETHER_ADDR_LEN];
-	uint8 interval;
-	chan_map_tuple_t map[1];
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_ibss_dfs dot11_ibss_dfs_t;
 
 #define WME_OUI			"\x00\x50\xf2"
 #define WME_VER			1
 #define WME_TYPE		2
-#define WME_SUBTYPE_IE		0
 #define WME_SUBTYPE_PARAM_IE	1
-#define WME_SUBTYPE_TSPEC	2
 
 #define AC_BE			0
 #define AC_BK			1
@@ -506,82 +97,44 @@ typedef struct dot11_ibss_dfs dot11_ibss_dfs_t;
 #define AC_VO			3
 #define AC_COUNT		4
 
-typedef uint8 ac_bitmap_t;
+typedef u8 ac_bitmap_t;
 
-#define AC_BITMAP_NONE		0x0
 #define AC_BITMAP_ALL		0xf
 #define AC_BITMAP_TST(ab, ac)	(((ab) & (1 << (ac))) != 0)
-#define AC_BITMAP_SET(ab, ac)	(((ab) |= (1 << (ac))))
-#define AC_BITMAP_RESET(ab, ac) (((ab) &= ~(1 << (ac))))
-
-BWL_PRE_PACKED_STRUCT struct wme_ie {
-	uint8 oui[3];
-	uint8 type;
-	uint8 subtype;
-	uint8 version;
-	uint8 qosinfo;
-} BWL_POST_PACKED_STRUCT;
-typedef struct wme_ie wme_ie_t;
-#define WME_IE_LEN 7
 
 BWL_PRE_PACKED_STRUCT struct edcf_acparam {
-	uint8 ACI;
-	uint8 ECW;
-	uint16 TXOP;
+	u8 ACI;
+	u8 ECW;
+	u16 TXOP;
 } BWL_POST_PACKED_STRUCT;
 typedef struct edcf_acparam edcf_acparam_t;
 
 BWL_PRE_PACKED_STRUCT struct wme_param_ie {
-	uint8 oui[3];
-	uint8 type;
-	uint8 subtype;
-	uint8 version;
-	uint8 qosinfo;
-	uint8 rsvd;
+	u8 oui[3];
+	u8 type;
+	u8 subtype;
+	u8 version;
+	u8 qosinfo;
+	u8 rsvd;
 	edcf_acparam_t acparam[AC_COUNT];
 } BWL_POST_PACKED_STRUCT;
 typedef struct wme_param_ie wme_param_ie_t;
 #define WME_PARAM_IE_LEN            24
 
-#define WME_QI_AP_APSD_MASK         0x80
-#define WME_QI_AP_APSD_SHIFT        7
-#define WME_QI_AP_COUNT_MASK        0x0f
-#define WME_QI_AP_COUNT_SHIFT       0
-
-#define WME_QI_STA_MAXSPLEN_MASK    0x60
-#define WME_QI_STA_MAXSPLEN_SHIFT   5
-#define WME_QI_STA_APSD_ALL_MASK    0xf
-#define WME_QI_STA_APSD_ALL_SHIFT   0
-#define WME_QI_STA_APSD_BE_MASK     0x8
-#define WME_QI_STA_APSD_BE_SHIFT    3
-#define WME_QI_STA_APSD_BK_MASK     0x4
-#define WME_QI_STA_APSD_BK_SHIFT    2
-#define WME_QI_STA_APSD_VI_MASK     0x2
-#define WME_QI_STA_APSD_VI_SHIFT    1
-#define WME_QI_STA_APSD_VO_MASK     0x1
-#define WME_QI_STA_APSD_VO_SHIFT    0
-
 #define EDCF_AIFSN_MIN               1
 #define EDCF_AIFSN_MAX               15
 #define EDCF_AIFSN_MASK              0x0f
 #define EDCF_ACM_MASK                0x10
 #define EDCF_ACI_MASK                0x60
 #define EDCF_ACI_SHIFT               5
-#define EDCF_AIFSN_SHIFT             12
 
-#define EDCF_ECW_MIN                 0
-#define EDCF_ECW_MAX                 15
 #define EDCF_ECW2CW(exp)             ((1 << (exp)) - 1)
 #define EDCF_ECWMIN_MASK             0x0f
 #define EDCF_ECWMAX_MASK             0xf0
 #define EDCF_ECWMAX_SHIFT            4
 
-#define EDCF_TXOP_MIN                0
-#define EDCF_TXOP_MAX                65535
 #define EDCF_TXOP2USEC(txop)         ((txop) << 5)
 
-#define NON_EDCF_AC_BE_ACI_STA          0x02
-
 #define EDCF_AC_BE_ACI_STA           0x03
 #define EDCF_AC_BE_ECW_STA           0xA4
 #define EDCF_AC_BE_TXOP_STA          0x0000
@@ -595,93 +148,16 @@ typedef struct wme_param_ie wme_param_ie_t;
 #define EDCF_AC_VO_ECW_STA           0x32
 #define EDCF_AC_VO_TXOP_STA          0x002f
 
-#define EDCF_AC_BE_ACI_AP            0x03
-#define EDCF_AC_BE_ECW_AP            0x64
-#define EDCF_AC_BE_TXOP_AP           0x0000
-#define EDCF_AC_BK_ACI_AP            0x27
-#define EDCF_AC_BK_ECW_AP            0xA4
-#define EDCF_AC_BK_TXOP_AP           0x0000
-#define EDCF_AC_VI_ACI_AP            0x41
-#define EDCF_AC_VI_ECW_AP            0x43
-#define EDCF_AC_VI_TXOP_AP           0x005e
-#define EDCF_AC_VO_ACI_AP            0x61
-#define EDCF_AC_VO_ECW_AP            0x32
 #define EDCF_AC_VO_TXOP_AP           0x002f
 
-BWL_PRE_PACKED_STRUCT struct edca_param_ie {
-	uint8 qosinfo;
-	uint8 rsvd;
-	edcf_acparam_t acparam[AC_COUNT];
-} BWL_POST_PACKED_STRUCT;
-typedef struct edca_param_ie edca_param_ie_t;
-#define EDCA_PARAM_IE_LEN            18
-
-BWL_PRE_PACKED_STRUCT struct qos_cap_ie {
-	uint8 qosinfo;
-} BWL_POST_PACKED_STRUCT;
-typedef struct qos_cap_ie qos_cap_ie_t;
-
-BWL_PRE_PACKED_STRUCT struct dot11_qbss_load_ie {
-	uint8 id;
-	uint8 length;
-	uint16 station_count;
-	uint8 channel_utilization;
-	uint16 aac;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_qbss_load_ie dot11_qbss_load_ie_t;
-
-#define FIXED_MSDU_SIZE 0x8000
-#define MSDU_SIZE_MASK	0x7fff
-
-#define	INTEGER_SHIFT	13
-#define FRACTION_MASK	0x1FFF
-
-BWL_PRE_PACKED_STRUCT struct dot11_management_notification {
-	uint8 category;
-	uint8 action;
-	uint8 token;
-	uint8 status;
-	uint8 data[1];
-} BWL_POST_PACKED_STRUCT;
-#define DOT11_MGMT_NOTIFICATION_LEN 4
-
-#define WME_ADDTS_REQUEST	0
-#define WME_ADDTS_RESPONSE	1
-#define WME_DELTS_REQUEST	2
-
-#define WME_ADMISSION_ACCEPTED		0
-#define WME_INVALID_PARAMETERS		1
-#define WME_ADMISSION_REFUSED		3
-
-#define BCN_PRB_SSID(body) ((char*)(body) + DOT11_BCN_PRB_LEN)
-
 #define DOT11_OPEN_SYSTEM	0
 #define DOT11_SHARED_KEY	1
-#define DOT11_OPEN_SHARED	2
-#define DOT11_CHALLENGE_LEN	128
 
-#define FC_PVER_MASK		0x3
-#define FC_PVER_SHIFT		0
 #define FC_TYPE_MASK		0xC
 #define FC_TYPE_SHIFT		2
 #define FC_SUBTYPE_MASK		0xF0
 #define FC_SUBTYPE_SHIFT	4
-#define FC_TODS			0x100
-#define FC_TODS_SHIFT		8
-#define FC_FROMDS		0x200
-#define FC_FROMDS_SHIFT		9
 #define FC_MOREFRAG		0x400
-#define FC_MOREFRAG_SHIFT	10
-#define FC_RETRY		0x800
-#define FC_RETRY_SHIFT		11
-#define FC_PM			0x1000
-#define FC_PM_SHIFT		12
-#define FC_MOREDATA		0x2000
-#define FC_MOREDATA_SHIFT	13
-#define FC_WEP			0x4000
-#define FC_WEP_SHIFT		14
-#define FC_ORDER		0x8000
-#define FC_ORDER_SHIFT		15
 
 #define SEQNUM_SHIFT		4
 #define SEQNUM_MAX		0x1000
@@ -691,50 +167,14 @@ BWL_PRE_PACKED_STRUCT struct dot11_management_notification {
 #define FC_TYPE_CTL		1
 #define FC_TYPE_DATA		2
 
-#define FC_SUBTYPE_ASSOC_REQ		0
-#define FC_SUBTYPE_ASSOC_RESP		1
-#define FC_SUBTYPE_REASSOC_REQ		2
-#define FC_SUBTYPE_REASSOC_RESP		3
 #define FC_SUBTYPE_PROBE_REQ		4
 #define FC_SUBTYPE_PROBE_RESP		5
 #define FC_SUBTYPE_BEACON		8
-#define FC_SUBTYPE_ATIM			9
-#define FC_SUBTYPE_DISASSOC		10
-#define FC_SUBTYPE_AUTH			11
-#define FC_SUBTYPE_DEAUTH		12
-#define FC_SUBTYPE_ACTION		13
-#define FC_SUBTYPE_ACTION_NOACK		14
-
-#define FC_SUBTYPE_CTL_WRAPPER		7
-#define FC_SUBTYPE_BLOCKACK_REQ		8
-#define FC_SUBTYPE_BLOCKACK		9
 #define FC_SUBTYPE_PS_POLL		10
 #define FC_SUBTYPE_RTS			11
 #define FC_SUBTYPE_CTS			12
-#define FC_SUBTYPE_ACK			13
-#define FC_SUBTYPE_CF_END		14
-#define FC_SUBTYPE_CF_END_ACK		15
-
-#define FC_SUBTYPE_DATA			0
-#define FC_SUBTYPE_DATA_CF_ACK		1
-#define FC_SUBTYPE_DATA_CF_POLL		2
-#define FC_SUBTYPE_DATA_CF_ACK_POLL	3
-#define FC_SUBTYPE_NULL			4
-#define FC_SUBTYPE_CF_ACK		5
-#define FC_SUBTYPE_CF_POLL		6
-#define FC_SUBTYPE_CF_ACK_POLL		7
-#define FC_SUBTYPE_QOS_DATA		8
-#define FC_SUBTYPE_QOS_DATA_CF_ACK	9
-#define FC_SUBTYPE_QOS_DATA_CF_POLL	10
-#define FC_SUBTYPE_QOS_DATA_CF_ACK_POLL	11
-#define FC_SUBTYPE_QOS_NULL		12
-#define FC_SUBTYPE_QOS_CF_POLL		14
-#define FC_SUBTYPE_QOS_CF_ACK_POLL	15
 
 #define FC_SUBTYPE_ANY_QOS(s)		(((s) & 8) != 0)
-#define FC_SUBTYPE_ANY_NULL(s)		(((s) & 4) != 0)
-#define FC_SUBTYPE_ANY_CF_POLL(s)	(((s) & 2) != 0)
-#define FC_SUBTYPE_ANY_CF_ACK(s)	(((s) & 1) != 0)
 
 #define FC_KIND_MASK		(FC_TYPE_MASK | FC_SUBTYPE_MASK)
 
@@ -743,431 +183,30 @@ BWL_PRE_PACKED_STRUCT struct dot11_management_notification {
 #define FC_SUBTYPE(fc)	(((fc) & FC_SUBTYPE_MASK) >> FC_SUBTYPE_SHIFT)
 #define FC_TYPE(fc)	(((fc) & FC_TYPE_MASK) >> FC_TYPE_SHIFT)
 
-#define FC_ASSOC_REQ	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ASSOC_REQ)
-#define FC_ASSOC_RESP	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ASSOC_RESP)
-#define FC_REASSOC_REQ	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_REASSOC_REQ)
-#define FC_REASSOC_RESP	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_REASSOC_RESP)
 #define FC_PROBE_REQ	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_PROBE_REQ)
 #define FC_PROBE_RESP	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_PROBE_RESP)
 #define FC_BEACON	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_BEACON)
-#define FC_DISASSOC	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_DISASSOC)
-#define FC_AUTH		FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_AUTH)
-#define FC_DEAUTH	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_DEAUTH)
-#define FC_ACTION	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ACTION)
-#define FC_ACTION_NOACK	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ACTION_NOACK)
-
-#define FC_CTL_WRAPPER	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CTL_WRAPPER)
-#define FC_BLOCKACK_REQ	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_BLOCKACK_REQ)
-#define FC_BLOCKACK	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_BLOCKACK)
 #define FC_PS_POLL	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_PS_POLL)
 #define FC_RTS		FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_RTS)
 #define FC_CTS		FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CTS)
-#define FC_ACK		FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_ACK)
-#define FC_CF_END	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CF_END)
-#define FC_CF_END_ACK	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CF_END_ACK)
-
-#define FC_DATA		FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_DATA)
-#define FC_NULL_DATA	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_NULL)
-#define FC_DATA_CF_ACK	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_DATA_CF_ACK)
-#define FC_QOS_DATA	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_QOS_DATA)
-#define FC_QOS_NULL	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_QOS_NULL)
-
-#define QOS_PRIO_SHIFT		0
-#define QOS_PRIO_MASK		0x0007
-#define QOS_PRIO(qos)		(((qos) & QOS_PRIO_MASK) >> QOS_PRIO_SHIFT)
-
-#define QOS_TID_SHIFT		0
-#define QOS_TID_MASK		0x000f
-#define QOS_TID(qos)		(((qos) & QOS_TID_MASK) >> QOS_TID_SHIFT)
-
-#define QOS_EOSP_SHIFT		4
-#define QOS_EOSP_MASK		0x0010
-#define QOS_EOSP(qos)		(((qos) & QOS_EOSP_MASK) >> QOS_EOSP_SHIFT)
-
-#define QOS_ACK_NORMAL_ACK	0
-#define QOS_ACK_NO_ACK		1
-#define QOS_ACK_NO_EXP_ACK	2
-#define QOS_ACK_BLOCK_ACK	3
-#define QOS_ACK_SHIFT		5
-#define QOS_ACK_MASK		0x0060
-#define QOS_ACK(qos)		(((qos) & QOS_ACK_MASK) >> QOS_ACK_SHIFT)
-
-#define QOS_AMSDU_SHIFT		7
-#define QOS_AMSDU_MASK		0x0080
-
-#define DOT11_MNG_AUTH_ALGO_LEN		2
-#define DOT11_MNG_AUTH_SEQ_LEN		2
-#define DOT11_MNG_BEACON_INT_LEN	2
-#define DOT11_MNG_CAP_LEN		2
-#define DOT11_MNG_AP_ADDR_LEN		6
-#define DOT11_MNG_LISTEN_INT_LEN	2
-#define DOT11_MNG_REASON_LEN		2
-#define DOT11_MNG_AID_LEN		2
-#define DOT11_MNG_STATUS_LEN		2
-#define DOT11_MNG_TIMESTAMP_LEN		8
-
-#define DOT11_AID_MASK			0x3fff
-
-#define DOT11_RC_RESERVED		0
-#define DOT11_RC_UNSPECIFIED		1
-#define DOT11_RC_AUTH_INVAL		2
-#define DOT11_RC_DEAUTH_LEAVING		3
-#define DOT11_RC_INACTIVITY		4
-#define DOT11_RC_BUSY			5
-#define DOT11_RC_INVAL_CLASS_2		6
-#define DOT11_RC_INVAL_CLASS_3		7
-#define DOT11_RC_DISASSOC_LEAVING	8
-#define DOT11_RC_NOT_AUTH		9
-#define DOT11_RC_BAD_PC			10
-#define DOT11_RC_BAD_CHANNELS		11
-
-#define DOT11_RC_UNSPECIFIED_QOS	32
-#define DOT11_RC_INSUFFCIENT_BW		33
-#define DOT11_RC_EXCESSIVE_FRAMES	34
-#define DOT11_RC_TX_OUTSIDE_TXOP	35
-#define DOT11_RC_LEAVING_QBSS		36
-#define DOT11_RC_BAD_MECHANISM		37
-#define DOT11_RC_SETUP_NEEDED		38
-#define DOT11_RC_TIMEOUT		39
-
-#define DOT11_RC_MAX			23
-
-#define DOT11_SC_SUCCESS		0
-#define DOT11_SC_FAILURE		1
-#define DOT11_SC_CAP_MISMATCH		10
-#define DOT11_SC_REASSOC_FAIL		11
-#define DOT11_SC_ASSOC_FAIL		12
-#define DOT11_SC_AUTH_MISMATCH		13
-#define DOT11_SC_AUTH_SEQ		14
-#define DOT11_SC_AUTH_CHALLENGE_FAIL	15
-#define DOT11_SC_AUTH_TIMEOUT		16
-#define DOT11_SC_ASSOC_BUSY_FAIL	17
-#define DOT11_SC_ASSOC_RATE_MISMATCH	18
-#define DOT11_SC_ASSOC_SHORT_REQUIRED	19
-#define DOT11_SC_ASSOC_PBCC_REQUIRED	20
-#define DOT11_SC_ASSOC_AGILITY_REQUIRED	21
-#define DOT11_SC_ASSOC_SPECTRUM_REQUIRED	22
-#define DOT11_SC_ASSOC_BAD_POWER_CAP	23
-#define DOT11_SC_ASSOC_BAD_SUP_CHANNELS	24
-#define DOT11_SC_ASSOC_SHORTSLOT_REQUIRED	25
-#define DOT11_SC_ASSOC_ERPBCC_REQUIRED	26
-#define DOT11_SC_ASSOC_DSSOFDM_REQUIRED	27
-
-#define	DOT11_SC_DECLINED		37
-#define	DOT11_SC_INVALID_PARAMS		38
-
-#define DOT11_MNG_DS_PARAM_LEN			1
-#define DOT11_MNG_IBSS_PARAM_LEN		2
-
-#define DOT11_MNG_TIM_FIXED_LEN			3
-#define DOT11_MNG_TIM_DTIM_COUNT		0
-#define DOT11_MNG_TIM_DTIM_PERIOD		1
-#define DOT11_MNG_TIM_BITMAP_CTL		2
-#define DOT11_MNG_TIM_PVB			3
-
-#define TLV_TAG_OFF		0
+
 #define TLV_LEN_OFF		1
 #define TLV_HDR_LEN		2
 #define TLV_BODY_OFF		2
 
-#define DOT11_MNG_SSID_ID			0
-#define DOT11_MNG_RATES_ID			1
-#define DOT11_MNG_FH_PARMS_ID			2
-#define DOT11_MNG_DS_PARMS_ID			3
-#define DOT11_MNG_CF_PARMS_ID			4
-#define DOT11_MNG_TIM_ID			5
-#define DOT11_MNG_IBSS_PARMS_ID			6
-#define DOT11_MNG_COUNTRY_ID			7
-#define DOT11_MNG_HOPPING_PARMS_ID		8
-#define DOT11_MNG_HOPPING_TABLE_ID		9
-#define DOT11_MNG_REQUEST_ID			10
-#define DOT11_MNG_QBSS_LOAD_ID 			11
-#define DOT11_MNG_EDCA_PARAM_ID			12
-#define DOT11_MNG_CHALLENGE_ID			16
-#define DOT11_MNG_PWR_CONSTRAINT_ID		32
-#define DOT11_MNG_PWR_CAP_ID			33
-#define DOT11_MNG_TPC_REQUEST_ID 		34
-#define DOT11_MNG_TPC_REPORT_ID			35
-#define DOT11_MNG_SUPP_CHANNELS_ID		36
-#define DOT11_MNG_CHANNEL_SWITCH_ID		37
-#define DOT11_MNG_MEASURE_REQUEST_ID		38
-#define DOT11_MNG_MEASURE_REPORT_ID		39
-#define DOT11_MNG_QUIET_ID			40
-#define DOT11_MNG_IBSS_DFS_ID			41
-#define DOT11_MNG_ERP_ID			42
-#define DOT11_MNG_TS_DELAY_ID			43
-#define	DOT11_MNG_HT_CAP			45
-#define DOT11_MNG_QOS_CAP_ID			46
-#define DOT11_MNG_NONERP_ID			47
 #define DOT11_MNG_RSN_ID			48
-#define DOT11_MNG_EXT_RATES_ID			50
-#define DOT11_MNG_AP_CHREP_ID		51
-#define DOT11_MNG_NBR_REP_ID		52
-#define	DOT11_MNG_REGCLASS_ID			59
-#define DOT11_MNG_EXT_CSA_ID			60
-#define	DOT11_MNG_HT_ADD			61
-#define	DOT11_MNG_EXT_CHANNEL_OFFSET		62
-
-#define DOT11_MNG_RRM_CAP_ID		70
-#define	DOT11_MNG_HT_BSS_COEXINFO_ID		72
-#define	DOT11_MNG_HT_BSS_CHANNEL_REPORT_ID	73
-#define	DOT11_MNG_HT_OBSS_ID			74
-#define	DOT11_MNG_EXT_CAP			127
 #define DOT11_MNG_WPA_ID			221
-#define DOT11_MNG_PROPR_ID			221
-
 #define DOT11_MNG_VS_ID				221
 
-#define DOT11_RATE_BASIC			0x80
-#define DOT11_RATE_MASK				0x7F
-
-#define DOT11_MNG_ERP_LEN			1
-#define DOT11_MNG_NONERP_PRESENT		0x01
-#define DOT11_MNG_USE_PROTECTION		0x02
-#define DOT11_MNG_BARKER_PREAMBLE		0x04
-
-#define DOT11_MGN_TS_DELAY_LEN		4
-#define TS_DELAY_FIELD_SIZE			4
-
 #define DOT11_CAP_ESS				0x0001
 #define DOT11_CAP_IBSS				0x0002
-#define DOT11_CAP_POLLABLE			0x0004
-#define DOT11_CAP_POLL_RQ			0x0008
 #define DOT11_CAP_PRIVACY			0x0010
 #define DOT11_CAP_SHORT				0x0020
-#define DOT11_CAP_PBCC				0x0040
-#define DOT11_CAP_AGILITY			0x0080
-#define DOT11_CAP_SPECTRUM			0x0100
 #define DOT11_CAP_SHORTSLOT			0x0400
-#define DOT11_CAP_RRM			0x1000
-#define DOT11_CAP_CCK_OFDM			0x2000
-
-#define DOT11_OBSS_COEX_MNG_SUPPORT	0x01
-
-#define DOT11_ACTION_HDR_LEN		2
-
-#define DOT11_ACTION_CAT_ERR_MASK	0x80
-#define DOT11_ACTION_CAT_MASK		0x7F
-#define DOT11_ACTION_CAT_SPECT_MNG	0
-#define DOT11_ACTION_CAT_QOS		1
-#define DOT11_ACTION_CAT_DLS		2
-#define DOT11_ACTION_CAT_BLOCKACK	3
-#define DOT11_ACTION_CAT_PUBLIC		4
-#define DOT11_ACTION_CAT_RRM		5
-#define DOT11_ACTION_CAT_HT		7
-#define DOT11_ACTION_NOTIFICATION	17
-#define DOT11_ACTION_CAT_VS		127
-
-#define DOT11_SM_ACTION_M_REQ		0
-#define DOT11_SM_ACTION_M_REP		1
-#define DOT11_SM_ACTION_TPC_REQ		2
-#define DOT11_SM_ACTION_TPC_REP		3
-#define DOT11_SM_ACTION_CHANNEL_SWITCH	4
-#define DOT11_SM_ACTION_EXT_CSA		5
-
-#define DOT11_ACTION_ID_HT_CH_WIDTH	0
-#define DOT11_ACTION_ID_HT_MIMO_PS	1
-
-#define DOT11_PUB_ACTION_BSS_COEX_MNG	0
-#define DOT11_PUB_ACTION_CHANNEL_SWITCH	4
-
-#define DOT11_BA_ACTION_ADDBA_REQ	0
-#define DOT11_BA_ACTION_ADDBA_RESP	1
-#define DOT11_BA_ACTION_DELBA		2
-
-#define DOT11_ADDBA_PARAM_AMSDU_SUP	0x0001
-#define DOT11_ADDBA_PARAM_POLICY_MASK	0x0002
-#define DOT11_ADDBA_PARAM_POLICY_SHIFT	1
-#define DOT11_ADDBA_PARAM_TID_MASK	0x003c
-#define DOT11_ADDBA_PARAM_TID_SHIFT	2
-#define DOT11_ADDBA_PARAM_BSIZE_MASK	0xffc0
-#define DOT11_ADDBA_PARAM_BSIZE_SHIFT	6
-
-#define DOT11_ADDBA_POLICY_DELAYED	0
-#define DOT11_ADDBA_POLICY_IMMEDIATE	1
-
-BWL_PRE_PACKED_STRUCT struct dot11_addba_req {
-	uint8 category;
-	uint8 action;
-	uint8 token;
-	uint16 addba_param_set;
-	uint16 timeout;
-	uint16 start_seqnum;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_addba_req dot11_addba_req_t;
-#define DOT11_ADDBA_REQ_LEN		9
-
-BWL_PRE_PACKED_STRUCT struct dot11_addba_resp {
-	uint8 category;
-	uint8 action;
-	uint8 token;
-	uint16 status;
-	uint16 addba_param_set;
-	uint16 timeout;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_addba_resp dot11_addba_resp_t;
-#define DOT11_ADDBA_RESP_LEN		9
-
-#define DOT11_DELBA_PARAM_INIT_MASK	0x0800
-#define DOT11_DELBA_PARAM_INIT_SHIFT	11
-#define DOT11_DELBA_PARAM_TID_MASK	0xf000
-#define DOT11_DELBA_PARAM_TID_SHIFT	12
-
-BWL_PRE_PACKED_STRUCT struct dot11_delba {
-	uint8 category;
-	uint8 action;
-	uint16 delba_param_set;
-	uint16 reason;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_delba dot11_delba_t;
-#define DOT11_DELBA_LEN			6
-
-#define DOT11_RRM_CAP_LEN		5
-BWL_PRE_PACKED_STRUCT struct dot11_rrm_cap_ie {
-	uint8 cap[DOT11_RRM_CAP_LEN];
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_rrm_cap_ie dot11_rrm_cap_ie_t;
-
-#define DOT11_RRM_CAP_LINK			0
-#define DOT11_RRM_CAP_NEIGHBOR_REPORT	1
-#define DOT11_RRM_CAP_PARALLEL		2
-#define DOT11_RRM_CAP_REPEATED		3
-#define DOT11_RRM_CAP_BCN_PASSIVE	4
-#define DOT11_RRM_CAP_BCN_ACTIVE	5
-#define DOT11_RRM_CAP_BCN_TABLE		6
-#define DOT11_RRM_CAP_BCN_REP_COND	7
-#define DOT11_RRM_CAP_AP_CHANREP	16
-
-#define DOT11_RM_ACTION_RM_REQ		0
-#define DOT11_RM_ACTION_RM_REP		1
-#define DOT11_RM_ACTION_LM_REQ		2
-#define DOT11_RM_ACTION_LM_REP		3
-#define DOT11_RM_ACTION_NR_REQ		4
-#define DOT11_RM_ACTION_NR_REP		5
-
-BWL_PRE_PACKED_STRUCT struct dot11_rm_action {
-	uint8 category;
-	uint8 action;
-	uint8 token;
-	uint8 data[1];
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_rm_action dot11_rm_action_t;
-#define DOT11_RM_ACTION_LEN 3
-
-BWL_PRE_PACKED_STRUCT struct dot11_rmreq {
-	uint8 category;
-	uint8 action;
-	uint8 token;
-	uint16 reps;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_rmreq dot11_rmreq_t;
-#define DOT11_RMREQ_LEN	5
-
-BWL_PRE_PACKED_STRUCT struct dot11_rm_ie {
-	uint8 id;
-	uint8 len;
-	uint8 token;
-	uint8 mode;
-	uint8 type;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_rm_ie dot11_rm_ie_t;
-#define DOT11_RM_IE_LEN	5
-
-#define DOT11_RMREQ_MODE_PARALLEL	1
-#define DOT11_RMREQ_MODE_ENABLE		2
-#define DOT11_RMREQ_MODE_REQUEST	4
-#define DOT11_RMREQ_MODE_REPORT		8
-#define DOT11_RMREQ_MODE_DURMAND	0x10
-
-#define DOT11_RMREP_MODE_LATE		1
-#define DOT11_RMREP_MODE_INCAPABLE	2
-#define DOT11_RMREP_MODE_REFUSED	4
-
-BWL_PRE_PACKED_STRUCT struct dot11_rmreq_bcn {
-	uint8 id;
-	uint8 len;
-	uint8 token;
-	uint8 mode;
-	uint8 type;
-	uint8 reg;
-	uint8 channel;
-	uint16 interval;
-	uint16 duration;
-	uint8 bcn_mode;
-	struct ether_addr bssid;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_rmreq_bcn dot11_rmreq_bcn_t;
-#define DOT11_RMREQ_BCN_LEN	18
-
-BWL_PRE_PACKED_STRUCT struct dot11_rmrep_bcn {
-	uint8 reg;
-	uint8 channel;
-	uint32 starttime[2];
-	uint16 duration;
-	uint8 frame_info;
-	uint8 rcpi;
-	uint8 rsni;
-	struct ether_addr bssid;
-	uint8 antenna_id;
-	uint32 parent_tsf;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_rmrep_bcn dot11_rmrep_bcn_t;
-#define DOT11_RMREP_BCN_LEN	26
-
-#define DOT11_RMREQ_BCN_PASSIVE	0
-#define DOT11_RMREQ_BCN_ACTIVE	1
-#define DOT11_RMREQ_BCN_TABLE	2
-
-#define DOT11_RMREQ_BCN_SSID_ID	0
-#define DOT11_RMREQ_BCN_REPINFO_ID	1
-#define DOT11_RMREQ_BCN_REPDET_ID	2
-#define DOT11_RMREQ_BCN_REQUEST_ID	10
-#define DOT11_RMREQ_BCN_APCHREP_ID	51
-
-#define DOT11_RMREQ_BCN_REPDET_FIXED	0
-#define DOT11_RMREQ_BCN_REPDET_REQUEST	1
-#define DOT11_RMREQ_BCN_REPDET_ALL	2
-
-#define DOT11_RMREP_BCN_FRM_BODY	1
-
-BWL_PRE_PACKED_STRUCT struct dot11_rmrep_nbr {
-	struct ether_addr bssid;
-	uint32 bssid_info;
-	uint8 reg;
-	uint8 channel;
-	uint8 phytype;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_rmrep_nbr dot11_rmrep_nbr_t;
-#define DOT11_RMREP_NBR_LEN	13
 
 #define DOT11_BSSTYPE_INFRASTRUCTURE		0
-#define DOT11_BSSTYPE_INDEPENDENT		1
 #define DOT11_BSSTYPE_ANY			2
 #define DOT11_SCANTYPE_ACTIVE			0
-#define DOT11_SCANTYPE_PASSIVE			1
-
-BWL_PRE_PACKED_STRUCT struct dot11_lmreq {
-	uint8 category;
-	uint8 action;
-	uint8 token;
-	uint8 txpwr;
-	uint8 maxtxpwr;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_lmreq dot11_lmreq_t;
-#define DOT11_LMREQ_LEN	5
-
-BWL_PRE_PACKED_STRUCT struct dot11_lmrep {
-	uint8 category;
-	uint8 action;
-	uint8 token;
-	dot11_tpc_rep_t tpc;
-	uint8 rxant;
-	uint8 txant;
-	uint8 rcpi;
-	uint8 rsni;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_lmrep dot11_lmrep_t;
-#define DOT11_LMREP_LEN	11
 
 #define PREN_PREAMBLE		24
 #define PREN_MM_EXT		12
@@ -1177,7 +216,6 @@ typedef struct dot11_lmrep dot11_lmrep_t;
 
 #define APHY_SLOT_TIME		9
 #define APHY_SIFS_TIME		16
-#define APHY_DIFS_TIME		(APHY_SIFS_TIME + (2 * APHY_SLOT_TIME))
 #define APHY_PREAMBLE_TIME	16
 #define APHY_SIGNAL_TIME	4
 #define APHY_SYMBOL_TIME	4
@@ -1187,10 +225,8 @@ typedef struct dot11_lmrep dot11_lmrep_t;
 
 #define BPHY_SLOT_TIME		20
 #define BPHY_SIFS_TIME		10
-#define BPHY_DIFS_TIME		50
 #define BPHY_PLCP_TIME		192
 #define BPHY_PLCP_SHORT_TIME	96
-#define	BPHY_CWMIN		31
 
 #define DOT11_OFDM_SIGNAL_EXTENSION	6
 
@@ -1199,58 +235,41 @@ typedef struct dot11_lmrep dot11_lmrep_t;
 #define	DOT11_MAXNUMFRAGS	16
 
 typedef struct d11cnt {
-	uint32 txfrag;
-	uint32 txmulti;
-	uint32 txfail;
-	uint32 txretry;
-	uint32 txretrie;
-	uint32 rxdup;
-	uint32 txrts;
-	uint32 txnocts;
-	uint32 txnoack;
-	uint32 rxfrag;
-	uint32 rxmulti;
-	uint32 rxcrc;
-	uint32 txfrmsnt;
-	uint32 rxundec;
+	u32 txfrag;
+	u32 txmulti;
+	u32 txfail;
+	u32 txretry;
+	u32 txretrie;
+	u32 rxdup;
+	u32 txrts;
+	u32 txnocts;
+	u32 txnoack;
+	u32 rxfrag;
+	u32 rxmulti;
+	u32 rxcrc;
+	u32 txfrmsnt;
+	u32 rxundec;
 } d11cnt_t;
 
-#define AB_GUARDCOUNT	10
-
-BWL_PRE_PACKED_STRUCT struct vndr_ie {
-	uchar id;
-	uchar len;
-	uchar oui[3];
-	uchar data[1];
-} BWL_POST_PACKED_STRUCT;
-typedef struct vndr_ie vndr_ie_t;
-
-#define VNDR_IE_HDR_LEN		2
-#define VNDR_IE_MIN_LEN		3
-#define VNDR_IE_MAX_LEN		256
-
 #define MCSSET_LEN	16
-#define MAX_MCS_NUM	(128)
 
 BWL_PRE_PACKED_STRUCT struct ht_cap_ie {
-	uint16 cap;
-	uint8 params;
-	uint8 supp_mcs[MCSSET_LEN];
-	uint16 ext_htcap;
-	uint32 txbf_cap;
-	uint8 as_cap;
+	u16 cap;
+	u8 params;
+	u8 supp_mcs[MCSSET_LEN];
+	u16 ext_htcap;
+	u32 txbf_cap;
+	u8 as_cap;
 } BWL_POST_PACKED_STRUCT;
 typedef struct ht_cap_ie ht_cap_ie_t;
 
 #define HT_CAP_IE_LEN		26
-#define HT_CAP_IE_TYPE		51
 
 #define HT_CAP_LDPC_CODING	0x0001
 #define HT_CAP_40MHZ		0x0002
 #define HT_CAP_MIMO_PS_MASK	0x000C
 #define HT_CAP_MIMO_PS_SHIFT	0x0002
 #define HT_CAP_MIMO_PS_OFF	0x0003
-#define HT_CAP_MIMO_PS_RTS	0x0001
 #define HT_CAP_MIMO_PS_ON	0x0000
 #define HT_CAP_GF		0x0010
 #define HT_CAP_SHORT_GI_20	0x0020
@@ -1258,150 +277,31 @@ typedef struct ht_cap_ie ht_cap_ie_t;
 #define HT_CAP_TX_STBC		0x0080
 #define HT_CAP_RX_STBC_MASK	0x0300
 #define HT_CAP_RX_STBC_SHIFT	8
-#define HT_CAP_DELAYED_BA	0x0400
 #define HT_CAP_MAX_AMSDU	0x0800
 #define HT_CAP_DSSS_CCK	0x1000
-#define HT_CAP_PSMP		0x2000
 #define HT_CAP_40MHZ_INTOLERANT 0x4000
-#define HT_CAP_LSIG_TXOP	0x8000
 
 #define HT_CAP_RX_STBC_NO		0x0
 #define HT_CAP_RX_STBC_ONE_STREAM	0x1
-#define HT_CAP_RX_STBC_TWO_STREAM	0x2
-#define HT_CAP_RX_STBC_THREE_STREAM	0x3
-
-#define HT_MAX_AMSDU		7935
-#define HT_MIN_AMSDU		3835
 
 #define HT_PARAMS_RX_FACTOR_MASK	0x03
-#define HT_PARAMS_DENSITY_MASK		0x1C
-#define HT_PARAMS_DENSITY_SHIFT	2
 
 #define AMPDU_MAX_MPDU_DENSITY	7
-#define AMPDU_RX_FACTOR_8K	0
 #define AMPDU_RX_FACTOR_16K	1
 #define AMPDU_RX_FACTOR_32K	2
 #define AMPDU_RX_FACTOR_64K	3
-#define AMPDU_RX_FACTOR_BASE	8*1024
 
 #define AMPDU_DELIMITER_LEN	4
 
-BWL_PRE_PACKED_STRUCT struct ht_add_ie {
-	uint8 ctl_ch;
-	uint8 byte1;
-	uint16 opmode;
-	uint16 misc_bits;
-	uint8 basic_mcs[MCSSET_LEN];
-} BWL_POST_PACKED_STRUCT;
-typedef struct ht_add_ie ht_add_ie_t;
-
-#define HT_ADD_IE_LEN	22
-#define HT_ADD_IE_TYPE	52
-
-#define HT_BW_ANY		0x04
-#define HT_RIFS_PERMITTED     	0x08
-
-#define HT_OPMODE_MASK	        0x0003
-#define HT_OPMODE_SHIFT		0
-#define HT_OPMODE_PURE		0x0000
-#define HT_OPMODE_OPTIONAL	0x0001
-#define HT_OPMODE_HT20IN40	0x0002
-#define HT_OPMODE_MIXED	0x0003
-#define HT_OPMODE_NONGF	0x0004
 #define DOT11N_TXBURST		0x0008
-#define DOT11N_OBSS_NONHT	0x0010
-
-#define HT_BASIC_STBC_MCS	0x007f
-#define HT_DUAL_STBC_PROT	0x0080
-#define HT_SECOND_BCN		0x0100
-#define HT_LSIG_TXOP		0x0200
-#define HT_PCO_ACTIVE		0x0400
-#define HT_PCO_PHASE		0x0800
-
-#define DOT11N_2G_TXBURST_LIMIT	6160
-#define DOT11N_5G_TXBURST_LIMIT	3080
-
-#define GET_HT_OPMODE(add_ie)	\
-	((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_MASK)  >> HT_OPMODE_SHIFT)
-#define HT_MIXEDMODE_PRESENT(add_ie)	\
-	((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_MASK) == HT_OPMODE_MIXED)
-#define HT_HT20_PRESENT(add_ie)	\
-	((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_MASK) == HT_OPMODE_HT20IN40)
-#define HT_OPTIONAL_PRESENT(add_ie)	\
-	((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_MASK) == HT_OPMODE_OPTIONAL)
-#define HT_USE_PROTECTION(add_ie)	\
-	(HT_HT20_PRESENT((add_ie)) || HT_MIXEDMODE_PRESENT((add_ie)))
-#define HT_NONGF_PRESENT(add_ie)	\
-	((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_NONGF) == HT_OPMODE_NONGF)
-#define DOT11N_TXBURST_PRESENT(add_ie)	\
-	((ltoh16_ua(&add_ie->opmode) & DOT11N_TXBURST) == DOT11N_TXBURST)
-#define DOT11N_OBSS_NONHT_PRESENT(add_ie)	\
-	((ltoh16_ua(&add_ie->opmode) & DOT11N_OBSS_NONHT) == DOT11N_OBSS_NONHT)
-
-BWL_PRE_PACKED_STRUCT struct obss_params {
-	uint16 passive_dwell;
-	uint16 active_dwell;
-	uint16 bss_widthscan_interval;
-	uint16 passive_total;
-	uint16 active_total;
-	uint16 chanwidth_transition_dly;
-	uint16 activity_threshold;
-} BWL_POST_PACKED_STRUCT;
-typedef struct obss_params obss_params_t;
-
-BWL_PRE_PACKED_STRUCT struct dot11_obss_ie {
-	uint8 id;
-	uint8 len;
-	obss_params_t obss_params;
-} BWL_POST_PACKED_STRUCT;
-typedef struct dot11_obss_ie dot11_obss_ie_t;
-#define DOT11_OBSS_SCAN_IE_LEN	sizeof(obss_params_t)
-
-#define HT_CTRL_LA_TRQ		0x00000002
-#define HT_CTRL_LA_MAI		0x0000003C
-#define HT_CTRL_LA_MAI_SHIFT	2
-#define HT_CTRL_LA_MAI_MRQ	0x00000004
-#define HT_CTRL_LA_MAI_MSI	0x00000038
-#define HT_CTRL_LA_MFSI		0x000001C0
-#define HT_CTRL_LA_MFSI_SHIFT	6
-#define HT_CTRL_LA_MFB_ASELC	0x0000FE00
-#define HT_CTRL_LA_MFB_ASELC_SH	9
-#define HT_CTRL_LA_ASELC_CMD	0x00000C00
-#define HT_CTRL_LA_ASELC_DATA	0x0000F000
-#define HT_CTRL_CAL_POS		0x00030000
-#define HT_CTRL_CAL_SEQ		0x000C0000
-#define HT_CTRL_CSI_STEERING	0x00C00000
-#define HT_CTRL_CSI_STEER_SHIFT	22
-#define HT_CTRL_CSI_STEER_NFB	0
-#define HT_CTRL_CSI_STEER_CSI	1
-#define HT_CTRL_CSI_STEER_NCOM	2
-#define HT_CTRL_CSI_STEER_COM	3
-#define HT_CTRL_NDP_ANNOUNCE	0x01000000
-#define HT_CTRL_AC_CONSTRAINT	0x40000000
-#define HT_CTRL_RDG_MOREPPDU	0x80000000
-
-#define HT_OPMODE_OPTIONAL	0x0001
-#define HT_OPMODE_HT20IN40	0x0002
-#define HT_OPMODE_MIXED	0x0003
-#define HT_OPMODE_NONGF	0x0004
-#define DOT11N_TXBURST		0x0008
-#define DOT11N_OBSS_NONHT	0x0010
 
 #define WPA_VERSION		1
 #define WPA_OUI			"\x00\x50\xF2"
 
-#define WPA2_VERSION		1
-#define WPA2_VERSION_LEN	2
-#define WPA2_OUI		"\x00\x0F\xAC"
-
-#define WPA_OUI_LEN	3
-
 #define WFA_OUI			"\x00\x50\xF2"
 #define WFA_OUI_LEN	3
 
 #define WFA_OUI_TYPE_WPA	1
-#define WFA_OUI_TYPE_WPS	4
-#define WFA_OUI_TYPE_P2P	9
 
 #define RSN_AKM_NONE		0
 #define RSN_AKM_UNSPECIFIED	1
@@ -1409,28 +309,14 @@ typedef struct dot11_obss_ie dot11_obss_ie_t;
 
 #define DOT11_MAX_DEFAULT_KEYS	4
 #define DOT11_MAX_KEY_SIZE	32
-#define DOT11_MAX_IV_SIZE	16
-#define DOT11_EXT_IV_FLAG	(1<<5)
 #define DOT11_WPA_KEY_RSC_LEN   8
 
 #define WEP1_KEY_SIZE		5
-#define WEP1_KEY_HEX_SIZE	10
 #define WEP128_KEY_SIZE		13
-#define WEP128_KEY_HEX_SIZE	26
-#define TKIP_MIC_SIZE		8
-#define TKIP_EOM_SIZE		7
-#define TKIP_EOM_FLAG		0x5a
 #define TKIP_KEY_SIZE		32
-#define TKIP_MIC_AUTH_TX	16
-#define TKIP_MIC_AUTH_RX	24
-#define TKIP_MIC_SUP_RX		TKIP_MIC_AUTH_TX
-#define TKIP_MIC_SUP_TX		TKIP_MIC_AUTH_RX
 #define AES_KEY_SIZE		16
-#define AES_MIC_SIZE		8
-
-#define WCN_OUI			"\x00\x50\xf2"
-#define WCN_TYPE		4
 
+#define BRCM_OUI		"\x00\x10\x18"
 #include <packed_section_end.h>
 
 #endif				/* _802_11_H_ */
diff --git a/drivers/staging/brcm80211/include/proto/802.11e.h b/drivers/staging/brcm80211/include/proto/802.11e.h
deleted file mode 100644
index f331e6d..0000000
--- a/drivers/staging/brcm80211/include/proto/802.11e.h
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Copyright (c) 2010 Broadcom Corporation
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#ifndef _802_11e_H_
-#define _802_11e_H_
-
-#ifndef _TYPEDEFS_H_
-#include <typedefs.h>
-#endif
-
-#include <packed_section_start.h>
-
-#define WME_TSPEC_HDR_LEN           2
-#define WME_TSPEC_BODY_OFF          2
-
-#define WME_CATEGORY_CODE_OFFSET	0
-#define WME_ACTION_CODE_OFFSET		1
-#define WME_TOKEN_CODE_OFFSET		2
-#define WME_STATUS_CODE_OFFSET		3
-
-BWL_PRE_PACKED_STRUCT struct tsinfo {
-	uint8 octets[3];
-} BWL_POST_PACKED_STRUCT;
-
-typedef struct tsinfo tsinfo_t;
-
-typedef BWL_PRE_PACKED_STRUCT struct tspec {
-	uint8 oui[DOT11_OUI_LEN];
-	uint8 type;
-	uint8 subtype;
-	uint8 version;
-	tsinfo_t tsinfo;
-	uint16 nom_msdu_size;
-	uint16 max_msdu_size;
-	uint32 min_srv_interval;
-	uint32 max_srv_interval;
-	uint32 inactivity_interval;
-	uint32 suspension_interval;
-	uint32 srv_start_time;
-	uint32 min_data_rate;
-	uint32 mean_data_rate;
-	uint32 peak_data_rate;
-	uint32 max_burst_size;
-	uint32 delay_bound;
-	uint32 min_phy_rate;
-	uint16 surplus_bw;
-	uint16 medium_time;
-} BWL_POST_PACKED_STRUCT tspec_t;
-
-#define WME_TSPEC_LEN	(sizeof(tspec_t))
-
-#define TS_INFO_TID_SHIFT		1
-#define TS_INFO_TID_MASK		(0xf << TS_INFO_TID_SHIFT)
-#define TS_INFO_CONTENTION_SHIFT	7
-#define TS_INFO_CONTENTION_MASK		(0x1 << TS_INFO_CONTENTION_SHIFT)
-#define TS_INFO_DIRECTION_SHIFT		5
-#define TS_INFO_DIRECTION_MASK		(0x3 << TS_INFO_DIRECTION_SHIFT)
-#define TS_INFO_PSB_SHIFT		2
-#define TS_INFO_PSB_MASK		(1 << TS_INFO_PSB_SHIFT)
-#define TS_INFO_UPLINK			(0 << TS_INFO_DIRECTION_SHIFT)
-#define TS_INFO_DOWNLINK		(1 << TS_INFO_DIRECTION_SHIFT)
-#define TS_INFO_BIDIRECTIONAL		(3 << TS_INFO_DIRECTION_SHIFT)
-#define TS_INFO_USER_PRIO_SHIFT		3
-#define TS_INFO_USER_PRIO_MASK		(0x7 << TS_INFO_USER_PRIO_SHIFT)
-
-#define WLC_CAC_GET_TID(pt)	((((pt).octets[0]) & \
-	TS_INFO_TID_MASK) >> TS_INFO_TID_SHIFT)
-#define WLC_CAC_GET_DIR(pt)	((((pt).octets[0]) & \
-	TS_INFO_DIRECTION_MASK) >> TS_INFO_DIRECTION_SHIFT)
-#define WLC_CAC_GET_PSB(pt)	((((pt).octets[1]) & \
-	TS_INFO_PSB_MASK) >> TS_INFO_PSB_SHIFT)
-#define WLC_CAC_GET_USER_PRIO(pt)	((((pt).octets[1]) & \
-	TS_INFO_USER_PRIO_MASK) >> TS_INFO_USER_PRIO_SHIFT)
-
-#define WLC_CAC_SET_TID(pt, id)	((((pt).octets[0]) & (~TS_INFO_TID_MASK)) | \
-	((id) << TS_INFO_TID_SHIFT))
-#define WLC_CAC_SET_USER_PRIO(pt, prio)	((((pt).octets[0]) & \
-	(~TS_INFO_USER_PRIO_MASK)) | ((prio) << TS_INFO_USER_PRIO_SHIFT))
-
-#define QBSS_LOAD_IE_LEN		5
-#define QBSS_LOAD_AAC_OFF		3
-
-#define CAC_ADDTS_RESP_TIMEOUT		300
-
-#define DOT11E_STATUS_ADMISSION_ACCEPTED	0
-#define DOT11E_STATUS_ADDTS_INVALID_PARAM	1
-#define DOT11E_STATUS_ADDTS_REFUSED_NSBW	3
-#define DOT11E_STATUS_ADDTS_REFUSED_AWHILE	47
-
-#define DOT11E_STATUS_QSTA_LEAVE_QBSS		36
-#define DOT11E_STATUS_END_TS			37
-#define DOT11E_STATUS_UNKNOWN_TS		38
-#define DOT11E_STATUS_QSTA_REQ_TIMEOUT		39
-
-#include <packed_section_end.h>
-
-#endif				/* _802_11e_H_ */
diff --git a/drivers/staging/brcm80211/include/proto/bcmeth.h b/drivers/staging/brcm80211/include/proto/bcmeth.h
new file mode 100644
index 0000000..f7d3d8d
--- /dev/null
+++ b/drivers/staging/brcm80211/include/proto/bcmeth.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _BCMETH_H_
+#define _BCMETH_H_
+
+#include <packed_section_start.h>
+
+#define	BCMILCP_SUBTYPE_RATE		1
+#define	BCMILCP_SUBTYPE_LINK		2
+#define	BCMILCP_SUBTYPE_CSA		3
+#define	BCMILCP_SUBTYPE_LARQ		4
+#define BCMILCP_SUBTYPE_VENDOR		5
+#define	BCMILCP_SUBTYPE_FLH		17
+#define BCMILCP_SUBTYPE_VENDOR_LONG	32769
+#define BCMILCP_SUBTYPE_CERT		32770
+#define BCMILCP_SUBTYPE_SES		32771
+#define BCMILCP_BCM_SUBTYPE_RESERVED		0
+#define BCMILCP_BCM_SUBTYPE_EVENT		1
+#define BCMILCP_BCM_SUBTYPE_SES			2
+#define BCMILCP_BCM_SUBTYPE_DPT			4
+#define BCMILCP_BCM_SUBTYPEHDR_MINLENGTH	8
+#define BCMILCP_BCM_SUBTYPEHDR_VERSION		0
+
+typedef BWL_PRE_PACKED_STRUCT struct bcmeth_hdr {
+	u16 subtype;
+	u16 length;
+	u8 version;
+	u8 oui[3];
+	u16 usr_subtype;
+} BWL_POST_PACKED_STRUCT bcmeth_hdr_t;
+
+#include <packed_section_end.h>
+
+#endif				/* _BCMETH_H_ */
diff --git a/drivers/staging/brcm80211/include/proto/bcmevent.h b/drivers/staging/brcm80211/include/proto/bcmevent.h
index 37257f9..865d157 100644
--- a/drivers/staging/brcm80211/include/proto/bcmevent.h
+++ b/drivers/staging/brcm80211/include/proto/bcmevent.h
@@ -17,10 +17,6 @@
 #ifndef _BCMEVENT_H_
 #define _BCMEVENT_H_
 
-#ifndef _TYPEDEFS_H_
-#include <typedefs.h>
-#endif
-
 #include <packed_section_start.h>
 
 #define BCM_EVENT_MSG_VERSION		1
@@ -31,17 +27,24 @@
 #define WLC_EVENT_MSG_GROUP		0x04
 
 typedef BWL_PRE_PACKED_STRUCT struct {
-	uint16 version;
-	uint16 flags;
-	uint32 event_type;
-	uint32 status;
-	uint32 reason;
-	uint32 auth_type;
-	uint32 datalen;
+	u16 version;
+	u16 flags;
+	u32 event_type;
+	u32 status;
+	u32 reason;
+	u32 auth_type;
+	u32 datalen;
 	struct ether_addr addr;
 	char ifname[BCM_MSG_IFNAME_MAX];
 } BWL_POST_PACKED_STRUCT wl_event_msg_t;
 
+#ifdef BRCM_FULLMAC
+typedef BWL_PRE_PACKED_STRUCT struct bcm_event {
+	struct ether_header eth;
+	bcmeth_hdr_t		bcm_hdr;
+	wl_event_msg_t		event;
+} BWL_POST_PACKED_STRUCT bcm_event_t;
+#endif
 #define BCM_MSG_LEN	(sizeof(bcm_event_t) - sizeof(bcmeth_hdr_t) - \
 	sizeof(struct ether_header))
 
@@ -189,11 +192,11 @@ extern const int bcmevent_names_size;
 #define WLC_E_SUP_DEAUTH		14
 
 typedef struct wl_event_data_if {
-	uint8 ifidx;
-	uint8 opcode;
-	uint8 reserved;
-	uint8 bssidx;
-	uint8 role;
+	u8 ifidx;
+	u8 opcode;
+	u8 reserved;
+	u8 bssidx;
+	u8 role;
 } wl_event_data_if_t;
 
 #define WLC_E_IF_ADD		1
diff --git a/drivers/staging/brcm80211/include/proto/ethernet.h b/drivers/staging/brcm80211/include/proto/ethernet.h
index 9d90b8d..cc17b42 100644
--- a/drivers/staging/brcm80211/include/proto/ethernet.h
+++ b/drivers/staging/brcm80211/include/proto/ethernet.h
@@ -17,9 +17,6 @@
 #ifndef _NET_ETHERNET_H_
 #define _NET_ETHERNET_H_
 
-#ifndef _TYPEDEFS_H_
-#include "typedefs.h"
-#endif
 #include <packed_section_start.h>
 
 #define	ETHER_ADDR_LEN		6
@@ -47,59 +44,59 @@
 	((foo) >= ETHER_MIN_LEN && (foo) <= ETHER_MAX_LEN)
 
 #define ETHER_FILL_MCAST_ADDR_FROM_IP(ea, mgrp_ip) {		\
-		((uint8 *)ea)[0] = 0x01;			\
-		((uint8 *)ea)[1] = 0x00;			\
-		((uint8 *)ea)[2] = 0x5e;			\
-		((uint8 *)ea)[3] = ((mgrp_ip) >> 16) & 0x7f;	\
-		((uint8 *)ea)[4] = ((mgrp_ip) >>  8) & 0xff;	\
-		((uint8 *)ea)[5] = ((mgrp_ip) >>  0) & 0xff;	\
+		((u8 *)ea)[0] = 0x01;			\
+		((u8 *)ea)[1] = 0x00;			\
+		((u8 *)ea)[2] = 0x5e;			\
+		((u8 *)ea)[3] = ((mgrp_ip) >> 16) & 0x7f;	\
+		((u8 *)ea)[4] = ((mgrp_ip) >>  8) & 0xff;	\
+		((u8 *)ea)[5] = ((mgrp_ip) >>  0) & 0xff;	\
 }
 
 BWL_PRE_PACKED_STRUCT struct ether_header {
-	uint8 ether_dhost[ETHER_ADDR_LEN];
-	uint8 ether_shost[ETHER_ADDR_LEN];
-	uint16 ether_type;
+	u8 ether_dhost[ETHER_ADDR_LEN];
+	u8 ether_shost[ETHER_ADDR_LEN];
+	u16 ether_type;
 } BWL_POST_PACKED_STRUCT;
 
 BWL_PRE_PACKED_STRUCT struct ether_addr {
-	uint8 octet[ETHER_ADDR_LEN];
+	u8 octet[ETHER_ADDR_LEN];
 } BWL_POST_PACKED_STRUCT;
 
-#define ETHER_SET_LOCALADDR(ea)	(((uint8 *)(ea))[0] = (((uint8 *)(ea))[0] | 2))
-#define ETHER_IS_LOCALADDR(ea) 	(((uint8 *)(ea))[0] & 2)
-#define ETHER_CLR_LOCALADDR(ea)	(((uint8 *)(ea))[0] = \
-	(((uint8 *)(ea))[0] & 0xd))
-#define ETHER_TOGGLE_LOCALADDR(ea)	(((uint8 *)(ea))[0] = \
-	(((uint8 *)(ea))[0] ^ 2))
+#define ETHER_SET_LOCALADDR(ea)	(((u8 *)(ea))[0] = (((u8 *)(ea))[0] | 2))
+#define ETHER_IS_LOCALADDR(ea) 	(((u8 *)(ea))[0] & 2)
+#define ETHER_CLR_LOCALADDR(ea)	(((u8 *)(ea))[0] = \
+	(((u8 *)(ea))[0] & 0xd))
+#define ETHER_TOGGLE_LOCALADDR(ea)	(((u8 *)(ea))[0] = \
+	(((u8 *)(ea))[0] ^ 2))
 
-#define ETHER_SET_UNICAST(ea)	(((uint8 *)(ea))[0] = (((uint8 *)(ea))[0] & ~1))
+#define ETHER_SET_UNICAST(ea)	(((u8 *)(ea))[0] = (((u8 *)(ea))[0] & ~1))
 
-#define ETHER_ISMULTI(ea) (((const uint8 *)(ea))[0] & 1)
+#define ETHER_ISMULTI(ea) (((const u8 *)(ea))[0] & 1)
 
-#define	ether_cmp(a, b)	(!(((short*)a)[0] == ((short*)b)[0]) | \
-			 !(((short*)a)[1] == ((short*)b)[1]) | \
-			 !(((short*)a)[2] == ((short*)b)[2]))
+#define	ether_cmp(a, b)	(!(((short *)a)[0] == ((short *)b)[0]) | \
+			 !(((short *)a)[1] == ((short *)b)[1]) | \
+			 !(((short *)a)[2] == ((short *)b)[2]))
 
 #define	ether_copy(s, d) { \
-		((short*)d)[0] = ((short*)s)[0]; \
-		((short*)d)[1] = ((short*)s)[1]; \
-		((short*)d)[2] = ((short*)s)[2]; }
+		((short *)d)[0] = ((short *)s)[0]; \
+		((short *)d)[1] = ((short *)s)[1]; \
+		((short *)d)[2] = ((short *)s)[2]; }
 
 static const struct ether_addr ether_bcast = { {255, 255, 255, 255, 255, 255} };
 static const struct ether_addr ether_null = { {0, 0, 0, 0, 0, 0} };
 
-#define ETHER_ISBCAST(ea)	((((uint8 *)(ea))[0] &		\
-	((uint8 *)(ea))[1] &		\
-	((uint8 *)(ea))[2] &		\
-	((uint8 *)(ea))[3] &		\
-	((uint8 *)(ea))[4] &		\
-	((uint8 *)(ea))[5]) == 0xff)
-#define ETHER_ISNULLADDR(ea)	((((uint8 *)(ea))[0] |		\
-	((uint8 *)(ea))[1] |		\
-	((uint8 *)(ea))[2] |		\
-	((uint8 *)(ea))[3] |		\
-	((uint8 *)(ea))[4] |		\
-	((uint8 *)(ea))[5]) == 0)
+#define ETHER_ISBCAST(ea)	((((u8 *)(ea))[0] &		\
+	((u8 *)(ea))[1] &		\
+	((u8 *)(ea))[2] &		\
+	((u8 *)(ea))[3] &		\
+	((u8 *)(ea))[4] &		\
+	((u8 *)(ea))[5]) == 0xff)
+#define ETHER_ISNULLADDR(ea)	((((u8 *)(ea))[0] |		\
+	((u8 *)(ea))[1] |		\
+	((u8 *)(ea))[2] |		\
+	((u8 *)(ea))[3] |		\
+	((u8 *)(ea))[4] |		\
+	((u8 *)(ea))[5]) == 0)
 
 #define ETHER_MOVE_HDR(d, s) \
 do { \
diff --git a/drivers/staging/brcm80211/include/proto/wpa.h b/drivers/staging/brcm80211/include/proto/wpa.h
index 7512e1a..ec84c9f 100644
--- a/drivers/staging/brcm80211/include/proto/wpa.h
+++ b/drivers/staging/brcm80211/include/proto/wpa.h
@@ -17,7 +17,6 @@
 #ifndef _proto_wpa_h_
 #define _proto_wpa_h_
 
-#include <typedefs.h>
 #include <proto/ethernet.h>
 
 #include <packed_section_start.h>
@@ -37,13 +36,13 @@
 #define WPA2_PMKID_LEN	16
 
 typedef BWL_PRE_PACKED_STRUCT struct {
-	uint8 tag;
-	uint8 length;
-	uint8 oui[3];
-	uint8 oui_type;
+	u8 tag;
+	u8 length;
+	u8 oui[3];
+	u8 oui_type;
 	BWL_PRE_PACKED_STRUCT struct {
-		uint8 low;
-		uint8 high;
+		u8 low;
+		u8 high;
 	} BWL_POST_PACKED_STRUCT version;
 } BWL_POST_PACKED_STRUCT wpa_ie_fixed_t;
 #define WPA_IE_OUITYPE_LEN	4
@@ -51,35 +50,35 @@ typedef BWL_PRE_PACKED_STRUCT struct {
 #define WPA_IE_TAG_FIXED_LEN	6
 
 typedef BWL_PRE_PACKED_STRUCT struct {
-	uint8 tag;
-	uint8 length;
+	u8 tag;
+	u8 length;
 	BWL_PRE_PACKED_STRUCT struct {
-		uint8 low;
-		uint8 high;
+		u8 low;
+		u8 high;
 	} BWL_POST_PACKED_STRUCT version;
 } BWL_POST_PACKED_STRUCT wpa_rsn_ie_fixed_t;
 #define WPA_RSN_IE_FIXED_LEN	4
 #define WPA_RSN_IE_TAG_FIXED_LEN	2
-typedef uint8 wpa_pmkid_t[WPA2_PMKID_LEN];
+typedef u8 wpa_pmkid_t[WPA2_PMKID_LEN];
 
 typedef BWL_PRE_PACKED_STRUCT struct {
-	uint8 oui[3];
-	uint8 type;
+	u8 oui[3];
+	u8 type;
 } BWL_POST_PACKED_STRUCT wpa_suite_t, wpa_suite_mcast_t;
 #define WPA_SUITE_LEN	4
 
 typedef BWL_PRE_PACKED_STRUCT struct {
 	BWL_PRE_PACKED_STRUCT struct {
-		uint8 low;
-		uint8 high;
+		u8 low;
+		u8 high;
 	} BWL_POST_PACKED_STRUCT count;
 	wpa_suite_t list[1];
 } BWL_POST_PACKED_STRUCT wpa_suite_ucast_t, wpa_suite_auth_key_mgmt_t;
 #define WPA_IE_SUITE_COUNT_LEN	2
 typedef BWL_PRE_PACKED_STRUCT struct {
 	BWL_PRE_PACKED_STRUCT struct {
-		uint8 low;
-		uint8 high;
+		u8 low;
+		u8 high;
 	} BWL_POST_PACKED_STRUCT count;
 	wpa_pmkid_t list[1];
 } BWL_POST_PACKED_STRUCT wpa_pmkid_list_t;
diff --git a/drivers/staging/brcm80211/include/qmath.h b/drivers/staging/brcm80211/include/qmath.h
index 594fb02..5f525db 100644
--- a/drivers/staging/brcm80211/include/qmath.h
+++ b/drivers/staging/brcm80211/include/qmath.h
@@ -17,64 +17,62 @@
 #ifndef __QMATH_H__
 #define __QMATH_H__
 
-#include <typedefs.h>
+s16 qm_sat32(s32 op);
 
-int16 qm_sat32(int32 op);
+s32 qm_mul321616(s16 op1, s16 op2);
 
-int32 qm_mul321616(int16 op1, int16 op2);
+s16 qm_mul16(s16 op1, s16 op2);
 
-int16 qm_mul16(int16 op1, int16 op2);
+s32 qm_muls321616(s16 op1, s16 op2);
 
-int32 qm_muls321616(int16 op1, int16 op2);
+u16 qm_mulu16(u16 op1, u16 op2);
 
-uint16 qm_mulu16(uint16 op1, uint16 op2);
+s16 qm_muls16(s16 op1, s16 op2);
 
-int16 qm_muls16(int16 op1, int16 op2);
+s32 qm_add32(s32 op1, s32 op2);
 
-int32 qm_add32(int32 op1, int32 op2);
+s16 qm_add16(s16 op1, s16 op2);
 
-int16 qm_add16(int16 op1, int16 op2);
+s16 qm_sub16(s16 op1, s16 op2);
 
-int16 qm_sub16(int16 op1, int16 op2);
+s32 qm_sub32(s32 op1, s32 op2);
 
-int32 qm_sub32(int32 op1, int32 op2);
+s32 qm_mac321616(s32 acc, s16 op1, s16 op2);
 
-int32 qm_mac321616(int32 acc, int16 op1, int16 op2);
+s32 qm_shl32(s32 op, int shift);
 
-int32 qm_shl32(int32 op, int shift);
+s32 qm_shr32(s32 op, int shift);
 
-int32 qm_shr32(int32 op, int shift);
+s16 qm_shl16(s16 op, int shift);
 
-int16 qm_shl16(int16 op, int shift);
+s16 qm_shr16(s16 op, int shift);
 
-int16 qm_shr16(int16 op, int shift);
+s16 qm_norm16(s16 op);
 
-int16 qm_norm16(int16 op);
+s16 qm_norm32(s32 op);
 
-int16 qm_norm32(int32 op);
+s16 qm_div_s(s16 num, s16 denom);
 
-int16 qm_div_s(int16 num, int16 denom);
+s16 qm_abs16(s16 op);
 
-int16 qm_abs16(int16 op);
+s16 qm_div16(s16 num, s16 denom, s16 *qQuotient);
 
-int16 qm_div16(int16 num, int16 denom, int16 * qQuotient);
+s32 qm_abs32(s32 op);
 
-int32 qm_abs32(int32 op);
+s16 qm_div163232(s32 num, s32 denom, s16 *qquotient);
 
-int16 qm_div163232(int32 num, int32 denom, int16 * qquotient);
+s32 qm_mul323216(s32 op1, s16 op2);
 
-int32 qm_mul323216(int32 op1, int16 op2);
+s32 qm_mulsu321616(s16 op1, u16 op2);
 
-int32 qm_mulsu321616(int16 op1, uint16 op2);
+s32 qm_muls323216(s32 op1, s16 op2);
 
-int32 qm_muls323216(int32 op1, int16 op2);
+s32 qm_mul32(s32 a, s32 b);
 
-int32 qm_mul32(int32 a, int32 b);
+s32 qm_muls32(s32 a, s32 b);
 
-int32 qm_muls32(int32 a, int32 b);
+void qm_log10(s32 N, s16 qN, s16 *log10N, s16 *qLog10N);
 
-void qm_log10(int32 N, int16 qN, int16 * log10N, int16 * qLog10N);
-
-void qm_1byN(int32 N, int16 qN, int32 * result, int16 * qResult);
+void qm_1byN(s32 N, s16 qN, s32 *result, s16 *qResult);
 
 #endif				/* #ifndef __QMATH_H__ */
diff --git a/drivers/staging/brcm80211/include/rpc_osl.h b/drivers/staging/brcm80211/include/rpc_osl.h
index 845808e..4a26480 100644
--- a/drivers/staging/brcm80211/include/rpc_osl.h
+++ b/drivers/staging/brcm80211/include/rpc_osl.h
@@ -18,16 +18,16 @@
 #define _rpcosl_h_
 
 typedef struct rpc_osl rpc_osl_t;
-extern rpc_osl_t *rpc_osl_attach(osl_t * osh);
-extern void rpc_osl_detach(rpc_osl_t * rpc_osh);
+extern rpc_osl_t *rpc_osl_attach(osl_t *osh);
+extern void rpc_osl_detach(rpc_osl_t *rpc_osh);
 
 #define RPC_OSL_LOCK(rpc_osh) rpc_osl_lock((rpc_osh))
 #define RPC_OSL_UNLOCK(rpc_osh) rpc_osl_unlock((rpc_osh))
 #define RPC_OSL_WAIT(rpc_osh, to, ptimedout)	rpc_osl_wait((rpc_osh), (to), (ptimedout))
 #define RPC_OSL_WAKE(rpc_osh)			rpc_osl_wake((rpc_osh))
-extern void rpc_osl_lock(rpc_osl_t * rpc_osh);
-extern void rpc_osl_unlock(rpc_osl_t * rpc_osh);
-extern int rpc_osl_wait(rpc_osl_t * rpc_osh, uint ms, bool * ptimedout);
-extern void rpc_osl_wake(rpc_osl_t * rpc_osh);
+extern void rpc_osl_lock(rpc_osl_t *rpc_osh);
+extern void rpc_osl_unlock(rpc_osl_t *rpc_osh);
+extern int rpc_osl_wait(rpc_osl_t *rpc_osh, uint ms, bool *ptimedout);
+extern void rpc_osl_wake(rpc_osl_t *rpc_osh);
 
 #endif				/* _rpcosl_h_ */
diff --git a/drivers/staging/brcm80211/include/sbchipc.h b/drivers/staging/brcm80211/include/sbchipc.h
index eb765a9..f608894 100644
--- a/drivers/staging/brcm80211/include/sbchipc.h
+++ b/drivers/staging/brcm80211/include/sbchipc.h
@@ -27,200 +27,200 @@
 #endif				/* PAD */
 
 typedef volatile struct {
-	uint32 chipid;		/* 0x0 */
-	uint32 capabilities;
-	uint32 corecontrol;	/* corerev >= 1 */
-	uint32 bist;
+	u32 chipid;		/* 0x0 */
+	u32 capabilities;
+	u32 corecontrol;	/* corerev >= 1 */
+	u32 bist;
 
 	/* OTP */
-	uint32 otpstatus;	/* 0x10, corerev >= 10 */
-	uint32 otpcontrol;
-	uint32 otpprog;
-	uint32 otplayout;	/* corerev >= 23 */
+	u32 otpstatus;	/* 0x10, corerev >= 10 */
+	u32 otpcontrol;
+	u32 otpprog;
+	u32 otplayout;	/* corerev >= 23 */
 
 	/* Interrupt control */
-	uint32 intstatus;	/* 0x20 */
-	uint32 intmask;
+	u32 intstatus;	/* 0x20 */
+	u32 intmask;
 
 	/* Chip specific regs */
-	uint32 chipcontrol;	/* 0x28, rev >= 11 */
-	uint32 chipstatus;	/* 0x2c, rev >= 11 */
+	u32 chipcontrol;	/* 0x28, rev >= 11 */
+	u32 chipstatus;	/* 0x2c, rev >= 11 */
 
 	/* Jtag Master */
-	uint32 jtagcmd;		/* 0x30, rev >= 10 */
-	uint32 jtagir;
-	uint32 jtagdr;
-	uint32 jtagctrl;
+	u32 jtagcmd;		/* 0x30, rev >= 10 */
+	u32 jtagir;
+	u32 jtagdr;
+	u32 jtagctrl;
 
 	/* serial flash interface registers */
-	uint32 flashcontrol;	/* 0x40 */
-	uint32 flashaddress;
-	uint32 flashdata;
-	uint32 PAD[1];
+	u32 flashcontrol;	/* 0x40 */
+	u32 flashaddress;
+	u32 flashdata;
+	u32 PAD[1];
 
 	/* Silicon backplane configuration broadcast control */
-	uint32 broadcastaddress;	/* 0x50 */
-	uint32 broadcastdata;
+	u32 broadcastaddress;	/* 0x50 */
+	u32 broadcastdata;
 
 	/* gpio - cleared only by power-on-reset */
-	uint32 gpiopullup;	/* 0x58, corerev >= 20 */
-	uint32 gpiopulldown;	/* 0x5c, corerev >= 20 */
-	uint32 gpioin;		/* 0x60 */
-	uint32 gpioout;		/* 0x64 */
-	uint32 gpioouten;	/* 0x68 */
-	uint32 gpiocontrol;	/* 0x6C */
-	uint32 gpiointpolarity;	/* 0x70 */
-	uint32 gpiointmask;	/* 0x74 */
+	u32 gpiopullup;	/* 0x58, corerev >= 20 */
+	u32 gpiopulldown;	/* 0x5c, corerev >= 20 */
+	u32 gpioin;		/* 0x60 */
+	u32 gpioout;		/* 0x64 */
+	u32 gpioouten;	/* 0x68 */
+	u32 gpiocontrol;	/* 0x6C */
+	u32 gpiointpolarity;	/* 0x70 */
+	u32 gpiointmask;	/* 0x74 */
 
 	/* GPIO events corerev >= 11 */
-	uint32 gpioevent;
-	uint32 gpioeventintmask;
+	u32 gpioevent;
+	u32 gpioeventintmask;
 
 	/* Watchdog timer */
-	uint32 watchdog;	/* 0x80 */
+	u32 watchdog;	/* 0x80 */
 
 	/* GPIO events corerev >= 11 */
-	uint32 gpioeventintpolarity;
+	u32 gpioeventintpolarity;
 
 	/* GPIO based LED powersave registers corerev >= 16 */
-	uint32 gpiotimerval;	/* 0x88 */
-	uint32 gpiotimeroutmask;
+	u32 gpiotimerval;	/* 0x88 */
+	u32 gpiotimeroutmask;
 
 	/* clock control */
-	uint32 clockcontrol_n;	/* 0x90 */
-	uint32 clockcontrol_sb;	/* aka m0 */
-	uint32 clockcontrol_pci;	/* aka m1 */
-	uint32 clockcontrol_m2;	/* mii/uart/mipsref */
-	uint32 clockcontrol_m3;	/* cpu */
-	uint32 clkdiv;		/* corerev >= 3 */
-	uint32 gpiodebugsel;	/* corerev >= 28 */
-	uint32 capabilities_ext;	/* 0xac  */
+	u32 clockcontrol_n;	/* 0x90 */
+	u32 clockcontrol_sb;	/* aka m0 */
+	u32 clockcontrol_pci;	/* aka m1 */
+	u32 clockcontrol_m2;	/* mii/uart/mipsref */
+	u32 clockcontrol_m3;	/* cpu */
+	u32 clkdiv;		/* corerev >= 3 */
+	u32 gpiodebugsel;	/* corerev >= 28 */
+	u32 capabilities_ext;	/* 0xac  */
 
 	/* pll delay registers (corerev >= 4) */
-	uint32 pll_on_delay;	/* 0xb0 */
-	uint32 fref_sel_delay;
-	uint32 slow_clk_ctl;	/* 5 < corerev < 10 */
-	uint32 PAD;
+	u32 pll_on_delay;	/* 0xb0 */
+	u32 fref_sel_delay;
+	u32 slow_clk_ctl;	/* 5 < corerev < 10 */
+	u32 PAD;
 
 	/* Instaclock registers (corerev >= 10) */
-	uint32 system_clk_ctl;	/* 0xc0 */
-	uint32 clkstatestretch;
-	uint32 PAD[2];
+	u32 system_clk_ctl;	/* 0xc0 */
+	u32 clkstatestretch;
+	u32 PAD[2];
 
 	/* Indirect backplane access (corerev >= 22) */
-	uint32 bp_addrlow;	/* 0xd0 */
-	uint32 bp_addrhigh;
-	uint32 bp_data;
-	uint32 PAD;
-	uint32 bp_indaccess;
-	uint32 PAD[3];
+	u32 bp_addrlow;	/* 0xd0 */
+	u32 bp_addrhigh;
+	u32 bp_data;
+	u32 PAD;
+	u32 bp_indaccess;
+	u32 PAD[3];
 
 	/* More clock dividers (corerev >= 32) */
-	uint32 clkdiv2;
-	uint32 PAD[2];
+	u32 clkdiv2;
+	u32 PAD[2];
 
 	/* In AI chips, pointer to erom */
-	uint32 eromptr;		/* 0xfc */
+	u32 eromptr;		/* 0xfc */
 
 	/* ExtBus control registers (corerev >= 3) */
-	uint32 pcmcia_config;	/* 0x100 */
-	uint32 pcmcia_memwait;
-	uint32 pcmcia_attrwait;
-	uint32 pcmcia_iowait;
-	uint32 ide_config;
-	uint32 ide_memwait;
-	uint32 ide_attrwait;
-	uint32 ide_iowait;
-	uint32 prog_config;
-	uint32 prog_waitcount;
-	uint32 flash_config;
-	uint32 flash_waitcount;
-	uint32 SECI_config;	/* 0x130 SECI configuration */
-	uint32 PAD[3];
+	u32 pcmcia_config;	/* 0x100 */
+	u32 pcmcia_memwait;
+	u32 pcmcia_attrwait;
+	u32 pcmcia_iowait;
+	u32 ide_config;
+	u32 ide_memwait;
+	u32 ide_attrwait;
+	u32 ide_iowait;
+	u32 prog_config;
+	u32 prog_waitcount;
+	u32 flash_config;
+	u32 flash_waitcount;
+	u32 SECI_config;	/* 0x130 SECI configuration */
+	u32 PAD[3];
 
 	/* Enhanced Coexistence Interface (ECI) registers (corerev >= 21) */
-	uint32 eci_output;	/* 0x140 */
-	uint32 eci_control;
-	uint32 eci_inputlo;
-	uint32 eci_inputmi;
-	uint32 eci_inputhi;
-	uint32 eci_inputintpolaritylo;
-	uint32 eci_inputintpolaritymi;
-	uint32 eci_inputintpolarityhi;
-	uint32 eci_intmasklo;
-	uint32 eci_intmaskmi;
-	uint32 eci_intmaskhi;
-	uint32 eci_eventlo;
-	uint32 eci_eventmi;
-	uint32 eci_eventhi;
-	uint32 eci_eventmasklo;
-	uint32 eci_eventmaskmi;
-	uint32 eci_eventmaskhi;
-	uint32 PAD[3];
+	u32 eci_output;	/* 0x140 */
+	u32 eci_control;
+	u32 eci_inputlo;
+	u32 eci_inputmi;
+	u32 eci_inputhi;
+	u32 eci_inputintpolaritylo;
+	u32 eci_inputintpolaritymi;
+	u32 eci_inputintpolarityhi;
+	u32 eci_intmasklo;
+	u32 eci_intmaskmi;
+	u32 eci_intmaskhi;
+	u32 eci_eventlo;
+	u32 eci_eventmi;
+	u32 eci_eventhi;
+	u32 eci_eventmasklo;
+	u32 eci_eventmaskmi;
+	u32 eci_eventmaskhi;
+	u32 PAD[3];
 
 	/* SROM interface (corerev >= 32) */
-	uint32 sromcontrol;	/* 0x190 */
-	uint32 sromaddress;
-	uint32 sromdata;
-	uint32 PAD[17];
+	u32 sromcontrol;	/* 0x190 */
+	u32 sromaddress;
+	u32 sromdata;
+	u32 PAD[17];
 
 	/* Clock control and hardware workarounds (corerev >= 20) */
-	uint32 clk_ctl_st;	/* 0x1e0 */
-	uint32 hw_war;
-	uint32 PAD[70];
+	u32 clk_ctl_st;	/* 0x1e0 */
+	u32 hw_war;
+	u32 PAD[70];
 
 	/* UARTs */
-	uint8 uart0data;	/* 0x300 */
-	uint8 uart0imr;
-	uint8 uart0fcr;
-	uint8 uart0lcr;
-	uint8 uart0mcr;
-	uint8 uart0lsr;
-	uint8 uart0msr;
-	uint8 uart0scratch;
-	uint8 PAD[248];		/* corerev >= 1 */
-
-	uint8 uart1data;	/* 0x400 */
-	uint8 uart1imr;
-	uint8 uart1fcr;
-	uint8 uart1lcr;
-	uint8 uart1mcr;
-	uint8 uart1lsr;
-	uint8 uart1msr;
-	uint8 uart1scratch;
-	uint32 PAD[126];
+	u8 uart0data;	/* 0x300 */
+	u8 uart0imr;
+	u8 uart0fcr;
+	u8 uart0lcr;
+	u8 uart0mcr;
+	u8 uart0lsr;
+	u8 uart0msr;
+	u8 uart0scratch;
+	u8 PAD[248];		/* corerev >= 1 */
+
+	u8 uart1data;	/* 0x400 */
+	u8 uart1imr;
+	u8 uart1fcr;
+	u8 uart1lcr;
+	u8 uart1mcr;
+	u8 uart1lsr;
+	u8 uart1msr;
+	u8 uart1scratch;
+	u32 PAD[126];
 
 	/* PMU registers (corerev >= 20) */
-	uint32 pmucontrol;	/* 0x600 */
-	uint32 pmucapabilities;
-	uint32 pmustatus;
-	uint32 res_state;
-	uint32 res_pending;
-	uint32 pmutimer;
-	uint32 min_res_mask;
-	uint32 max_res_mask;
-	uint32 res_table_sel;
-	uint32 res_dep_mask;
-	uint32 res_updn_timer;
-	uint32 res_timer;
-	uint32 clkstretch;
-	uint32 pmuwatchdog;
-	uint32 gpiosel;		/* 0x638, rev >= 1 */
-	uint32 gpioenable;	/* 0x63c, rev >= 1 */
-	uint32 res_req_timer_sel;
-	uint32 res_req_timer;
-	uint32 res_req_mask;
-	uint32 PAD;
-	uint32 chipcontrol_addr;	/* 0x650 */
-	uint32 chipcontrol_data;	/* 0x654 */
-	uint32 regcontrol_addr;
-	uint32 regcontrol_data;
-	uint32 pllcontrol_addr;
-	uint32 pllcontrol_data;
-	uint32 pmustrapopt;	/* 0x668, corerev >= 28 */
-	uint32 pmu_xtalfreq;	/* 0x66C, pmurev >= 10 */
-	uint32 PAD[100];
-	uint16 sromotp[768];
+	u32 pmucontrol;	/* 0x600 */
+	u32 pmucapabilities;
+	u32 pmustatus;
+	u32 res_state;
+	u32 res_pending;
+	u32 pmutimer;
+	u32 min_res_mask;
+	u32 max_res_mask;
+	u32 res_table_sel;
+	u32 res_dep_mask;
+	u32 res_updn_timer;
+	u32 res_timer;
+	u32 clkstretch;
+	u32 pmuwatchdog;
+	u32 gpiosel;		/* 0x638, rev >= 1 */
+	u32 gpioenable;	/* 0x63c, rev >= 1 */
+	u32 res_req_timer_sel;
+	u32 res_req_timer;
+	u32 res_req_mask;
+	u32 PAD;
+	u32 chipcontrol_addr;	/* 0x650 */
+	u32 chipcontrol_data;	/* 0x654 */
+	u32 regcontrol_addr;
+	u32 regcontrol_data;
+	u32 pllcontrol_addr;
+	u32 pllcontrol_data;
+	u32 pmustrapopt;	/* 0x668, corerev >= 28 */
+	u32 pmu_xtalfreq;	/* 0x66C, pmurev >= 10 */
+	u32 PAD[100];
+	u16 sromotp[768];
 } chipcregs_t;
 
 #endif				/* _LANGUAGE_ASSEMBLY */
@@ -1299,15 +1299,15 @@ typedef volatile struct {
 #define CCTRL4331_EXT_LNA		(1<<2)	/* 0 disable */
 #define CCTRL4331_SPROM_GPIO13_15       (1<<3)	/* sprom/gpio13-15 mux */
 #define CCTRL4331_EXTPA_EN		(1<<4)	/* 0 ext pa disable, 1 ext pa enabled */
-#define CCTRL4331_GPIOCLK_ON_SPROMCS	<1<<5)	/* set drive out GPIO_CLK on sprom_cs pin */
+#define CCTRL4331_GPIOCLK_ON_SPROMCS	(1<<5)	/* set drive out GPIO_CLK on sprom_cs pin */
 #define CCTRL4331_PCIE_MDIO_ON_SPROMCS	(1<<6)	/* use sprom_cs pin as PCIE mdio interface */
 #define CCTRL4331_EXTPA_ON_GPIO2_5	(1<<7)	/* aband extpa will be at gpio2/5 and sprom_dout */
 #define CCTRL4331_OVR_PIPEAUXCLKEN	(1<<8)	/* override core control on pipe_AuxClkEnable */
 #define CCTRL4331_OVR_PIPEAUXPWRDOWN	(1<<9)	/* override core control on pipe_AuxPowerDown */
-#define CCTRL4331_PCIE_AUXCLKEN		<1<<10)	/* pcie_auxclkenable */
-#define CCTRL4331_PCIE_PIPE_PLLDOWN	<1<<11)	/* pcie_pipe_pllpowerdown */
-#define CCTRL4331_BT_SHD0_ON_GPIO4	<1<<16)	/* enable bt_shd0 at gpio4 */
-#define CCTRL4331_BT_SHD1_ON_GPIO5	<1<<17)	/* enable bt_shd1 at gpio5 */
+#define CCTRL4331_PCIE_AUXCLKEN		(1<<10)	/* pcie_auxclkenable */
+#define CCTRL4331_PCIE_PIPE_PLLDOWN	(1<<11)	/* pcie_pipe_pllpowerdown */
+#define CCTRL4331_BT_SHD0_ON_GPIO4	(1<<16)	/* enable bt_shd0 at gpio4 */
+#define CCTRL4331_BT_SHD1_ON_GPIO5	(1<<17)	/* enable bt_shd1 at gpio5 */
 
 /* 4331 Chip specific ChipStatus register bits */
 #define	CST4331_XTAL_FREQ		0x00000001	/* crystal frequency 20/40Mhz */
diff --git a/drivers/staging/brcm80211/include/sbconfig.h b/drivers/staging/brcm80211/include/sbconfig.h
index c296f60..5247f01 100644
--- a/drivers/staging/brcm80211/include/sbconfig.h
+++ b/drivers/staging/brcm80211/include/sbconfig.h
@@ -74,43 +74,43 @@
 #ifndef _LANGUAGE_ASSEMBLY
 
 typedef volatile struct _sbconfig {
-	uint32 PAD[2];
-	uint32 sbipsflag;	/* initiator port ocp slave flag */
-	uint32 PAD[3];
-	uint32 sbtpsflag;	/* target port ocp slave flag */
-	uint32 PAD[11];
-	uint32 sbtmerrloga;	/* (sonics >= 2.3) */
-	uint32 PAD;
-	uint32 sbtmerrlog;	/* (sonics >= 2.3) */
-	uint32 PAD[3];
-	uint32 sbadmatch3;	/* address match3 */
-	uint32 PAD;
-	uint32 sbadmatch2;	/* address match2 */
-	uint32 PAD;
-	uint32 sbadmatch1;	/* address match1 */
-	uint32 PAD[7];
-	uint32 sbimstate;	/* initiator agent state */
-	uint32 sbintvec;	/* interrupt mask */
-	uint32 sbtmstatelow;	/* target state */
-	uint32 sbtmstatehigh;	/* target state */
-	uint32 sbbwa0;		/* bandwidth allocation table0 */
-	uint32 PAD;
-	uint32 sbimconfiglow;	/* initiator configuration */
-	uint32 sbimconfighigh;	/* initiator configuration */
-	uint32 sbadmatch0;	/* address match0 */
-	uint32 PAD;
-	uint32 sbtmconfiglow;	/* target configuration */
-	uint32 sbtmconfighigh;	/* target configuration */
-	uint32 sbbconfig;	/* broadcast configuration */
-	uint32 PAD;
-	uint32 sbbstate;	/* broadcast state */
-	uint32 PAD[3];
-	uint32 sbactcnfg;	/* activate configuration */
-	uint32 PAD[3];
-	uint32 sbflagst;	/* current sbflags */
-	uint32 PAD[3];
-	uint32 sbidlow;		/* identification */
-	uint32 sbidhigh;	/* identification */
+	u32 PAD[2];
+	u32 sbipsflag;	/* initiator port ocp slave flag */
+	u32 PAD[3];
+	u32 sbtpsflag;	/* target port ocp slave flag */
+	u32 PAD[11];
+	u32 sbtmerrloga;	/* (sonics >= 2.3) */
+	u32 PAD;
+	u32 sbtmerrlog;	/* (sonics >= 2.3) */
+	u32 PAD[3];
+	u32 sbadmatch3;	/* address match3 */
+	u32 PAD;
+	u32 sbadmatch2;	/* address match2 */
+	u32 PAD;
+	u32 sbadmatch1;	/* address match1 */
+	u32 PAD[7];
+	u32 sbimstate;	/* initiator agent state */
+	u32 sbintvec;	/* interrupt mask */
+	u32 sbtmstatelow;	/* target state */
+	u32 sbtmstatehigh;	/* target state */
+	u32 sbbwa0;		/* bandwidth allocation table0 */
+	u32 PAD;
+	u32 sbimconfiglow;	/* initiator configuration */
+	u32 sbimconfighigh;	/* initiator configuration */
+	u32 sbadmatch0;	/* address match0 */
+	u32 PAD;
+	u32 sbtmconfiglow;	/* target configuration */
+	u32 sbtmconfighigh;	/* target configuration */
+	u32 sbbconfig;	/* broadcast configuration */
+	u32 PAD;
+	u32 sbbstate;	/* broadcast state */
+	u32 PAD[3];
+	u32 sbactcnfg;	/* activate configuration */
+	u32 PAD[3];
+	u32 sbflagst;	/* current sbflags */
+	u32 PAD[3];
+	u32 sbidlow;		/* identification */
+	u32 sbidhigh;	/* identification */
 } sbconfig_t;
 
 #endif				/* _LANGUAGE_ASSEMBLY */
diff --git a/drivers/staging/brcm80211/include/sbhnddma.h b/drivers/staging/brcm80211/include/sbhnddma.h
index 598d68b..09e6d33 100644
--- a/drivers/staging/brcm80211/include/sbhnddma.h
+++ b/drivers/staging/brcm80211/include/sbhnddma.h
@@ -27,10 +27,10 @@
 
 /* dma registers per channel(xmt or rcv) */
 typedef volatile struct {
-	uint32 control;		/* enable, et al */
-	uint32 addr;		/* descriptor ring base address (4K aligned) */
-	uint32 ptr;		/* last descriptor posted to chip */
-	uint32 status;		/* current active descriptor, et al */
+	u32 control;		/* enable, et al */
+	u32 addr;		/* descriptor ring base address (4K aligned) */
+	u32 ptr;		/* last descriptor posted to chip */
+	u32 status;		/* current active descriptor, et al */
 } dma32regs_t;
 
 typedef volatile struct {
@@ -39,10 +39,10 @@ typedef volatile struct {
 } dma32regp_t;
 
 typedef volatile struct {	/* diag access */
-	uint32 fifoaddr;	/* diag address */
-	uint32 fifodatalow;	/* low 32bits of data */
-	uint32 fifodatahigh;	/* high 32bits of data */
-	uint32 pad;		/* reserved */
+	u32 fifoaddr;	/* diag address */
+	u32 fifodatalow;	/* low 32bits of data */
+	u32 fifodatahigh;	/* high 32bits of data */
+	u32 pad;		/* reserved */
 } dma32diag_t;
 
 /*
@@ -50,8 +50,8 @@ typedef volatile struct {	/* diag access */
  * Descriptors are only read by the hardware, never written back.
  */
 typedef volatile struct {
-	uint32 ctrl;		/* misc control bits & bufcount */
-	uint32 addr;		/* data buffer address */
+	u32 ctrl;		/* misc control bits & bufcount */
+	u32 addr;		/* data buffer address */
 } dma32dd_t;
 
 /*
@@ -64,12 +64,12 @@ typedef volatile struct {
 #define	D32MAXDD	(D32MAXRINGSZ / sizeof (dma32dd_t))
 
 /* transmit channel control */
-#define	XC_XE		((uint32)1 << 0)	/* transmit enable */
-#define	XC_SE		((uint32)1 << 1)	/* transmit suspend request */
-#define	XC_LE		((uint32)1 << 2)	/* loopback enable */
-#define	XC_FL		((uint32)1 << 4)	/* flush request */
-#define	XC_PD		((uint32)1 << 11)	/* parity check disable */
-#define	XC_AE		((uint32)3 << 16)	/* address extension bits */
+#define	XC_XE		((u32)1 << 0)	/* transmit enable */
+#define	XC_SE		((u32)1 << 1)	/* transmit suspend request */
+#define	XC_LE		((u32)1 << 2)	/* loopback enable */
+#define	XC_FL		((u32)1 << 4)	/* flush request */
+#define	XC_PD		((u32)1 << 11)	/* parity check disable */
+#define	XC_AE		((u32)3 << 16)	/* address extension bits */
 #define	XC_AE_SHIFT	16
 
 /* transmit descriptor table pointer */
@@ -95,14 +95,14 @@ typedef volatile struct {
 #define	XS_AD_SHIFT	20
 
 /* receive channel control */
-#define	RC_RE		((uint32)1 << 0)	/* receive enable */
+#define	RC_RE		((u32)1 << 0)	/* receive enable */
 #define	RC_RO_MASK	0xfe	/* receive frame offset */
 #define	RC_RO_SHIFT	1
-#define	RC_FM		((uint32)1 << 8)	/* direct fifo receive (pio) mode */
-#define	RC_SH		((uint32)1 << 9)	/* separate rx header descriptor enable */
-#define	RC_OC		((uint32)1 << 10)	/* overflow continue */
-#define	RC_PD		((uint32)1 << 11)	/* parity check disable */
-#define	RC_AE		((uint32)3 << 16)	/* address extension bits */
+#define	RC_FM		((u32)1 << 8)	/* direct fifo receive (pio) mode */
+#define	RC_SH		((u32)1 << 9)	/* separate rx header descriptor enable */
+#define	RC_OC		((u32)1 << 10)	/* overflow continue */
+#define	RC_PD		((u32)1 << 11)	/* parity check disable */
+#define	RC_AE		((u32)3 << 16)	/* address extension bits */
 #define	RC_AE_SHIFT	16
 
 /* receive descriptor table pointer */
@@ -143,13 +143,13 @@ typedef volatile struct {
 
 /* descriptor control flags */
 #define	CTRL_BC_MASK	0x00001fff	/* buffer byte count, real data len must <= 4KB */
-#define	CTRL_AE		((uint32)3 << 16)	/* address extension bits */
+#define	CTRL_AE		((u32)3 << 16)	/* address extension bits */
 #define	CTRL_AE_SHIFT	16
-#define	CTRL_PARITY	((uint32)3 << 18)	/* parity bit */
-#define	CTRL_EOT	((uint32)1 << 28)	/* end of descriptor table */
-#define	CTRL_IOC	((uint32)1 << 29)	/* interrupt on completion */
-#define	CTRL_EOF	((uint32)1 << 30)	/* end of frame */
-#define	CTRL_SOF	((uint32)1 << 31)	/* start of frame */
+#define	CTRL_PARITY	((u32)3 << 18)	/* parity bit */
+#define	CTRL_EOT	((u32)1 << 28)	/* end of descriptor table */
+#define	CTRL_IOC	((u32)1 << 29)	/* interrupt on completion */
+#define	CTRL_EOF	((u32)1 << 30)	/* end of frame */
+#define	CTRL_SOF	((u32)1 << 31)	/* start of frame */
 
 /* control flags in the range [27:20] are core-specific and not defined here */
 #define	CTRL_CORE_MASK	0x0ff00000
@@ -158,12 +158,12 @@ typedef volatile struct {
 
 /* dma registers per channel(xmt or rcv) */
 typedef volatile struct {
-	uint32 control;		/* enable, et al */
-	uint32 ptr;		/* last descriptor posted to chip */
-	uint32 addrlow;		/* descriptor ring base address low 32-bits (8K aligned) */
-	uint32 addrhigh;	/* descriptor ring base address bits 63:32 (8K aligned) */
-	uint32 status0;		/* current descriptor, xmt state */
-	uint32 status1;		/* active descriptor, xmt error */
+	u32 control;		/* enable, et al */
+	u32 ptr;		/* last descriptor posted to chip */
+	u32 addrlow;		/* descriptor ring base address low 32-bits (8K aligned) */
+	u32 addrhigh;	/* descriptor ring base address bits 63:32 (8K aligned) */
+	u32 status0;		/* current descriptor, xmt state */
+	u32 status1;		/* active descriptor, xmt error */
 } dma64regs_t;
 
 typedef volatile struct {
@@ -172,10 +172,10 @@ typedef volatile struct {
 } dma64regp_t;
 
 typedef volatile struct {	/* diag access */
-	uint32 fifoaddr;	/* diag address */
-	uint32 fifodatalow;	/* low 32bits of data */
-	uint32 fifodatahigh;	/* high 32bits of data */
-	uint32 pad;		/* reserved */
+	u32 fifoaddr;	/* diag address */
+	u32 fifodatalow;	/* low 32bits of data */
+	u32 fifodatahigh;	/* high 32bits of data */
+	u32 pad;		/* reserved */
 } dma64diag_t;
 
 /*
@@ -183,10 +183,10 @@ typedef volatile struct {	/* diag access */
  * Descriptors are only read by the hardware, never written back.
  */
 typedef volatile struct {
-	uint32 ctrl1;		/* misc control bits & bufcount */
-	uint32 ctrl2;		/* buffer count and address extension */
-	uint32 addrlow;		/* memory address of the date buffer, bits 31:0 */
-	uint32 addrhigh;	/* memory address of the date buffer, bits 63:32 */
+	u32 ctrl1;		/* misc control bits & bufcount */
+	u32 ctrl2;		/* buffer count and address extension */
+	u32 addrlow;		/* memory address of the date buffer, bits 31:0 */
+	u32 addrhigh;	/* memory address of the date buffer, bits 63:32 */
 } dma64dd_t;
 
 /*
@@ -287,10 +287,10 @@ typedef volatile struct {
 
 /* descriptor control flags 1 */
 #define D64_CTRL_COREFLAGS	0x0ff00000	/* core specific flags */
-#define	D64_CTRL1_EOT		((uint32)1 << 28)	/* end of descriptor table */
-#define	D64_CTRL1_IOC		((uint32)1 << 29)	/* interrupt on completion */
-#define	D64_CTRL1_EOF		((uint32)1 << 30)	/* end of frame */
-#define	D64_CTRL1_SOF		((uint32)1 << 31)	/* start of frame */
+#define	D64_CTRL1_EOT		((u32)1 << 28)	/* end of descriptor table */
+#define	D64_CTRL1_IOC		((u32)1 << 29)	/* interrupt on completion */
+#define	D64_CTRL1_EOF		((u32)1 << 30)	/* end of frame */
+#define	D64_CTRL1_SOF		((u32)1 << 31)	/* start of frame */
 
 /* descriptor control flags 2 */
 #define	D64_CTRL2_BC_MASK	0x00007fff	/* buffer byte count. real data len must <= 16KB */
@@ -308,8 +308,8 @@ typedef volatile struct {
 
 /* receive frame status */
 typedef volatile struct {
-	uint16 len;
-	uint16 flags;
+	u16 len;
+	u16 flags;
 } dma_rxh_t;
 
 #endif				/* _sbhnddma_h_ */
diff --git a/drivers/staging/brcm80211/include/sbhndpio.h b/drivers/staging/brcm80211/include/sbhndpio.h
index e64f6aa..9eabdb5 100644
--- a/drivers/staging/brcm80211/include/sbhndpio.h
+++ b/drivers/staging/brcm80211/include/sbhndpio.h
@@ -25,10 +25,10 @@
 
 /* 2byte-wide pio register set per channel(xmt or rcv) */
 typedef volatile struct {
-	uint16 fifocontrol;
-	uint16 fifodata;
-	uint16 fifofree;	/* only valid in xmt channel, not in rcv channel */
-	uint16 PAD;
+	u16 fifocontrol;
+	u16 fifodata;
+	u16 fifofree;	/* only valid in xmt channel, not in rcv channel */
+	u16 PAD;
 } pio2regs_t;
 
 /* a pair of pio channels(tx and rx) */
@@ -39,8 +39,8 @@ typedef volatile struct {
 
 /* 4byte-wide pio register set per channel(xmt or rcv) */
 typedef volatile struct {
-	uint32 fifocontrol;
-	uint32 fifodata;
+	u32 fifocontrol;
+	u32 fifodata;
 } pio4regs_t;
 
 /* a pair of pio channels(tx and rx) */
diff --git a/drivers/staging/brcm80211/include/sbsdpcmdev.h b/drivers/staging/brcm80211/include/sbsdpcmdev.h
index d07a13c..afd3581 100644
--- a/drivers/staging/brcm80211/include/sbsdpcmdev.h
+++ b/drivers/staging/brcm80211/include/sbsdpcmdev.h
@@ -26,92 +26,92 @@
 
 typedef volatile struct {
 	dma64regs_t xmt;	/* dma tx */
-	uint32 PAD[2];
+	u32 PAD[2];
 	dma64regs_t rcv;	/* dma rx */
-	uint32 PAD[2];
+	u32 PAD[2];
 } dma64p_t;
 
 /* dma64 sdiod corerev >= 1 */
 typedef volatile struct {
 	dma64p_t dma64regs[2];
 	dma64diag_t dmafifo;	/* DMA Diagnostic Regs, 0x280-0x28c */
-	uint32 PAD[92];
+	u32 PAD[92];
 } sdiodma64_t;
 
 /* dma32 sdiod corerev == 0 */
 typedef volatile struct {
 	dma32regp_t dma32regs[2];	/* dma tx & rx, 0x200-0x23c */
 	dma32diag_t dmafifo;	/* DMA Diagnostic Regs, 0x240-0x24c */
-	uint32 PAD[108];
+	u32 PAD[108];
 } sdiodma32_t;
 
 /* dma32 regs for pcmcia core */
 typedef volatile struct {
 	dma32regp_t dmaregs;	/* DMA Regs, 0x200-0x21c, rev8 */
 	dma32diag_t dmafifo;	/* DMA Diagnostic Regs, 0x220-0x22c */
-	uint32 PAD[116];
+	u32 PAD[116];
 } pcmdma32_t;
 
 /* core registers */
 typedef volatile struct {
-	uint32 corecontrol;	/* CoreControl, 0x000, rev8 */
-	uint32 corestatus;	/* CoreStatus, 0x004, rev8  */
-	uint32 PAD[1];
-	uint32 biststatus;	/* BistStatus, 0x00c, rev8  */
+	u32 corecontrol;	/* CoreControl, 0x000, rev8 */
+	u32 corestatus;	/* CoreStatus, 0x004, rev8  */
+	u32 PAD[1];
+	u32 biststatus;	/* BistStatus, 0x00c, rev8  */
 
 	/* PCMCIA access */
-	uint16 pcmciamesportaladdr;	/* PcmciaMesPortalAddr, 0x010, rev8   */
-	uint16 PAD[1];
-	uint16 pcmciamesportalmask;	/* PcmciaMesPortalMask, 0x014, rev8   */
-	uint16 PAD[1];
-	uint16 pcmciawrframebc;	/* PcmciaWrFrameBC, 0x018, rev8   */
-	uint16 PAD[1];
-	uint16 pcmciaunderflowtimer;	/* PcmciaUnderflowTimer, 0x01c, rev8   */
-	uint16 PAD[1];
+	u16 pcmciamesportaladdr;	/* PcmciaMesPortalAddr, 0x010, rev8   */
+	u16 PAD[1];
+	u16 pcmciamesportalmask;	/* PcmciaMesPortalMask, 0x014, rev8   */
+	u16 PAD[1];
+	u16 pcmciawrframebc;	/* PcmciaWrFrameBC, 0x018, rev8   */
+	u16 PAD[1];
+	u16 pcmciaunderflowtimer;	/* PcmciaUnderflowTimer, 0x01c, rev8   */
+	u16 PAD[1];
 
 	/* interrupt */
-	uint32 intstatus;	/* IntStatus, 0x020, rev8   */
-	uint32 hostintmask;	/* IntHostMask, 0x024, rev8   */
-	uint32 intmask;		/* IntSbMask, 0x028, rev8   */
-	uint32 sbintstatus;	/* SBIntStatus, 0x02c, rev8   */
-	uint32 sbintmask;	/* SBIntMask, 0x030, rev8   */
-	uint32 funcintmask;	/* SDIO Function Interrupt Mask, SDIO rev4 */
-	uint32 PAD[2];
-	uint32 tosbmailbox;	/* ToSBMailbox, 0x040, rev8   */
-	uint32 tohostmailbox;	/* ToHostMailbox, 0x044, rev8   */
-	uint32 tosbmailboxdata;	/* ToSbMailboxData, 0x048, rev8   */
-	uint32 tohostmailboxdata;	/* ToHostMailboxData, 0x04c, rev8   */
+	u32 intstatus;	/* IntStatus, 0x020, rev8   */
+	u32 hostintmask;	/* IntHostMask, 0x024, rev8   */
+	u32 intmask;		/* IntSbMask, 0x028, rev8   */
+	u32 sbintstatus;	/* SBIntStatus, 0x02c, rev8   */
+	u32 sbintmask;	/* SBIntMask, 0x030, rev8   */
+	u32 funcintmask;	/* SDIO Function Interrupt Mask, SDIO rev4 */
+	u32 PAD[2];
+	u32 tosbmailbox;	/* ToSBMailbox, 0x040, rev8   */
+	u32 tohostmailbox;	/* ToHostMailbox, 0x044, rev8   */
+	u32 tosbmailboxdata;	/* ToSbMailboxData, 0x048, rev8   */
+	u32 tohostmailboxdata;	/* ToHostMailboxData, 0x04c, rev8   */
 
 	/* synchronized access to registers in SDIO clock domain */
-	uint32 sdioaccess;	/* SdioAccess, 0x050, rev8   */
-	uint32 PAD[3];
+	u32 sdioaccess;	/* SdioAccess, 0x050, rev8   */
+	u32 PAD[3];
 
 	/* PCMCIA frame control */
-	uint8 pcmciaframectrl;	/* pcmciaFrameCtrl, 0x060, rev8   */
-	uint8 PAD[3];
-	uint8 pcmciawatermark;	/* pcmciaWaterMark, 0x064, rev8   */
-	uint8 PAD[155];
+	u8 pcmciaframectrl;	/* pcmciaFrameCtrl, 0x060, rev8   */
+	u8 PAD[3];
+	u8 pcmciawatermark;	/* pcmciaWaterMark, 0x064, rev8   */
+	u8 PAD[155];
 
 	/* interrupt batching control */
-	uint32 intrcvlazy;	/* IntRcvLazy, 0x100, rev8 */
-	uint32 PAD[3];
+	u32 intrcvlazy;	/* IntRcvLazy, 0x100, rev8 */
+	u32 PAD[3];
 
 	/* counters */
-	uint32 cmd52rd;		/* Cmd52RdCount, 0x110, rev8, SDIO: cmd52 reads */
-	uint32 cmd52wr;		/* Cmd52WrCount, 0x114, rev8, SDIO: cmd52 writes */
-	uint32 cmd53rd;		/* Cmd53RdCount, 0x118, rev8, SDIO: cmd53 reads */
-	uint32 cmd53wr;		/* Cmd53WrCount, 0x11c, rev8, SDIO: cmd53 writes */
-	uint32 abort;		/* AbortCount, 0x120, rev8, SDIO: aborts */
-	uint32 datacrcerror;	/* DataCrcErrorCount, 0x124, rev8, SDIO: frames w/bad CRC */
-	uint32 rdoutofsync;	/* RdOutOfSyncCount, 0x128, rev8, SDIO/PCMCIA: Rd Frm OOS */
-	uint32 wroutofsync;	/* RdOutOfSyncCount, 0x12c, rev8, SDIO/PCMCIA: Wr Frm OOS */
-	uint32 writebusy;	/* WriteBusyCount, 0x130, rev8, SDIO: dev asserted "busy" */
-	uint32 readwait;	/* ReadWaitCount, 0x134, rev8, SDIO: read: no data avail */
-	uint32 readterm;	/* ReadTermCount, 0x138, rev8, SDIO: rd frm terminates */
-	uint32 writeterm;	/* WriteTermCount, 0x13c, rev8, SDIO: wr frm terminates */
-	uint32 PAD[40];
-	uint32 clockctlstatus;	/* ClockCtlStatus, 0x1e0, rev8 */
-	uint32 PAD[7];
+	u32 cmd52rd;		/* Cmd52RdCount, 0x110, rev8, SDIO: cmd52 reads */
+	u32 cmd52wr;		/* Cmd52WrCount, 0x114, rev8, SDIO: cmd52 writes */
+	u32 cmd53rd;		/* Cmd53RdCount, 0x118, rev8, SDIO: cmd53 reads */
+	u32 cmd53wr;		/* Cmd53WrCount, 0x11c, rev8, SDIO: cmd53 writes */
+	u32 abort;		/* AbortCount, 0x120, rev8, SDIO: aborts */
+	u32 datacrcerror;	/* DataCrcErrorCount, 0x124, rev8, SDIO: frames w/bad CRC */
+	u32 rdoutofsync;	/* RdOutOfSyncCount, 0x128, rev8, SDIO/PCMCIA: Rd Frm OOS */
+	u32 wroutofsync;	/* RdOutOfSyncCount, 0x12c, rev8, SDIO/PCMCIA: Wr Frm OOS */
+	u32 writebusy;	/* WriteBusyCount, 0x130, rev8, SDIO: dev asserted "busy" */
+	u32 readwait;	/* ReadWaitCount, 0x134, rev8, SDIO: read: no data avail */
+	u32 readterm;	/* ReadTermCount, 0x138, rev8, SDIO: rd frm terminates */
+	u32 writeterm;	/* WriteTermCount, 0x13c, rev8, SDIO: wr frm terminates */
+	u32 PAD[40];
+	u32 clockctlstatus;	/* ClockCtlStatus, 0x1e0, rev8 */
+	u32 PAD[7];
 
 	/* DMA engines */
 	volatile union {
@@ -125,23 +125,23 @@ typedef volatile struct {
 
 	/* PCMCIA function control registers */
 	char pcmciafcr[256];	/* PCMCIA FCR, 0x600-6ff, rev6 */
-	uint16 PAD[55];
+	u16 PAD[55];
 
 	/* PCMCIA backplane access */
-	uint16 backplanecsr;	/* BackplaneCSR, 0x76E, rev6 */
-	uint16 backplaneaddr0;	/* BackplaneAddr0, 0x770, rev6 */
-	uint16 backplaneaddr1;	/* BackplaneAddr1, 0x772, rev6 */
-	uint16 backplaneaddr2;	/* BackplaneAddr2, 0x774, rev6 */
-	uint16 backplaneaddr3;	/* BackplaneAddr3, 0x776, rev6 */
-	uint16 backplanedata0;	/* BackplaneData0, 0x778, rev6 */
-	uint16 backplanedata1;	/* BackplaneData1, 0x77a, rev6 */
-	uint16 backplanedata2;	/* BackplaneData2, 0x77c, rev6 */
-	uint16 backplanedata3;	/* BackplaneData3, 0x77e, rev6 */
-	uint16 PAD[31];
+	u16 backplanecsr;	/* BackplaneCSR, 0x76E, rev6 */
+	u16 backplaneaddr0;	/* BackplaneAddr0, 0x770, rev6 */
+	u16 backplaneaddr1;	/* BackplaneAddr1, 0x772, rev6 */
+	u16 backplaneaddr2;	/* BackplaneAddr2, 0x774, rev6 */
+	u16 backplaneaddr3;	/* BackplaneAddr3, 0x776, rev6 */
+	u16 backplanedata0;	/* BackplaneData0, 0x778, rev6 */
+	u16 backplanedata1;	/* BackplaneData1, 0x77a, rev6 */
+	u16 backplanedata2;	/* BackplaneData2, 0x77c, rev6 */
+	u16 backplanedata3;	/* BackplaneData3, 0x77e, rev6 */
+	u16 PAD[31];
 
 	/* sprom "size" & "blank" info */
-	uint16 spromstatus;	/* SPROMStatus, 0x7BE, rev2 */
-	uint32 PAD[464];
+	u16 spromstatus;	/* SPROMStatus, 0x7BE, rev2 */
+	u32 PAD[464];
 
 	/* Sonics SiliconBackplane registers */
 	sbconfig_t sbconfig;	/* SbConfig Regs, 0xf00-0xfff, rev8 */
@@ -264,8 +264,8 @@ typedef volatile struct {
 
 /* rx header */
 typedef volatile struct {
-	uint16 len;
-	uint16 flags;
+	u16 len;
+	u16 flags;
 } sdpcmd_rxh_t;
 
 /* rx header flags */
diff --git a/drivers/staging/brcm80211/include/sbsocram.h b/drivers/staging/brcm80211/include/sbsocram.h
index 7b09be9..0cfe985 100644
--- a/drivers/staging/brcm80211/include/sbsocram.h
+++ b/drivers/staging/brcm80211/include/sbsocram.h
@@ -28,34 +28,34 @@
 
 /* Memcsocram core registers */
 typedef volatile struct sbsocramregs {
-	uint32 coreinfo;
-	uint32 bwalloc;
-	uint32 extracoreinfo;
-	uint32 biststat;
-	uint32 bankidx;
-	uint32 standbyctrl;
-
-	uint32 errlogstatus;	/* rev 6 */
-	uint32 errlogaddr;	/* rev 6 */
+	u32 coreinfo;
+	u32 bwalloc;
+	u32 extracoreinfo;
+	u32 biststat;
+	u32 bankidx;
+	u32 standbyctrl;
+
+	u32 errlogstatus;	/* rev 6 */
+	u32 errlogaddr;	/* rev 6 */
 	/* used for patching rev 3 & 5 */
-	uint32 cambankidx;
-	uint32 cambankstandbyctrl;
-	uint32 cambankpatchctrl;
-	uint32 cambankpatchtblbaseaddr;
-	uint32 cambankcmdreg;
-	uint32 cambankdatareg;
-	uint32 cambankmaskreg;
-	uint32 PAD[1];
-	uint32 bankinfo;	/* corev 8 */
-	uint32 PAD[15];
-	uint32 extmemconfig;
-	uint32 extmemparitycsr;
-	uint32 extmemparityerrdata;
-	uint32 extmemparityerrcnt;
-	uint32 extmemwrctrlandsize;
-	uint32 PAD[84];
-	uint32 workaround;
-	uint32 pwrctl;		/* corerev >= 2 */
+	u32 cambankidx;
+	u32 cambankstandbyctrl;
+	u32 cambankpatchctrl;
+	u32 cambankpatchtblbaseaddr;
+	u32 cambankcmdreg;
+	u32 cambankdatareg;
+	u32 cambankmaskreg;
+	u32 PAD[1];
+	u32 bankinfo;	/* corev 8 */
+	u32 PAD[15];
+	u32 extmemconfig;
+	u32 extmemparitycsr;
+	u32 extmemparityerrdata;
+	u32 extmemparityerrcnt;
+	u32 extmemwrctrlandsize;
+	u32 PAD[84];
+	u32 workaround;
+	u32 pwrctl;		/* corerev >= 2 */
 } sbsocramregs_t;
 
 #endif				/* _LANGUAGE_ASSEMBLY */
diff --git a/drivers/staging/brcm80211/include/sdio.h b/drivers/staging/brcm80211/include/sdio.h
index 8769c45..670e379 100644
--- a/drivers/staging/brcm80211/include/sdio.h
+++ b/drivers/staging/brcm80211/include/sdio.h
@@ -21,31 +21,31 @@
 
 /* CCCR structure for function 0 */
 typedef volatile struct {
-	uint8 cccr_sdio_rev;	/* RO, cccr and sdio revision */
-	uint8 sd_rev;		/* RO, sd spec revision */
-	uint8 io_en;		/* I/O enable */
-	uint8 io_rdy;		/* I/O ready reg */
-	uint8 intr_ctl;		/* Master and per function interrupt enable control */
-	uint8 intr_status;	/* RO, interrupt pending status */
-	uint8 io_abort;		/* read/write abort or reset all functions */
-	uint8 bus_inter;	/* bus interface control */
-	uint8 capability;	/* RO, card capability */
-
-	uint8 cis_base_low;	/* 0x9 RO, common CIS base address, LSB */
-	uint8 cis_base_mid;
-	uint8 cis_base_high;	/* 0xB RO, common CIS base address, MSB */
+	u8 cccr_sdio_rev;	/* RO, cccr and sdio revision */
+	u8 sd_rev;		/* RO, sd spec revision */
+	u8 io_en;		/* I/O enable */
+	u8 io_rdy;		/* I/O ready reg */
+	u8 intr_ctl;		/* Master and per function interrupt enable control */
+	u8 intr_status;	/* RO, interrupt pending status */
+	u8 io_abort;		/* read/write abort or reset all functions */
+	u8 bus_inter;	/* bus interface control */
+	u8 capability;	/* RO, card capability */
+
+	u8 cis_base_low;	/* 0x9 RO, common CIS base address, LSB */
+	u8 cis_base_mid;
+	u8 cis_base_high;	/* 0xB RO, common CIS base address, MSB */
 
 	/* suspend/resume registers */
-	uint8 bus_suspend;	/* 0xC */
-	uint8 func_select;	/* 0xD */
-	uint8 exec_flag;	/* 0xE */
-	uint8 ready_flag;	/* 0xF */
+	u8 bus_suspend;	/* 0xC */
+	u8 func_select;	/* 0xD */
+	u8 exec_flag;	/* 0xE */
+	u8 ready_flag;	/* 0xF */
 
-	uint8 fn0_blk_size[2];	/* 0x10(LSB), 0x11(MSB) */
+	u8 fn0_blk_size[2];	/* 0x10(LSB), 0x11(MSB) */
 
-	uint8 power_control;	/* 0x12 (SDIO version 1.10) */
+	u8 power_control;	/* 0x12 (SDIO version 1.10) */
 
-	uint8 speed_control;	/* 0x13 */
+	u8 speed_control;	/* 0x13 */
 } sdio_regs_t;
 
 /* SDIO Device CCCR offsets */
@@ -134,20 +134,20 @@ typedef volatile struct {
 
 /* FBR structure for function 1-7, FBR addresses and register offsets */
 typedef volatile struct {
-	uint8 devctr;		/* device interface, CSA control */
-	uint8 ext_dev;		/* extended standard I/O device type code */
-	uint8 pwr_sel;		/* power selection support */
-	uint8 PAD[6];		/* reserved */
-
-	uint8 cis_low;		/* CIS LSB */
-	uint8 cis_mid;
-	uint8 cis_high;		/* CIS MSB */
-	uint8 csa_low;		/* code storage area, LSB */
-	uint8 csa_mid;
-	uint8 csa_high;		/* code storage area, MSB */
-	uint8 csa_dat_win;	/* data access window to function */
-
-	uint8 fnx_blk_size[2];	/* block size, little endian */
+	u8 devctr;		/* device interface, CSA control */
+	u8 ext_dev;		/* extended standard I/O device type code */
+	u8 pwr_sel;		/* power selection support */
+	u8 PAD[6];		/* reserved */
+
+	u8 cis_low;		/* CIS LSB */
+	u8 cis_mid;
+	u8 cis_high;		/* CIS MSB */
+	u8 csa_low;		/* code storage area, LSB */
+	u8 csa_mid;
+	u8 csa_high;		/* code storage area, MSB */
+	u8 csa_dat_win;	/* data access window to function */
+
+	u8 fnx_blk_size[2];	/* block size, little endian */
 } sdio_fbr_t;
 
 /* Maximum number of I/O funcs */
diff --git a/drivers/staging/brcm80211/include/sdiovar.h b/drivers/staging/brcm80211/include/sdiovar.h
index 2112cb6..7686fde 100644
--- a/drivers/staging/brcm80211/include/sdiovar.h
+++ b/drivers/staging/brcm80211/include/sdiovar.h
@@ -17,8 +17,6 @@
 #ifndef _sdiovar_h_
 #define _sdiovar_h_
 
-#include <typedefs.h>
-
 /* require default structure packing */
 #define BWL_DEFAULT_PACKING
 #include <packed_section_start.h>
diff --git a/drivers/staging/brcm80211/include/siutils.h b/drivers/staging/brcm80211/include/siutils.h
index 13925b2..57c3650 100644
--- a/drivers/staging/brcm80211/include/siutils.h
+++ b/drivers/staging/brcm80211/include/siutils.h
@@ -34,10 +34,10 @@ struct si_pub {
 	uint buscorerev;	/* buscore rev */
 	uint buscoreidx;	/* buscore index */
 	int ccrev;		/* chip common core rev */
-	uint32 cccaps;		/* chip common capabilities */
-	uint32 cccaps_ext;	/* chip common capabilities extension */
+	u32 cccaps;		/* chip common capabilities */
+	u32 cccaps_ext;	/* chip common capabilities extension */
 	int pmurev;		/* pmu core rev */
-	uint32 pmucaps;		/* pmu capabilities */
+	u32 pmucaps;		/* pmu capabilities */
 	uint boardtype;		/* board type */
 	uint boardvendor;	/* board vendor */
 	uint boardflags;	/* board flags */
@@ -45,7 +45,7 @@ struct si_pub {
 	uint chip;		/* chip number */
 	uint chiprev;		/* chip revision */
 	uint chippkg;		/* chip package option */
-	uint32 chipst;		/* chip status */
+	u32 chipst;		/* chip status */
 	bool issim;		/* chip is in simulation or emulation */
 	uint socirev;		/* SOC interconnect rev */
 	bool pci_pr32414;
@@ -122,147 +122,83 @@ typedef const struct si_pub si_t;
 #define CCPLL_ENAB(sih)		((sih)->cccaps & CC_CAP_PLL_MASK)
 #endif
 
-typedef void (*gpio_handler_t) (uint32 stat, void *arg);
+typedef void (*gpio_handler_t) (u32 stat, void *arg);
 
 /* External PA enable mask */
 #define GPIO_CTRL_EPA_EN_MASK 0x40
 
 /* === exported functions === */
-extern si_t *si_attach(uint pcidev, osl_t * osh, void *regs, uint bustype,
-		       void *sdh, char **vars, uint * varsz);
-
-extern void si_detach(si_t * sih);
-extern bool si_pci_war16165(si_t * sih);
-
-extern uint si_corelist(si_t * sih, uint coreid[]);
-extern uint si_coreid(si_t * sih);
-extern uint si_flag(si_t * sih);
-extern uint si_intflag(si_t * sih);
-extern uint si_coreidx(si_t * sih);
-extern uint si_coreunit(si_t * sih);
-extern uint si_corevendor(si_t * sih);
-extern uint si_corerev(si_t * sih);
-extern void *si_osh(si_t * sih);
-extern void si_setosh(si_t * sih, osl_t * osh);
-extern uint si_corereg(si_t * sih, uint coreidx, uint regoff, uint mask,
-		       uint val);
-extern void *si_coreregs(si_t * sih);
-extern void si_write_wrapperreg(si_t * sih, uint32 offset, uint32 val);
-extern uint32 si_core_cflags(si_t * sih, uint32 mask, uint32 val);
-extern void si_core_cflags_wo(si_t * sih, uint32 mask, uint32 val);
-extern uint32 si_core_sflags(si_t * sih, uint32 mask, uint32 val);
-extern bool si_iscoreup(si_t * sih);
-extern uint si_findcoreidx(si_t * sih, uint coreid, uint coreunit);
+extern si_t *si_attach(uint pcidev, osl_t *osh, void *regs, uint bustype,
+		       void *sdh, char **vars, uint *varsz);
+
+extern void si_detach(si_t *sih);
+extern bool si_pci_war16165(si_t *sih);
+
+extern uint si_coreid(si_t *sih);
+extern uint si_flag(si_t *sih);
+extern uint si_coreidx(si_t *sih);
+extern uint si_corerev(si_t *sih);
+extern void *si_osh(si_t *sih);
+extern uint si_corereg(si_t *sih, uint coreidx, uint regoff, uint mask,
+		uint val);
+extern void si_write_wrapperreg(si_t *sih, u32 offset, u32 val);
+extern u32 si_core_cflags(si_t *sih, u32 mask, u32 val);
+extern u32 si_core_sflags(si_t *sih, u32 mask, u32 val);
+extern bool si_iscoreup(si_t *sih);
+extern uint si_findcoreidx(si_t *sih, uint coreid, uint coreunit);
 #ifndef BCMSDIO
-extern void *si_setcoreidx(si_t * sih, uint coreidx);
+extern void *si_setcoreidx(si_t *sih, uint coreidx);
 #endif
-extern void *si_setcore(si_t * sih, uint coreid, uint coreunit);
-extern void *si_switch_core(si_t * sih, uint coreid, uint * origidx,
-			    uint * intr_val);
-extern void si_restore_core(si_t * sih, uint coreid, uint intr_val);
-extern int si_numaddrspaces(si_t * sih);
-extern uint32 si_addrspace(si_t * sih, uint asidx);
-extern uint32 si_addrspacesize(si_t * sih, uint asidx);
-extern int si_corebist(si_t * sih);
-extern void si_core_reset(si_t * sih, uint32 bits, uint32 resetbits);
-extern void si_core_disable(si_t * sih, uint32 bits);
-extern uint32 si_clock_rate(uint32 pll_type, uint32 n, uint32 m);
-extern uint32 si_clock(si_t * sih);
-extern uint32 si_alp_clock(si_t * sih);
-extern uint32 si_ilp_clock(si_t * sih);
-extern void si_pci_setup(si_t * sih, uint coremask);
-extern void si_setint(si_t * sih, int siflag);
-extern bool si_backplane64(si_t * sih);
-extern void si_register_intr_callback(si_t * sih, void *intrsoff_fn,
+extern void *si_setcore(si_t *sih, uint coreid, uint coreunit);
+extern void *si_switch_core(si_t *sih, uint coreid, uint *origidx,
+			    uint *intr_val);
+extern void si_restore_core(si_t *sih, uint coreid, uint intr_val);
+extern void si_core_reset(si_t *sih, u32 bits, u32 resetbits);
+extern void si_core_disable(si_t *sih, u32 bits);
+extern u32 si_alp_clock(si_t *sih);
+extern u32 si_ilp_clock(si_t *sih);
+extern void si_pci_setup(si_t *sih, uint coremask);
+extern void si_setint(si_t *sih, int siflag);
+extern bool si_backplane64(si_t *sih);
+extern void si_register_intr_callback(si_t *sih, void *intrsoff_fn,
 				      void *intrsrestore_fn,
 				      void *intrsenabled_fn, void *intr_arg);
-extern void si_deregister_intr_callback(si_t * sih);
-extern void si_clkctl_init(si_t * sih);
-extern uint16 si_clkctl_fast_pwrup_delay(si_t * sih);
-extern bool si_clkctl_cc(si_t * sih, uint mode);
-extern int si_clkctl_xtal(si_t * sih, uint what, bool on);
-extern uint32 si_gpiotimerval(si_t * sih, uint32 mask, uint32 val);
-extern bool si_deviceremoved(si_t * sih);
-extern uint32 si_socram_size(si_t * sih);
-extern uint32 si_socdevram_size(si_t * sih);
-extern void si_socdevram(si_t * sih, bool set, uint8 * ennable,
-			 uint8 * protect);
-extern bool si_socdevram_pkg(si_t * sih);
-
-extern void si_watchdog(si_t * sih, uint ticks);
-extern void si_watchdog_ms(si_t * sih, uint32 ms);
-extern void *si_gpiosetcore(si_t * sih);
-extern uint32 si_gpiocontrol(si_t * sih, uint32 mask, uint32 val,
-			     uint8 priority);
-extern uint32 si_gpioouten(si_t * sih, uint32 mask, uint32 val, uint8 priority);
-extern uint32 si_gpioout(si_t * sih, uint32 mask, uint32 val, uint8 priority);
-extern uint32 si_gpioin(si_t * sih);
-extern uint32 si_gpiointpolarity(si_t * sih, uint32 mask, uint32 val,
-				 uint8 priority);
-extern uint32 si_gpiointmask(si_t * sih, uint32 mask, uint32 val,
-			     uint8 priority);
-extern uint32 si_gpioled(si_t * sih, uint32 mask, uint32 val);
-extern uint32 si_gpioreserve(si_t * sih, uint32 gpio_num, uint8 priority);
-extern uint32 si_gpiorelease(si_t * sih, uint32 gpio_num, uint8 priority);
-extern uint32 si_gpiopull(si_t * sih, bool updown, uint32 mask, uint32 val);
-extern uint32 si_gpioevent(si_t * sih, uint regtype, uint32 mask, uint32 val);
-extern uint32 si_gpio_int_enable(si_t * sih, bool enable);
-
-/* GPIO event handlers */
-extern void *si_gpio_handler_register(si_t * sih, uint32 e, bool lev,
-				      gpio_handler_t cb, void *arg);
-extern void si_gpio_handler_unregister(si_t * sih, void *gpioh);
-extern void si_gpio_handler_process(si_t * sih);
-
-/* Wake-on-wireless-LAN (WOWL) */
-extern bool si_pci_pmecap(si_t * sih);
-struct osl_info;
-extern bool si_pci_fastpmecap(struct osl_info *osh);
-extern bool si_pci_pmestat(si_t * sih);
-extern void si_pci_pmeclr(si_t * sih);
-extern void si_pci_pmeen(si_t * sih);
-extern uint si_pcie_readreg(void *sih, uint addrtype, uint offset);
+extern void si_deregister_intr_callback(si_t *sih);
+extern void si_clkctl_init(si_t *sih);
+extern u16 si_clkctl_fast_pwrup_delay(si_t *sih);
+extern bool si_clkctl_cc(si_t *sih, uint mode);
+extern int si_clkctl_xtal(si_t *sih, uint what, bool on);
+extern bool si_deviceremoved(si_t *sih);
+extern u32 si_socram_size(si_t *sih);
+
+extern void si_watchdog(si_t *sih, uint ticks);
+extern u32 si_gpiocontrol(si_t *sih, u32 mask, u32 val,
+			     u8 priority);
 
 #ifdef BCMSDIO
-extern void si_sdio_init(si_t * sih);
+extern void si_sdio_init(si_t *sih);
 #endif
 
-extern uint16 si_d11_devid(si_t * sih);
-
 #define si_eci(sih) 0
 #define si_eci_init(sih) (0)
 #define si_eci_notify_bt(sih, type, val)  (0)
 #define si_seci(sih) 0
-static INLINE void *si_seci_init(si_t * sih, uint8 use_seci)
+static inline void *si_seci_init(si_t *sih, u8 use_seci)
 {
 	return NULL;
 }
 
 /* OTP status */
-extern bool si_is_otp_disabled(si_t * sih);
-extern bool si_is_otp_powered(si_t * sih);
-extern void si_otp_power(si_t * sih, bool on);
+extern bool si_is_otp_disabled(si_t *sih);
+extern bool si_is_otp_powered(si_t *sih);
+extern void si_otp_power(si_t *sih, bool on);
 
 /* SPROM availability */
-extern bool si_is_sprom_available(si_t * sih);
-extern bool si_is_sprom_enabled(si_t * sih);
-extern void si_sprom_enable(si_t * sih, bool enable);
+extern bool si_is_sprom_available(si_t *sih);
 #ifdef SI_SPROM_PROBE
-extern void si_sprom_init(si_t * sih);
+extern void si_sprom_init(si_t *sih);
 #endif				/* SI_SPROM_PROBE */
 
-/* OTP/SROM CIS stuff */
-extern int si_cis_source(si_t * sih);
-#define CIS_DEFAULT	0
-#define CIS_SROM	1
-#define CIS_OTP		2
-
-/* Fab-id information */
-#define	DEFAULT_FAB	0x0	/* Original/first fab used for this chip */
-#define	CSM_FAB7	0x1	/* CSM Fab7 chip */
-#define	TSMC_FAB12	0x2	/* TSMC Fab12/Fab14 chip */
-#define	SMIC_FAB4	0x3	/* SMIC Fab4 chip */
-
 #define	SI_ERROR(args)
 
 #ifdef BCMDBG
@@ -276,15 +212,15 @@ extern int si_cis_source(si_t * sih);
 
 #define	IS_SIM(chippkg)	((chippkg == HDLSIM_PKG_ID) || (chippkg == HWSIM_PKG_ID))
 
-typedef uint32(*si_intrsoff_t) (void *intr_arg);
-typedef void (*si_intrsrestore_t) (void *intr_arg, uint32 arg);
+typedef u32(*si_intrsoff_t) (void *intr_arg);
+typedef void (*si_intrsrestore_t) (void *intr_arg, u32 arg);
 typedef bool(*si_intrsenabled_t) (void *intr_arg);
 
 typedef struct gpioh_item {
 	void *arg;
 	bool level;
 	gpio_handler_t handler;
-	uint32 event;
+	u32 event;
 	struct gpioh_item *next;
 } gpioh_item_t;
 
@@ -314,26 +250,26 @@ typedef struct si_info {
 	uint curidx;		/* current core index */
 	uint numcores;		/* # discovered cores */
 	uint coreid[SI_MAXCORES];	/* id of each core */
-	uint32 coresba[SI_MAXCORES];	/* backplane address of each core */
+	u32 coresba[SI_MAXCORES];	/* backplane address of each core */
 	void *regs2[SI_MAXCORES];	/* va of each core second register set (usbh20) */
-	uint32 coresba2[SI_MAXCORES];	/* address of each core second register set (usbh20) */
-	uint32 coresba_size[SI_MAXCORES];	/* backplane address space size */
-	uint32 coresba2_size[SI_MAXCORES];	/* second address space size */
+	u32 coresba2[SI_MAXCORES];	/* address of each core second register set (usbh20) */
+	u32 coresba_size[SI_MAXCORES];	/* backplane address space size */
+	u32 coresba2_size[SI_MAXCORES];	/* second address space size */
 
 	void *curwrap;		/* current wrapper va */
 	void *wrappers[SI_MAXCORES];	/* other cores wrapper va */
-	uint32 wrapba[SI_MAXCORES];	/* address of controlling wrapper */
+	u32 wrapba[SI_MAXCORES];	/* address of controlling wrapper */
 
-	uint32 cia[SI_MAXCORES];	/* erom cia entry for each core */
-	uint32 cib[SI_MAXCORES];	/* erom cia entry for each core */
-	uint32 oob_router;	/* oob router registers for axi */
+	u32 cia[SI_MAXCORES];	/* erom cia entry for each core */
+	u32 cib[SI_MAXCORES];	/* erom cia entry for each core */
+	u32 oob_router;	/* oob router registers for axi */
 } si_info_t;
 
-#define	SI_INFO(sih)	(si_info_t *)(uintptr)sih
+#define	SI_INFO(sih)	(si_info_t *)sih
 
 #define	GOODCOREADDR(x, b) (((x) >= (b)) && ((x) < ((b) + SI_MAXCORES * SI_CORE_SIZE)) && \
-		ISALIGNED((x), SI_CORE_SIZE))
-#define	GOODREGS(regs)	((regs) != NULL && ISALIGNED((uintptr)(regs), SI_CORE_SIZE))
+		IS_ALIGNED((x), SI_CORE_SIZE))
+#define	GOODREGS(regs)	((regs) != NULL && IS_ALIGNED((unsigned long)(regs), SI_CORE_SIZE))
 #define BADCOREADDR	0
 #define	GOODIDX(idx)	(((uint)idx) < SI_MAXCORES)
 #define	NOREV		-1	/* Invalid rev */
@@ -389,62 +325,48 @@ typedef struct si_info {
  * The returned path is NULL terminated and has trailing '/'.
  * Return 0 on success, nonzero otherwise.
  */
-extern int si_devpath(si_t * sih, char *path, int size);
+extern int si_devpath(si_t *sih, char *path, int size);
 /* Read variable with prepending the devpath to the name */
-extern char *si_getdevpathvar(si_t * sih, const char *name);
-extern int si_getdevpathintvar(si_t * sih, const char *name);
-
-extern uint8 si_pcieclkreq(si_t * sih, uint32 mask, uint32 val);
-extern uint32 si_pcielcreg(si_t * sih, uint32 mask, uint32 val);
-extern void si_war42780_clkreq(si_t * sih, bool clkreq);
-extern void si_pci_sleep(si_t * sih);
-extern void si_pci_down(si_t * sih);
-extern void si_pci_up(si_t * sih);
-extern void si_pcie_war_ovr_update(si_t * sih, uint8 aspm);
-extern void si_pcie_extendL1timer(si_t * sih, bool extend);
-extern int si_pci_fixcfg(si_t * sih);
-extern void si_chippkg_set(si_t * sih, uint);
-
-extern void si_chipcontrl_epa4331(si_t * sih, bool on);
-/* Enable Ex-PA for 4313 */
-extern void si_epa_4313war(si_t * sih);
+extern char *si_getdevpathvar(si_t *sih, const char *name);
+extern int si_getdevpathintvar(si_t *sih, const char *name);
 
-/* === debug routines === */
-extern uint32 si_pciereg(si_t * sih, uint32 offset, uint32 mask, uint32 val,
-			 uint type);
-extern uint32 si_pcieserdesreg(si_t * sih, uint32 mdioslave, uint32 offset,
-			       uint32 mask, uint32 val);
+extern void si_war42780_clkreq(si_t *sih, bool clkreq);
+extern void si_pci_sleep(si_t *sih);
+extern void si_pci_down(si_t *sih);
+extern void si_pci_up(si_t *sih);
+extern void si_pcie_extendL1timer(si_t *sih, bool extend);
+extern int si_pci_fixcfg(si_t *sih);
 
-char *si_getnvramflvar(si_t * sih, const char *name);
+extern void si_chipcontrl_epa4331(si_t *sih, bool on);
+/* Enable Ex-PA for 4313 */
+extern void si_epa_4313war(si_t *sih);
+
+char *si_getnvramflvar(si_t *sih, const char *name);
 
 /* AMBA Interconnect exported externs */
-extern si_t *ai_attach(uint pcidev, osl_t * osh, void *regs, uint bustype,
-		       void *sdh, char **vars, uint * varsz);
-extern si_t *ai_kattach(osl_t * osh);
-extern void ai_scan(si_t * sih, void *regs, uint devid);
-
-extern uint ai_flag(si_t * sih);
-extern void ai_setint(si_t * sih, int siflag);
-extern uint ai_coreidx(si_t * sih);
-extern uint ai_corevendor(si_t * sih);
-extern uint ai_corerev(si_t * sih);
-extern bool ai_iscoreup(si_t * sih);
-extern void *ai_setcoreidx(si_t * sih, uint coreidx);
-extern uint32 ai_core_cflags(si_t * sih, uint32 mask, uint32 val);
-extern void ai_core_cflags_wo(si_t * sih, uint32 mask, uint32 val);
-extern uint32 ai_core_sflags(si_t * sih, uint32 mask, uint32 val);
-extern uint ai_corereg(si_t * sih, uint coreidx, uint regoff, uint mask,
+extern si_t *ai_attach(uint pcidev, osl_t *osh, void *regs, uint bustype,
+		       void *sdh, char **vars, uint *varsz);
+extern si_t *ai_kattach(osl_t *osh);
+extern void ai_scan(si_t *sih, void *regs, uint devid);
+
+extern uint ai_flag(si_t *sih);
+extern void ai_setint(si_t *sih, int siflag);
+extern uint ai_coreidx(si_t *sih);
+extern uint ai_corevendor(si_t *sih);
+extern uint ai_corerev(si_t *sih);
+extern bool ai_iscoreup(si_t *sih);
+extern void *ai_setcoreidx(si_t *sih, uint coreidx);
+extern u32 ai_core_cflags(si_t *sih, u32 mask, u32 val);
+extern void ai_core_cflags_wo(si_t *sih, u32 mask, u32 val);
+extern u32 ai_core_sflags(si_t *sih, u32 mask, u32 val);
+extern uint ai_corereg(si_t *sih, uint coreidx, uint regoff, uint mask,
 		       uint val);
-extern void ai_core_reset(si_t * sih, uint32 bits, uint32 resetbits);
-extern void ai_core_disable(si_t * sih, uint32 bits);
-extern int ai_numaddrspaces(si_t * sih);
-extern uint32 ai_addrspace(si_t * sih, uint asidx);
-extern uint32 ai_addrspacesize(si_t * sih, uint asidx);
-extern void ai_write_wrap_reg(si_t * sih, uint32 offset, uint32 val);
-
-#ifdef BCMDBG
-extern void ai_view(si_t * sih, bool verbose);
-#endif
+extern void ai_core_reset(si_t *sih, u32 bits, u32 resetbits);
+extern void ai_core_disable(si_t *sih, u32 bits);
+extern int ai_numaddrspaces(si_t *sih);
+extern u32 ai_addrspace(si_t *sih, uint asidx);
+extern u32 ai_addrspacesize(si_t *sih, uint asidx);
+extern void ai_write_wrap_reg(si_t *sih, u32 offset, u32 val);
 
 #ifdef BCMSDIO
 #define si_setcoreidx(sih, idx) sb_setcoreidx(sih, idx)
diff --git a/drivers/staging/brcm80211/include/spid.h b/drivers/staging/brcm80211/include/spid.h
index 9cf4e0b..e0abb84 100644
--- a/drivers/staging/brcm80211/include/spid.h
+++ b/drivers/staging/brcm80211/include/spid.h
@@ -23,24 +23,24 @@
  */
 
 typedef volatile struct {
-	uint8 config;		/* 0x00, len, endian, clock, speed, polarity, wakeup */
-	uint8 response_delay;	/* 0x01, read response delay in bytes (corerev < 3) */
-	uint8 status_enable;	/* 0x02, status-enable, intr with status, response_delay
+	u8 config;		/* 0x00, len, endian, clock, speed, polarity, wakeup */
+	u8 response_delay;	/* 0x01, read response delay in bytes (corerev < 3) */
+	u8 status_enable;	/* 0x02, status-enable, intr with status, response_delay
 				 * function selection, command/data error check
 				 */
-	uint8 reset_bp;		/* 0x03, reset on wlan/bt backplane reset (corerev >= 1) */
-	uint16 intr_reg;	/* 0x04, Intr status register */
-	uint16 intr_en_reg;	/* 0x06, Intr mask register */
-	uint32 status_reg;	/* 0x08, RO, Status bits of last spi transfer */
-	uint16 f1_info_reg;	/* 0x0c, RO, enabled, ready for data transfer, blocksize */
-	uint16 f2_info_reg;	/* 0x0e, RO, enabled, ready for data transfer, blocksize */
-	uint16 f3_info_reg;	/* 0x10, RO, enabled, ready for data transfer, blocksize */
-	uint32 test_read;	/* 0x14, RO 0xfeedbead signature */
-	uint32 test_rw;		/* 0x18, RW */
-	uint8 resp_delay_f0;	/* 0x1c, read resp delay bytes for F0 (corerev >= 3) */
-	uint8 resp_delay_f1;	/* 0x1d, read resp delay bytes for F1 (corerev >= 3) */
-	uint8 resp_delay_f2;	/* 0x1e, read resp delay bytes for F2 (corerev >= 3) */
-	uint8 resp_delay_f3;	/* 0x1f, read resp delay bytes for F3 (corerev >= 3) */
+	u8 reset_bp;		/* 0x03, reset on wlan/bt backplane reset (corerev >= 1) */
+	u16 intr_reg;	/* 0x04, Intr status register */
+	u16 intr_en_reg;	/* 0x06, Intr mask register */
+	u32 status_reg;	/* 0x08, RO, Status bits of last spi transfer */
+	u16 f1_info_reg;	/* 0x0c, RO, enabled, ready for data transfer, blocksize */
+	u16 f2_info_reg;	/* 0x0e, RO, enabled, ready for data transfer, blocksize */
+	u16 f3_info_reg;	/* 0x10, RO, enabled, ready for data transfer, blocksize */
+	u32 test_read;	/* 0x14, RO 0xfeedbead signature */
+	u32 test_rw;		/* 0x18, RW */
+	u8 resp_delay_f0;	/* 0x1c, read resp delay bytes for F0 (corerev >= 3) */
+	u8 resp_delay_f1;	/* 0x1d, read resp delay bytes for F1 (corerev >= 3) */
+	u8 resp_delay_f2;	/* 0x1e, read resp delay bytes for F2 (corerev >= 3) */
+	u8 resp_delay_f3;	/* 0x1f, read resp delay bytes for F3 (corerev >= 3) */
 } spi_regs_t;
 
 /* SPI device register offsets */
diff --git a/drivers/staging/brcm80211/include/typedefs.h b/drivers/staging/brcm80211/include/typedefs.h
deleted file mode 100644
index f7d1a5e..0000000
--- a/drivers/staging/brcm80211/include/typedefs.h
+++ /dev/null
@@ -1,214 +0,0 @@
-/*
- * Copyright (c) 2010 Broadcom Corporation
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#ifndef _TYPEDEFS_H_
-#define _TYPEDEFS_H_
-
-/*
- * Infer the compile environment based on preprocessor symbols and pragmas.
- * Override type definitions as needed, and include configuration-dependent
- * header files to define types.
- */
-
-#if defined(__x86_64__)
-#define TYPEDEF_UINTPTR
-typedef unsigned long long int uintptr;
-#endif
-
-#if defined(_NEED_SIZE_T_)
-typedef long unsigned int size_t;
-#endif
-
-#define TYPEDEF_UINT
-#define TYPEDEF_USHORT
-#define TYPEDEF_ULONG
-#include <linux/version.h>
-#define TYPEDEF_BOOL
-
-/* Do not support the (u)int64 types with strict ansi for GNU C */
-#if defined(__GNUC__) && defined(__STRICT_ANSI__)
-#define TYPEDEF_INT64
-#define TYPEDEF_UINT64
-#endif
-
-#include <linux/types.h>
-
-/*
- * Default Typedefs
- */
-#ifndef TYPEDEF_BOOL
-typedef /* @abstract@ */ unsigned char bool;
-#endif
-
-/* define uchar, ushort, uint, ulong */
-
-#ifndef TYPEDEF_UCHAR
-typedef unsigned char uchar;
-#endif
-
-#ifndef TYPEDEF_USHORT
-typedef unsigned short ushort;
-#endif
-
-#ifndef TYPEDEF_UINT
-typedef unsigned int uint;
-#endif
-
-#ifndef TYPEDEF_ULONG
-typedef unsigned long ulong;
-#endif
-
-/* define [u]int8/16/32/64, uintptr */
-
-#ifndef TYPEDEF_UINT8
-typedef unsigned char uint8;
-#endif
-
-#ifndef TYPEDEF_UINT16
-typedef unsigned short uint16;
-#endif
-
-#ifndef TYPEDEF_UINT32
-typedef unsigned int uint32;
-#endif
-
-#ifndef TYPEDEF_UINT64
-typedef unsigned long long uint64;
-#endif
-
-#ifndef TYPEDEF_UINTPTR
-typedef unsigned int uintptr;
-#endif
-
-#ifndef TYPEDEF_INT8
-typedef signed char int8;
-#endif
-
-#ifndef TYPEDEF_INT16
-typedef signed short int16;
-#endif
-
-#ifndef TYPEDEF_INT32
-typedef signed int int32;
-#endif
-
-#ifndef TYPEDEF_INT64
-typedef signed long long int64;
-#endif
-
-/* define float32/64, float_t */
-
-#ifndef TYPEDEF_FLOAT32
-typedef float float32;
-#endif
-
-#ifndef TYPEDEF_FLOAT64
-typedef double float64;
-#endif
-
-/*
- * abstracted floating point type allows for compile time selection of
- * single or double precision arithmetic.  Compiling with -DFLOAT32
- * selects single precision; the default is double precision.
- */
-
-#ifndef TYPEDEF_FLOAT_T
-
-#if defined(FLOAT32)
-typedef float32 float_t;
-#else				/* default to double precision floating point */
-typedef float64 float_t;
-#endif
-
-#endif				/* TYPEDEF_FLOAT_T */
-
-/* define macro values */
-
-#ifndef FALSE
-#define FALSE	0
-#endif
-
-#ifndef TRUE
-#define TRUE	1		/* TRUE */
-#endif
-
-#ifndef NULL
-#define	NULL	0
-#endif
-
-#ifndef OFF
-#define	OFF	0
-#endif
-
-#ifndef ON
-#define	ON	1		/* ON = 1 */
-#endif
-
-#define	AUTO	(-1)		/* Auto = -1 */
-
-/* define PTRSZ, INLINE */
-
-#ifndef PTRSZ
-#define	PTRSZ	sizeof(char*)
-#endif
-
-/* Detect compiler type. */
-#if defined(__GNUC__)
-#define BWL_COMPILER_GNU
-#elif defined(__CC_ARM) && __CC_ARM
-#define BWL_COMPILER_ARMCC
-#else
-#error "Unknown compiler!"
-#endif
-
-#ifndef INLINE
-#if defined(BWL_COMPILER_GNU)
-#define INLINE __inline__
-#elif defined(BWL_COMPILER_ARMCC)
-#define INLINE	__inline
-#else
-#define INLINE
-#endif
-#endif				/* INLINE */
-
-#undef TYPEDEF_BOOL
-#undef TYPEDEF_UCHAR
-#undef TYPEDEF_USHORT
-#undef TYPEDEF_UINT
-#undef TYPEDEF_ULONG
-#undef TYPEDEF_UINT8
-#undef TYPEDEF_UINT16
-#undef TYPEDEF_UINT32
-#undef TYPEDEF_UINT64
-#undef TYPEDEF_UINTPTR
-#undef TYPEDEF_INT8
-#undef TYPEDEF_INT16
-#undef TYPEDEF_INT32
-#undef TYPEDEF_INT64
-#undef TYPEDEF_FLOAT32
-#undef TYPEDEF_FLOAT64
-#undef TYPEDEF_FLOAT_T
-
-/* Suppress unused parameter warning */
-#define UNUSED_PARAMETER(x) (void)(x)
-
-/*
- * Including the bcmdefs.h here, to make sure everyone including typedefs.h
- * gets this automatically
-*/
-#include <bcmdefs.h>
-
-#endif				/* _TYPEDEFS_H_ */
diff --git a/drivers/staging/brcm80211/include/wlioctl.h b/drivers/staging/brcm80211/include/wlioctl.h
index 970573b..96866fb 100644
--- a/drivers/staging/brcm80211/include/wlioctl.h
+++ b/drivers/staging/brcm80211/include/wlioctl.h
@@ -17,8 +17,10 @@
 #ifndef _wlioctl_h_
 #define	_wlioctl_h_
 
-#include <typedefs.h>
 #include <proto/ethernet.h>
+#ifdef BRCM_FULLMAC
+#include <proto/bcmeth.h>
+#endif
 #include <proto/bcmevent.h>
 #include <proto/802.11.h>
 #include <bcmwifi.h>
@@ -36,25 +38,25 @@
 #define	LEGACY_WL_BSS_INFO_VERSION	107	/* older version of wl_bss_info struct */
 
 typedef struct wl_bss_info_107 {
-	uint32 version;		/* version field */
-	uint32 length;		/* byte length of data in this record,
+	u32 version;		/* version field */
+	u32 length;		/* byte length of data in this record,
 				 * starting at version and including IEs
 				 */
 	struct ether_addr BSSID;
-	uint16 beacon_period;	/* units are Kusec */
-	uint16 capability;	/* Capability information */
-	uint8 SSID_len;
-	uint8 SSID[32];
+	u16 beacon_period;	/* units are Kusec */
+	u16 capability;	/* Capability information */
+	u8 SSID_len;
+	u8 SSID[32];
 	struct {
 		uint count;	/* # rates in this set */
-		uint8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
+		u8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
 	} rateset;		/* supported rates */
-	uint8 channel;		/* Channel no. */
-	uint16 atim_window;	/* units are Kusec */
-	uint8 dtim_period;	/* DTIM period */
-	int16 RSSI;		/* receive signal strength (in dBm) */
-	int8 phy_noise;		/* noise (in dBm) */
-	uint32 ie_length;	/* byte length of Information Elements */
+	u8 channel;		/* Channel no. */
+	u16 atim_window;	/* units are Kusec */
+	u8 dtim_period;	/* DTIM period */
+	s16 RSSI;		/* receive signal strength (in dBm) */
+	s8 phy_noise;		/* noise (in dBm) */
+	u32 ie_length;	/* byte length of Information Elements */
 	/* variable length Information Elements */
 } wl_bss_info_107_t;
 
@@ -69,91 +71,95 @@ typedef struct wl_bss_info_107 {
  * next bss_info structure in a vector (in wl_scan_results_t)
  */
 typedef struct wl_bss_info_108 {
-	uint32 version;		/* version field */
-	uint32 length;		/* byte length of data in this record,
+	u32 version;		/* version field */
+	u32 length;		/* byte length of data in this record,
 				 * starting at version and including IEs
 				 */
 	struct ether_addr BSSID;
-	uint16 beacon_period;	/* units are Kusec */
-	uint16 capability;	/* Capability information */
-	uint8 SSID_len;
-	uint8 SSID[32];
+	u16 beacon_period;	/* units are Kusec */
+	u16 capability;	/* Capability information */
+	u8 SSID_len;
+	u8 SSID[32];
 	struct {
 		uint count;	/* # rates in this set */
-		uint8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
+		u8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
 	} rateset;		/* supported rates */
 	chanspec_t chanspec;	/* chanspec for bss */
-	uint16 atim_window;	/* units are Kusec */
-	uint8 dtim_period;	/* DTIM period */
-	int16 RSSI;		/* receive signal strength (in dBm) */
-	int8 phy_noise;		/* noise (in dBm) */
-
-	uint8 n_cap;		/* BSS is 802.11N Capable */
-	uint32 nbss_cap;	/* 802.11N BSS Capabilities (based on HT_CAP_*) */
-	uint8 ctl_ch;		/* 802.11N BSS control channel number */
-	uint32 reserved32[1];	/* Reserved for expansion of BSS properties */
-	uint8 flags;		/* flags */
-	uint8 reserved[3];	/* Reserved for expansion of BSS properties */
-	uint8 basic_mcs[MCSSET_LEN];	/* 802.11N BSS required MCS set */
-
-	uint16 ie_offset;	/* offset at which IEs start, from beginning */
-	uint32 ie_length;	/* byte length of Information Elements */
+	u16 atim_window;	/* units are Kusec */
+	u8 dtim_period;	/* DTIM period */
+	s16 RSSI;		/* receive signal strength (in dBm) */
+	s8 phy_noise;		/* noise (in dBm) */
+
+	u8 n_cap;		/* BSS is 802.11N Capable */
+	u32 nbss_cap;	/* 802.11N BSS Capabilities (based on HT_CAP_*) */
+	u8 ctl_ch;		/* 802.11N BSS control channel number */
+	u32 reserved32[1];	/* Reserved for expansion of BSS properties */
+	u8 flags;		/* flags */
+	u8 reserved[3];	/* Reserved for expansion of BSS properties */
+	u8 basic_mcs[MCSSET_LEN];	/* 802.11N BSS required MCS set */
+
+	u16 ie_offset;	/* offset at which IEs start, from beginning */
+	u32 ie_length;	/* byte length of Information Elements */
 	/* Add new fields here */
 	/* variable length Information Elements */
 } wl_bss_info_108_t;
 
-#define	WL_BSS_INFO_VERSION	109	/* current version of wl_bss_info struct */
+#ifdef BRCM_FULLMAC
+#define	WL_BSS_INFO_VERSION	108	/* current ver of wl_bss_info struct */
+#else
+#define	WL_BSS_INFO_VERSION	109	/* current ver of wl_bss_info struct */
+#endif
 
 /* BSS info structure
  * Applications MUST CHECK ie_offset field and length field to access IEs and
  * next bss_info structure in a vector (in wl_scan_results_t)
  */
 typedef struct wl_bss_info {
-	uint32 version;		/* version field */
-	uint32 length;		/* byte length of data in this record,
+	u32 version;		/* version field */
+	u32 length;		/* byte length of data in this record,
 				 * starting at version and including IEs
 				 */
 	struct ether_addr BSSID;
-	uint16 beacon_period;	/* units are Kusec */
-	uint16 capability;	/* Capability information */
-	uint8 SSID_len;
-	uint8 SSID[32];
+	u16 beacon_period;	/* units are Kusec */
+	u16 capability;	/* Capability information */
+	u8 SSID_len;
+	u8 SSID[32];
 	struct {
 		uint count;	/* # rates in this set */
-		uint8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
+		u8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
 	} rateset;		/* supported rates */
 	chanspec_t chanspec;	/* chanspec for bss */
-	uint16 atim_window;	/* units are Kusec */
-	uint8 dtim_period;	/* DTIM period */
-	int16 RSSI;		/* receive signal strength (in dBm) */
-	int8 phy_noise;		/* noise (in dBm) */
-
-	uint8 n_cap;		/* BSS is 802.11N Capable */
-	uint32 nbss_cap;	/* 802.11N BSS Capabilities (based on HT_CAP_*) */
-	uint8 ctl_ch;		/* 802.11N BSS control channel number */
-	uint32 reserved32[1];	/* Reserved for expansion of BSS properties */
-	uint8 flags;		/* flags */
-	uint8 reserved[3];	/* Reserved for expansion of BSS properties */
-	uint8 basic_mcs[MCSSET_LEN];	/* 802.11N BSS required MCS set */
-
-	uint16 ie_offset;	/* offset at which IEs start, from beginning */
-	uint32 ie_length;	/* byte length of Information Elements */
-	int16 SNR;		/* average SNR of during frame reception */
+	u16 atim_window;	/* units are Kusec */
+	u8 dtim_period;	/* DTIM period */
+	s16 RSSI;		/* receive signal strength (in dBm) */
+	s8 phy_noise;		/* noise (in dBm) */
+
+	u8 n_cap;		/* BSS is 802.11N Capable */
+	u32 nbss_cap;	/* 802.11N BSS Capabilities (based on HT_CAP_*) */
+	u8 ctl_ch;		/* 802.11N BSS control channel number */
+	u32 reserved32[1];	/* Reserved for expansion of BSS properties */
+	u8 flags;		/* flags */
+	u8 reserved[3];	/* Reserved for expansion of BSS properties */
+	u8 basic_mcs[MCSSET_LEN];	/* 802.11N BSS required MCS set */
+
+	u16 ie_offset;	/* offset at which IEs start, from beginning */
+	u32 ie_length;	/* byte length of Information Elements */
+	s16 SNR;		/* average SNR of during frame reception */
 	/* Add new fields here */
 	/* variable length Information Elements */
 } wl_bss_info_t;
 
 typedef struct wlc_ssid {
-	uint32 SSID_len;
-	uchar SSID[32];
+	u32 SSID_len;
+	unsigned char SSID[32];
 } wlc_ssid_t;
 
 typedef struct chan_scandata {
-	uint8 txpower;
-	uint8 pad;
+	u8 txpower;
+	u8 pad;
 	chanspec_t channel;	/* Channel num, bw, ctrl_sb and band */
-	uint32 channel_mintime;
-	uint32 channel_maxtime;
+	u32 channel_mintime;
+	u32 channel_maxtime;
 } chan_scandata_t;
 
 typedef enum wl_scan_type {
@@ -169,14 +175,14 @@ typedef enum wl_scan_type {
 #define WL_BSS_FLAGS_RSSI_ONCHANNEL     0x04	/* rssi info was received on channel (vs offchannel) */
 
 typedef struct wl_extdscan_params {
-	int8 nprobes;		/* 0, passive, otherwise active */
-	int8 split_scan;	/* split scan */
-	int8 band;		/* band */
-	int8 pad;
+	s8 nprobes;		/* 0, passive, otherwise active */
+	s8 split_scan;	/* split scan */
+	s8 band;		/* band */
+	s8 pad;
 	wlc_ssid_t ssid[WLC_EXTDSCAN_MAX_SSID];	/* ssid list */
-	uint32 tx_rate;		/* in 500ksec units */
+	u32 tx_rate;		/* in 500ksec units */
 	wl_scan_type_t scan_type;	/* enum */
-	int32 channel_num;
+	s32 channel_num;
 	chan_scandata_t channel_list[1];	/* list of chandata structs */
 } wl_extdscan_params_t;
 
@@ -194,27 +200,27 @@ typedef struct wl_extdscan_params {
 typedef struct wl_scan_params {
 	wlc_ssid_t ssid;	/* default: {0, ""} */
 	struct ether_addr bssid;	/* default: bcast */
-	int8 bss_type;		/* default: any,
+	s8 bss_type;		/* default: any,
 				 * DOT11_BSSTYPE_ANY/INFRASTRUCTURE/INDEPENDENT
 				 */
-	uint8 scan_type;	/* flags, 0 use default */
-	int32 nprobes;		/* -1 use default, number of probes per channel */
-	int32 active_time;	/* -1 use default, dwell time per channel for
+	u8 scan_type;	/* flags, 0 use default */
+	s32 nprobes;		/* -1 use default, number of probes per channel */
+	s32 active_time;	/* -1 use default, dwell time per channel for
 				 * active scanning
 				 */
-	int32 passive_time;	/* -1 use default, dwell time per channel
+	s32 passive_time;	/* -1 use default, dwell time per channel
 				 * for passive scanning
 				 */
-	int32 home_time;	/* -1 use default, dwell time for the home channel
+	s32 home_time;	/* -1 use default, dwell time for the home channel
 				 * between channel scans
 				 */
-	int32 channel_num;	/* count of channels and ssids that follow
+	s32 channel_num;	/* count of channels and ssids that follow
 				 *
 				 * low half is count of channels in channel_list, 0
 				 * means default (use all available channels)
 				 *
 				 * high half is entries in wlc_ssid_t array that
-				 * follows channel_list, aligned for int32 (4 bytes)
+				 * follows channel_list, aligned for s32 (4 bytes)
 				 * meaning an odd channel count implies a 2-byte pad
 				 * between end of channel_list and first ssid
 				 *
@@ -222,7 +228,7 @@ typedef struct wl_scan_params {
 				 * parameter portion is assumed, otherwise ssid in
 				 * the fixed portion is ignored
 				 */
-	uint16 channel_list[1];	/* list of chanspecs */
+	u16 channel_list[1];	/* list of chanspecs */
 } wl_scan_params_t;
 
 /* size of wl_scan_params not including variable length array */
@@ -240,19 +246,19 @@ typedef struct wl_scan_params {
 
 /* incremental scan struct */
 typedef struct wl_iscan_params {
-	uint32 version;
-	uint16 action;
-	uint16 scan_duration;
+	u32 version;
+	u16 action;
+	u16 scan_duration;
 	wl_scan_params_t params;
 } wl_iscan_params_t;
 
 /* 3 fields + size of wl_scan_params, not including variable length array */
-#define WL_ISCAN_PARAMS_FIXED_SIZE (OFFSETOF(wl_iscan_params_t, params) + sizeof(wlc_ssid_t))
+#define WL_ISCAN_PARAMS_FIXED_SIZE (offsetof(wl_iscan_params_t, params) + sizeof(wlc_ssid_t))
 
 typedef struct wl_scan_results {
-	uint32 buflen;
-	uint32 version;
-	uint32 count;
+	u32 buflen;
+	u32 version;
+	u32 count;
 	wl_bss_info_t bss_info[1];
 } wl_scan_results_t;
 
@@ -264,23 +270,24 @@ typedef struct wl_scan_results {
 #define WL_SCAN_RESULTS_PARTIAL	1
 #define WL_SCAN_RESULTS_PENDING	2
 #define WL_SCAN_RESULTS_ABORTED	3
+#define WL_SCAN_RESULTS_NO_MEM	4
 
 #define ESCAN_REQ_VERSION 1
 
 typedef struct wl_escan_params {
-	uint32 version;
-	uint16 action;
-	uint16 sync_id;
+	u32 version;
+	u16 action;
+	u16 sync_id;
 	wl_scan_params_t params;
 } wl_escan_params_t;
 
-#define WL_ESCAN_PARAMS_FIXED_SIZE (OFFSETOF(wl_escan_params_t, params) + sizeof(wlc_ssid_t))
+#define WL_ESCAN_PARAMS_FIXED_SIZE (offsetof(wl_escan_params_t, params) + sizeof(wlc_ssid_t))
 
 typedef struct wl_escan_result {
-	uint32 buflen;
-	uint32 version;
-	uint16 sync_id;
-	uint16 bss_count;
+	u32 buflen;
+	u32 version;
+	u16 sync_id;
+	u16 bss_count;
 	wl_bss_info_t bss_info[1];
 } wl_escan_result_t;
 
@@ -288,13 +295,13 @@ typedef struct wl_escan_result {
 
 /* incremental scan results struct */
 typedef struct wl_iscan_results {
-	uint32 status;
+	u32 status;
 	wl_scan_results_t results;
 } wl_iscan_results_t;
 
 /* size of wl_iscan_results not including variable length array */
 #define WL_ISCAN_RESULTS_FIXED_SIZE \
-	(WL_SCAN_RESULTS_FIXED_SIZE + OFFSETOF(wl_iscan_results_t, results))
+	(WL_SCAN_RESULTS_FIXED_SIZE + offsetof(wl_iscan_results_t, results))
 
 typedef struct wl_probe_params {
 	wlc_ssid_t ssid;
@@ -304,28 +311,28 @@ typedef struct wl_probe_params {
 
 #define WL_NUMRATES		16	/* max # of rates in a rateset */
 typedef struct wl_rateset {
-	uint32 count;		/* # rates in this set */
-	uint8 rates[WL_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
+	u32 count;		/* # rates in this set */
+	u8 rates[WL_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
 } wl_rateset_t;
 
 typedef struct wl_rateset_args {
-	uint32 count;		/* # rates in this set */
-	uint8 rates[WL_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
-	uint8 mcs[MCSSET_LEN];	/* supported mcs index bit map */
+	u32 count;		/* # rates in this set */
+	u8 rates[WL_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
+	u8 mcs[MCSSET_LEN];	/* supported mcs index bit map */
 } wl_rateset_args_t;
 
-/* uint32 list */
-typedef struct wl_uint32_list {
+/* u32 list */
+typedef struct wl_u32_list {
 	/* in - # of elements, out - # of entries */
-	uint32 count;
-	/* variable length uint32 list */
-	uint32 element[1];
-} wl_uint32_list_t;
+	u32 count;
+	/* variable length u32 list */
+	u32 element[1];
+} wl_u32_list_t;
 
 /* used for association with a specific BSSID and chanspec list */
 typedef struct wl_assoc_params {
 	struct ether_addr bssid;	/* 00:00:00:00:00:00: broadcast scan */
-	int32 chanspec_num;	/* 0: all available channels,
+	s32 chanspec_num;	/* 0: all available channels,
 				 * otherwise count of chanspecs in chanspec_list
 				 */
 	chanspec_t chanspec_list[1];	/* list of chanspecs */
@@ -378,8 +385,8 @@ typedef struct wl_join_params {
 #define MAX_STREAMS_SUPPORTED	4	/* max number of streams supported */
 
 typedef struct {
-	uint8 ant_config[ANT_SELCFG_MAX];	/* antenna configuration */
-	uint8 num_antcfg;	/* number of available antenna configurations */
+	u8 ant_config[ANT_SELCFG_MAX];	/* antenna configuration */
+	u8 num_antcfg;	/* number of available antenna configurations */
 } wlc_antselcfg_t;
 
 #define HIGHEST_SINGLE_STREAM_MCS	7	/* MCS values greater than this enable multiple streams */
@@ -407,17 +414,17 @@ typedef struct {
 #define CCA_ERRNO_TOO_FEW	5	/* Only 1 channel was input */
 
 typedef struct {
-	uint32 duration;	/* millisecs spent sampling this channel */
-	uint32 congest_ibss;	/* millisecs in our bss (presumably this traffic will */
+	u32 duration;	/* millisecs spent sampling this channel */
+	u32 congest_ibss;	/* millisecs in our bss (presumably this traffic will */
 	/*  move if cur bss moves channels) */
-	uint32 congest_obss;	/* traffic not in our bss */
-	uint32 interference;	/* millisecs detecting a non 802.11 interferer. */
-	uint32 timestamp;	/* second timestamp */
+	u32 congest_obss;	/* traffic not in our bss */
+	u32 interference;	/* millisecs detecting a non 802.11 interferer. */
+	u32 timestamp;	/* second timestamp */
 } cca_congest_t;
 
 typedef struct {
 	chanspec_t chanspec;	/* Which channel? */
-	uint8 num_secs;		/* How many secs worth of data */
+	u8 num_secs;		/* How many secs worth of data */
 	cca_congest_t secs[1];	/* Data */
 } cca_congest_channel_req_t;
 
@@ -427,7 +434,7 @@ typedef struct wl_country {
 	char country_abbrev[WLC_CNTRY_BUF_SZ];	/* nul-terminated country code used in
 						 * the Country IE
 						 */
-	int32 rev;		/* revision specifier for ccode
+	s32 rev;		/* revision specifier for ccode
 				 * on set, -1 indicates unspecified.
 				 * on get, rev >= 0
 				 */
@@ -439,18 +446,18 @@ typedef struct wl_country {
 } wl_country_t;
 
 typedef struct wl_channels_in_country {
-	uint32 buflen;
-	uint32 band;
+	u32 buflen;
+	u32 band;
 	char country_abbrev[WLC_CNTRY_BUF_SZ];
-	uint32 count;
-	uint32 channel[1];
+	u32 count;
+	u32 channel[1];
 } wl_channels_in_country_t;
 
 typedef struct wl_country_list {
-	uint32 buflen;
-	uint32 band_set;
-	uint32 band;
-	uint32 count;
+	u32 buflen;
+	u32 band_set;
+	u32 band;
+	u32 count;
 	char country_abbrev[1];
 } wl_country_list_t;
 
@@ -466,46 +473,46 @@ typedef struct wl_country_list {
 #define WL_RM_FLAG_REFUSED	(1<<3)
 
 typedef struct wl_rm_req_elt {
-	int8 type;
-	int8 flags;
+	s8 type;
+	s8 flags;
 	chanspec_t chanspec;
-	uint32 token;		/* token for this measurement */
-	uint32 tsf_h;		/* TSF high 32-bits of Measurement start time */
-	uint32 tsf_l;		/* TSF low 32-bits */
-	uint32 dur;		/* TUs */
+	u32 token;		/* token for this measurement */
+	u32 tsf_h;		/* TSF high 32-bits of Measurement start time */
+	u32 tsf_l;		/* TSF low 32-bits */
+	u32 dur;		/* TUs */
 } wl_rm_req_elt_t;
 
 typedef struct wl_rm_req {
-	uint32 token;		/* overall measurement set token */
-	uint32 count;		/* number of measurement requests */
+	u32 token;		/* overall measurement set token */
+	u32 count;		/* number of measurement requests */
 	void *cb;		/* completion callback function: may be NULL */
 	void *cb_arg;		/* arg to completion callback function */
 	wl_rm_req_elt_t req[1];	/* variable length block of requests */
 } wl_rm_req_t;
-#define WL_RM_REQ_FIXED_LEN	OFFSETOF(wl_rm_req_t, req)
+#define WL_RM_REQ_FIXED_LEN	offsetof(wl_rm_req_t, req)
 
 typedef struct wl_rm_rep_elt {
-	int8 type;
-	int8 flags;
+	s8 type;
+	s8 flags;
 	chanspec_t chanspec;
-	uint32 token;		/* token for this measurement */
-	uint32 tsf_h;		/* TSF high 32-bits of Measurement start time */
-	uint32 tsf_l;		/* TSF low 32-bits */
-	uint32 dur;		/* TUs */
-	uint32 len;		/* byte length of data block */
-	uint8 data[1];		/* variable length data block */
+	u32 token;		/* token for this measurement */
+	u32 tsf_h;		/* TSF high 32-bits of Measurement start time */
+	u32 tsf_l;		/* TSF low 32-bits */
+	u32 dur;		/* TUs */
+	u32 len;		/* byte length of data block */
+	u8 data[1];		/* variable length data block */
 } wl_rm_rep_elt_t;
 #define WL_RM_REP_ELT_FIXED_LEN	24	/* length excluding data block */
 
 #define WL_RPI_REP_BIN_NUM 8
 typedef struct wl_rm_rpi_rep {
-	uint8 rpi[WL_RPI_REP_BIN_NUM];
-	int8 rpi_max[WL_RPI_REP_BIN_NUM];
+	u8 rpi[WL_RPI_REP_BIN_NUM];
+	s8 rpi_max[WL_RPI_REP_BIN_NUM];
 } wl_rm_rpi_rep_t;
 
 typedef struct wl_rm_rep {
-	uint32 token;		/* overall measurement set token */
-	uint32 len;		/* length of measurement report block */
+	u32 token;		/* overall measurement set token */
+	u32 len;		/* length of measurement report block */
 	wl_rm_rep_elt_t rep[1];	/* variable length block of reports */
 } wl_rm_rep_t;
 #define WL_RM_REP_FIXED_LEN	8
@@ -531,22 +538,22 @@ typedef struct wl_rm_rep {
 #define WL_IBSS_PEER_GROUP_KEY	(1 << 6)	/* Indicates a group key for a IBSS PEER */
 
 typedef struct wl_wsec_key {
-	uint32 index;		/* key index */
-	uint32 len;		/* key length */
-	uint8 data[DOT11_MAX_KEY_SIZE];	/* key data */
-	uint32 pad_1[18];
-	uint32 algo;		/* CRYPTO_ALGO_AES_CCM, CRYPTO_ALGO_WEP128, etc */
-	uint32 flags;		/* misc flags */
-	uint32 pad_2[2];
+	u32 index;		/* key index */
+	u32 len;		/* key length */
+	u8 data[DOT11_MAX_KEY_SIZE];	/* key data */
+	u32 pad_1[18];
+	u32 algo;		/* CRYPTO_ALGO_AES_CCM, CRYPTO_ALGO_WEP128, etc */
+	u32 flags;		/* misc flags */
+	u32 pad_2[2];
 	int pad_3;
 	int iv_initialized;	/* has IV been initialized already? */
 	int pad_4;
 	/* Rx IV */
 	struct {
-		uint32 hi;	/* upper 32 bits of IV */
-		uint16 lo;	/* lower 16 bits of IV */
+		u32 hi;	/* upper 32 bits of IV */
+		u16 lo;	/* lower 16 bits of IV */
 	} rxiv;
-	uint32 pad_5[2];
+	u32 pad_5[2];
 	struct ether_addr ea;	/* per station */
 } wl_wsec_key_t;
 
@@ -558,9 +565,9 @@ typedef struct wl_wsec_key {
 
 /* receptacle for WLC_SET_WSEC_PMK parameter */
 typedef struct {
-	ushort key_len;		/* octets in key material */
-	ushort flags;		/* key handling qualification */
-	uint8 key[WSEC_MAX_PSK_LEN];	/* PMK material */
+	unsigned short key_len;		/* octets in key material */
+	unsigned short flags;		/* key handling qualification */
+	u8 key[WSEC_MAX_PSK_LEN];	/* PMK material */
 } wsec_pmk_t;
 
 /* wireless security bitvec */
@@ -590,39 +597,30 @@ typedef struct {
 
 typedef struct _pmkid {
 	struct ether_addr BSSID;
-	uint8 PMKID[WPA2_PMKID_LEN];
+	u8 PMKID[WPA2_PMKID_LEN];
 } pmkid_t;
 
 typedef struct _pmkid_list {
-	uint32 npmkid;
+	u32 npmkid;
 	pmkid_t pmkid[1];
 } pmkid_list_t;
 
 typedef struct _pmkid_cand {
 	struct ether_addr BSSID;
-	uint8 preauth;
+	u8 preauth;
 } pmkid_cand_t;
 
 typedef struct _pmkid_cand_list {
-	uint32 npmkid_cand;
+	u32 npmkid_cand;
 	pmkid_cand_t pmkid_cand[1];
 } pmkid_cand_list_t;
 
 typedef struct wl_led_info {
-	uint32 index;		/* led index */
-	uint32 behavior;
-	uint8 activehi;
+	u32 index;		/* led index */
+	u32 behavior;
+	u8 activehi;
 } wl_led_info_t;
 
-typedef struct wl_assoc_info {
-	uint32 req_len;
-	uint32 resp_len;
-	uint32 flags;
-	struct dot11_assoc_req req;
-	struct ether_addr reassoc_bssid;	/* used in reassoc's */
-	struct dot11_assoc_resp resp;
-} wl_assoc_info_t;
-
 /* flags */
 #define WLC_ASSOC_REQ_IS_REASSOC 0x01	/* assoc req was actually a reassoc */
 
@@ -630,14 +628,14 @@ typedef struct wl_assoc_info {
 typedef struct {
 	uint byteoff;		/* byte offset */
 	uint nbytes;		/* number of bytes */
-	uint16 buf[1];
+	u16 buf[1];
 } srom_rw_t;
 
 /* similar cis (srom or otp) struct [iovar: may not be aligned] */
 typedef struct {
-	uint32 source;		/* cis source */
-	uint32 byteoff;		/* byte offset */
-	uint32 nbytes;		/* number of bytes */
+	u32 source;		/* cis source */
+	u32 byteoff;		/* byte offset */
+	u32 nbytes;		/* number of bytes */
 	/* data follows here */
 } cis_rw_t;
 
@@ -647,9 +645,9 @@ typedef struct {
 
 /* R_REG and W_REG struct passed through ioctl */
 typedef struct {
-	uint32 byteoff;		/* byte offset of the field in d11regs_t */
-	uint32 val;		/* read/write value of the field */
-	uint32 size;		/* sizeof the field */
+	u32 byteoff;		/* byte offset of the field in d11regs_t */
+	u32 val;		/* read/write value of the field */
+	u32 size;		/* sizeof the field */
 	uint band;		/* band (optional) */
 } rw_reg_t;
 
@@ -662,19 +660,19 @@ typedef struct {
 #define WL_ATTEN_PCL_OFF		2	/* turn off PCL. */
 
 typedef struct {
-	uint16 auto_ctrl;	/* WL_ATTEN_XX */
-	uint16 bb;		/* Baseband attenuation */
-	uint16 radio;		/* Radio attenuation */
-	uint16 txctl1;		/* Radio TX_CTL1 value */
+	u16 auto_ctrl;	/* WL_ATTEN_XX */
+	u16 bb;		/* Baseband attenuation */
+	u16 radio;		/* Radio attenuation */
+	u16 txctl1;		/* Radio TX_CTL1 value */
 } atten_t;
 
 /* Per-AC retry parameters */
 struct wme_tx_params_s {
-	uint8 short_retry;
-	uint8 short_fallback;
-	uint8 long_retry;
-	uint8 long_fallback;
-	uint16 max_rate;	/* In units of 512 Kbps */
+	u8 short_retry;
+	u8 short_fallback;
+	u8 long_retry;
+	u8 long_fallback;
+	u16 max_rate;	/* In units of 512 Kbps */
 };
 
 typedef struct wme_tx_params_s wme_tx_params_t;
@@ -695,33 +693,33 @@ typedef struct wme_tx_params_s wme_tx_params_t;
 /* Used to get specific link/ac parameters */
 typedef struct {
 	int ac;
-	uint8 val;
+	u8 val;
 	struct ether_addr ea;
 } link_val_t;
 
 #define BCM_MAC_STATUS_INDICATION	(0x40010200L)
 
 typedef struct {
-	uint16 ver;		/* version of this struct */
-	uint16 len;		/* length in bytes of this structure */
-	uint16 cap;		/* sta's advertised capabilities */
-	uint32 flags;		/* flags defined below */
-	uint32 idle;		/* time since data pkt rx'd from sta */
+	u16 ver;		/* version of this struct */
+	u16 len;		/* length in bytes of this structure */
+	u16 cap;		/* sta's advertised capabilities */
+	u32 flags;		/* flags defined below */
+	u32 idle;		/* time since data pkt rx'd from sta */
 	struct ether_addr ea;	/* Station address */
 	wl_rateset_t rateset;	/* rateset in use */
-	uint32 in;		/* seconds elapsed since associated */
-	uint32 listen_interval_inms;	/* Min Listen interval in ms for this STA */
-	uint32 tx_pkts;		/* # of packets transmitted */
-	uint32 tx_failures;	/* # of packets failed */
-	uint32 rx_ucast_pkts;	/* # of unicast packets received */
-	uint32 rx_mcast_pkts;	/* # of multicast packets received */
-	uint32 tx_rate;		/* Rate of last successful tx frame */
-	uint32 rx_rate;		/* Rate of last successful rx frame */
-	uint32 rx_decrypt_succeeds;	/* # of packet decrypted successfully */
-	uint32 rx_decrypt_failures;	/* # of packet decrypted unsuccessfully */
+	u32 in;		/* seconds elapsed since associated */
+	u32 listen_interval_inms;	/* Min Listen interval in ms for this STA */
+	u32 tx_pkts;		/* # of packets transmitted */
+	u32 tx_failures;	/* # of packets failed */
+	u32 rx_ucast_pkts;	/* # of unicast packets received */
+	u32 rx_mcast_pkts;	/* # of multicast packets received */
+	u32 tx_rate;		/* Rate of last successful tx frame */
+	u32 rx_rate;		/* Rate of last successful rx frame */
+	u32 rx_decrypt_succeeds;	/* # of packet decrypted successfully */
+	u32 rx_decrypt_failures;	/* # of packet decrypted unsuccessfully */
 } sta_info_t;
 
-#define WL_OLD_STAINFO_SIZE	OFFSETOF(sta_info_t, tx_pkts)
+#define WL_OLD_STAINFO_SIZE	offsetof(sta_info_t, tx_pkts)
 
 #define WL_STA_VER		3
 
@@ -746,7 +744,7 @@ typedef struct {
 
 /* Used to get specific STA parameters */
 typedef struct {
-	uint32 val;
+	u32 val;
 	struct ether_addr ea;
 } scb_val_t;
 
@@ -777,7 +775,7 @@ typedef struct wl_ioctl {
 	uint cmd;		/* common ioctl definition */
 	void *buf;		/* pointer to user buffer */
 	uint len;		/* length of user buffer */
-	uint8 set;		/* get or set request (optional) */
+	u8 set;		/* get or set request (optional) */
 	uint used;		/* bytes read or written (optional) */
 	uint needed;		/* bytes needed (optional) */
 } wl_ioctl_t;
@@ -820,9 +818,9 @@ typedef struct wl_instance_info {
 
 /* structure to change size of tx fifo */
 typedef struct wl_txfifo_sz {
-	uint16 magic;
-	uint16 fifo;
-	uint16 size;
+	u16 magic;
+	u16 fifo;
+	u16 size;
 } wl_txfifo_sz_t;
 /* magic pattern used for mismatch driver and wl */
 #define WL_TXFIFO_SZ_MAGIC	0xa5a5
@@ -831,8 +829,8 @@ typedef struct wl_txfifo_sz {
 /* Max supported IOV name size in bytes, + 1 for nul termination */
 #define WLC_IOV_NAME_LEN 30
 typedef struct wlc_iov_trx_s {
-	uint8 module;
-	uint8 type;
+	u8 module;
+	u8 type;
 	char name[WLC_IOV_NAME_LEN];
 } wlc_iov_trx_t;
 
@@ -843,7 +841,11 @@ typedef struct wlc_iov_trx_s {
 /* bump this number if you change the ioctl interface */
 #define WLC_IOCTL_VERSION	1
 
+#ifdef BRCM_FULLMAC
+#define	WLC_IOCTL_MAXLEN	8192
+#else
 #define	WLC_IOCTL_MAXLEN		3072	/* max length ioctl buffer required */
+#endif
 #define	WLC_IOCTL_SMLEN			256	/* "small" length ioctl buffer required */
 #define WLC_IOCTL_MEDLEN		1536	/* "med" length ioctl buffer required */
 #define WLC_SAMPLECOLLECT_MAXLEN	10240	/* Max Sample Collect buffer for two cores */
@@ -1202,15 +1204,15 @@ typedef struct wlc_iov_trx_s {
 #define WL_PHY_PAVARS_LEN	6	/* Phy type, Band range, chain, a1, b0, b1 */
 
 typedef struct wl_po {
-	uint16 phy_type;	/* Phy type */
-	uint16 band;
-	uint16 cckpo;
-	uint32 ofdmpo;
-	uint16 mcspo[8];
+	u16 phy_type;	/* Phy type */
+	u16 band;
+	u16 cckpo;
+	u32 ofdmpo;
+	u16 mcspo[8];
 } wl_po_t;
 
-/* a large TX Power as an init value to factor out of MIN() calculations,
- * keep low enough to fit in an int8, units are .25 dBm
+/* a large TX Power as an init value to factor out of min() calculations,
+ * keep low enough to fit in an s8, units are .25 dBm
  */
 #define WLC_TXPWR_MAX		(127)	/* ~32 dBm = 1,500 mW */
 
@@ -1368,27 +1370,27 @@ typedef struct wl_po {
 
 /* RSSI per antenna */
 typedef struct {
-	uint32 version;		/* version field */
-	uint32 count;		/* number of valid antenna rssi */
-	int8 rssi_ant[WL_RSSI_ANT_MAX];	/* rssi per antenna */
+	u32 version;		/* version field */
+	u32 count;		/* number of valid antenna rssi */
+	s8 rssi_ant[WL_RSSI_ANT_MAX];	/* rssi per antenna */
 } wl_rssi_ant_t;
 
 #define NUM_PWRCTRL_RATES 12
 
 typedef struct {
-	uint8 txpwr_band_max[NUM_PWRCTRL_RATES];	/* User set target */
-	uint8 txpwr_limit[NUM_PWRCTRL_RATES];	/* reg and local power limit */
-	uint8 txpwr_local_max;	/* local max according to the AP */
-	uint8 txpwr_local_constraint;	/* local constraint according to the AP */
-	uint8 txpwr_chan_reg_max;	/* Regulatory max for this channel */
-	uint8 txpwr_target[2][NUM_PWRCTRL_RATES];	/* Latest target for 2.4 and 5 Ghz */
-	uint8 txpwr_est_Pout[2];	/* Latest estimate for 2.4 and 5 Ghz */
-	uint8 txpwr_opo[NUM_PWRCTRL_RATES];	/* On G phy, OFDM power offset */
-	uint8 txpwr_bphy_cck_max[NUM_PWRCTRL_RATES];	/* Max CCK power for this band (SROM) */
-	uint8 txpwr_bphy_ofdm_max;	/* Max OFDM power for this band (SROM) */
-	uint8 txpwr_aphy_max[NUM_PWRCTRL_RATES];	/* Max power for A band (SROM) */
-	int8 txpwr_antgain[2];	/* Ant gain for each band - from SROM */
-	uint8 txpwr_est_Pout_gofdm;	/* Pwr estimate for 2.4 OFDM */
+	u8 txpwr_band_max[NUM_PWRCTRL_RATES];	/* User set target */
+	u8 txpwr_limit[NUM_PWRCTRL_RATES];	/* reg and local power limit */
+	u8 txpwr_local_max;	/* local max according to the AP */
+	u8 txpwr_local_constraint;	/* local constraint according to the AP */
+	u8 txpwr_chan_reg_max;	/* Regulatory max for this channel */
+	u8 txpwr_target[2][NUM_PWRCTRL_RATES];	/* Latest target for 2.4 and 5 Ghz */
+	u8 txpwr_est_Pout[2];	/* Latest estimate for 2.4 and 5 Ghz */
+	u8 txpwr_opo[NUM_PWRCTRL_RATES];	/* On G phy, OFDM power offset */
+	u8 txpwr_bphy_cck_max[NUM_PWRCTRL_RATES];	/* Max CCK power for this band (SROM) */
+	u8 txpwr_bphy_ofdm_max;	/* Max OFDM power for this band (SROM) */
+	u8 txpwr_aphy_max[NUM_PWRCTRL_RATES];	/* Max power for A band (SROM) */
+	s8 txpwr_antgain[2];	/* Ant gain for each band - from SROM */
+	u8 txpwr_est_Pout_gofdm;	/* Pwr estimate for 2.4 OFDM */
 } tx_power_legacy_t;
 
 #define WL_TX_POWER_RATES_LEGACY	45
@@ -1398,21 +1400,21 @@ typedef struct {
 #define WL_TX_POWER_MCS40_NUM	        17
 
 typedef struct {
-	uint32 flags;
+	u32 flags;
 	chanspec_t chanspec;	/* txpwr report for this channel */
 	chanspec_t local_chanspec;	/* channel on which we are associated */
-	uint8 local_max;	/* local max according to the AP */
-	uint8 local_constraint;	/* local constraint according to the AP */
-	int8 antgain[2];	/* Ant gain for each band - from SROM */
-	uint8 rf_cores;		/* count of RF Cores being reported */
-	uint8 est_Pout[4];	/* Latest tx power out estimate per RF
+	u8 local_max;	/* local max according to the AP */
+	u8 local_constraint;	/* local constraint according to the AP */
+	s8 antgain[2];	/* Ant gain for each band - from SROM */
+	u8 rf_cores;		/* count of RF Cores being reported */
+	u8 est_Pout[4];	/* Latest tx power out estimate per RF
 				 * chain without adjustment
 				 */
-	uint8 est_Pout_cck;	/* Latest CCK tx power out estimate */
-	uint8 user_limit[WL_TX_POWER_RATES_LEGACY];	/* User limit */
-	uint8 reg_limit[WL_TX_POWER_RATES_LEGACY];	/* Regulatory power limit */
-	uint8 board_limit[WL_TX_POWER_RATES_LEGACY];	/* Max power board can support (SROM) */
-	uint8 target[WL_TX_POWER_RATES_LEGACY];	/* Latest target power */
+	u8 est_Pout_cck;	/* Latest CCK tx power out estimate */
+	u8 user_limit[WL_TX_POWER_RATES_LEGACY];	/* User limit */
+	u8 reg_limit[WL_TX_POWER_RATES_LEGACY];	/* Regulatory power limit */
+	u8 board_limit[WL_TX_POWER_RATES_LEGACY];	/* Max power board can support (SROM) */
+	u8 target[WL_TX_POWER_RATES_LEGACY];	/* Latest target power */
 } tx_power_legacy2_t;
 
 #define WL_TX_POWER_RATES	       101
@@ -1446,29 +1448,29 @@ typedef struct {
 #define WL_TX_POWER_F_SISO	8
 
 typedef struct {
-	uint32 flags;
+	u32 flags;
 	chanspec_t chanspec;	/* txpwr report for this channel */
 	chanspec_t local_chanspec;	/* channel on which we are associated */
-	uint8 local_max;	/* local max according to the AP */
-	uint8 local_constraint;	/* local constraint according to the AP */
-	int8 antgain[2];	/* Ant gain for each band - from SROM */
-	uint8 rf_cores;		/* count of RF Cores being reported */
-	uint8 est_Pout[4];	/* Latest tx power out estimate per RF chain */
-	uint8 est_Pout_act[4];	/* Latest tx power out estimate per RF chain
+	u8 local_max;	/* local max according to the AP */
+	u8 local_constraint;	/* local constraint according to the AP */
+	s8 antgain[2];	/* Ant gain for each band - from SROM */
+	u8 rf_cores;		/* count of RF Cores being reported */
+	u8 est_Pout[4];	/* Latest tx power out estimate per RF chain */
+	u8 est_Pout_act[4];	/* Latest tx power out estimate per RF chain
 				 * without adjustment
 				 */
-	uint8 est_Pout_cck;	/* Latest CCK tx power out estimate */
-	uint8 tx_power_max[4];	/* Maximum target power among all rates */
-	uint8 tx_power_max_rate_ind[4];	/* Index of the rate with the max target power */
-	uint8 user_limit[WL_TX_POWER_RATES];	/* User limit */
-	uint8 reg_limit[WL_TX_POWER_RATES];	/* Regulatory power limit */
-	uint8 board_limit[WL_TX_POWER_RATES];	/* Max power board can support (SROM) */
-	uint8 target[WL_TX_POWER_RATES];	/* Latest target power */
+	u8 est_Pout_cck;	/* Latest CCK tx power out estimate */
+	u8 tx_power_max[4];	/* Maximum target power among all rates */
+	u8 tx_power_max_rate_ind[4];	/* Index of the rate with the max target power */
+	u8 user_limit[WL_TX_POWER_RATES];	/* User limit */
+	u8 reg_limit[WL_TX_POWER_RATES];	/* Regulatory power limit */
+	u8 board_limit[WL_TX_POWER_RATES];	/* Max power board can support (SROM) */
+	u8 target[WL_TX_POWER_RATES];	/* Latest target power */
 } tx_power_t;
 
 typedef struct tx_inst_power {
-	uint8 txpwr_est_Pout[2];	/* Latest estimate for 2.4 and 5 Ghz */
-	uint8 txpwr_est_Pout_gofdm;	/* Pwr estimate for 2.4 OFDM */
+	u8 txpwr_est_Pout[2];	/* Latest estimate for 2.4 and 5 Ghz */
+	u8 txpwr_est_Pout_gofdm;	/* Pwr estimate for 2.4 OFDM */
 } tx_inst_power_t;
 
 /* Message levels */
@@ -1482,7 +1484,7 @@ typedef struct tx_inst_power {
 #define WL_NUMCHANSPECS		100
 
 struct tsinfo_arg {
-	uint8 octets[3];
+	u8 octets[3];
 };
 
 #define	NFIFO			6	/* # tx/rx fifopairs */
@@ -1490,287 +1492,287 @@ struct tsinfo_arg {
 #define	WL_CNT_T_VERSION	7	/* current version of wl_cnt_t struct */
 
 typedef struct {
-	uint16 version;		/* see definition of WL_CNT_T_VERSION */
-	uint16 length;		/* length of entire structure */
+	u16 version;		/* see definition of WL_CNT_T_VERSION */
+	u16 length;		/* length of entire structure */
 
 	/* transmit stat counters */
-	uint32 txframe;		/* tx data frames */
-	uint32 txbyte;		/* tx data bytes */
-	uint32 txretrans;	/* tx mac retransmits */
-	uint32 txerror;		/* tx data errors (derived: sum of others) */
-	uint32 txctl;		/* tx management frames */
-	uint32 txprshort;	/* tx short preamble frames */
-	uint32 txserr;		/* tx status errors */
-	uint32 txnobuf;		/* tx out of buffers errors */
-	uint32 txnoassoc;	/* tx discard because we're not associated */
-	uint32 txrunt;		/* tx runt frames */
-	uint32 txchit;		/* tx header cache hit (fastpath) */
-	uint32 txcmiss;		/* tx header cache miss (slowpath) */
-	uint32 ieee_tx_status;	/* calls to ieee80211_tx_status */
-	uint32 ieee_tx;		/* tx calls frm mac0211 */
-	uint32 ieee_rx;		/* calls to ieee_rx */
+	u32 txframe;		/* tx data frames */
+	u32 txbyte;		/* tx data bytes */
+	u32 txretrans;	/* tx mac retransmits */
+	u32 txerror;		/* tx data errors (derived: sum of others) */
+	u32 txctl;		/* tx management frames */
+	u32 txprshort;	/* tx short preamble frames */
+	u32 txserr;		/* tx status errors */
+	u32 txnobuf;		/* tx out of buffers errors */
+	u32 txnoassoc;	/* tx discard because we're not associated */
+	u32 txrunt;		/* tx runt frames */
+	u32 txchit;		/* tx header cache hit (fastpath) */
+	u32 txcmiss;		/* tx header cache miss (slowpath) */
+	u32 ieee_tx_status;	/* calls to ieee80211_tx_status */
+	u32 ieee_tx;		/* tx calls frm mac0211 */
+	u32 ieee_rx;		/* calls to ieee_rx */
 
 	/* transmit chip error counters */
-	uint32 txuflo;		/* tx fifo underflows */
-	uint32 txphyerr;	/* tx phy errors (indicated in tx status) */
-	uint32 txphycrs;
+	u32 txuflo;		/* tx fifo underflows */
+	u32 txphyerr;	/* tx phy errors (indicated in tx status) */
+	u32 txphycrs;
 
 	/* receive stat counters */
-	uint32 rxframe;		/* rx data frames */
-	uint32 rxbyte;		/* rx data bytes */
-	uint32 rxerror;		/* rx data errors (derived: sum of others) */
-	uint32 rxctl;		/* rx management frames */
-	uint32 rxnobuf;		/* rx out of buffers errors */
-	uint32 rxnondata;	/* rx non data frames in the data channel errors */
-	uint32 rxbadds;		/* rx bad DS errors */
-	uint32 rxbadcm;		/* rx bad control or management frames */
-	uint32 rxfragerr;	/* rx fragmentation errors */
-	uint32 rxrunt;		/* rx runt frames */
-	uint32 rxgiant;		/* rx giant frames */
-	uint32 rxnoscb;		/* rx no scb error */
-	uint32 rxbadproto;	/* rx invalid frames */
-	uint32 rxbadsrcmac;	/* rx frames with Invalid Src Mac */
-	uint32 rxbadda;		/* rx frames tossed for invalid da */
-	uint32 rxfilter;	/* rx frames filtered out */
+	u32 rxframe;		/* rx data frames */
+	u32 rxbyte;		/* rx data bytes */
+	u32 rxerror;		/* rx data errors (derived: sum of others) */
+	u32 rxctl;		/* rx management frames */
+	u32 rxnobuf;		/* rx out of buffers errors */
+	u32 rxnondata;	/* rx non data frames in the data channel errors */
+	u32 rxbadds;		/* rx bad DS errors */
+	u32 rxbadcm;		/* rx bad control or management frames */
+	u32 rxfragerr;	/* rx fragmentation errors */
+	u32 rxrunt;		/* rx runt frames */
+	u32 rxgiant;		/* rx giant frames */
+	u32 rxnoscb;		/* rx no scb error */
+	u32 rxbadproto;	/* rx invalid frames */
+	u32 rxbadsrcmac;	/* rx frames with Invalid Src Mac */
+	u32 rxbadda;		/* rx frames tossed for invalid da */
+	u32 rxfilter;	/* rx frames filtered out */
 
 	/* receive chip error counters */
-	uint32 rxoflo;		/* rx fifo overflow errors */
-	uint32 rxuflo[NFIFO];	/* rx dma descriptor underflow errors */
+	u32 rxoflo;		/* rx fifo overflow errors */
+	u32 rxuflo[NFIFO];	/* rx dma descriptor underflow errors */
 
-	uint32 d11cnt_txrts_off;	/* d11cnt txrts value when reset d11cnt */
-	uint32 d11cnt_rxcrc_off;	/* d11cnt rxcrc value when reset d11cnt */
-	uint32 d11cnt_txnocts_off;	/* d11cnt txnocts value when reset d11cnt */
+	u32 d11cnt_txrts_off;	/* d11cnt txrts value when reset d11cnt */
+	u32 d11cnt_rxcrc_off;	/* d11cnt rxcrc value when reset d11cnt */
+	u32 d11cnt_txnocts_off;	/* d11cnt txnocts value when reset d11cnt */
 
 	/* misc counters */
-	uint32 dmade;		/* tx/rx dma descriptor errors */
-	uint32 dmada;		/* tx/rx dma data errors */
-	uint32 dmape;		/* tx/rx dma descriptor protocol errors */
-	uint32 reset;		/* reset count */
-	uint32 tbtt;		/* cnts the TBTT int's */
-	uint32 txdmawar;
-	uint32 pkt_callback_reg_fail;	/* callbacks register failure */
+	u32 dmade;		/* tx/rx dma descriptor errors */
+	u32 dmada;		/* tx/rx dma data errors */
+	u32 dmape;		/* tx/rx dma descriptor protocol errors */
+	u32 reset;		/* reset count */
+	u32 tbtt;		/* cnts the TBTT int's */
+	u32 txdmawar;
+	u32 pkt_callback_reg_fail;	/* callbacks register failure */
 
 	/* MAC counters: 32-bit version of d11.h's macstat_t */
-	uint32 txallfrm;	/* total number of frames sent, incl. Data, ACK, RTS, CTS,
+	u32 txallfrm;	/* total number of frames sent, incl. Data, ACK, RTS, CTS,
 				 * Control Management (includes retransmissions)
 				 */
-	uint32 txrtsfrm;	/* number of RTS sent out by the MAC */
-	uint32 txctsfrm;	/* number of CTS sent out by the MAC */
-	uint32 txackfrm;	/* number of ACK frames sent out */
-	uint32 txdnlfrm;	/* Not used */
-	uint32 txbcnfrm;	/* beacons transmitted */
-	uint32 txfunfl[8];	/* per-fifo tx underflows */
-	uint32 txtplunfl;	/* Template underflows (mac was too slow to transmit ACK/CTS
+	u32 txrtsfrm;	/* number of RTS sent out by the MAC */
+	u32 txctsfrm;	/* number of CTS sent out by the MAC */
+	u32 txackfrm;	/* number of ACK frames sent out */
+	u32 txdnlfrm;	/* Not used */
+	u32 txbcnfrm;	/* beacons transmitted */
+	u32 txfunfl[8];	/* per-fifo tx underflows */
+	u32 txtplunfl;	/* Template underflows (mac was too slow to transmit ACK/CTS
 				 * or BCN)
 				 */
-	uint32 txphyerror;	/* Transmit phy error, type of error is reported in tx-status for
+	u32 txphyerror;	/* Transmit phy error, type of error is reported in tx-status for
 				 * driver enqueued frames
 				 */
-	uint32 rxfrmtoolong;	/* Received frame longer than legal limit (2346 bytes) */
-	uint32 rxfrmtooshrt;	/* Received frame did not contain enough bytes for its frame type */
-	uint32 rxinvmachdr;	/* Either the protocol version != 0 or frame type not
+	u32 rxfrmtoolong;	/* Received frame longer than legal limit (2346 bytes) */
+	u32 rxfrmtooshrt;	/* Received frame did not contain enough bytes for its frame type */
+	u32 rxinvmachdr;	/* Either the protocol version != 0 or frame type not
 				 * data/control/management
 				 */
-	uint32 rxbadfcs;	/* number of frames for which the CRC check failed in the MAC */
-	uint32 rxbadplcp;	/* parity check of the PLCP header failed */
-	uint32 rxcrsglitch;	/* PHY was able to correlate the preamble but not the header */
-	uint32 rxstrt;		/* Number of received frames with a good PLCP
+	u32 rxbadfcs;	/* number of frames for which the CRC check failed in the MAC */
+	u32 rxbadplcp;	/* parity check of the PLCP header failed */
+	u32 rxcrsglitch;	/* PHY was able to correlate the preamble but not the header */
+	u32 rxstrt;		/* Number of received frames with a good PLCP
 				 * (i.e. passing parity check)
 				 */
-	uint32 rxdfrmucastmbss;	/* Number of received DATA frames with good FCS and matching RA */
-	uint32 rxmfrmucastmbss;	/* number of received mgmt frames with good FCS and matching RA */
-	uint32 rxcfrmucast;	/* number of received CNTRL frames with good FCS and matching RA */
-	uint32 rxrtsucast;	/* number of unicast RTS addressed to the MAC (good FCS) */
-	uint32 rxctsucast;	/* number of unicast CTS addressed to the MAC (good FCS) */
-	uint32 rxackucast;	/* number of ucast ACKS received (good FCS) */
-	uint32 rxdfrmocast;	/* number of received DATA frames (good FCS and not matching RA) */
-	uint32 rxmfrmocast;	/* number of received MGMT frames (good FCS and not matching RA) */
-	uint32 rxcfrmocast;	/* number of received CNTRL frame (good FCS and not matching RA) */
-	uint32 rxrtsocast;	/* number of received RTS not addressed to the MAC */
-	uint32 rxctsocast;	/* number of received CTS not addressed to the MAC */
-	uint32 rxdfrmmcast;	/* number of RX Data multicast frames received by the MAC */
-	uint32 rxmfrmmcast;	/* number of RX Management multicast frames received by the MAC */
-	uint32 rxcfrmmcast;	/* number of RX Control multicast frames received by the MAC
+	u32 rxdfrmucastmbss;	/* Number of received DATA frames with good FCS and matching RA */
+	u32 rxmfrmucastmbss;	/* number of received mgmt frames with good FCS and matching RA */
+	u32 rxcfrmucast;	/* number of received CNTRL frames with good FCS and matching RA */
+	u32 rxrtsucast;	/* number of unicast RTS addressed to the MAC (good FCS) */
+	u32 rxctsucast;	/* number of unicast CTS addressed to the MAC (good FCS) */
+	u32 rxackucast;	/* number of ucast ACKS received (good FCS) */
+	u32 rxdfrmocast;	/* number of received DATA frames (good FCS and not matching RA) */
+	u32 rxmfrmocast;	/* number of received MGMT frames (good FCS and not matching RA) */
+	u32 rxcfrmocast;	/* number of received CNTRL frame (good FCS and not matching RA) */
+	u32 rxrtsocast;	/* number of received RTS not addressed to the MAC */
+	u32 rxctsocast;	/* number of received CTS not addressed to the MAC */
+	u32 rxdfrmmcast;	/* number of RX Data multicast frames received by the MAC */
+	u32 rxmfrmmcast;	/* number of RX Management multicast frames received by the MAC */
+	u32 rxcfrmmcast;	/* number of RX Control multicast frames received by the MAC
 				 * (unlikely to see these)
 				 */
-	uint32 rxbeaconmbss;	/* beacons received from member of BSS */
-	uint32 rxdfrmucastobss;	/* number of unicast frames addressed to the MAC from
+	u32 rxbeaconmbss;	/* beacons received from member of BSS */
+	u32 rxdfrmucastobss;	/* number of unicast frames addressed to the MAC from
 				 * other BSS (WDS FRAME)
 				 */
-	uint32 rxbeaconobss;	/* beacons received from other BSS */
-	uint32 rxrsptmout;	/* Number of response timeouts for transmitted frames
+	u32 rxbeaconobss;	/* beacons received from other BSS */
+	u32 rxrsptmout;	/* Number of response timeouts for transmitted frames
 				 * expecting a response
 				 */
-	uint32 bcntxcancl;	/* transmit beacons canceled due to receipt of beacon (IBSS) */
-	uint32 rxf0ovfl;	/* Number of receive fifo 0 overflows */
-	uint32 rxf1ovfl;	/* Number of receive fifo 1 overflows (obsolete) */
-	uint32 rxf2ovfl;	/* Number of receive fifo 2 overflows (obsolete) */
-	uint32 txsfovfl;	/* Number of transmit status fifo overflows (obsolete) */
-	uint32 pmqovfl;		/* Number of PMQ overflows */
-	uint32 rxcgprqfrm;	/* Number of received Probe requests that made it into
+	u32 bcntxcancl;	/* transmit beacons canceled due to receipt of beacon (IBSS) */
+	u32 rxf0ovfl;	/* Number of receive fifo 0 overflows */
+	u32 rxf1ovfl;	/* Number of receive fifo 1 overflows (obsolete) */
+	u32 rxf2ovfl;	/* Number of receive fifo 2 overflows (obsolete) */
+	u32 txsfovfl;	/* Number of transmit status fifo overflows (obsolete) */
+	u32 pmqovfl;		/* Number of PMQ overflows */
+	u32 rxcgprqfrm;	/* Number of received Probe requests that made it into
 				 * the PRQ fifo
 				 */
-	uint32 rxcgprsqovfl;	/* Rx Probe Request Que overflow in the AP */
-	uint32 txcgprsfail;	/* Tx Probe Response Fail. AP sent probe response but did
+	u32 rxcgprsqovfl;	/* Rx Probe Request Que overflow in the AP */
+	u32 txcgprsfail;	/* Tx Probe Response Fail. AP sent probe response but did
 				 * not get ACK
 				 */
-	uint32 txcgprssuc;	/* Tx Probe Response Success (ACK was received) */
-	uint32 prs_timeout;	/* Number of probe requests that were dropped from the PRQ
+	u32 txcgprssuc;	/* Tx Probe Response Success (ACK was received) */
+	u32 prs_timeout;	/* Number of probe requests that were dropped from the PRQ
 				 * fifo because a probe response could not be sent out within
 				 * the time limit defined in M_PRS_MAXTIME
 				 */
-	uint32 rxnack;
-	uint32 frmscons;
-	uint32 txnack;
-	uint32 txglitch_nack;	/* obsolete */
-	uint32 txburst;		/* obsolete */
+	u32 rxnack;
+	u32 frmscons;
+	u32 txnack;
+	u32 txglitch_nack;	/* obsolete */
+	u32 txburst;		/* obsolete */
 
 	/* 802.11 MIB counters, pp. 614 of 802.11 reaff doc. */
-	uint32 txfrag;		/* dot11TransmittedFragmentCount */
-	uint32 txmulti;		/* dot11MulticastTransmittedFrameCount */
-	uint32 txfail;		/* dot11FailedCount */
-	uint32 txretry;		/* dot11RetryCount */
-	uint32 txretrie;	/* dot11MultipleRetryCount */
-	uint32 rxdup;		/* dot11FrameduplicateCount */
-	uint32 txrts;		/* dot11RTSSuccessCount */
-	uint32 txnocts;		/* dot11RTSFailureCount */
-	uint32 txnoack;		/* dot11ACKFailureCount */
-	uint32 rxfrag;		/* dot11ReceivedFragmentCount */
-	uint32 rxmulti;		/* dot11MulticastReceivedFrameCount */
-	uint32 rxcrc;		/* dot11FCSErrorCount */
-	uint32 txfrmsnt;	/* dot11TransmittedFrameCount (bogus MIB?) */
-	uint32 rxundec;		/* dot11WEPUndecryptableCount */
+	u32 txfrag;		/* dot11TransmittedFragmentCount */
+	u32 txmulti;		/* dot11MulticastTransmittedFrameCount */
+	u32 txfail;		/* dot11FailedCount */
+	u32 txretry;		/* dot11RetryCount */
+	u32 txretrie;	/* dot11MultipleRetryCount */
+	u32 rxdup;		/* dot11FrameduplicateCount */
+	u32 txrts;		/* dot11RTSSuccessCount */
+	u32 txnocts;		/* dot11RTSFailureCount */
+	u32 txnoack;		/* dot11ACKFailureCount */
+	u32 rxfrag;		/* dot11ReceivedFragmentCount */
+	u32 rxmulti;		/* dot11MulticastReceivedFrameCount */
+	u32 rxcrc;		/* dot11FCSErrorCount */
+	u32 txfrmsnt;	/* dot11TransmittedFrameCount (bogus MIB?) */
+	u32 rxundec;		/* dot11WEPUndecryptableCount */
 
 	/* WPA2 counters (see rxundec for DecryptFailureCount) */
-	uint32 tkipmicfaill;	/* TKIPLocalMICFailures */
-	uint32 tkipcntrmsr;	/* TKIPCounterMeasuresInvoked */
-	uint32 tkipreplay;	/* TKIPReplays */
-	uint32 ccmpfmterr;	/* CCMPFormatErrors */
-	uint32 ccmpreplay;	/* CCMPReplays */
-	uint32 ccmpundec;	/* CCMPDecryptErrors */
-	uint32 fourwayfail;	/* FourWayHandshakeFailures */
-	uint32 wepundec;	/* dot11WEPUndecryptableCount */
-	uint32 wepicverr;	/* dot11WEPICVErrorCount */
-	uint32 decsuccess;	/* DecryptSuccessCount */
-	uint32 tkipicverr;	/* TKIPICVErrorCount */
-	uint32 wepexcluded;	/* dot11WEPExcludedCount */
-
-	uint32 rxundec_mcst;	/* dot11WEPUndecryptableCount */
+	u32 tkipmicfaill;	/* TKIPLocalMICFailures */
+	u32 tkipcntrmsr;	/* TKIPCounterMeasuresInvoked */
+	u32 tkipreplay;	/* TKIPReplays */
+	u32 ccmpfmterr;	/* CCMPFormatErrors */
+	u32 ccmpreplay;	/* CCMPReplays */
+	u32 ccmpundec;	/* CCMPDecryptErrors */
+	u32 fourwayfail;	/* FourWayHandshakeFailures */
+	u32 wepundec;	/* dot11WEPUndecryptableCount */
+	u32 wepicverr;	/* dot11WEPICVErrorCount */
+	u32 decsuccess;	/* DecryptSuccessCount */
+	u32 tkipicverr;	/* TKIPICVErrorCount */
+	u32 wepexcluded;	/* dot11WEPExcludedCount */
+
+	u32 rxundec_mcst;	/* dot11WEPUndecryptableCount */
 
 	/* WPA2 counters (see rxundec for DecryptFailureCount) */
-	uint32 tkipmicfaill_mcst;	/* TKIPLocalMICFailures */
-	uint32 tkipcntrmsr_mcst;	/* TKIPCounterMeasuresInvoked */
-	uint32 tkipreplay_mcst;	/* TKIPReplays */
-	uint32 ccmpfmterr_mcst;	/* CCMPFormatErrors */
-	uint32 ccmpreplay_mcst;	/* CCMPReplays */
-	uint32 ccmpundec_mcst;	/* CCMPDecryptErrors */
-	uint32 fourwayfail_mcst;	/* FourWayHandshakeFailures */
-	uint32 wepundec_mcst;	/* dot11WEPUndecryptableCount */
-	uint32 wepicverr_mcst;	/* dot11WEPICVErrorCount */
-	uint32 decsuccess_mcst;	/* DecryptSuccessCount */
-	uint32 tkipicverr_mcst;	/* TKIPICVErrorCount */
-	uint32 wepexcluded_mcst;	/* dot11WEPExcludedCount */
-
-	uint32 txchanrej;	/* Tx frames suppressed due to channel rejection */
-	uint32 txexptime;	/* Tx frames suppressed due to timer expiration */
-	uint32 psmwds;		/* Count PSM watchdogs */
-	uint32 phywatchdog;	/* Count Phy watchdogs (triggered by ucode) */
+	u32 tkipmicfaill_mcst;	/* TKIPLocalMICFailures */
+	u32 tkipcntrmsr_mcst;	/* TKIPCounterMeasuresInvoked */
+	u32 tkipreplay_mcst;	/* TKIPReplays */
+	u32 ccmpfmterr_mcst;	/* CCMPFormatErrors */
+	u32 ccmpreplay_mcst;	/* CCMPReplays */
+	u32 ccmpundec_mcst;	/* CCMPDecryptErrors */
+	u32 fourwayfail_mcst;	/* FourWayHandshakeFailures */
+	u32 wepundec_mcst;	/* dot11WEPUndecryptableCount */
+	u32 wepicverr_mcst;	/* dot11WEPICVErrorCount */
+	u32 decsuccess_mcst;	/* DecryptSuccessCount */
+	u32 tkipicverr_mcst;	/* TKIPICVErrorCount */
+	u32 wepexcluded_mcst;	/* dot11WEPExcludedCount */
+
+	u32 txchanrej;	/* Tx frames suppressed due to channel rejection */
+	u32 txexptime;	/* Tx frames suppressed due to timer expiration */
+	u32 psmwds;		/* Count PSM watchdogs */
+	u32 phywatchdog;	/* Count Phy watchdogs (triggered by ucode) */
 
 	/* MBSS counters, AP only */
-	uint32 prq_entries_handled;	/* PRQ entries read in */
-	uint32 prq_undirected_entries;	/*    which were bcast bss & ssid */
-	uint32 prq_bad_entries;	/*    which could not be translated to info */
-	uint32 atim_suppress_count;	/* TX suppressions on ATIM fifo */
-	uint32 bcn_template_not_ready;	/* Template marked in use on send bcn ... */
-	uint32 bcn_template_not_ready_done;	/* ...but "DMA done" interrupt rcvd */
-	uint32 late_tbtt_dpc;	/* TBTT DPC did not happen in time */
+	u32 prq_entries_handled;	/* PRQ entries read in */
+	u32 prq_undirected_entries;	/*    which were bcast bss & ssid */
+	u32 prq_bad_entries;	/*    which could not be translated to info */
+	u32 atim_suppress_count;	/* TX suppressions on ATIM fifo */
+	u32 bcn_template_not_ready;	/* Template marked in use on send bcn ... */
+	u32 bcn_template_not_ready_done;	/* ...but "DMA done" interrupt rcvd */
+	u32 late_tbtt_dpc;	/* TBTT DPC did not happen in time */
 
 	/* per-rate receive stat counters */
-	uint32 rx1mbps;		/* packets rx at 1Mbps */
-	uint32 rx2mbps;		/* packets rx at 2Mbps */
-	uint32 rx5mbps5;	/* packets rx at 5.5Mbps */
-	uint32 rx6mbps;		/* packets rx at 6Mbps */
-	uint32 rx9mbps;		/* packets rx at 9Mbps */
-	uint32 rx11mbps;	/* packets rx at 11Mbps */
-	uint32 rx12mbps;	/* packets rx at 12Mbps */
-	uint32 rx18mbps;	/* packets rx at 18Mbps */
-	uint32 rx24mbps;	/* packets rx at 24Mbps */
-	uint32 rx36mbps;	/* packets rx at 36Mbps */
-	uint32 rx48mbps;	/* packets rx at 48Mbps */
-	uint32 rx54mbps;	/* packets rx at 54Mbps */
-	uint32 rx108mbps;	/* packets rx at 108mbps */
-	uint32 rx162mbps;	/* packets rx at 162mbps */
-	uint32 rx216mbps;	/* packets rx at 216 mbps */
-	uint32 rx270mbps;	/* packets rx at 270 mbps */
-	uint32 rx324mbps;	/* packets rx at 324 mbps */
-	uint32 rx378mbps;	/* packets rx at 378 mbps */
-	uint32 rx432mbps;	/* packets rx at 432 mbps */
-	uint32 rx486mbps;	/* packets rx at 486 mbps */
-	uint32 rx540mbps;	/* packets rx at 540 mbps */
+	u32 rx1mbps;		/* packets rx at 1Mbps */
+	u32 rx2mbps;		/* packets rx at 2Mbps */
+	u32 rx5mbps5;	/* packets rx at 5.5Mbps */
+	u32 rx6mbps;		/* packets rx at 6Mbps */
+	u32 rx9mbps;		/* packets rx at 9Mbps */
+	u32 rx11mbps;	/* packets rx at 11Mbps */
+	u32 rx12mbps;	/* packets rx at 12Mbps */
+	u32 rx18mbps;	/* packets rx at 18Mbps */
+	u32 rx24mbps;	/* packets rx at 24Mbps */
+	u32 rx36mbps;	/* packets rx at 36Mbps */
+	u32 rx48mbps;	/* packets rx at 48Mbps */
+	u32 rx54mbps;	/* packets rx at 54Mbps */
+	u32 rx108mbps;	/* packets rx at 108mbps */
+	u32 rx162mbps;	/* packets rx at 162mbps */
+	u32 rx216mbps;	/* packets rx at 216 mbps */
+	u32 rx270mbps;	/* packets rx at 270 mbps */
+	u32 rx324mbps;	/* packets rx at 324 mbps */
+	u32 rx378mbps;	/* packets rx at 378 mbps */
+	u32 rx432mbps;	/* packets rx at 432 mbps */
+	u32 rx486mbps;	/* packets rx at 486 mbps */
+	u32 rx540mbps;	/* packets rx at 540 mbps */
 
 	/* pkteng rx frame stats */
-	uint32 pktengrxducast;	/* unicast frames rxed by the pkteng code */
-	uint32 pktengrxdmcast;	/* multicast frames rxed by the pkteng code */
+	u32 pktengrxducast;	/* unicast frames rxed by the pkteng code */
+	u32 pktengrxdmcast;	/* multicast frames rxed by the pkteng code */
 
-	uint32 rfdisable;	/* count of radio disables */
-	uint32 bphy_rxcrsglitch;	/* PHY count of bphy glitches */
+	u32 rfdisable;	/* count of radio disables */
+	u32 bphy_rxcrsglitch;	/* PHY count of bphy glitches */
 
-	uint32 txmpdu_sgi;	/* count for sgi transmit */
-	uint32 rxmpdu_sgi;	/* count for sgi received */
-	uint32 txmpdu_stbc;	/* count for stbc transmit */
-	uint32 rxmpdu_stbc;	/* count for stbc received */
+	u32 txmpdu_sgi;	/* count for sgi transmit */
+	u32 rxmpdu_sgi;	/* count for sgi received */
+	u32 txmpdu_stbc;	/* count for stbc transmit */
+	u32 rxmpdu_stbc;	/* count for stbc received */
 } wl_cnt_t;
 
 #define	WL_DELTA_STATS_T_VERSION	1	/* current version of wl_delta_stats_t struct */
 
 typedef struct {
-	uint16 version;		/* see definition of WL_DELTA_STATS_T_VERSION */
-	uint16 length;		/* length of entire structure */
+	u16 version;		/* see definition of WL_DELTA_STATS_T_VERSION */
+	u16 length;		/* length of entire structure */
 
 	/* transmit stat counters */
-	uint32 txframe;		/* tx data frames */
-	uint32 txbyte;		/* tx data bytes */
-	uint32 txretrans;	/* tx mac retransmits */
-	uint32 txfail;		/* tx failures */
+	u32 txframe;		/* tx data frames */
+	u32 txbyte;		/* tx data bytes */
+	u32 txretrans;	/* tx mac retransmits */
+	u32 txfail;		/* tx failures */
 
 	/* receive stat counters */
-	uint32 rxframe;		/* rx data frames */
-	uint32 rxbyte;		/* rx data bytes */
+	u32 rxframe;		/* rx data frames */
+	u32 rxbyte;		/* rx data bytes */
 
 	/* per-rate receive stat counters */
-	uint32 rx1mbps;		/* packets rx at 1Mbps */
-	uint32 rx2mbps;		/* packets rx at 2Mbps */
-	uint32 rx5mbps5;	/* packets rx at 5.5Mbps */
-	uint32 rx6mbps;		/* packets rx at 6Mbps */
-	uint32 rx9mbps;		/* packets rx at 9Mbps */
-	uint32 rx11mbps;	/* packets rx at 11Mbps */
-	uint32 rx12mbps;	/* packets rx at 12Mbps */
-	uint32 rx18mbps;	/* packets rx at 18Mbps */
-	uint32 rx24mbps;	/* packets rx at 24Mbps */
-	uint32 rx36mbps;	/* packets rx at 36Mbps */
-	uint32 rx48mbps;	/* packets rx at 48Mbps */
-	uint32 rx54mbps;	/* packets rx at 54Mbps */
-	uint32 rx108mbps;	/* packets rx at 108mbps */
-	uint32 rx162mbps;	/* packets rx at 162mbps */
-	uint32 rx216mbps;	/* packets rx at 216 mbps */
-	uint32 rx270mbps;	/* packets rx at 270 mbps */
-	uint32 rx324mbps;	/* packets rx at 324 mbps */
-	uint32 rx378mbps;	/* packets rx at 378 mbps */
-	uint32 rx432mbps;	/* packets rx at 432 mbps */
-	uint32 rx486mbps;	/* packets rx at 486 mbps */
-	uint32 rx540mbps;	/* packets rx at 540 mbps */
+	u32 rx1mbps;		/* packets rx at 1Mbps */
+	u32 rx2mbps;		/* packets rx at 2Mbps */
+	u32 rx5mbps5;	/* packets rx at 5.5Mbps */
+	u32 rx6mbps;		/* packets rx at 6Mbps */
+	u32 rx9mbps;		/* packets rx at 9Mbps */
+	u32 rx11mbps;	/* packets rx at 11Mbps */
+	u32 rx12mbps;	/* packets rx at 12Mbps */
+	u32 rx18mbps;	/* packets rx at 18Mbps */
+	u32 rx24mbps;	/* packets rx at 24Mbps */
+	u32 rx36mbps;	/* packets rx at 36Mbps */
+	u32 rx48mbps;	/* packets rx at 48Mbps */
+	u32 rx54mbps;	/* packets rx at 54Mbps */
+	u32 rx108mbps;	/* packets rx at 108mbps */
+	u32 rx162mbps;	/* packets rx at 162mbps */
+	u32 rx216mbps;	/* packets rx at 216 mbps */
+	u32 rx270mbps;	/* packets rx at 270 mbps */
+	u32 rx324mbps;	/* packets rx at 324 mbps */
+	u32 rx378mbps;	/* packets rx at 378 mbps */
+	u32 rx432mbps;	/* packets rx at 432 mbps */
+	u32 rx486mbps;	/* packets rx at 486 mbps */
+	u32 rx540mbps;	/* packets rx at 540 mbps */
 } wl_delta_stats_t;
 
 #define WL_WME_CNT_VERSION	1	/* current version of wl_wme_cnt_t */
 
 typedef struct {
-	uint32 packets;
-	uint32 bytes;
+	u32 packets;
+	u32 bytes;
 } wl_traffic_stats_t;
 
 typedef struct {
-	uint16 version;		/* see definition of WL_WME_CNT_VERSION */
-	uint16 length;		/* length of entire structure */
+	u16 version;		/* see definition of WL_WME_CNT_VERSION */
+	u16 length;		/* length of entire structure */
 
 	wl_traffic_stats_t tx[AC_COUNT];	/* Packets transmitted */
 	wl_traffic_stats_t tx_failed[AC_COUNT];	/* Packets dropped or failed to transmit */
@@ -1784,8 +1786,8 @@ typedef struct {
 } wl_wme_cnt_t;
 
 struct wl_msglevel2 {
-	uint32 low;
-	uint32 high;
+	u32 low;
+	u32 high;
 };
 
 #ifdef WLBA
@@ -1794,56 +1796,56 @@ struct wl_msglevel2 {
 
 /* block ack related stats */
 typedef struct wlc_ba_cnt {
-	uint16 version;		/* WLC_BA_CNT_VERSION */
-	uint16 length;		/* length of entire structure */
+	u16 version;		/* WLC_BA_CNT_VERSION */
+	u16 length;		/* length of entire structure */
 
 	/* transmit stat counters */
-	uint32 txpdu;		/* pdus sent */
-	uint32 txsdu;		/* sdus sent */
-	uint32 txfc;		/* tx side flow controlled packets */
-	uint32 txfci;		/* tx side flow control initiated */
-	uint32 txretrans;	/* retransmitted pdus */
-	uint32 txbatimer;	/* ba resend due to timer */
-	uint32 txdrop;		/* dropped packets */
-	uint32 txaddbareq;	/* addba req sent */
-	uint32 txaddbaresp;	/* addba resp sent */
-	uint32 txdelba;		/* delba sent */
-	uint32 txba;		/* ba sent */
-	uint32 txbar;		/* bar sent */
-	uint32 txpad[4];	/* future */
+	u32 txpdu;		/* pdus sent */
+	u32 txsdu;		/* sdus sent */
+	u32 txfc;		/* tx side flow controlled packets */
+	u32 txfci;		/* tx side flow control initiated */
+	u32 txretrans;	/* retransmitted pdus */
+	u32 txbatimer;	/* ba resend due to timer */
+	u32 txdrop;		/* dropped packets */
+	u32 txaddbareq;	/* addba req sent */
+	u32 txaddbaresp;	/* addba resp sent */
+	u32 txdelba;		/* delba sent */
+	u32 txba;		/* ba sent */
+	u32 txbar;		/* bar sent */
+	u32 txpad[4];	/* future */
 
 	/* receive side counters */
-	uint32 rxpdu;		/* pdus recd */
-	uint32 rxqed;		/* pdus buffered before sending up */
-	uint32 rxdup;		/* duplicate pdus */
-	uint32 rxnobuf;		/* pdus discarded due to no buf */
-	uint32 rxaddbareq;	/* addba req recd */
-	uint32 rxaddbaresp;	/* addba resp recd */
-	uint32 rxdelba;		/* delba recd */
-	uint32 rxba;		/* ba recd */
-	uint32 rxbar;		/* bar recd */
-	uint32 rxinvba;		/* invalid ba recd */
-	uint32 rxbaholes;	/* ba recd with holes */
-	uint32 rxunexp;		/* unexpected packets */
-	uint32 rxpad[4];	/* future */
+	u32 rxpdu;		/* pdus recd */
+	u32 rxqed;		/* pdus buffered before sending up */
+	u32 rxdup;		/* duplicate pdus */
+	u32 rxnobuf;		/* pdus discarded due to no buf */
+	u32 rxaddbareq;	/* addba req recd */
+	u32 rxaddbaresp;	/* addba resp recd */
+	u32 rxdelba;		/* delba recd */
+	u32 rxba;		/* ba recd */
+	u32 rxbar;		/* bar recd */
+	u32 rxinvba;		/* invalid ba recd */
+	u32 rxbaholes;	/* ba recd with holes */
+	u32 rxunexp;		/* unexpected packets */
+	u32 rxpad[4];	/* future */
 } wlc_ba_cnt_t;
 #endif				/* WLBA */
 
 /* structure for per-tid ampdu control */
 struct ampdu_tid_control {
-	uint8 tid;		/* tid */
-	uint8 enable;		/* enable/disable */
+	u8 tid;		/* tid */
+	u8 enable;		/* enable/disable */
 };
 
 /* structure for identifying ea/tid for sending addba/delba */
 struct ampdu_ea_tid {
 	struct ether_addr ea;	/* Station address */
-	uint8 tid;		/* tid */
+	u8 tid;		/* tid */
 };
 /* structure for identifying retry/tid for retry_limit_tid/rr_retry_limit_tid */
 struct ampdu_retry_tid {
-	uint8 tid;		/* tid */
-	uint8 retry;		/* retry value */
+	u8 tid;		/* tid */
+	u8 retry;		/* retry value */
 };
 
 /* structure for addts arguments */
@@ -1855,13 +1857,13 @@ struct tslist {
 
 /* structure for addts/delts arguments */
 typedef struct tspec_arg {
-	uint16 version;		/* see definition of TSPEC_ARG_VERSION */
-	uint16 length;		/* length of entire structure */
+	u16 version;		/* see definition of TSPEC_ARG_VERSION */
+	u16 length;		/* length of entire structure */
 	uint flag;		/* bit field */
 	/* TSPEC Arguments */
 	struct tsinfo_arg tsinfo;	/* TS Info bit field */
-	uint16 nom_msdu_size;	/* (Nominal or fixed) MSDU Size (bytes) */
-	uint16 max_msdu_size;	/* Maximum MSDU Size (bytes) */
+	u16 nom_msdu_size;	/* (Nominal or fixed) MSDU Size (bytes) */
+	u16 max_msdu_size;	/* Maximum MSDU Size (bytes) */
 	uint min_srv_interval;	/* Minimum Service Interval (us) */
 	uint max_srv_interval;	/* Maximum Service Interval (us) */
 	uint inactivity_interval;	/* Inactivity Interval (us) */
@@ -1873,9 +1875,9 @@ typedef struct tspec_arg {
 	uint max_burst_size;	/* Maximum Burst Size (bytes) */
 	uint delay_bound;	/* Delay Bound (us) */
 	uint min_phy_rate;	/* Minimum PHY Rate (bps) */
-	uint16 surplus_bw;	/* Surplus Bandwidth Allowance (range 1.0 to 8.0) */
-	uint16 medium_time;	/* Medium Time (32 us/s periods) */
-	uint8 dialog_token;	/* dialog token */
+	u16 surplus_bw;	/* Surplus Bandwidth Allowance (range 1.0 to 8.0) */
+	u16 medium_time;	/* Medium Time (32 us/s periods) */
+	u8 dialog_token;	/* dialog token */
 } tspec_arg_t;
 
 /* tspec arg for desired station */
@@ -1886,7 +1888,7 @@ typedef struct tspec_per_sta_arg {
 
 /* structure for max bandwidth for each access category */
 typedef struct wme_max_bandwidth {
-	uint32 ac[AC_COUNT];	/* max bandwidth for each access category */
+	u32 ac[AC_COUNT];	/* max bandwidth for each access category */
 } wme_max_bandwidth_t;
 
 #define WL_WME_MBW_PARAMS_IO_BYTES (sizeof(wme_max_bandwidth_t))
@@ -1927,59 +1929,49 @@ typedef enum wl_pkt_filter_type {
  * that indicates which bits within the pattern should be matched.
  */
 typedef struct wl_pkt_filter_pattern {
-	uint32 offset;		/* Offset within received packet to start pattern matching.
+	u32 offset;		/* Offset within received packet to start pattern matching.
 				 * Offset '0' is the first byte of the ethernet header.
 				 */
-	uint32 size_bytes;	/* Size of the pattern.  Bitmask must be the same size. */
-	uint8 mask_and_pattern[1];	/* Variable length mask and pattern data.  mask starts
+	u32 size_bytes;	/* Size of the pattern.  Bitmask must be the same size. */
+	u8 mask_and_pattern[1];	/* Variable length mask and pattern data.  mask starts
 					 * at offset 0.  Pattern immediately follows mask.
 					 */
 } wl_pkt_filter_pattern_t;
 
 /* IOVAR "pkt_filter_add" parameter. Used to install packet filters. */
 typedef struct wl_pkt_filter {
-	uint32 id;		/* Unique filter id, specified by app. */
-	uint32 type;		/* Filter type (WL_PKT_FILTER_TYPE_xxx). */
-	uint32 negate_match;	/* Negate the result of filter matches */
+	u32 id;		/* Unique filter id, specified by app. */
+	u32 type;		/* Filter type (WL_PKT_FILTER_TYPE_xxx). */
+	u32 negate_match;	/* Negate the result of filter matches */
 	union {			/* Filter definitions */
 		wl_pkt_filter_pattern_t pattern;	/* Pattern matching filter */
 	} u;
 } wl_pkt_filter_t;
 
-#define WL_PKT_FILTER_FIXED_LEN		  OFFSETOF(wl_pkt_filter_t, u)
-#define WL_PKT_FILTER_PATTERN_FIXED_LEN	  OFFSETOF(wl_pkt_filter_pattern_t, mask_and_pattern)
+#define WL_PKT_FILTER_FIXED_LEN		  offsetof(wl_pkt_filter_t, u)
+#define WL_PKT_FILTER_PATTERN_FIXED_LEN	  offsetof(wl_pkt_filter_pattern_t, mask_and_pattern)
 
 /* IOVAR "pkt_filter_enable" parameter. */
 typedef struct wl_pkt_filter_enable {
-	uint32 id;		/* Unique filter id */
-	uint32 enable;		/* Enable/disable bool */
+	u32 id;		/* Unique filter id */
+	u32 enable;		/* Enable/disable bool */
 } wl_pkt_filter_enable_t;
 
 /* IOVAR "pkt_filter_list" parameter. Used to retrieve a list of installed filters. */
 typedef struct wl_pkt_filter_list {
-	uint32 num;		/* Number of installed packet filters */
+	u32 num;		/* Number of installed packet filters */
 	wl_pkt_filter_t filter[1];	/* Variable array of packet filters. */
 } wl_pkt_filter_list_t;
 
-#define WL_PKT_FILTER_LIST_FIXED_LEN	  OFFSETOF(wl_pkt_filter_list_t, filter)
+#define WL_PKT_FILTER_LIST_FIXED_LEN	  offsetof(wl_pkt_filter_list_t, filter)
 
 /* IOVAR "pkt_filter_stats" parameter. Used to retrieve debug statistics. */
 typedef struct wl_pkt_filter_stats {
-	uint32 num_pkts_matched;	/* # filter matches for specified filter id */
-	uint32 num_pkts_forwarded;	/* # packets fwded from dongle to host for all filters */
-	uint32 num_pkts_discarded;	/* # packets discarded by dongle for all filters */
+	u32 num_pkts_matched;	/* # filter matches for specified filter id */
+	u32 num_pkts_forwarded;	/* # packets fwded from dongle to host for all filters */
+	u32 num_pkts_discarded;	/* # packets discarded by dongle for all filters */
 } wl_pkt_filter_stats_t;
 
-typedef struct wl_pkteng {
-	uint32 flags;
-	uint32 delay;		/* Inter-packet delay */
-	uint32 nframes;		/* Number of frames */
-	uint32 length;		/* Packet length */
-	uint8 seqno;		/* Enable/disable sequence no. */
-	struct ether_addr dest;	/* Destination address */
-	struct ether_addr src;	/* Source address */
-} wl_pkteng_t;
-
 #define	WLC_RSSI_INVALID	 0	/* invalid RSSI value */
 
 /* require default structure packing */
@@ -2004,4 +1996,30 @@ typedef struct wl_pkteng {
 #define WLFEATURE_DISABLE_11N_AMPDU_RX	0x00000040
 #define WLFEATURE_DISABLE_11N_GF	0x00000080
 
+#define WL_EVENTING_MASK_LEN	16
+
+#define TOE_TX_CSUM_OL		0x00000001
+#define TOE_RX_CSUM_OL		0x00000002
+
+#define PM_OFF	0
+#define PM_MAX	1
+#define PM_FAST 2
+
+typedef enum sup_auth_status {
+	WLC_SUP_DISCONNECTED = 0,
+	WLC_SUP_CONNECTING,
+	WLC_SUP_IDREQUIRED,
+	WLC_SUP_AUTHENTICATING,
+	WLC_SUP_AUTHENTICATED,
+	WLC_SUP_KEYXCHANGE,
+	WLC_SUP_KEYED,
+	WLC_SUP_TIMEOUT,
+	WLC_SUP_LAST_BASIC_STATE,
+	WLC_SUP_KEYXCHANGE_WAIT_M1 = WLC_SUP_AUTHENTICATED,
+	WLC_SUP_KEYXCHANGE_PREP_M2 = WLC_SUP_KEYXCHANGE,
+	WLC_SUP_KEYXCHANGE_WAIT_M3 = WLC_SUP_LAST_BASIC_STATE,
+	WLC_SUP_KEYXCHANGE_PREP_M4,
+	WLC_SUP_KEYXCHANGE_WAIT_G1,
+	WLC_SUP_KEYXCHANGE_PREP_G2
+} sup_auth_status_t;
 #endif				/* _wlioctl_h_ */
diff --git a/drivers/staging/brcm80211/phy/phy_version.h b/drivers/staging/brcm80211/phy/phy_version.h
index 209a785..51a2238 100644
--- a/drivers/staging/brcm80211/phy/phy_version.h
+++ b/drivers/staging/brcm80211/phy/phy_version.h
@@ -27,7 +27,7 @@
 
 #define	PHY_BUILD_NUMBER		0
 
-#define	PHY_VERSION			1, 82, 8, 0
+#define	PHY_VERSION			{ 1, 82, 8, 0 }
 
 #define	PHY_VERSION_NUM		0x01520800
 
diff --git a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
index 5c7858a..8287261 100644
--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -16,7 +16,11 @@
 
 #include <wlc_cfg.h>
 
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <bcmdefs.h>
 #include <osl.h>
+#include <linuxver.h>
 #include <bcmendian.h>
 #include <bcmnvram.h>
 #include <sbchipc.h>
@@ -26,11 +30,11 @@
 #include <wlc_phy_radio.h>
 #include <wlc_phy_lcn.h>
 
-uint32 phyhal_msg_level = PHYHAL_ERROR;
+u32 phyhal_msg_level = PHYHAL_ERROR;
 
 typedef struct _chan_info_basic {
-	uint16 chan;
-	uint16 freq;
+	u16 chan;
+	u16 freq;
 } chan_info_basic_t;
 
 static chan_info_basic_t chan_info_all[] = {
@@ -93,7 +97,7 @@ static chan_info_basic_t chan_info_all[] = {
 	{216, 50800}
 };
 
-uint16 ltrn_list[PHY_LTRN_LIST_LEN] = {
+u16 ltrn_list[PHY_LTRN_LIST_LEN] = {
 	0x18f9, 0x0d01, 0x00e4, 0xdef4, 0x06f1, 0x0ffc,
 	0xfa27, 0x1dff, 0x10f0, 0x0918, 0xf20a, 0xe010,
 	0x1417, 0x1104, 0xf114, 0xf2fa, 0xf7db, 0xe2fc,
@@ -107,7 +111,7 @@ uint16 ltrn_list[PHY_LTRN_LIST_LEN] = {
 	0x0507, 0x0fea, 0xe4f2, 0xf6e6
 };
 
-const uint8 ofdm_rate_lookup[] = {
+const u8 ofdm_rate_lookup[] = {
 
 	WLC_RATE_48M,
 	WLC_RATE_24M,
@@ -121,29 +125,29 @@ const uint8 ofdm_rate_lookup[] = {
 
 #define PHY_WREG_LIMIT	24
 
-static void wlc_set_phy_uninitted(phy_info_t * pi);
-static uint32 wlc_phy_get_radio_ver(phy_info_t * pi);
+static void wlc_set_phy_uninitted(phy_info_t *pi);
+static u32 wlc_phy_get_radio_ver(phy_info_t *pi);
 static void wlc_phy_timercb_phycal(void *arg);
 
-static bool wlc_phy_noise_calc_phy(phy_info_t * pi, uint32 * cmplx_pwr,
-				   int8 * pwr_ant);
+static bool wlc_phy_noise_calc_phy(phy_info_t *pi, u32 *cmplx_pwr,
+				   s8 *pwr_ant);
 
-static void wlc_phy_cal_perical_mphase_schedule(phy_info_t * pi, uint delay);
-static void wlc_phy_noise_cb(phy_info_t * pi, uint8 channel, int8 noise_dbm);
-static void wlc_phy_noise_sample_request(wlc_phy_t * pih, uint8 reason,
-					 uint8 ch);
+static void wlc_phy_cal_perical_mphase_schedule(phy_info_t *pi, uint delay);
+static void wlc_phy_noise_cb(phy_info_t *pi, u8 channel, s8 noise_dbm);
+static void wlc_phy_noise_sample_request(wlc_phy_t *pih, u8 reason,
+					 u8 ch);
 
-static void wlc_phy_txpower_reg_limit_calc(phy_info_t * pi,
+static void wlc_phy_txpower_reg_limit_calc(phy_info_t *pi,
 					   struct txpwr_limits *tp, chanspec_t);
-static bool wlc_phy_cal_txpower_recalc_sw(phy_info_t * pi);
+static bool wlc_phy_cal_txpower_recalc_sw(phy_info_t *pi);
 
-static int8 wlc_user_txpwr_antport_to_rfport(phy_info_t * pi, uint chan,
-					     uint32 band, uint8 rate);
-static void wlc_phy_upd_env_txpwr_rate_limits(phy_info_t * pi, uint32 band);
-static int8 wlc_phy_env_measure_vbat(phy_info_t * pi);
-static int8 wlc_phy_env_measure_temperature(phy_info_t * pi);
+static s8 wlc_user_txpwr_antport_to_rfport(phy_info_t *pi, uint chan,
+					     u32 band, u8 rate);
+static void wlc_phy_upd_env_txpwr_rate_limits(phy_info_t *pi, u32 band);
+static s8 wlc_phy_env_measure_vbat(phy_info_t *pi);
+static s8 wlc_phy_env_measure_temperature(phy_info_t *pi);
 
-char *phy_getvar(phy_info_t * pi, const char *name)
+char *phy_getvar(phy_info_t *pi, const char *name)
 {
 	char *vars = pi->vars;
 	char *s;
@@ -160,63 +164,65 @@ char *phy_getvar(phy_info_t * pi, const char *name)
 
 	for (s = vars; s && *s;) {
 		if ((bcmp(s, name, len) == 0) && (s[len] == '='))
-			return (&s[len + 1]);
+			return &s[len + 1];
 
-		while (*s++) ;
+		while (*s++)
+			;
 	}
 
-	return (nvram_get(name));
+	return nvram_get(name);
 }
 
-int phy_getintvar(phy_info_t * pi, const char *name)
+int phy_getintvar(phy_info_t *pi, const char *name)
 {
 	char *val;
 
-	if ((val = PHY_GETVAR(pi, name)) == NULL)
-		return (0);
+	val = PHY_GETVAR(pi, name);
+	if (val == NULL)
+		return 0;
 
-	return (bcm_strtoul(val, NULL, 0));
+	return simple_strtoul(val, NULL, 0);
 }
 
-void wlc_phyreg_enter(wlc_phy_t * pih)
+void wlc_phyreg_enter(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	wlapi_bmac_ucode_wake_override_phyreg_set(pi->sh->physhim);
 }
 
-void wlc_phyreg_exit(wlc_phy_t * pih)
+void wlc_phyreg_exit(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	wlapi_bmac_ucode_wake_override_phyreg_clear(pi->sh->physhim);
 }
 
-void wlc_radioreg_enter(wlc_phy_t * pih)
+void wlc_radioreg_enter(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	wlapi_bmac_mctrl(pi->sh->physhim, MCTL_LOCK_RADIO, MCTL_LOCK_RADIO);
 
-	OSL_DELAY(10);
+	udelay(10);
 }
 
-void wlc_radioreg_exit(wlc_phy_t * pih)
+void wlc_radioreg_exit(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
-	volatile uint16 dummy;
+	volatile u16 dummy;
 
 	dummy = R_REG(pi->sh->osh, &pi->regs->phyversion);
 	pi->phy_wreg = 0;
 	wlapi_bmac_mctrl(pi->sh->physhim, MCTL_LOCK_RADIO, 0);
 }
 
-uint16 read_radio_reg(phy_info_t * pi, uint16 addr)
+u16 read_radio_reg(phy_info_t *pi, u16 addr)
 {
-	uint16 data;
+	u16 data;
 
 	if ((addr == RADIO_IDCODE))
 		return 0xffff;
 
 	if (NORADIO_ENAB(pi->pubpi))
-		return (NORADIO_IDCODE & 0xffff);
+		return NORADIO_IDCODE & 0xffff;
 
 	switch (pi->pubpi.phy_type) {
 	case PHY_TYPE_N:
@@ -264,7 +270,7 @@ uint16 read_radio_reg(phy_info_t * pi, uint16 addr)
 	return data;
 }
 
-void write_radio_reg(phy_info_t * pi, uint16 addr, uint16 val)
+void write_radio_reg(phy_info_t *pi, u16 addr, u16 val)
 {
 	osl_t *osh;
 
@@ -298,31 +304,31 @@ void write_radio_reg(phy_info_t * pi, uint16 addr, uint16 val)
 	}
 }
 
-static uint32 read_radio_id(phy_info_t * pi)
+static u32 read_radio_id(phy_info_t *pi)
 {
-	uint32 id;
+	u32 id;
 
 	if (NORADIO_ENAB(pi->pubpi))
-		return (NORADIO_IDCODE);
+		return NORADIO_IDCODE;
 
 	if (D11REV_GE(pi->sh->corerev, 24)) {
-		uint32 b0, b1, b2;
+		u32 b0, b1, b2;
 
 		W_REG(pi->sh->osh, &pi->regs->radioregaddr, 0);
 #ifdef __mips__
 		(void)R_REG(pi->sh->osh, &pi->regs->radioregaddr);
 #endif
-		b0 = (uint32) R_REG(pi->sh->osh, &pi->regs->radioregdata);
+		b0 = (u32) R_REG(pi->sh->osh, &pi->regs->radioregdata);
 		W_REG(pi->sh->osh, &pi->regs->radioregaddr, 1);
 #ifdef __mips__
 		(void)R_REG(pi->sh->osh, &pi->regs->radioregaddr);
 #endif
-		b1 = (uint32) R_REG(pi->sh->osh, &pi->regs->radioregdata);
+		b1 = (u32) R_REG(pi->sh->osh, &pi->regs->radioregdata);
 		W_REG(pi->sh->osh, &pi->regs->radioregaddr, 2);
 #ifdef __mips__
 		(void)R_REG(pi->sh->osh, &pi->regs->radioregaddr);
 #endif
-		b2 = (uint32) R_REG(pi->sh->osh, &pi->regs->radioregdata);
+		b2 = (u32) R_REG(pi->sh->osh, &pi->regs->radioregdata);
 
 		id = ((b0 & 0xf) << 28) | (((b2 << 8) | b1) << 12) | ((b0 >> 4)
 								      & 0xf);
@@ -331,16 +337,16 @@ static uint32 read_radio_id(phy_info_t * pi)
 #ifdef __mips__
 		(void)R_REG(pi->sh->osh, &pi->regs->phy4waddr);
 #endif
-		id = (uint32) R_REG(pi->sh->osh, &pi->regs->phy4wdatalo);
-		id |= (uint32) R_REG(pi->sh->osh, &pi->regs->phy4wdatahi) << 16;
+		id = (u32) R_REG(pi->sh->osh, &pi->regs->phy4wdatalo);
+		id |= (u32) R_REG(pi->sh->osh, &pi->regs->phy4wdatahi) << 16;
 	}
 	pi->phy_wreg = 0;
 	return id;
 }
 
-void and_radio_reg(phy_info_t * pi, uint16 addr, uint16 val)
+void and_radio_reg(phy_info_t *pi, u16 addr, u16 val)
 {
-	uint16 rval;
+	u16 rval;
 
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
@@ -349,9 +355,9 @@ void and_radio_reg(phy_info_t * pi, uint16 addr, uint16 val)
 	write_radio_reg(pi, addr, (rval & val));
 }
 
-void or_radio_reg(phy_info_t * pi, uint16 addr, uint16 val)
+void or_radio_reg(phy_info_t *pi, u16 addr, u16 val)
 {
-	uint16 rval;
+	u16 rval;
 
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
@@ -360,9 +366,9 @@ void or_radio_reg(phy_info_t * pi, uint16 addr, uint16 val)
 	write_radio_reg(pi, addr, (rval | val));
 }
 
-void xor_radio_reg(phy_info_t * pi, uint16 addr, uint16 mask)
+void xor_radio_reg(phy_info_t *pi, u16 addr, u16 mask)
 {
-	uint16 rval;
+	u16 rval;
 
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
@@ -371,9 +377,9 @@ void xor_radio_reg(phy_info_t * pi, uint16 addr, uint16 mask)
 	write_radio_reg(pi, addr, (rval ^ mask));
 }
 
-void mod_radio_reg(phy_info_t * pi, uint16 addr, uint16 mask, uint16 val)
+void mod_radio_reg(phy_info_t *pi, u16 addr, u16 mask, u16 val)
 {
-	uint16 rval;
+	u16 rval;
 
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
@@ -382,22 +388,22 @@ void mod_radio_reg(phy_info_t * pi, uint16 addr, uint16 mask, uint16 val)
 	write_radio_reg(pi, addr, (rval & ~mask) | (val & mask));
 }
 
-void write_phy_channel_reg(phy_info_t * pi, uint val)
+void write_phy_channel_reg(phy_info_t *pi, uint val)
 {
 	W_REG(pi->sh->osh, &pi->regs->phychannel, val);
 }
 
 #if defined(BCMDBG)
-static bool wlc_phy_war41476(phy_info_t * pi)
+static bool wlc_phy_war41476(phy_info_t *pi)
 {
-	uint32 mc = R_REG(pi->sh->osh, &pi->regs->maccontrol);
+	u32 mc = R_REG(pi->sh->osh, &pi->regs->maccontrol);
 
 	return ((mc & MCTL_EN_MAC) == 0)
 	    || ((mc & MCTL_PHYLOCK) == MCTL_PHYLOCK);
 }
 #endif
 
-uint16 read_phy_reg(phy_info_t * pi, uint16 addr)
+u16 read_phy_reg(phy_info_t *pi, u16 addr)
 {
 	osl_t *osh;
 	d11regs_t *regs;
@@ -415,10 +421,10 @@ uint16 read_phy_reg(phy_info_t * pi, uint16 addr)
 		|| D11REV_IS(pi->sh->corerev, 12)) || wlc_phy_war41476(pi));
 
 	pi->phy_wreg = 0;
-	return (R_REG(osh, &regs->phyregdata));
+	return R_REG(osh, &regs->phyregdata);
 }
 
-void write_phy_reg(phy_info_t * pi, uint16 addr, uint16 val)
+void write_phy_reg(phy_info_t *pi, u16 addr, u16 val)
 {
 	osl_t *osh;
 	d11regs_t *regs;
@@ -433,7 +439,7 @@ void write_phy_reg(phy_info_t * pi, uint16 addr, uint16 val)
 	if (addr == 0x72)
 		(void)R_REG(osh, &regs->phyregdata);
 #else
-	W_REG(osh, (volatile uint32 *)(uintptr) (&regs->phyregaddr),
+	W_REG(osh, (volatile u32 *)(&regs->phyregaddr),
 	      addr | (val << 16));
 	if (BUSTYPE(pi->sh->bustype) == PCI_BUS) {
 		if (++pi->phy_wreg >= pi->phy_wreg_limit) {
@@ -444,7 +450,7 @@ void write_phy_reg(phy_info_t * pi, uint16 addr, uint16 val)
 #endif
 }
 
-void and_phy_reg(phy_info_t * pi, uint16 addr, uint16 val)
+void and_phy_reg(phy_info_t *pi, u16 addr, u16 val)
 {
 	osl_t *osh;
 	d11regs_t *regs;
@@ -465,7 +471,7 @@ void and_phy_reg(phy_info_t * pi, uint16 addr, uint16 val)
 	pi->phy_wreg = 0;
 }
 
-void or_phy_reg(phy_info_t * pi, uint16 addr, uint16 val)
+void or_phy_reg(phy_info_t *pi, u16 addr, u16 val)
 {
 	osl_t *osh;
 	d11regs_t *regs;
@@ -486,7 +492,7 @@ void or_phy_reg(phy_info_t * pi, uint16 addr, uint16 val)
 	pi->phy_wreg = 0;
 }
 
-void mod_phy_reg(phy_info_t * pi, uint16 addr, uint16 mask, uint16 val)
+void mod_phy_reg(phy_info_t *pi, u16 addr, u16 mask, u16 val)
 {
 	osl_t *osh;
 	d11regs_t *regs;
@@ -508,10 +514,11 @@ void mod_phy_reg(phy_info_t * pi, uint16 addr, uint16 mask, uint16 val)
 	pi->phy_wreg = 0;
 }
 
-static void WLBANDINITFN(wlc_set_phy_uninitted) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_set_phy_uninitted) (phy_info_t *pi)
+{
 	int i, j;
 
-	pi->initialized = FALSE;
+	pi->initialized = false;
 
 	pi->tx_vos = 0xffff;
 	pi->nrssi_table_delta = 0x7fffffff;
@@ -544,14 +551,14 @@ static void WLBANDINITFN(wlc_set_phy_uninitted) (phy_info_t * pi) {
 	}
 }
 
-shared_phy_t *BCMATTACHFN(wlc_phy_shared_attach) (shared_phy_params_t * shp) {
+shared_phy_t *wlc_phy_shared_attach(shared_phy_params_t *shp)
+{
 	shared_phy_t *sh;
 
-	if ((sh =
-	     (shared_phy_t *) MALLOC(shp->osh, sizeof(shared_phy_t))) == NULL) {
+	sh = kzalloc(sizeof(shared_phy_t), GFP_ATOMIC);
+	if (sh == NULL) {
 		return NULL;
 	}
-	bzero((char *)sh, sizeof(shared_phy_t));
 
 	sh->osh = shp->osh;
 	sh->sih = shp->sih;
@@ -582,7 +589,8 @@ shared_phy_t *BCMATTACHFN(wlc_phy_shared_attach) (shared_phy_params_t * shp) {
 	return sh;
 }
 
-void BCMATTACHFN(wlc_phy_shared_detach) (shared_phy_t * phy_sh) {
+void wlc_phy_shared_detach(shared_phy_t *phy_sh)
+{
 	osl_t *osh;
 
 	if (phy_sh) {
@@ -591,14 +599,14 @@ void BCMATTACHFN(wlc_phy_shared_detach) (shared_phy_t * phy_sh) {
 		if (phy_sh->phy_head) {
 			ASSERT(!phy_sh->phy_head);
 		}
-		MFREE(osh, phy_sh, sizeof(shared_phy_t));
+		kfree(phy_sh);
 	}
 }
 
-wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (shared_phy_t * sh, void *regs,
-					int bandtype, char *vars) {
+wlc_phy_t *wlc_phy_attach(shared_phy_t *sh, void *regs, int bandtype, char *vars)
+{
 	phy_info_t *pi;
-	uint32 sflags = 0;
+	u32 sflags = 0;
 	uint phyversion;
 	int i;
 	osl_t *osh;
@@ -616,27 +624,28 @@ wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (shared_phy_t * sh, void *regs,
 		}
 	}
 
-	if ((sflags & SISF_DB_PHY) && (pi = sh->phy_head)) {
+	pi = sh->phy_head;
+	if ((sflags & SISF_DB_PHY) && pi) {
 
 		wlapi_bmac_corereset(pi->sh->physhim, pi->pubpi.coreflags);
 		pi->refcnt++;
 		return &pi->pubpi_ro;
 	}
 
-	if ((pi = (phy_info_t *) MALLOC(osh, sizeof(phy_info_t))) == NULL) {
+	pi = kzalloc(sizeof(phy_info_t), GFP_ATOMIC);
+	if (pi == NULL) {
 		return NULL;
 	}
-	bzero((char *)pi, sizeof(phy_info_t));
 	pi->regs = (d11regs_t *) regs;
 	pi->sh = sh;
-	pi->phy_init_por = TRUE;
+	pi->phy_init_por = true;
 	pi->phy_wreg_limit = PHY_WREG_LIMIT;
 
 	pi->vars = vars;
 
 	pi->txpwr_percent = 100;
 
-	pi->do_initcal = TRUE;
+	pi->do_initcal = true;
 
 	pi->phycal_tempdelta = 0;
 
@@ -675,7 +684,7 @@ wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (shared_phy_t * sh, void *regs,
 		pi->pubpi.radioid = NORADIO_ID;
 		pi->pubpi.radiorev = 5;
 	} else {
-		uint32 idcode;
+		u32 idcode;
 
 		wlc_phy_anacore((wlc_phy_t *) pi, ON);
 
@@ -702,7 +711,7 @@ wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (shared_phy_t * sh, void *regs,
 	pi->rxiq_samps = PHY_NOISE_SAMPLE_LOG_NUM_NPHY;
 	pi->rxiq_antsel = ANT_RX_DIV_DEF;
 
-	pi->watchdog_override = TRUE;
+	pi->watchdog_override = true;
 
 	pi->cal_type_override = PHY_PERICAL_AUTO;
 
@@ -721,13 +730,13 @@ wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (shared_phy_t * sh, void *regs,
 	pi->phy_txcore_enable_temp =
 	    PHY_CHAIN_TX_DISABLE_TEMP - PHY_HYSTERESIS_DELTATEMP;
 	pi->phy_tempsense_offset = 0;
-	pi->phy_txcore_heatedup = FALSE;
+	pi->phy_txcore_heatedup = false;
 
 	pi->nphy_lastcal_temp = -50;
 
-	pi->phynoise_polling = TRUE;
+	pi->phynoise_polling = true;
 	if (ISNPHY(pi) || ISLCNPHY(pi))
-		pi->phynoise_polling = FALSE;
+		pi->phynoise_polling = false;
 
 	for (i = 0; i < TXP_NUM_RATES; i++) {
 		pi->txpwr_limit[i] = WLC_TXPWR_MAX;
@@ -737,13 +746,14 @@ wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (shared_phy_t * sh, void *regs,
 
 	pi->radiopwr_override = RADIOPWR_OVERRIDE_DEF;
 
-	pi->user_txpwr_at_rfport = FALSE;
+	pi->user_txpwr_at_rfport = false;
 
 	if (ISNPHY(pi)) {
 
-		if (!(pi->phycal_timer = wlapi_init_timer(pi->sh->physhim,
+		pi->phycal_timer = wlapi_init_timer(pi->sh->physhim,
 							  wlc_phy_timercb_phycal,
-							  pi, "phycal"))) {
+							  pi, "phycal");
+		if (!pi->phycal_timer) {
 			goto err;
 		}
 
@@ -770,11 +780,12 @@ wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (shared_phy_t * sh, void *regs,
 
  err:
 	if (pi)
-		MFREE(sh->osh, pi, sizeof(phy_info_t));
+		kfree(pi);
 	return NULL;
 }
 
-void BCMATTACHFN(wlc_phy_detach) (wlc_phy_t * pih) {
+void wlc_phy_detach(wlc_phy_t *pih)
+{
 	phy_info_t *pi = (phy_info_t *) pih;
 
 	if (pih) {
@@ -797,30 +808,30 @@ void BCMATTACHFN(wlc_phy_detach) (wlc_phy_t * pih) {
 		if (pi->pi_fptr.detach)
 			(pi->pi_fptr.detach) (pi);
 
-		MFREE(pi->sh->osh, pi, sizeof(phy_info_t));
+		kfree(pi);
 	}
 }
 
 bool
-wlc_phy_get_phyversion(wlc_phy_t * pih, uint16 * phytype, uint16 * phyrev,
-		       uint16 * radioid, uint16 * radiover)
+wlc_phy_get_phyversion(wlc_phy_t *pih, u16 *phytype, u16 *phyrev,
+		       u16 *radioid, u16 *radiover)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
-	*phytype = (uint16) pi->pubpi.phy_type;
-	*phyrev = (uint16) pi->pubpi.phy_rev;
+	*phytype = (u16) pi->pubpi.phy_type;
+	*phyrev = (u16) pi->pubpi.phy_rev;
 	*radioid = pi->pubpi.radioid;
 	*radiover = pi->pubpi.radiorev;
 
-	return TRUE;
+	return true;
 }
 
-bool wlc_phy_get_encore(wlc_phy_t * pih)
+bool wlc_phy_get_encore(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	return pi->pubpi.abgphy_encore;
 }
 
-uint32 wlc_phy_get_coreflags(wlc_phy_t * pih)
+u32 wlc_phy_get_coreflags(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	return pi->pubpi.coreflags;
@@ -849,7 +860,7 @@ static void wlc_phy_timercb_phycal(void *arg)
 
 }
 
-void wlc_phy_anacore(wlc_phy_t * pih, bool on)
+void wlc_phy_anacore(wlc_phy_t *pih, bool on)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -886,11 +897,11 @@ void wlc_phy_anacore(wlc_phy_t * pih, bool on)
 	}
 }
 
-uint32 wlc_phy_clk_bwbits(wlc_phy_t * pih)
+u32 wlc_phy_clk_bwbits(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
-	uint32 phy_bw_clkbits = 0;
+	u32 phy_bw_clkbits = 0;
 
 	if (pi && (ISNPHY(pi) || ISLCNPHY(pi))) {
 		switch (pi->bw) {
@@ -912,13 +923,14 @@ uint32 wlc_phy_clk_bwbits(wlc_phy_t * pih)
 	return phy_bw_clkbits;
 }
 
-void WLBANDINITFN(wlc_phy_por_inform) (wlc_phy_t * ppi) {
+void WLBANDINITFN(wlc_phy_por_inform) (wlc_phy_t *ppi)
+{
 	phy_info_t *pi = (phy_info_t *) ppi;
 
-	pi->phy_init_por = TRUE;
+	pi->phy_init_por = true;
 }
 
-void wlc_phy_edcrs_lock(wlc_phy_t * pih, bool lock)
+void wlc_phy_edcrs_lock(wlc_phy_t *pih, bool lock)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -930,14 +942,14 @@ void wlc_phy_edcrs_lock(wlc_phy_t * pih, bool lock)
 	write_phy_reg(pi, 0x22f, 0x3c0);
 }
 
-void wlc_phy_initcal_enable(wlc_phy_t * pih, bool initcal)
+void wlc_phy_initcal_enable(wlc_phy_t *pih, bool initcal)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
 	pi->do_initcal = initcal;
 }
 
-void wlc_phy_hw_clk_state_upd(wlc_phy_t * pih, bool newstate)
+void wlc_phy_hw_clk_state_upd(wlc_phy_t *pih, bool newstate)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -947,7 +959,7 @@ void wlc_phy_hw_clk_state_upd(wlc_phy_t * pih, bool newstate)
 	pi->sh->clk = newstate;
 }
 
-void wlc_phy_hw_state_upd(wlc_phy_t * pih, bool newstate)
+void wlc_phy_hw_state_upd(wlc_phy_t *pih, bool newstate)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -957,15 +969,16 @@ void wlc_phy_hw_state_upd(wlc_phy_t * pih, bool newstate)
 	pi->sh->up = newstate;
 }
 
-void WLBANDINITFN(wlc_phy_init) (wlc_phy_t * pih, chanspec_t chanspec) {
-	uint32 mc;
+void WLBANDINITFN(wlc_phy_init) (wlc_phy_t *pih, chanspec_t chanspec)
+{
+	u32 mc;
 	initfn_t phy_init = NULL;
 	phy_info_t *pi = (phy_info_t *) pih;
 
 	if (pi->init_in_progress)
 		return;
 
-	pi->init_in_progress = TRUE;
+	pi->init_in_progress = true;
 
 	pi->radio_chanspec = chanspec;
 
@@ -997,26 +1010,27 @@ void WLBANDINITFN(wlc_phy_init) (wlc_phy_t * pih, chanspec_t chanspec) {
 		wlapi_bmac_bw_set(pi->sh->physhim,
 				  CHSPEC_BW(pi->radio_chanspec));
 
-	pi->nphy_gain_boost = TRUE;
+	pi->nphy_gain_boost = true;
 
 	wlc_phy_switch_radio((wlc_phy_t *) pi, ON);
 
 	(*phy_init) (pi);
 
-	pi->phy_init_por = FALSE;
+	pi->phy_init_por = false;
 
 	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))
-		wlc_phy_do_dummy_tx(pi, TRUE, OFF);
+		wlc_phy_do_dummy_tx(pi, true, OFF);
 
 	if (!(ISNPHY(pi)))
 		wlc_phy_txpower_update_shm(pi);
 
 	wlc_phy_ant_rxdiv_set((wlc_phy_t *) pi, pi->sh->rx_antdiv);
 
-	pi->init_in_progress = FALSE;
+	pi->init_in_progress = false;
 }
 
-void BCMINITFN(wlc_phy_cal_init) (wlc_phy_t * pih) {
+void wlc_phy_cal_init(wlc_phy_t *pih)
+{
 	phy_info_t *pi = (phy_info_t *) pih;
 	initfn_t cal_init = NULL;
 
@@ -1027,15 +1041,16 @@ void BCMINITFN(wlc_phy_cal_init) (wlc_phy_t * pih) {
 		if (cal_init)
 			(*cal_init) (pi);
 
-		pi->initialized = TRUE;
+		pi->initialized = true;
 	}
 }
 
-int BCMUNINITFN(wlc_phy_down) (wlc_phy_t * pih) {
+int wlc_phy_down(wlc_phy_t *pih)
+{
 	phy_info_t *pi = (phy_info_t *) pih;
 	int callbacks = 0;
 
-	ASSERT(pi->phytest_on == FALSE);
+	ASSERT(pi->phytest_on == false);
 
 	if (pi->phycal_timer
 	    && !wlapi_del_timer(pi->sh->physhim, pi->phycal_timer))
@@ -1047,9 +1062,9 @@ int BCMUNINITFN(wlc_phy_down) (wlc_phy_t * pih) {
 	return callbacks;
 }
 
-static uint32 wlc_phy_get_radio_ver(phy_info_t * pi)
+static u32 wlc_phy_get_radio_ver(phy_info_t *pi)
 {
-	uint32 ver;
+	u32 ver;
 
 	ver = read_radio_id(pi);
 
@@ -1057,8 +1072,8 @@ static uint32 wlc_phy_get_radio_ver(phy_info_t * pi)
 }
 
 void
-wlc_phy_table_addr(phy_info_t * pi, uint tbl_id, uint tbl_offset,
-		   uint16 tblAddr, uint16 tblDataHi, uint16 tblDataLo)
+wlc_phy_table_addr(phy_info_t *pi, uint tbl_id, uint tbl_offset,
+		   u16 tblAddr, u16 tblDataHi, u16 tblDataLo)
 {
 	write_phy_reg(pi, tblAddr, (tbl_id << 10) | tbl_offset);
 
@@ -1074,7 +1089,7 @@ wlc_phy_table_addr(phy_info_t * pi, uint tbl_id, uint tbl_offset,
 	}
 }
 
-void wlc_phy_table_data_write(phy_info_t * pi, uint width, uint32 val)
+void wlc_phy_table_data_write(phy_info_t *pi, uint width, u32 val)
 {
 	ASSERT((width == 8) || (width == 16) || (width == 32));
 
@@ -1091,25 +1106,25 @@ void wlc_phy_table_data_write(phy_info_t * pi, uint width, uint32 val)
 
 	if (width == 32) {
 
-		write_phy_reg(pi, pi->tbl_data_hi, (uint16) (val >> 16));
-		write_phy_reg(pi, pi->tbl_data_lo, (uint16) val);
+		write_phy_reg(pi, pi->tbl_data_hi, (u16) (val >> 16));
+		write_phy_reg(pi, pi->tbl_data_lo, (u16) val);
 	} else {
 
-		write_phy_reg(pi, pi->tbl_data_lo, (uint16) val);
+		write_phy_reg(pi, pi->tbl_data_lo, (u16) val);
 	}
 }
 
 void
-wlc_phy_write_table(phy_info_t * pi, const phytbl_info_t * ptbl_info,
-		    uint16 tblAddr, uint16 tblDataHi, uint16 tblDataLo)
+wlc_phy_write_table(phy_info_t *pi, const phytbl_info_t *ptbl_info,
+		    u16 tblAddr, u16 tblDataHi, u16 tblDataLo)
 {
 	uint idx;
 	uint tbl_id = ptbl_info->tbl_id;
 	uint tbl_offset = ptbl_info->tbl_offset;
 	uint tbl_width = ptbl_info->tbl_width;
-	const uint8 *ptbl_8b = (const uint8 *)ptbl_info->tbl_ptr;
-	const uint16 *ptbl_16b = (const uint16 *)ptbl_info->tbl_ptr;
-	const uint32 *ptbl_32b = (const uint32 *)ptbl_info->tbl_ptr;
+	const u8 *ptbl_8b = (const u8 *)ptbl_info->tbl_ptr;
+	const u16 *ptbl_16b = (const u16 *)ptbl_info->tbl_ptr;
+	const u32 *ptbl_32b = (const u32 *)ptbl_info->tbl_ptr;
 
 	ASSERT((tbl_width == 8) || (tbl_width == 16) || (tbl_width == 32));
 
@@ -1130,8 +1145,8 @@ wlc_phy_write_table(phy_info_t * pi, const phytbl_info_t * ptbl_info,
 		if (tbl_width == 32) {
 
 			write_phy_reg(pi, tblDataHi,
-				      (uint16) (ptbl_32b[idx] >> 16));
-			write_phy_reg(pi, tblDataLo, (uint16) ptbl_32b[idx]);
+				      (u16) (ptbl_32b[idx] >> 16));
+			write_phy_reg(pi, tblDataLo, (u16) ptbl_32b[idx]);
 		} else if (tbl_width == 16) {
 
 			write_phy_reg(pi, tblDataLo, ptbl_16b[idx]);
@@ -1143,16 +1158,16 @@ wlc_phy_write_table(phy_info_t * pi, const phytbl_info_t * ptbl_info,
 }
 
 void
-wlc_phy_read_table(phy_info_t * pi, const phytbl_info_t * ptbl_info,
-		   uint16 tblAddr, uint16 tblDataHi, uint16 tblDataLo)
+wlc_phy_read_table(phy_info_t *pi, const phytbl_info_t *ptbl_info,
+		   u16 tblAddr, u16 tblDataHi, u16 tblDataLo)
 {
 	uint idx;
 	uint tbl_id = ptbl_info->tbl_id;
 	uint tbl_offset = ptbl_info->tbl_offset;
 	uint tbl_width = ptbl_info->tbl_width;
-	uint8 *ptbl_8b = (uint8 *) (uintptr) ptbl_info->tbl_ptr;
-	uint16 *ptbl_16b = (uint16 *) (uintptr) ptbl_info->tbl_ptr;
-	uint32 *ptbl_32b = (uint32 *) (uintptr) ptbl_info->tbl_ptr;
+	u8 *ptbl_8b = (u8 *)ptbl_info->tbl_ptr;
+	u16 *ptbl_16b = (u16 *)ptbl_info->tbl_ptr;
+	u32 *ptbl_32b = (u32 *)ptbl_info->tbl_ptr;
 
 	ASSERT((tbl_width == 8) || (tbl_width == 16) || (tbl_width == 32));
 
@@ -1178,20 +1193,20 @@ wlc_phy_read_table(phy_info_t * pi, const phytbl_info_t * ptbl_info,
 			ptbl_16b[idx] = read_phy_reg(pi, tblDataLo);
 		} else {
 
-			ptbl_8b[idx] = (uint8) read_phy_reg(pi, tblDataLo);
+			ptbl_8b[idx] = (u8) read_phy_reg(pi, tblDataLo);
 		}
 	}
 }
 
 uint
-wlc_phy_init_radio_regs_allbands(phy_info_t * pi, radio_20xx_regs_t * radioregs)
+wlc_phy_init_radio_regs_allbands(phy_info_t *pi, radio_20xx_regs_t *radioregs)
 {
 	uint i = 0;
 
 	do {
 		if (radioregs[i].do_init) {
 			write_radio_reg(pi, radioregs[i].address,
-					(uint16) radioregs[i].init);
+					(u16) radioregs[i].init);
 		}
 
 		i++;
@@ -1201,8 +1216,8 @@ wlc_phy_init_radio_regs_allbands(phy_info_t * pi, radio_20xx_regs_t * radioregs)
 }
 
 uint
-wlc_phy_init_radio_regs(phy_info_t * pi, radio_regs_t * radioregs,
-			uint16 core_offset)
+wlc_phy_init_radio_regs(phy_info_t *pi, radio_regs_t *radioregs,
+			u16 core_offset)
 {
 	uint i = 0;
 	uint count = 0;
@@ -1213,7 +1228,7 @@ wlc_phy_init_radio_regs(phy_info_t * pi, radio_regs_t * radioregs,
 				write_radio_reg(pi,
 						radioregs[i].
 						address | core_offset,
-						(uint16) radioregs[i].init_a);
+						(u16) radioregs[i].init_a);
 				if (ISNPHY(pi) && (++count % 4 == 0))
 					WLC_PHY_WAR_PR51571(pi);
 			}
@@ -1222,7 +1237,7 @@ wlc_phy_init_radio_regs(phy_info_t * pi, radio_regs_t * radioregs,
 				write_radio_reg(pi,
 						radioregs[i].
 						address | core_offset,
-						(uint16) radioregs[i].init_g);
+						(u16) radioregs[i].init_g);
 				if (ISNPHY(pi) && (++count % 4 == 0))
 					WLC_PHY_WAR_PR51571(pi);
 			}
@@ -1234,24 +1249,24 @@ wlc_phy_init_radio_regs(phy_info_t * pi, radio_regs_t * radioregs,
 	return i;
 }
 
-void wlc_phy_do_dummy_tx(phy_info_t * pi, bool ofdm, bool pa_on)
+void wlc_phy_do_dummy_tx(phy_info_t *pi, bool ofdm, bool pa_on)
 {
 #define	DUMMY_PKT_LEN	20
 	d11regs_t *regs = pi->regs;
 	int i, count;
-	uint8 ofdmpkt[DUMMY_PKT_LEN] = {
+	u8 ofdmpkt[DUMMY_PKT_LEN] = {
 		0xcc, 0x01, 0x02, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00,
 		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
 	};
-	uint8 cckpkt[DUMMY_PKT_LEN] = {
+	u8 cckpkt[DUMMY_PKT_LEN] = {
 		0x6e, 0x84, 0x0b, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00,
 		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
 	};
-	uint32 *dummypkt;
+	u32 *dummypkt;
 
 	ASSERT((R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC) == 0);
 
-	dummypkt = (uint32 *) (ofdm ? ofdmpkt : cckpkt);
+	dummypkt = (u32 *) (ofdm ? ofdmpkt : cckpkt);
 	wlapi_bmac_write_template_ram(pi->sh->physhim, 0, DUMMY_PKT_LEN,
 				      dummypkt);
 
@@ -1299,20 +1314,20 @@ void wlc_phy_do_dummy_tx(phy_info_t * pi, bool ofdm, bool pa_on)
 
 	while ((i++ < count)
 	       && (R_REG(pi->sh->osh, &regs->txe_status) & (1 << 7))) {
-		OSL_DELAY(10);
+		udelay(10);
 	}
 
 	i = 0;
 
 	while ((i++ < 10)
 	       && ((R_REG(pi->sh->osh, &regs->txe_status) & (1 << 10)) == 0)) {
-		OSL_DELAY(10);
+		udelay(10);
 	}
 
 	i = 0;
 
 	while ((i++ < 10) && ((R_REG(pi->sh->osh, &regs->ifsstat) & (1 << 8)))) {
-		OSL_DELAY(10);
+		udelay(10);
 	}
 	if (!pa_on) {
 		if (ISNPHY(pi))
@@ -1320,7 +1335,7 @@ void wlc_phy_do_dummy_tx(phy_info_t * pi, bool ofdm, bool pa_on)
 	}
 }
 
-void wlc_phy_hold_upd(wlc_phy_t * pih, mbool id, bool set)
+void wlc_phy_hold_upd(wlc_phy_t *pih, mbool id, bool set)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	ASSERT(id);
@@ -1334,7 +1349,7 @@ void wlc_phy_hold_upd(wlc_phy_t * pih, mbool id, bool set)
 	return;
 }
 
-void wlc_phy_mute_upd(wlc_phy_t * pih, bool mute, mbool flags)
+void wlc_phy_mute_upd(wlc_phy_t *pih, bool mute, mbool flags)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -1349,7 +1364,7 @@ void wlc_phy_mute_upd(wlc_phy_t * pih, bool mute, mbool flags)
 	return;
 }
 
-void wlc_phy_clear_tssi(wlc_phy_t * pih)
+void wlc_phy_clear_tssi(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -1363,12 +1378,12 @@ void wlc_phy_clear_tssi(wlc_phy_t * pih)
 	}
 }
 
-static bool wlc_phy_cal_txpower_recalc_sw(phy_info_t * pi)
+static bool wlc_phy_cal_txpower_recalc_sw(phy_info_t *pi)
 {
-	return FALSE;
+	return false;
 }
 
-void wlc_phy_switch_radio(wlc_phy_t * pih, bool on)
+void wlc_phy_switch_radio(wlc_phy_t *pih, bool on)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -1411,38 +1426,38 @@ void wlc_phy_switch_radio(wlc_phy_t * pih, bool on)
 	}
 }
 
-uint16 wlc_phy_bw_state_get(wlc_phy_t * ppi)
+u16 wlc_phy_bw_state_get(wlc_phy_t *ppi)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	return pi->bw;
 }
 
-void wlc_phy_bw_state_set(wlc_phy_t * ppi, uint16 bw)
+void wlc_phy_bw_state_set(wlc_phy_t *ppi, u16 bw)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	pi->bw = bw;
 }
 
-void wlc_phy_chanspec_radio_set(wlc_phy_t * ppi, chanspec_t newch)
+void wlc_phy_chanspec_radio_set(wlc_phy_t *ppi, chanspec_t newch)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	pi->radio_chanspec = newch;
 
 }
 
-chanspec_t wlc_phy_chanspec_get(wlc_phy_t * ppi)
+chanspec_t wlc_phy_chanspec_get(wlc_phy_t *ppi)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	return pi->radio_chanspec;
 }
 
-void wlc_phy_chanspec_set(wlc_phy_t * ppi, chanspec_t chanspec)
+void wlc_phy_chanspec_set(wlc_phy_t *ppi, chanspec_t chanspec)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
-	uint16 m_cur_channel;
+	u16 m_cur_channel;
 	chansetfn_t chanspec_set = NULL;
 
 	ASSERT(!wf_chspec_malformed(chanspec));
@@ -1476,7 +1491,7 @@ int wlc_phy_chanspec_freq2bandrange_lpssn(uint freq)
 	return range;
 }
 
-int wlc_phy_chanspec_bandrange_get(phy_info_t * pi, chanspec_t chanspec)
+int wlc_phy_chanspec_bandrange_get(phy_info_t *pi, chanspec_t chanspec)
 {
 	int range = -1;
 	uint channel = CHSPEC_CHANNEL(chanspec);
@@ -1492,7 +1507,7 @@ int wlc_phy_chanspec_bandrange_get(phy_info_t * pi, chanspec_t chanspec)
 	return range;
 }
 
-void wlc_phy_chanspec_ch14_widefilter_set(wlc_phy_t * ppi, bool wide_filter)
+void wlc_phy_chanspec_ch14_widefilter_set(wlc_phy_t *ppi, bool wide_filter)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
@@ -1504,14 +1519,14 @@ int wlc_phy_channel2freq(uint channel)
 {
 	uint i;
 
-	for (i = 0; i < ARRAYSIZE(chan_info_all); i++)
+	for (i = 0; i < ARRAY_SIZE(chan_info_all); i++)
 		if (chan_info_all[i].chan == channel)
-			return (chan_info_all[i].freq);
-	return (0);
+			return chan_info_all[i].freq;
+	return 0;
 }
 
 void
-wlc_phy_chanspec_band_validch(wlc_phy_t * ppi, uint band, chanvec_t * channels)
+wlc_phy_chanspec_band_validch(wlc_phy_t *ppi, uint band, chanvec_t *channels)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	uint i;
@@ -1521,7 +1536,7 @@ wlc_phy_chanspec_band_validch(wlc_phy_t * ppi, uint band, chanvec_t * channels)
 
 	bzero(channels, sizeof(chanvec_t));
 
-	for (i = 0; i < ARRAYSIZE(chan_info_all); i++) {
+	for (i = 0; i < ARRAY_SIZE(chan_info_all); i++) {
 		channel = chan_info_all[i].chan;
 
 		if ((pi->a_band_high_disable) && (channel >= FIRST_REF5_CHANNUM)
@@ -1534,7 +1549,7 @@ wlc_phy_chanspec_band_validch(wlc_phy_t * ppi, uint band, chanvec_t * channels)
 	}
 }
 
-chanspec_t wlc_phy_chanspec_band_firstch(wlc_phy_t * ppi, uint band)
+chanspec_t wlc_phy_chanspec_band_firstch(wlc_phy_t *ppi, uint band)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	uint i;
@@ -1543,19 +1558,19 @@ chanspec_t wlc_phy_chanspec_band_firstch(wlc_phy_t * ppi, uint band)
 
 	ASSERT((band == WLC_BAND_2G) || (band == WLC_BAND_5G));
 
-	for (i = 0; i < ARRAYSIZE(chan_info_all); i++) {
+	for (i = 0; i < ARRAY_SIZE(chan_info_all); i++) {
 		channel = chan_info_all[i].chan;
 
 		if (ISNPHY(pi) && IS40MHZ(pi)) {
 			uint j;
 
-			for (j = 0; j < ARRAYSIZE(chan_info_all); j++) {
+			for (j = 0; j < ARRAY_SIZE(chan_info_all); j++) {
 				if (chan_info_all[j].chan ==
 				    channel + CH_10MHZ_APART)
 					break;
 			}
 
-			if (j == ARRAYSIZE(chan_info_all))
+			if (j == ARRAY_SIZE(chan_info_all))
 				continue;
 
 			channel = UPPER_20_SB(channel);
@@ -1583,7 +1598,7 @@ chanspec_t wlc_phy_chanspec_band_firstch(wlc_phy_t * ppi, uint band)
 	return (chanspec_t) INVCHANSPEC;
 }
 
-int wlc_phy_txpower_get(wlc_phy_t * ppi, uint * qdbm, bool * override)
+int wlc_phy_txpower_get(wlc_phy_t *ppi, uint *qdbm, bool *override)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
@@ -1591,12 +1606,12 @@ int wlc_phy_txpower_get(wlc_phy_t * ppi, uint * qdbm, bool * override)
 	*qdbm = pi->tx_user_target[0];
 	if (override != NULL)
 		*override = pi->txpwroverride;
-	return (0);
+	return 0;
 }
 
-void wlc_phy_txpower_target_set(wlc_phy_t * ppi, struct txpwr_limits *txpwr)
+void wlc_phy_txpower_target_set(wlc_phy_t *ppi, struct txpwr_limits *txpwr)
 {
-	bool mac_enabled = FALSE;
+	bool mac_enabled = false;
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	bcopy(&txpwr->cck[0], &pi->tx_user_target[TXP_FIRST_CCK],
@@ -1635,7 +1650,7 @@ void wlc_phy_txpower_target_set(wlc_phy_t * ppi, struct txpwr_limits *txpwr)
 	      WLC_NUM_RATES_MCS_2_STREAM);
 
 	if (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC)
-		mac_enabled = TRUE;
+		mac_enabled = true;
 
 	if (mac_enabled)
 		wlapi_suspend_mac_and_wait(pi->sh->physhim);
@@ -1647,7 +1662,7 @@ void wlc_phy_txpower_target_set(wlc_phy_t * ppi, struct txpwr_limits *txpwr)
 		wlapi_enable_mac(pi->sh->physhim);
 }
 
-int wlc_phy_txpower_set(wlc_phy_t * ppi, uint qdbm, bool override)
+int wlc_phy_txpower_set(wlc_phy_t *ppi, uint qdbm, bool override)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	int i;
@@ -1656,9 +1671,9 @@ int wlc_phy_txpower_set(wlc_phy_t * ppi, uint qdbm, bool override)
 		return 5;
 
 	for (i = 0; i < TXP_NUM_RATES; i++)
-		pi->tx_user_target[i] = (uint8) qdbm;
+		pi->tx_user_target[i] = (u8) qdbm;
 
-	pi->txpwroverride = FALSE;
+	pi->txpwroverride = false;
 
 	if (pi->sh->up) {
 		if (!SCAN_INPROG_PHY(pi)) {
@@ -1679,12 +1694,12 @@ int wlc_phy_txpower_set(wlc_phy_t * ppi, uint qdbm, bool override)
 				wlapi_enable_mac(pi->sh->physhim);
 		}
 	}
-	return (0);
+	return 0;
 }
 
 void
-wlc_phy_txpower_sromlimit(wlc_phy_t * ppi, uint channel, uint8 * min_pwr,
-			  uint8 * max_pwr, int txp_rate_idx)
+wlc_phy_txpower_sromlimit(wlc_phy_t *ppi, uint channel, u8 *min_pwr,
+			  u8 *max_pwr, int txp_rate_idx)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	uint i;
@@ -1695,7 +1710,7 @@ wlc_phy_txpower_sromlimit(wlc_phy_t * ppi, uint channel, uint8 * min_pwr,
 		if (txp_rate_idx < 0)
 			txp_rate_idx = TXP_FIRST_CCK;
 		wlc_phy_txpower_sromlimit_get_nphy(pi, channel, max_pwr,
-						   (uint8) txp_rate_idx);
+						   (u8) txp_rate_idx);
 
 	} else if ((channel <= CH_MAX_2G_CHANNEL)) {
 		if (txp_rate_idx < 0)
@@ -1708,12 +1723,12 @@ wlc_phy_txpower_sromlimit(wlc_phy_t * ppi, uint channel, uint8 * min_pwr,
 		if (txp_rate_idx < 0)
 			txp_rate_idx = TXP_FIRST_OFDM;
 
-		for (i = 0; i < ARRAYSIZE(chan_info_all); i++) {
+		for (i = 0; i < ARRAY_SIZE(chan_info_all); i++) {
 			if (channel == chan_info_all[i].chan) {
 				break;
 			}
 		}
-		ASSERT(i < ARRAYSIZE(chan_info_all));
+		ASSERT(i < ARRAY_SIZE(chan_info_all));
 
 		if (pi->hwtxpwr) {
 			*max_pwr = pi->hwtxpwr[i];
@@ -1734,14 +1749,14 @@ wlc_phy_txpower_sromlimit(wlc_phy_t * ppi, uint channel, uint8 * min_pwr,
 }
 
 void
-wlc_phy_txpower_sromlimit_max_get(wlc_phy_t * ppi, uint chan, uint8 * max_txpwr,
-				  uint8 * min_txpwr)
+wlc_phy_txpower_sromlimit_max_get(wlc_phy_t *ppi, uint chan, u8 *max_txpwr,
+				  u8 *min_txpwr)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
-	uint8 tx_pwr_max = 0;
-	uint8 tx_pwr_min = 255;
-	uint8 max_num_rate;
-	uint8 maxtxpwr, mintxpwr, rate, pactrl;
+	u8 tx_pwr_max = 0;
+	u8 tx_pwr_min = 255;
+	u8 max_num_rate;
+	u8 maxtxpwr, mintxpwr, rate, pactrl;
 
 	pactrl = 0;
 
@@ -1757,46 +1772,46 @@ wlc_phy_txpower_sromlimit_max_get(wlc_phy_t * ppi, uint chan, uint8 * max_txpwr,
 
 		maxtxpwr = (maxtxpwr > 6) ? (maxtxpwr - 6) : 0;
 
-		tx_pwr_max = MAX(tx_pwr_max, maxtxpwr);
-		tx_pwr_min = MIN(tx_pwr_min, maxtxpwr);
+		tx_pwr_max = max(tx_pwr_max, maxtxpwr);
+		tx_pwr_min = min(tx_pwr_min, maxtxpwr);
 	}
 	*max_txpwr = tx_pwr_max;
 	*min_txpwr = tx_pwr_min;
 }
 
 void
-wlc_phy_txpower_boardlimit_band(wlc_phy_t * ppi, uint bandunit, int32 * max_pwr,
-				int32 * min_pwr, uint32 * step_pwr)
+wlc_phy_txpower_boardlimit_band(wlc_phy_t *ppi, uint bandunit, s32 *max_pwr,
+				s32 *min_pwr, u32 *step_pwr)
 {
 	return;
 }
 
-uint8 wlc_phy_txpower_get_target_min(wlc_phy_t * ppi)
+u8 wlc_phy_txpower_get_target_min(wlc_phy_t *ppi)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	return pi->tx_power_min;
 }
 
-uint8 wlc_phy_txpower_get_target_max(wlc_phy_t * ppi)
+u8 wlc_phy_txpower_get_target_max(wlc_phy_t *ppi)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	return pi->tx_power_max;
 }
 
-void wlc_phy_txpower_recalc_target(phy_info_t * pi)
+void wlc_phy_txpower_recalc_target(phy_info_t *pi)
 {
-	uint8 maxtxpwr, mintxpwr, rate, pactrl;
+	u8 maxtxpwr, mintxpwr, rate, pactrl;
 	uint target_chan;
-	uint8 tx_pwr_target[TXP_NUM_RATES];
-	uint8 tx_pwr_max = 0;
-	uint8 tx_pwr_min = 255;
-	uint8 tx_pwr_max_rate_ind = 0;
-	uint8 max_num_rate;
-	uint8 start_rate = 0;
+	u8 tx_pwr_target[TXP_NUM_RATES];
+	u8 tx_pwr_max = 0;
+	u8 tx_pwr_min = 255;
+	u8 tx_pwr_max_rate_ind = 0;
+	u8 max_num_rate;
+	u8 start_rate = 0;
 	chanspec_t chspec;
-	uint32 band = CHSPEC2WLC_BAND(pi->radio_chanspec);
+	u32 band = CHSPEC2WLC_BAND(pi->radio_chanspec);
 	initfn_t txpwr_recalc_fn = NULL;
 
 	chspec = pi->radio_chanspec;
@@ -1809,7 +1824,7 @@ void wlc_phy_txpower_recalc_target(phy_info_t * pi)
 
 	pactrl = 0;
 	if (ISLCNPHY(pi)) {
-		uint32 offset_mcs, i;
+		u32 offset_mcs, i;
 
 		if (CHSPEC_IS40(pi->radio_chanspec)) {
 			offset_mcs = pi->mcs40_po;
@@ -1856,29 +1871,29 @@ void wlc_phy_txpower_recalc_target(phy_info_t * pi)
 			wlc_phy_txpower_sromlimit((wlc_phy_t *) pi, target_chan,
 						  &mintxpwr, &maxtxpwr, rate);
 
-			maxtxpwr = MIN(maxtxpwr, pi->txpwr_limit[rate]);
+			maxtxpwr = min(maxtxpwr, pi->txpwr_limit[rate]);
 
 			maxtxpwr =
 			    (maxtxpwr > pactrl) ? (maxtxpwr - pactrl) : 0;
 
 			maxtxpwr = (maxtxpwr > 6) ? (maxtxpwr - 6) : 0;
 
-			maxtxpwr = MIN(maxtxpwr, tx_pwr_target[rate]);
+			maxtxpwr = min(maxtxpwr, tx_pwr_target[rate]);
 
 			if (pi->txpwr_percent <= 100)
 				maxtxpwr = (maxtxpwr * pi->txpwr_percent) / 100;
 
-			tx_pwr_target[rate] = MAX(maxtxpwr, mintxpwr);
+			tx_pwr_target[rate] = max(maxtxpwr, mintxpwr);
 		}
 
 		tx_pwr_target[rate] =
-		    MIN(tx_pwr_target[rate], pi->txpwr_env_limit[rate]);
+		    min(tx_pwr_target[rate], pi->txpwr_env_limit[rate]);
 
 		if (tx_pwr_target[rate] > tx_pwr_max)
 			tx_pwr_max_rate_ind = rate;
 
-		tx_pwr_max = MAX(tx_pwr_max, tx_pwr_target[rate]);
-		tx_pwr_min = MIN(tx_pwr_min, tx_pwr_target[rate]);
+		tx_pwr_max = max(tx_pwr_max, tx_pwr_target[rate]);
+		tx_pwr_min = min(tx_pwr_min, tx_pwr_target[rate]);
 	}
 
 	bzero(pi->tx_power_offset, sizeof(pi->tx_power_offset));
@@ -1904,11 +1919,11 @@ void wlc_phy_txpower_recalc_target(phy_info_t * pi)
 }
 
 void
-wlc_phy_txpower_reg_limit_calc(phy_info_t * pi, struct txpwr_limits *txpwr,
+wlc_phy_txpower_reg_limit_calc(phy_info_t *pi, struct txpwr_limits *txpwr,
 			       chanspec_t chanspec)
 {
-	uint8 tmp_txpwr_limit[2 * WLC_NUM_RATES_OFDM];
-	uint8 *txpwr_ptr1 = NULL, *txpwr_ptr2 = NULL;
+	u8 tmp_txpwr_limit[2 * WLC_NUM_RATES_OFDM];
+	u8 *txpwr_ptr1 = NULL, *txpwr_ptr2 = NULL;
 	int rate_start_index = 0, rate1, rate2, k;
 
 	for (rate1 = WL_TX_POWER_CCK_FIRST, rate2 = 0;
@@ -1961,7 +1976,7 @@ wlc_phy_txpower_reg_limit_calc(phy_info_t * pi, struct txpwr_limits *txpwr,
 			for (rate1 = rate_start_index, rate2 = 0;
 			     rate2 < WLC_NUM_RATES_OFDM; rate1++, rate2++)
 				pi->txpwr_limit[rate1] =
-				    MIN(txpwr_ptr2[rate2],
+				    min(txpwr_ptr2[rate2],
 					tmp_txpwr_limit[rate2]);
 		}
 
@@ -2004,7 +2019,7 @@ wlc_phy_txpower_reg_limit_calc(phy_info_t * pi, struct txpwr_limits *txpwr,
 			     rate2 < WLC_NUM_RATES_MCS_1_STREAM;
 			     rate1++, rate2++)
 				pi->txpwr_limit[rate1] =
-				    MIN(txpwr_ptr2[rate2],
+				    min(txpwr_ptr2[rate2],
 					tmp_txpwr_limit[rate2]);
 		}
 
@@ -2049,31 +2064,31 @@ wlc_phy_txpower_reg_limit_calc(phy_info_t * pi, struct txpwr_limits *txpwr,
 		pi->txpwr_limit[WL_TX_POWER_MCS_32] = txpwr->mcs32;
 
 		pi->txpwr_limit[WL_TX_POWER_MCS40_CDD_FIRST] =
-		    MIN(pi->txpwr_limit[WL_TX_POWER_MCS40_CDD_FIRST],
+		    min(pi->txpwr_limit[WL_TX_POWER_MCS40_CDD_FIRST],
 			pi->txpwr_limit[WL_TX_POWER_MCS_32]);
 		pi->txpwr_limit[WL_TX_POWER_MCS_32] =
 		    pi->txpwr_limit[WL_TX_POWER_MCS40_CDD_FIRST];
 	}
 }
 
-void wlc_phy_txpwr_percent_set(wlc_phy_t * ppi, uint8 txpwr_percent)
+void wlc_phy_txpwr_percent_set(wlc_phy_t *ppi, u8 txpwr_percent)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	pi->txpwr_percent = txpwr_percent;
 }
 
-void wlc_phy_machwcap_set(wlc_phy_t * ppi, uint32 machwcap)
+void wlc_phy_machwcap_set(wlc_phy_t *ppi, u32 machwcap)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	pi->sh->machwcap = machwcap;
 }
 
-void wlc_phy_runbist_config(wlc_phy_t * ppi, bool start_end)
+void wlc_phy_runbist_config(wlc_phy_t *ppi, bool start_end)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
-	uint16 rxc;
+	u16 rxc;
 	rxc = 0;
 
 	if (start_end == ON) {
@@ -2101,7 +2116,7 @@ void wlc_phy_runbist_config(wlc_phy_t * ppi, bool start_end)
 }
 
 void
-wlc_phy_txpower_limit_set(wlc_phy_t * ppi, struct txpwr_limits *txpwr,
+wlc_phy_txpower_limit_set(wlc_phy_t *ppi, struct txpwr_limits *txpwr,
 			  chanspec_t chanspec)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
@@ -2126,21 +2141,21 @@ wlc_phy_txpower_limit_set(wlc_phy_t * ppi, struct txpwr_limits *txpwr,
 	wlapi_enable_mac(pi->sh->physhim);
 }
 
-void wlc_phy_ofdm_rateset_war(wlc_phy_t * pih, bool war)
+void wlc_phy_ofdm_rateset_war(wlc_phy_t *pih, bool war)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
 	pi->ofdm_rateset_war = war;
 }
 
-void wlc_phy_bf_preempt_enable(wlc_phy_t * pih, bool bf_preempt)
+void wlc_phy_bf_preempt_enable(wlc_phy_t *pih, bool bf_preempt)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
 	pi->bf_preempt_4306 = bf_preempt;
 }
 
-void wlc_phy_txpower_update_shm(phy_info_t * pi)
+void wlc_phy_txpower_update_shm(phy_info_t *pi)
 {
 	int j;
 	if (ISNPHY(pi)) {
@@ -2152,7 +2167,7 @@ void wlc_phy_txpower_update_shm(phy_info_t * pi)
 		return;
 
 	if (pi->hwpwrctrl) {
-		uint16 offset;
+		u16 offset;
 
 		wlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_MAX, 63);
 		wlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_N,
@@ -2165,7 +2180,7 @@ void wlc_phy_txpower_update_shm(phy_info_t * pi)
 				     pi->hwpwr_txcur);
 
 		for (j = TXP_FIRST_OFDM; j <= TXP_LAST_OFDM; j++) {
-			const uint8 ucode_ofdm_rates[] = {
+			const u8 ucode_ofdm_rates[] = {
 				0x0c, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6c
 			};
 			offset = wlapi_bmac_rate_shm_offset(pi->sh->physhim,
@@ -2184,15 +2199,15 @@ void wlc_phy_txpower_update_shm(phy_info_t * pi)
 
 		for (i = TXP_FIRST_OFDM; i <= TXP_LAST_OFDM; i++)
 			pi->tx_power_offset[i] =
-			    (uint8) ROUNDUP(pi->tx_power_offset[i], 8);
+			    (u8) roundup(pi->tx_power_offset[i], 8);
 		wlapi_bmac_write_shm(pi->sh->physhim, M_OFDM_OFFSET,
-				     (uint16) ((pi->
+				     (u16) ((pi->
 						tx_power_offset[TXP_FIRST_OFDM]
 						+ 7) >> 3));
 	}
 }
 
-bool wlc_phy_txpower_hw_ctrl_get(wlc_phy_t * ppi)
+bool wlc_phy_txpower_hw_ctrl_get(wlc_phy_t *ppi)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
@@ -2203,7 +2218,7 @@ bool wlc_phy_txpower_hw_ctrl_get(wlc_phy_t * ppi)
 	}
 }
 
-void wlc_phy_txpower_hw_ctrl_set(wlc_phy_t * ppi, bool hwpwrctrl)
+void wlc_phy_txpower_hw_ctrl_set(wlc_phy_t *ppi, bool hwpwrctrl)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	bool cur_hwpwrctrl = pi->hwpwrctrl;
@@ -2241,33 +2256,33 @@ void wlc_phy_txpower_hw_ctrl_set(wlc_phy_t * ppi, bool hwpwrctrl)
 	}
 }
 
-void wlc_phy_txpower_ipa_upd(phy_info_t * pi)
+void wlc_phy_txpower_ipa_upd(phy_info_t *pi)
 {
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		pi->ipa2g_on = (pi->srom_fem2g.extpagain == 2);
 		pi->ipa5g_on = (pi->srom_fem5g.extpagain == 2);
 	} else {
-		pi->ipa2g_on = FALSE;
-		pi->ipa5g_on = FALSE;
+		pi->ipa2g_on = false;
+		pi->ipa5g_on = false;
 	}
 }
 
-static uint32 wlc_phy_txpower_est_power_nphy(phy_info_t * pi);
+static u32 wlc_phy_txpower_est_power_nphy(phy_info_t *pi);
 
-static uint32 wlc_phy_txpower_est_power_nphy(phy_info_t * pi)
+static u32 wlc_phy_txpower_est_power_nphy(phy_info_t *pi)
 {
-	int16 tx0_status, tx1_status;
-	uint16 estPower1, estPower2;
-	uint8 pwr0, pwr1, adj_pwr0, adj_pwr1;
-	uint32 est_pwr;
+	s16 tx0_status, tx1_status;
+	u16 estPower1, estPower2;
+	u8 pwr0, pwr1, adj_pwr0, adj_pwr1;
+	u32 est_pwr;
 
 	estPower1 = read_phy_reg(pi, 0x118);
 	estPower2 = read_phy_reg(pi, 0x119);
 
 	if ((estPower1 & (0x1 << 8))
 	    == (0x1 << 8)) {
-		pwr0 = (uint8) (estPower1 & (0xff << 0))
+		pwr0 = (u8) (estPower1 & (0xff << 0))
 		    >> 0;
 	} else {
 		pwr0 = 0x80;
@@ -2275,7 +2290,7 @@ static uint32 wlc_phy_txpower_est_power_nphy(phy_info_t * pi)
 
 	if ((estPower2 & (0x1 << 8))
 	    == (0x1 << 8)) {
-		pwr1 = (uint8) (estPower2 & (0xff << 0))
+		pwr1 = (u8) (estPower2 & (0xff << 0))
 		    >> 0;
 	} else {
 		pwr1 = 0x80;
@@ -2286,30 +2301,30 @@ static uint32 wlc_phy_txpower_est_power_nphy(phy_info_t * pi)
 
 	if ((tx0_status & (0x1 << 15))
 	    == (0x1 << 15)) {
-		adj_pwr0 = (uint8) (tx0_status & (0xff << 0))
+		adj_pwr0 = (u8) (tx0_status & (0xff << 0))
 		    >> 0;
 	} else {
 		adj_pwr0 = 0x80;
 	}
 	if ((tx1_status & (0x1 << 15))
 	    == (0x1 << 15)) {
-		adj_pwr1 = (uint8) (tx1_status & (0xff << 0))
+		adj_pwr1 = (u8) (tx1_status & (0xff << 0))
 		    >> 0;
 	} else {
 		adj_pwr1 = 0x80;
 	}
 
 	est_pwr =
-	    (uint32) ((pwr0 << 24) | (pwr1 << 16) | (adj_pwr0 << 8) | adj_pwr1);
-	return (est_pwr);
+	    (u32) ((pwr0 << 24) | (pwr1 << 16) | (adj_pwr0 << 8) | adj_pwr1);
+	return est_pwr;
 }
 
 void
-wlc_phy_txpower_get_current(wlc_phy_t * ppi, tx_power_t * power, uint channel)
+wlc_phy_txpower_get_current(wlc_phy_t *ppi, tx_power_t *power, uint channel)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	uint rate, num_rates;
-	uint8 min_pwr, max_pwr;
+	u8 min_pwr, max_pwr;
 
 #if WL_TX_POWER_RATES != TXP_NUM_RATES
 #error "tx_power_t struct out of sync with this fn"
@@ -2338,12 +2353,12 @@ wlc_phy_txpower_get_current(wlc_phy_t * ppi, tx_power_t * power, uint channel)
 		power->user_limit[rate] = pi->tx_user_target[rate];
 		wlc_phy_txpower_sromlimit(ppi, channel, &min_pwr, &max_pwr,
 					  rate);
-		power->board_limit[rate] = (uint8) max_pwr;
+		power->board_limit[rate] = (u8) max_pwr;
 		power->target[rate] = pi->tx_power_target[rate];
 	}
 
 	if (ISNPHY(pi)) {
-		uint32 est_pout;
+		u32 est_pout;
 
 		wlapi_suspend_mac_and_wait(pi->sh->physhim);
 		wlc_phyreg_enter((wlc_phy_t *) pi);
@@ -2395,40 +2410,40 @@ wlc_phy_txpower_get_current(wlc_phy_t * ppi, tx_power_t * power, uint channel)
 				power->flags &=
 				    ~(WL_TX_POWER_F_HW | WL_TX_POWER_F_ENABLED);
 
-			wlc_lcnphy_get_tssi(pi, (int8 *) & power->est_Pout[0],
-					    (int8 *) & power->est_Pout_cck);
+			wlc_lcnphy_get_tssi(pi, (s8 *) &power->est_Pout[0],
+					    (s8 *) &power->est_Pout_cck);
 		}
 		wlc_phyreg_exit(ppi);
 	}
 }
 
-void wlc_phy_antsel_type_set(wlc_phy_t * ppi, uint8 antsel_type)
+void wlc_phy_antsel_type_set(wlc_phy_t *ppi, u8 antsel_type)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	pi->antsel_type = antsel_type;
 }
 
-bool wlc_phy_test_ison(wlc_phy_t * ppi)
+bool wlc_phy_test_ison(wlc_phy_t *ppi)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
-	return (pi->phytest_on);
+	return pi->phytest_on;
 }
 
-bool wlc_phy_ant_rxdiv_get(wlc_phy_t * ppi, uint8 * pval)
+bool wlc_phy_ant_rxdiv_get(wlc_phy_t *ppi, u8 *pval)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
-	bool ret = TRUE;
+	bool ret = true;
 
 	wlc_phyreg_enter(ppi);
 
 	if (ISNPHY(pi)) {
 
-		ret = FALSE;
+		ret = false;
 	} else if (ISLCNPHY(pi)) {
-		uint16 crsctrl = read_phy_reg(pi, 0x410);
-		uint16 div = crsctrl & (0x1 << 1);
+		u16 crsctrl = read_phy_reg(pi, 0x410);
+		u16 div = crsctrl & (0x1 << 1);
 		*pval = (div | ((crsctrl & (0x1 << 0)) ^ (div >> 1)));
 	}
 
@@ -2437,7 +2452,7 @@ bool wlc_phy_ant_rxdiv_get(wlc_phy_t * ppi, uint8 * pval)
 	return ret;
 }
 
-void wlc_phy_ant_rxdiv_set(wlc_phy_t * ppi, uint8 val)
+void wlc_phy_ant_rxdiv_set(wlc_phy_t *ppi, u8 val)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	bool suspend;
@@ -2474,7 +2489,7 @@ void wlc_phy_ant_rxdiv_set(wlc_phy_t * ppi, uint8 val)
 				    ((ANT_RX_DIV_START_1 == val) ? 1 : 0) << 0);
 		} else {
 			mod_phy_reg(pi, 0x410, (0x1 << 1), 0x00 << 1);
-			mod_phy_reg(pi, 0x410, (0x1 << 0), (uint16) val << 0);
+			mod_phy_reg(pi, 0x410, (0x1 << 0), (u16) val << 0);
 		}
 	} else {
 		ASSERT(0);
@@ -2487,21 +2502,21 @@ void wlc_phy_ant_rxdiv_set(wlc_phy_t * ppi, uint8 val)
 }
 
 static bool
-wlc_phy_noise_calc_phy(phy_info_t * pi, uint32 * cmplx_pwr, int8 * pwr_ant)
+wlc_phy_noise_calc_phy(phy_info_t *pi, u32 *cmplx_pwr, s8 *pwr_ant)
 {
-	int8 cmplx_pwr_dbm[PHY_CORE_MAX];
-	uint8 i;
+	s8 cmplx_pwr_dbm[PHY_CORE_MAX];
+	u8 i;
 
-	bzero((uint8 *) cmplx_pwr_dbm, sizeof(cmplx_pwr_dbm));
+	bzero((u8 *) cmplx_pwr_dbm, sizeof(cmplx_pwr_dbm));
 	ASSERT(pi->pubpi.phy_corenum <= PHY_CORE_MAX);
 	wlc_phy_compute_dB(cmplx_pwr, cmplx_pwr_dbm, pi->pubpi.phy_corenum);
 
 	for (i = 0; i < pi->pubpi.phy_corenum; i++) {
 		if (NREV_GE(pi->pubpi.phy_rev, 3))
-			cmplx_pwr_dbm[i] += (int8) PHY_NOISE_OFFSETFACT_4322;
+			cmplx_pwr_dbm[i] += (s8) PHY_NOISE_OFFSETFACT_4322;
 		else
 
-			cmplx_pwr_dbm[i] += (int8) (16 - (15) * 3 - 70);
+			cmplx_pwr_dbm[i] += (s8) (16 - (15) * 3 - 70);
 	}
 
 	for (i = 0; i < pi->pubpi.phy_corenum; i++) {
@@ -2510,16 +2525,16 @@ wlc_phy_noise_calc_phy(phy_info_t * pi, uint32 * cmplx_pwr, int8 * pwr_ant)
 	}
 	pi->nphy_noise_index =
 	    MODINC_POW2(pi->nphy_noise_index, PHY_NOISE_WINDOW_SZ);
-	return TRUE;
+	return true;
 }
 
 static void
-wlc_phy_noise_sample_request(wlc_phy_t * pih, uint8 reason, uint8 ch)
+wlc_phy_noise_sample_request(wlc_phy_t *pih, u8 reason, u8 ch)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
-	int8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
+	s8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
 	bool sampling_in_progress = (pi->phynoise_state != 0);
-	bool wait_for_intr = TRUE;
+	bool wait_for_intr = true;
 
 	if (NORADIO_ENAB(pi->pubpi)) {
 		return;
@@ -2563,7 +2578,7 @@ wlc_phy_noise_sample_request(wlc_phy_t * pih, uint8 reason, uint8 ch)
 			noise_dbm = PHY_NOISE_FIXED_VAL;
 		}
 
-		wait_for_intr = FALSE;
+		wait_for_intr = false;
 		goto done;
 	}
 
@@ -2581,10 +2596,10 @@ wlc_phy_noise_sample_request(wlc_phy_t * pih, uint8 reason, uint8 ch)
 		} else {
 			wlapi_suspend_mac_and_wait(pi->sh->physhim);
 			wlc_lcnphy_deaf_mode(pi, (bool) 0);
-			noise_dbm = (int8) wlc_lcnphy_rx_signal_power(pi, 20);
+			noise_dbm = (s8) wlc_lcnphy_rx_signal_power(pi, 20);
 			wlc_lcnphy_deaf_mode(pi, (bool) 1);
 			wlapi_enable_mac(pi->sh->physhim);
-			wait_for_intr = FALSE;
+			wait_for_intr = false;
 		}
 	} else if (ISNPHY(pi)) {
 		if (!pi->phynoise_polling
@@ -2599,16 +2614,16 @@ wlc_phy_noise_sample_request(wlc_phy_t * pih, uint8 reason, uint8 ch)
 			       MCMD_BG_NOISE);
 		} else {
 			phy_iq_est_t est[PHY_CORE_MAX];
-			uint32 cmplx_pwr[PHY_CORE_MAX];
-			int8 noise_dbm_ant[PHY_CORE_MAX];
-			uint16 log_num_samps, num_samps, classif_state = 0;
-			uint8 wait_time = 32;
-			uint8 wait_crs = 0;
-			uint8 i;
+			u32 cmplx_pwr[PHY_CORE_MAX];
+			s8 noise_dbm_ant[PHY_CORE_MAX];
+			u16 log_num_samps, num_samps, classif_state = 0;
+			u8 wait_time = 32;
+			u8 wait_crs = 0;
+			u8 i;
 
-			bzero((uint8 *) est, sizeof(est));
-			bzero((uint8 *) cmplx_pwr, sizeof(cmplx_pwr));
-			bzero((uint8 *) noise_dbm_ant, sizeof(noise_dbm_ant));
+			bzero((u8 *) est, sizeof(est));
+			bzero((u8 *) cmplx_pwr, sizeof(cmplx_pwr));
+			bzero((u8 *) noise_dbm_ant, sizeof(noise_dbm_ant));
 
 			log_num_samps = PHY_NOISE_SAMPLE_LOG_NUM_NPHY;
 			num_samps = 1 << log_num_samps;
@@ -2638,7 +2653,7 @@ wlc_phy_noise_sample_request(wlc_phy_t * pih, uint8 reason, uint8 ch)
 			pi->nphy_noise_index = MODINC_POW2(pi->nphy_noise_index,
 							   PHY_NOISE_WINDOW_SZ);
 
-			wait_for_intr = FALSE;
+			wait_for_intr = false;
 		}
 	}
 
@@ -2649,16 +2664,16 @@ wlc_phy_noise_sample_request(wlc_phy_t * pih, uint8 reason, uint8 ch)
 
 }
 
-void wlc_phy_noise_sample_request_external(wlc_phy_t * pih)
+void wlc_phy_noise_sample_request_external(wlc_phy_t *pih)
 {
-	uint8 channel;
+	u8 channel;
 
 	channel = CHSPEC_CHANNEL(wlc_phy_chanspec_get(pih));
 
 	wlc_phy_noise_sample_request(pih, PHY_NOISE_SAMPLE_EXTERNAL, channel);
 }
 
-static void wlc_phy_noise_cb(phy_info_t * pi, uint8 channel, int8 noise_dbm)
+static void wlc_phy_noise_cb(phy_info_t *pi, u8 channel, s8 noise_dbm)
 {
 	if (!pi->phynoise_state)
 		return;
@@ -2679,18 +2694,18 @@ static void wlc_phy_noise_cb(phy_info_t * pi, uint8 channel, int8 noise_dbm)
 
 }
 
-static int8 wlc_phy_noise_read_shmem(phy_info_t * pi)
+static s8 wlc_phy_noise_read_shmem(phy_info_t *pi)
 {
-	uint32 cmplx_pwr[PHY_CORE_MAX];
-	int8 noise_dbm_ant[PHY_CORE_MAX];
-	uint16 lo, hi;
-	uint32 cmplx_pwr_tot = 0;
-	int8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
-	uint8 idx, core;
+	u32 cmplx_pwr[PHY_CORE_MAX];
+	s8 noise_dbm_ant[PHY_CORE_MAX];
+	u16 lo, hi;
+	u32 cmplx_pwr_tot = 0;
+	s8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
+	u8 idx, core;
 
 	ASSERT(pi->pubpi.phy_corenum <= PHY_CORE_MAX);
-	bzero((uint8 *) cmplx_pwr, sizeof(cmplx_pwr));
-	bzero((uint8 *) noise_dbm_ant, sizeof(noise_dbm_ant));
+	bzero((u8 *) cmplx_pwr, sizeof(cmplx_pwr));
+	bzero((u8 *) noise_dbm_ant, sizeof(noise_dbm_ant));
 
 	for (idx = 0, core = 0; core < pi->pubpi.phy_corenum; idx += 2, core++) {
 		lo = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP(idx));
@@ -2721,18 +2736,18 @@ static int8 wlc_phy_noise_read_shmem(phy_info_t * pi)
 
 }
 
-void wlc_phy_noise_sample_intr(wlc_phy_t * pih)
+void wlc_phy_noise_sample_intr(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
-	uint16 jssi_aux;
-	uint8 channel = 0;
-	int8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
+	u16 jssi_aux;
+	u8 channel = 0;
+	s8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
 
 	if (ISLCNPHY(pi)) {
-		uint32 cmplx_pwr, cmplx_pwr0, cmplx_pwr1;
-		uint16 lo, hi;
-		int32 pwr_offset_dB, gain_dB;
-		uint16 status_0, status_1;
+		u32 cmplx_pwr, cmplx_pwr0, cmplx_pwr1;
+		u16 lo, hi;
+		s32 pwr_offset_dB, gain_dB;
+		u16 status_0, status_1;
 
 		jssi_aux = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_AUX);
 		channel = jssi_aux & D11_CURCHANNEL_MAX;
@@ -2757,10 +2772,10 @@ void wlc_phy_noise_sample_intr(wlc_phy_t * pih)
 			if (pwr_offset_dB > 127)
 				pwr_offset_dB -= 256;
 
-			noise_dbm += (int8) (pwr_offset_dB - 30);
+			noise_dbm += (s8) (pwr_offset_dB - 30);
 
 			gain_dB = (status_0 & 0x1ff);
-			noise_dbm -= (int8) (gain_dB);
+			noise_dbm -= (s8) (gain_dB);
 		} else {
 			noise_dbm = PHY_NOISE_FIXED_VAL_LCNPHY;
 		}
@@ -2778,7 +2793,7 @@ void wlc_phy_noise_sample_intr(wlc_phy_t * pih)
 
 }
 
-int8 lcnphy_gain_index_offset_for_pkt_rssi[] = {
+s8 lcnphy_gain_index_offset_for_pkt_rssi[] = {
 	8,
 	8,
 	8,
@@ -2819,10 +2834,10 @@ int8 lcnphy_gain_index_offset_for_pkt_rssi[] = {
 	0
 };
 
-void wlc_phy_compute_dB(uint32 * cmplx_pwr, int8 * p_cmplx_pwr_dB, uint8 core)
+void wlc_phy_compute_dB(u32 *cmplx_pwr, s8 *p_cmplx_pwr_dB, u8 core)
 {
-	uint8 shift_ct, lsb, msb, secondmsb, i;
-	uint32 tmp;
+	u8 shift_ct, lsb, msb, secondmsb, i;
+	u32 tmp;
 
 	for (i = 0; i < core; i++) {
 		tmp = cmplx_pwr[i];
@@ -2830,16 +2845,16 @@ void wlc_phy_compute_dB(uint32 * cmplx_pwr, int8 * p_cmplx_pwr_dB, uint8 core)
 		while (tmp != 0) {
 			tmp = tmp >> 1;
 			shift_ct++;
-			lsb = (uint8) (tmp & 1);
+			lsb = (u8) (tmp & 1);
 			if (lsb == 1)
 				msb = shift_ct;
 		}
-		secondmsb = (uint8) ((cmplx_pwr[i] >> (msb - 1)) & 1);
-		p_cmplx_pwr_dB[i] = (int8) (3 * msb + 2 * secondmsb);
+		secondmsb = (u8) ((cmplx_pwr[i] >> (msb - 1)) & 1);
+		p_cmplx_pwr_dB[i] = (s8) (3 * msb + 2 * secondmsb);
 	}
 }
 
-void BCMFASTPATH wlc_phy_rssi_compute(wlc_phy_t * pih, void *ctx)
+void BCMFASTPATH wlc_phy_rssi_compute(wlc_phy_t *pih, void *ctx)
 {
 	wlc_d11rxhdr_t *wlc_rxhdr = (wlc_d11rxhdr_t *) ctx;
 	d11rxhdr_t *rxh = &wlc_rxhdr->rxhdr;
@@ -2859,7 +2874,7 @@ void BCMFASTPATH wlc_phy_rssi_compute(wlc_phy_t * pih, void *ctx)
 	}
 
 	if (ISLCNPHY(pi)) {
-		uint8 gidx = (ltoh16(rxh->PhyRxStatus_2) & 0xFC00) >> 10;
+		u8 gidx = (ltoh16(rxh->PhyRxStatus_2) & 0xFC00) >> 10;
 		phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 		if (rssi > 127)
@@ -2888,37 +2903,37 @@ void BCMFASTPATH wlc_phy_rssi_compute(wlc_phy_t * pih, void *ctx)
 	}
 
  end:
-	wlc_rxhdr->rssi = (int8) rssi;
+	wlc_rxhdr->rssi = (s8) rssi;
 }
 
-void wlc_phy_freqtrack_start(wlc_phy_t * pih)
+void wlc_phy_freqtrack_start(wlc_phy_t *pih)
 {
 	return;
 }
 
-void wlc_phy_freqtrack_end(wlc_phy_t * pih)
+void wlc_phy_freqtrack_end(wlc_phy_t *pih)
 {
 	return;
 }
 
-void wlc_phy_set_deaf(wlc_phy_t * ppi, bool user_flag)
+void wlc_phy_set_deaf(wlc_phy_t *ppi, bool user_flag)
 {
 	phy_info_t *pi;
 	pi = (phy_info_t *) ppi;
 
 	if (ISLCNPHY(pi))
-		wlc_lcnphy_deaf_mode(pi, TRUE);
+		wlc_lcnphy_deaf_mode(pi, true);
 	else if (ISNPHY(pi))
-		wlc_nphy_deaf_mode(pi, TRUE);
+		wlc_nphy_deaf_mode(pi, true);
 	else {
 		ASSERT(0);
 	}
 }
 
-void wlc_phy_watchdog(wlc_phy_t * pih)
+void wlc_phy_watchdog(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
-	bool delay_phy_cal = FALSE;
+	bool delay_phy_cal = false;
 	pi->sh->now++;
 
 	if (!pi->watchdog_override)
@@ -2973,21 +2988,21 @@ void wlc_phy_watchdog(wlc_phy_t * pih)
 			    (SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi)
 			     || ASSOC_INPROG_PHY(pi)
 			     || pi->carrier_suppr_disable
-			     || pi->pkteng_in_progress || pi->disable_percal))
+			     || pi->disable_percal))
 				wlc_lcnphy_calib_modes(pi,
 						       PHY_PERICAL_WATCHDOG);
 		}
 	}
 }
 
-void wlc_phy_BSSinit(wlc_phy_t * pih, bool bonlyap, int rssi)
+void wlc_phy_BSSinit(wlc_phy_t *pih, bool bonlyap, int rssi)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	uint i;
 	uint k;
 
 	for (i = 0; i < MA_WINDOW_SZ; i++) {
-		pi->sh->phy_noise_window[i] = (int8) (rssi & 0xff);
+		pi->sh->phy_noise_window[i] = (s8) (rssi & 0xff);
 	}
 	if (ISLCNPHY(pi)) {
 		for (i = 0; i < MA_WINDOW_SZ; i++)
@@ -3004,11 +3019,14 @@ void wlc_phy_BSSinit(wlc_phy_t * pih, bool bonlyap, int rssi)
 }
 
 void
-wlc_phy_papd_decode_epsilon(uint32 epsilon, int32 * eps_real, int32 * eps_imag)
+wlc_phy_papd_decode_epsilon(u32 epsilon, s32 *eps_real, s32 *eps_imag)
 {
-	if ((*eps_imag = (epsilon >> 13)) > 0xfff)
+	*eps_imag = (epsilon >> 13);
+	if (*eps_imag > 0xfff)
 		*eps_imag -= 0x2000;
-	if ((*eps_real = (epsilon & 0x1fff)) > 0xfff)
+
+	*eps_real = (epsilon & 0x1fff);
+	if (*eps_real > 0xfff)
 		*eps_real -= 0x2000;
 }
 
@@ -3033,7 +3051,7 @@ static const fixed AtanTbl[] = {
 	29
 };
 
-void wlc_phy_cordic(fixed theta, cint32 * val)
+void wlc_phy_cordic(fixed theta, cs32 *val)
 {
 	fixed angle, valtmp;
 	unsigned iter;
@@ -3075,7 +3093,7 @@ void wlc_phy_cordic(fixed theta, cint32 * val)
 	val[0].q = val[0].q * signx;
 }
 
-void wlc_phy_cal_perical_mphase_reset(phy_info_t * pi)
+void wlc_phy_cal_perical_mphase_reset(phy_info_t *pi)
 {
 	wlapi_del_timer(pi->sh->physhim, pi->phycal_timer);
 
@@ -3084,7 +3102,7 @@ void wlc_phy_cal_perical_mphase_reset(phy_info_t * pi)
 	pi->mphase_txcal_cmdidx = 0;
 }
 
-static void wlc_phy_cal_perical_mphase_schedule(phy_info_t * pi, uint delay)
+static void wlc_phy_cal_perical_mphase_schedule(phy_info_t *pi, uint delay)
 {
 
 	if ((pi->nphy_perical != PHY_PERICAL_MPHASE) &&
@@ -3097,11 +3115,11 @@ static void wlc_phy_cal_perical_mphase_schedule(phy_info_t * pi, uint delay)
 	wlapi_add_timer(pi->sh->physhim, pi->phycal_timer, delay, 0);
 }
 
-void wlc_phy_cal_perical(wlc_phy_t * pih, uint8 reason)
+void wlc_phy_cal_perical(wlc_phy_t *pih, u8 reason)
 {
-	int16 nphy_currtemp = 0;
-	int16 delta_temp = 0;
-	bool do_periodic_cal = TRUE;
+	s16 nphy_currtemp = 0;
+	s16 delta_temp = 0;
+	bool do_periodic_cal = true;
 	phy_info_t *pi = (phy_info_t *) pih;
 
 	if (!ISNPHY(pi))
@@ -3133,7 +3151,7 @@ void wlc_phy_cal_perical(wlc_phy_t * pih, uint8 reason)
 			wlc_phy_cal_perical_mphase_reset(pi);
 		}
 
-		pi->first_cal_after_assoc = TRUE;
+		pi->first_cal_after_assoc = true;
 
 		pi->cal_type_override = PHY_PERICAL_FULL;
 
@@ -3151,10 +3169,10 @@ void wlc_phy_cal_perical(wlc_phy_t * pih, uint8 reason)
 			    nphy_currtemp - pi->nphy_lastcal_temp :
 			    pi->nphy_lastcal_temp - nphy_currtemp;
 
-			if ((delta_temp < (int16) pi->phycal_tempdelta) &&
+			if ((delta_temp < (s16) pi->phycal_tempdelta) &&
 			    (pi->nphy_txiqlocal_chanspec ==
 			     pi->radio_chanspec)) {
-				do_periodic_cal = FALSE;
+				do_periodic_cal = false;
 			} else {
 				pi->nphy_lastcal_temp = nphy_currtemp;
 			}
@@ -3181,16 +3199,16 @@ void wlc_phy_cal_perical(wlc_phy_t * pih, uint8 reason)
 	}
 }
 
-void wlc_phy_cal_perical_mphase_restart(phy_info_t * pi)
+void wlc_phy_cal_perical_mphase_restart(phy_info_t *pi)
 {
 	pi->mphase_cal_phase_id = MPHASE_CAL_STATE_INIT;
 	pi->mphase_txcal_cmdidx = 0;
 }
 
-uint8 wlc_phy_nbits(int32 value)
+u8 wlc_phy_nbits(s32 value)
 {
-	int32 abs_val;
-	uint8 nbits = 0;
+	s32 abs_val;
+	u8 nbits = 0;
 
 	abs_val = ABS(value);
 	while ((abs_val >> nbits) > 0)
@@ -3199,9 +3217,9 @@ uint8 wlc_phy_nbits(int32 value)
 	return nbits;
 }
 
-uint32 wlc_phy_sqrt_int(uint32 value)
+u32 wlc_phy_sqrt_int(u32 value)
 {
-	uint32 root = 0, shift = 0;
+	u32 root = 0, shift = 0;
 
 	for (shift = 0; shift < 32; shift += 2) {
 		if (((0x40000000 >> shift) + root) <= value) {
@@ -3218,7 +3236,7 @@ uint32 wlc_phy_sqrt_int(uint32 value)
 	return root;
 }
 
-void wlc_phy_stf_chain_init(wlc_phy_t * pih, uint8 txchain, uint8 rxchain)
+void wlc_phy_stf_chain_init(wlc_phy_t *pih, u8 txchain, u8 rxchain)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -3226,10 +3244,10 @@ void wlc_phy_stf_chain_init(wlc_phy_t * pih, uint8 txchain, uint8 rxchain)
 	pi->sh->hw_phyrxchain = rxchain;
 	pi->sh->phytxchain = txchain;
 	pi->sh->phyrxchain = rxchain;
-	pi->pubpi.phy_corenum = (uint8) PHY_BITSCNT(pi->sh->phyrxchain);
+	pi->pubpi.phy_corenum = (u8) PHY_BITSCNT(pi->sh->phyrxchain);
 }
 
-void wlc_phy_stf_chain_set(wlc_phy_t * pih, uint8 txchain, uint8 rxchain)
+void wlc_phy_stf_chain_set(wlc_phy_t *pih, u8 txchain, u8 rxchain)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -3238,10 +3256,10 @@ void wlc_phy_stf_chain_set(wlc_phy_t * pih, uint8 txchain, uint8 rxchain)
 	if (ISNPHY(pi)) {
 		wlc_phy_rxcore_setstate_nphy(pih, rxchain);
 	}
-	pi->pubpi.phy_corenum = (uint8) PHY_BITSCNT(pi->sh->phyrxchain);
+	pi->pubpi.phy_corenum = (u8) PHY_BITSCNT(pi->sh->phyrxchain);
 }
 
-void wlc_phy_stf_chain_get(wlc_phy_t * pih, uint8 * txchain, uint8 * rxchain)
+void wlc_phy_stf_chain_get(wlc_phy_t *pih, u8 *txchain, u8 *rxchain)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -3249,10 +3267,10 @@ void wlc_phy_stf_chain_get(wlc_phy_t * pih, uint8 * txchain, uint8 * rxchain)
 	*rxchain = pi->sh->phyrxchain;
 }
 
-uint8 wlc_phy_stf_chain_active_get(wlc_phy_t * pih)
+u8 wlc_phy_stf_chain_active_get(wlc_phy_t *pih)
 {
-	int16 nphy_currtemp;
-	uint8 active_bitmap;
+	s16 nphy_currtemp;
+	u8 active_bitmap;
 	phy_info_t *pi = (phy_info_t *) pih;
 
 	active_bitmap = (pi->phy_txcore_heatedup) ? 0x31 : 0x33;
@@ -3268,12 +3286,12 @@ uint8 wlc_phy_stf_chain_active_get(wlc_phy_t * pih)
 		if (!pi->phy_txcore_heatedup) {
 			if (nphy_currtemp >= pi->phy_txcore_disable_temp) {
 				active_bitmap &= 0xFD;
-				pi->phy_txcore_heatedup = TRUE;
+				pi->phy_txcore_heatedup = true;
 			}
 		} else {
 			if (nphy_currtemp <= pi->phy_txcore_enable_temp) {
 				active_bitmap |= 0x2;
-				pi->phy_txcore_heatedup = FALSE;
+				pi->phy_txcore_heatedup = false;
 			}
 		}
 	}
@@ -3281,10 +3299,10 @@ uint8 wlc_phy_stf_chain_active_get(wlc_phy_t * pih)
 	return active_bitmap;
 }
 
-int8 wlc_phy_stf_ssmode_get(wlc_phy_t * pih, chanspec_t chanspec)
+s8 wlc_phy_stf_ssmode_get(wlc_phy_t *pih, chanspec_t chanspec)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
-	uint8 siso_mcs_id, cdd_mcs_id;
+	u8 siso_mcs_id, cdd_mcs_id;
 
 	siso_mcs_id =
 	    (CHSPEC_IS40(chanspec)) ? TXP_FIRST_MCS_40_SISO :
@@ -3300,17 +3318,17 @@ int8 wlc_phy_stf_ssmode_get(wlc_phy_t * pih, chanspec_t chanspec)
 		return PHY_TXC1_MODE_CDD;
 }
 
-const uint8 *wlc_phy_get_ofdm_rate_lookup(void)
+const u8 *wlc_phy_get_ofdm_rate_lookup(void)
 {
 	return ofdm_rate_lookup;
 }
 
-void wlc_lcnphy_epa_switch(phy_info_t * pi, bool mode)
+void wlc_lcnphy_epa_switch(phy_info_t *pi, bool mode)
 {
 	if ((CHIPID(pi->sh->chip) == BCM4313_CHIP_ID) &&
 	    (pi->sh->boardflags & BFL_FEM)) {
 		if (mode) {
-			uint16 txant = 0;
+			u16 txant = 0;
 			txant = wlapi_bmac_get_txant(pi->sh->physhim);
 			if (txant == 1) {
 				mod_phy_reg(pi, 0x44d, (0x1 << 2), (1) << 2);
@@ -3319,12 +3337,12 @@ void wlc_lcnphy_epa_switch(phy_info_t * pi, bool mode)
 
 			}
 			si_corereg(pi->sh->sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, gpiocontrol), ~0x0,
+				   offsetof(chipcregs_t, gpiocontrol), ~0x0,
 				   0x0);
 			si_corereg(pi->sh->sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, gpioout), 0x40, 0x40);
+				   offsetof(chipcregs_t, gpioout), 0x40, 0x40);
 			si_corereg(pi->sh->sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, gpioouten), 0x40,
+				   offsetof(chipcregs_t, gpioouten), 0x40,
 				   0x40);
 		} else {
 			mod_phy_reg(pi, 0x44c, (0x1 << 2), (0) << 2);
@@ -3332,28 +3350,28 @@ void wlc_lcnphy_epa_switch(phy_info_t * pi, bool mode)
 			mod_phy_reg(pi, 0x44d, (0x1 << 2), (0) << 2);
 
 			si_corereg(pi->sh->sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, gpioout), 0x40, 0x00);
+				   offsetof(chipcregs_t, gpioout), 0x40, 0x00);
 			si_corereg(pi->sh->sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, gpioouten), 0x40, 0x0);
+				   offsetof(chipcregs_t, gpioouten), 0x40, 0x0);
 			si_corereg(pi->sh->sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, gpiocontrol), ~0x0,
+				   offsetof(chipcregs_t, gpiocontrol), ~0x0,
 				   0x40);
 		}
 	}
 }
 
-static int8
-wlc_user_txpwr_antport_to_rfport(phy_info_t * pi, uint chan, uint32 band,
-				 uint8 rate)
+static s8
+wlc_user_txpwr_antport_to_rfport(phy_info_t *pi, uint chan, u32 band,
+				 u8 rate)
 {
-	int8 offset = 0;
+	s8 offset = 0;
 
 	if (!pi->user_txpwr_at_rfport)
 		return offset;
 	return offset;
 }
 
-static int8 wlc_phy_env_measure_vbat(phy_info_t * pi)
+static s8 wlc_phy_env_measure_vbat(phy_info_t *pi)
 {
 	if (ISLCNPHY(pi))
 		return wlc_lcnphy_vbatsense(pi, 0);
@@ -3361,7 +3379,7 @@ static int8 wlc_phy_env_measure_vbat(phy_info_t * pi)
 		return 0;
 }
 
-static int8 wlc_phy_env_measure_temperature(phy_info_t * pi)
+static s8 wlc_phy_env_measure_temperature(phy_info_t *pi)
 {
 	if (ISLCNPHY(pi))
 		return wlc_lcnphy_tempsense_degree(pi, 0);
@@ -3369,10 +3387,10 @@ static int8 wlc_phy_env_measure_temperature(phy_info_t * pi)
 		return 0;
 }
 
-static void wlc_phy_upd_env_txpwr_rate_limits(phy_info_t * pi, uint32 band)
+static void wlc_phy_upd_env_txpwr_rate_limits(phy_info_t *pi, u32 band)
 {
-	uint8 i;
-	int8 temp, vbat;
+	u8 i;
+	s8 temp, vbat;
 
 	for (i = 0; i < TXP_NUM_RATES; i++)
 		pi->txpwr_env_limit[i] = WLC_TXPWR_MAX;
@@ -3382,21 +3400,21 @@ static void wlc_phy_upd_env_txpwr_rate_limits(phy_info_t * pi, uint32 band)
 
 }
 
-void wlc_phy_ldpc_override_set(wlc_phy_t * ppi, bool ldpc)
+void wlc_phy_ldpc_override_set(wlc_phy_t *ppi, bool ldpc)
 {
 	return;
 }
 
 void
-wlc_phy_get_pwrdet_offsets(phy_info_t * pi, int8 * cckoffset, int8 * ofdmoffset)
+wlc_phy_get_pwrdet_offsets(phy_info_t *pi, s8 *cckoffset, s8 *ofdmoffset)
 {
 	*cckoffset = 0;
 	*ofdmoffset = 0;
 }
 
-uint32 wlc_phy_qdiv_roundup(uint32 dividend, uint32 divisor, uint8 precision)
+u32 wlc_phy_qdiv_roundup(u32 dividend, u32 divisor, u8 precision)
 {
-	uint32 quotient, remainder, roundup, rbit;
+	u32 quotient, remainder, roundup, rbit;
 
 	ASSERT(divisor);
 
@@ -3421,18 +3439,18 @@ uint32 wlc_phy_qdiv_roundup(uint32 dividend, uint32 divisor, uint8 precision)
 	return quotient;
 }
 
-int8 wlc_phy_upd_rssi_offset(phy_info_t * pi, int8 rssi, chanspec_t chanspec)
+s8 wlc_phy_upd_rssi_offset(phy_info_t *pi, s8 rssi, chanspec_t chanspec)
 {
 
 	return rssi;
 }
 
-bool wlc_phy_txpower_ipa_ison(wlc_phy_t * ppi)
+bool wlc_phy_txpower_ipa_ison(wlc_phy_t *ppi)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	if (ISNPHY(pi))
-		return (wlc_phy_n_txpower_ipa_ison(pi));
+		return wlc_phy_n_txpower_ipa_ison(pi);
 	else
 		return 0;
 }
diff --git a/drivers/staging/brcm80211/phy/wlc_phy_hal.h b/drivers/staging/brcm80211/phy/wlc_phy_hal.h
index 18e0f55..52260b2 100644
--- a/drivers/staging/brcm80211/phy/wlc_phy_hal.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_hal.h
@@ -17,7 +17,6 @@
 #ifndef _wlc_phy_h_
 #define _wlc_phy_h_
 
-#include <typedefs.h>
 #include <wlioctl.h>
 #include <siutils.h>
 #include <d11.h>
@@ -51,8 +50,8 @@
 #define BCM2064_IDCODE		0x02064000
 #define BCM2064A0_IDCODE	0x0206417f
 
-#define PHY_TPC_HW_OFF		FALSE
-#define PHY_TPC_HW_ON		TRUE
+#define PHY_TPC_HW_OFF		false
+#define PHY_TPC_HW_ON		true
 
 #define PHY_PERICAL_DRIVERUP	1
 #define PHY_PERICAL_WATCHDOG	2
@@ -94,28 +93,28 @@
 #define WLC_NUM_RATES_MCS_3_STREAM  8
 #define WLC_NUM_RATES_MCS_4_STREAM  8
 typedef struct txpwr_limits {
-	uint8 cck[WLC_NUM_RATES_CCK];
-	uint8 ofdm[WLC_NUM_RATES_OFDM];
+	u8 cck[WLC_NUM_RATES_CCK];
+	u8 ofdm[WLC_NUM_RATES_OFDM];
 
-	uint8 ofdm_cdd[WLC_NUM_RATES_OFDM];
+	u8 ofdm_cdd[WLC_NUM_RATES_OFDM];
 
-	uint8 ofdm_40_siso[WLC_NUM_RATES_OFDM];
-	uint8 ofdm_40_cdd[WLC_NUM_RATES_OFDM];
+	u8 ofdm_40_siso[WLC_NUM_RATES_OFDM];
+	u8 ofdm_40_cdd[WLC_NUM_RATES_OFDM];
 
-	uint8 mcs_20_siso[WLC_NUM_RATES_MCS_1_STREAM];
-	uint8 mcs_20_cdd[WLC_NUM_RATES_MCS_1_STREAM];
-	uint8 mcs_20_stbc[WLC_NUM_RATES_MCS_1_STREAM];
-	uint8 mcs_20_mimo[WLC_NUM_RATES_MCS_2_STREAM];
+	u8 mcs_20_siso[WLC_NUM_RATES_MCS_1_STREAM];
+	u8 mcs_20_cdd[WLC_NUM_RATES_MCS_1_STREAM];
+	u8 mcs_20_stbc[WLC_NUM_RATES_MCS_1_STREAM];
+	u8 mcs_20_mimo[WLC_NUM_RATES_MCS_2_STREAM];
 
-	uint8 mcs_40_siso[WLC_NUM_RATES_MCS_1_STREAM];
-	uint8 mcs_40_cdd[WLC_NUM_RATES_MCS_1_STREAM];
-	uint8 mcs_40_stbc[WLC_NUM_RATES_MCS_1_STREAM];
-	uint8 mcs_40_mimo[WLC_NUM_RATES_MCS_2_STREAM];
-	uint8 mcs32;
+	u8 mcs_40_siso[WLC_NUM_RATES_MCS_1_STREAM];
+	u8 mcs_40_cdd[WLC_NUM_RATES_MCS_1_STREAM];
+	u8 mcs_40_stbc[WLC_NUM_RATES_MCS_1_STREAM];
+	u8 mcs_40_mimo[WLC_NUM_RATES_MCS_2_STREAM];
+	u8 mcs32;
 } txpwr_limits_t;
 
 typedef struct {
-	uint8 vec[MAXCHANNEL / NBBY];
+	u8 vec[MAXCHANNEL / NBBY];
 } chanvec_t;
 
 struct rpc_info;
@@ -138,8 +137,8 @@ typedef struct shared_phy_params {
 	uint bustype;
 	uint buscorerev;
 	char *vars;
-	uint16 vid;
-	uint16 did;
+	u16 vid;
+	u16 did;
 	uint chip;
 	uint chiprev;
 	uint chippkg;
@@ -147,117 +146,117 @@ typedef struct shared_phy_params {
 	uint boardtype;
 	uint boardrev;
 	uint boardvendor;
-	uint32 boardflags;
-	uint32 boardflags2;
+	u32 boardflags;
+	u32 boardflags2;
 } shared_phy_params_t;
 
 #ifdef WLC_LOW
 
-extern shared_phy_t *wlc_phy_shared_attach(shared_phy_params_t * shp);
-extern void wlc_phy_shared_detach(shared_phy_t * phy_sh);
-extern wlc_phy_t *wlc_phy_attach(shared_phy_t * sh, void *regs, int bandtype,
+extern shared_phy_t *wlc_phy_shared_attach(shared_phy_params_t *shp);
+extern void wlc_phy_shared_detach(shared_phy_t *phy_sh);
+extern wlc_phy_t *wlc_phy_attach(shared_phy_t *sh, void *regs, int bandtype,
 				 char *vars);
-extern void wlc_phy_detach(wlc_phy_t * ppi);
-
-extern bool wlc_phy_get_phyversion(wlc_phy_t * pih, uint16 * phytype,
-				   uint16 * phyrev, uint16 * radioid,
-				   uint16 * radiover);
-extern bool wlc_phy_get_encore(wlc_phy_t * pih);
-extern uint32 wlc_phy_get_coreflags(wlc_phy_t * pih);
-
-extern void wlc_phy_hw_clk_state_upd(wlc_phy_t * ppi, bool newstate);
-extern void wlc_phy_hw_state_upd(wlc_phy_t * ppi, bool newstate);
-extern void wlc_phy_init(wlc_phy_t * ppi, chanspec_t chanspec);
-extern void wlc_phy_watchdog(wlc_phy_t * ppi);
-extern int wlc_phy_down(wlc_phy_t * ppi);
-extern uint32 wlc_phy_clk_bwbits(wlc_phy_t * pih);
-extern void wlc_phy_cal_init(wlc_phy_t * ppi);
-extern void wlc_phy_antsel_init(wlc_phy_t * ppi, bool lut_init);
-
-extern void wlc_phy_chanspec_set(wlc_phy_t * ppi, chanspec_t chanspec);
-extern chanspec_t wlc_phy_chanspec_get(wlc_phy_t * ppi);
-extern void wlc_phy_chanspec_radio_set(wlc_phy_t * ppi, chanspec_t newch);
-extern uint16 wlc_phy_bw_state_get(wlc_phy_t * ppi);
-extern void wlc_phy_bw_state_set(wlc_phy_t * ppi, uint16 bw);
-
-extern void wlc_phy_rssi_compute(wlc_phy_t * pih, void *ctx);
-extern void wlc_phy_por_inform(wlc_phy_t * ppi);
-extern void wlc_phy_noise_sample_intr(wlc_phy_t * ppi);
-extern bool wlc_phy_bist_check_phy(wlc_phy_t * ppi);
-
-extern void wlc_phy_set_deaf(wlc_phy_t * ppi, bool user_flag);
-
-extern void wlc_phy_switch_radio(wlc_phy_t * ppi, bool on);
-extern void wlc_phy_anacore(wlc_phy_t * ppi, bool on);
+extern void wlc_phy_detach(wlc_phy_t *ppi);
+
+extern bool wlc_phy_get_phyversion(wlc_phy_t *pih, u16 *phytype,
+				   u16 *phyrev, u16 *radioid,
+				   u16 *radiover);
+extern bool wlc_phy_get_encore(wlc_phy_t *pih);
+extern u32 wlc_phy_get_coreflags(wlc_phy_t *pih);
+
+extern void wlc_phy_hw_clk_state_upd(wlc_phy_t *ppi, bool newstate);
+extern void wlc_phy_hw_state_upd(wlc_phy_t *ppi, bool newstate);
+extern void wlc_phy_init(wlc_phy_t *ppi, chanspec_t chanspec);
+extern void wlc_phy_watchdog(wlc_phy_t *ppi);
+extern int wlc_phy_down(wlc_phy_t *ppi);
+extern u32 wlc_phy_clk_bwbits(wlc_phy_t *pih);
+extern void wlc_phy_cal_init(wlc_phy_t *ppi);
+extern void wlc_phy_antsel_init(wlc_phy_t *ppi, bool lut_init);
+
+extern void wlc_phy_chanspec_set(wlc_phy_t *ppi, chanspec_t chanspec);
+extern chanspec_t wlc_phy_chanspec_get(wlc_phy_t *ppi);
+extern void wlc_phy_chanspec_radio_set(wlc_phy_t *ppi, chanspec_t newch);
+extern u16 wlc_phy_bw_state_get(wlc_phy_t *ppi);
+extern void wlc_phy_bw_state_set(wlc_phy_t *ppi, u16 bw);
+
+extern void wlc_phy_rssi_compute(wlc_phy_t *pih, void *ctx);
+extern void wlc_phy_por_inform(wlc_phy_t *ppi);
+extern void wlc_phy_noise_sample_intr(wlc_phy_t *ppi);
+extern bool wlc_phy_bist_check_phy(wlc_phy_t *ppi);
+
+extern void wlc_phy_set_deaf(wlc_phy_t *ppi, bool user_flag);
+
+extern void wlc_phy_switch_radio(wlc_phy_t *ppi, bool on);
+extern void wlc_phy_anacore(wlc_phy_t *ppi, bool on);
 
 #endif				/* WLC_LOW */
 
-extern void wlc_phy_BSSinit(wlc_phy_t * ppi, bool bonlyap, int rssi);
+extern void wlc_phy_BSSinit(wlc_phy_t *ppi, bool bonlyap, int rssi);
 
-extern void wlc_phy_chanspec_ch14_widefilter_set(wlc_phy_t * ppi,
+extern void wlc_phy_chanspec_ch14_widefilter_set(wlc_phy_t *ppi,
 						 bool wide_filter);
-extern void wlc_phy_chanspec_band_validch(wlc_phy_t * ppi, uint band,
-					  chanvec_t * channels);
-extern chanspec_t wlc_phy_chanspec_band_firstch(wlc_phy_t * ppi, uint band);
-
-extern void wlc_phy_txpower_sromlimit(wlc_phy_t * ppi, uint chan,
-				      uint8 * _min_, uint8 * _max_, int rate);
-extern void wlc_phy_txpower_sromlimit_max_get(wlc_phy_t * ppi, uint chan,
-					      uint8 * _max_, uint8 * _min_);
-extern void wlc_phy_txpower_boardlimit_band(wlc_phy_t * ppi, uint band, int32 *,
-					    int32 *, uint32 *);
-extern void wlc_phy_txpower_limit_set(wlc_phy_t * ppi, struct txpwr_limits *,
+extern void wlc_phy_chanspec_band_validch(wlc_phy_t *ppi, uint band,
+					  chanvec_t *channels);
+extern chanspec_t wlc_phy_chanspec_band_firstch(wlc_phy_t *ppi, uint band);
+
+extern void wlc_phy_txpower_sromlimit(wlc_phy_t *ppi, uint chan,
+				      u8 *_min_, u8 *_max_, int rate);
+extern void wlc_phy_txpower_sromlimit_max_get(wlc_phy_t *ppi, uint chan,
+					      u8 *_max_, u8 *_min_);
+extern void wlc_phy_txpower_boardlimit_band(wlc_phy_t *ppi, uint band, s32 *,
+					    s32 *, u32 *);
+extern void wlc_phy_txpower_limit_set(wlc_phy_t *ppi, struct txpwr_limits *,
 				      chanspec_t chanspec);
-extern int wlc_phy_txpower_get(wlc_phy_t * ppi, uint * qdbm, bool * override);
-extern int wlc_phy_txpower_set(wlc_phy_t * ppi, uint qdbm, bool override);
-extern void wlc_phy_txpower_target_set(wlc_phy_t * ppi, struct txpwr_limits *);
-extern bool wlc_phy_txpower_hw_ctrl_get(wlc_phy_t * ppi);
-extern void wlc_phy_txpower_hw_ctrl_set(wlc_phy_t * ppi, bool hwpwrctrl);
-extern uint8 wlc_phy_txpower_get_target_min(wlc_phy_t * ppi);
-extern uint8 wlc_phy_txpower_get_target_max(wlc_phy_t * ppi);
-extern bool wlc_phy_txpower_ipa_ison(wlc_phy_t * pih);
-
-extern void wlc_phy_stf_chain_init(wlc_phy_t * pih, uint8 txchain,
-				   uint8 rxchain);
-extern void wlc_phy_stf_chain_set(wlc_phy_t * pih, uint8 txchain,
-				  uint8 rxchain);
-extern void wlc_phy_stf_chain_get(wlc_phy_t * pih, uint8 * txchain,
-				  uint8 * rxchain);
-extern uint8 wlc_phy_stf_chain_active_get(wlc_phy_t * pih);
-extern int8 wlc_phy_stf_ssmode_get(wlc_phy_t * pih, chanspec_t chanspec);
-extern void wlc_phy_ldpc_override_set(wlc_phy_t * ppi, bool val);
-
-extern void wlc_phy_cal_perical(wlc_phy_t * ppi, uint8 reason);
-extern void wlc_phy_noise_sample_request_external(wlc_phy_t * ppi);
-extern void wlc_phy_edcrs_lock(wlc_phy_t * pih, bool lock);
-extern void wlc_phy_cal_papd_recal(wlc_phy_t * ppi);
-
-extern void wlc_phy_ant_rxdiv_set(wlc_phy_t * ppi, uint8 val);
-extern bool wlc_phy_ant_rxdiv_get(wlc_phy_t * ppi, uint8 * pval);
-extern void wlc_phy_clear_tssi(wlc_phy_t * ppi);
-extern void wlc_phy_hold_upd(wlc_phy_t * ppi, mbool id, bool val);
-extern void wlc_phy_mute_upd(wlc_phy_t * ppi, bool val, mbool flags);
-
-extern void wlc_phy_antsel_type_set(wlc_phy_t * ppi, uint8 antsel_type);
-
-extern void wlc_phy_txpower_get_current(wlc_phy_t * ppi, tx_power_t * power,
+extern int wlc_phy_txpower_get(wlc_phy_t *ppi, uint *qdbm, bool *override);
+extern int wlc_phy_txpower_set(wlc_phy_t *ppi, uint qdbm, bool override);
+extern void wlc_phy_txpower_target_set(wlc_phy_t *ppi, struct txpwr_limits *);
+extern bool wlc_phy_txpower_hw_ctrl_get(wlc_phy_t *ppi);
+extern void wlc_phy_txpower_hw_ctrl_set(wlc_phy_t *ppi, bool hwpwrctrl);
+extern u8 wlc_phy_txpower_get_target_min(wlc_phy_t *ppi);
+extern u8 wlc_phy_txpower_get_target_max(wlc_phy_t *ppi);
+extern bool wlc_phy_txpower_ipa_ison(wlc_phy_t *pih);
+
+extern void wlc_phy_stf_chain_init(wlc_phy_t *pih, u8 txchain,
+				   u8 rxchain);
+extern void wlc_phy_stf_chain_set(wlc_phy_t *pih, u8 txchain,
+				  u8 rxchain);
+extern void wlc_phy_stf_chain_get(wlc_phy_t *pih, u8 *txchain,
+				  u8 *rxchain);
+extern u8 wlc_phy_stf_chain_active_get(wlc_phy_t *pih);
+extern s8 wlc_phy_stf_ssmode_get(wlc_phy_t *pih, chanspec_t chanspec);
+extern void wlc_phy_ldpc_override_set(wlc_phy_t *ppi, bool val);
+
+extern void wlc_phy_cal_perical(wlc_phy_t *ppi, u8 reason);
+extern void wlc_phy_noise_sample_request_external(wlc_phy_t *ppi);
+extern void wlc_phy_edcrs_lock(wlc_phy_t *pih, bool lock);
+extern void wlc_phy_cal_papd_recal(wlc_phy_t *ppi);
+
+extern void wlc_phy_ant_rxdiv_set(wlc_phy_t *ppi, u8 val);
+extern bool wlc_phy_ant_rxdiv_get(wlc_phy_t *ppi, u8 *pval);
+extern void wlc_phy_clear_tssi(wlc_phy_t *ppi);
+extern void wlc_phy_hold_upd(wlc_phy_t *ppi, mbool id, bool val);
+extern void wlc_phy_mute_upd(wlc_phy_t *ppi, bool val, mbool flags);
+
+extern void wlc_phy_antsel_type_set(wlc_phy_t *ppi, u8 antsel_type);
+
+extern void wlc_phy_txpower_get_current(wlc_phy_t *ppi, tx_power_t *power,
 					uint channel);
 
-extern void wlc_phy_initcal_enable(wlc_phy_t * pih, bool initcal);
-extern bool wlc_phy_test_ison(wlc_phy_t * ppi);
-extern void wlc_phy_txpwr_percent_set(wlc_phy_t * ppi, uint8 txpwr_percent);
-extern void wlc_phy_ofdm_rateset_war(wlc_phy_t * pih, bool war);
-extern void wlc_phy_bf_preempt_enable(wlc_phy_t * pih, bool bf_preempt);
-extern void wlc_phy_machwcap_set(wlc_phy_t * ppi, uint32 machwcap);
+extern void wlc_phy_initcal_enable(wlc_phy_t *pih, bool initcal);
+extern bool wlc_phy_test_ison(wlc_phy_t *ppi);
+extern void wlc_phy_txpwr_percent_set(wlc_phy_t *ppi, u8 txpwr_percent);
+extern void wlc_phy_ofdm_rateset_war(wlc_phy_t *pih, bool war);
+extern void wlc_phy_bf_preempt_enable(wlc_phy_t *pih, bool bf_preempt);
+extern void wlc_phy_machwcap_set(wlc_phy_t *ppi, u32 machwcap);
 
-extern void wlc_phy_runbist_config(wlc_phy_t * ppi, bool start_end);
+extern void wlc_phy_runbist_config(wlc_phy_t *ppi, bool start_end);
 
-extern void wlc_phy_freqtrack_start(wlc_phy_t * ppi);
-extern void wlc_phy_freqtrack_end(wlc_phy_t * ppi);
+extern void wlc_phy_freqtrack_start(wlc_phy_t *ppi);
+extern void wlc_phy_freqtrack_end(wlc_phy_t *ppi);
 
-extern const uint8 *wlc_phy_get_ofdm_rate_lookup(void);
+extern const u8 *wlc_phy_get_ofdm_rate_lookup(void);
 
-extern int8 wlc_phy_get_tx_power_offset_by_mcs(wlc_phy_t * ppi,
-					       uint8 mcs_offset);
-extern int8 wlc_phy_get_tx_power_offset(wlc_phy_t * ppi, uint8 tbl_offset);
+extern s8 wlc_phy_get_tx_power_offset_by_mcs(wlc_phy_t *ppi,
+					       u8 mcs_offset);
+extern s8 wlc_phy_get_tx_power_offset(wlc_phy_t *ppi, u8 tbl_offset);
 #endif				/* _wlc_phy_h_ */
diff --git a/drivers/staging/brcm80211/phy/wlc_phy_int.h b/drivers/staging/brcm80211/phy/wlc_phy_int.h
index 54c61d6..9513b87 100644
--- a/drivers/staging/brcm80211/phy/wlc_phy_int.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_int.h
@@ -17,7 +17,8 @@
 #ifndef _wlc_phy_int_h_
 #define _wlc_phy_int_h_
 
-#include <typedefs.h>
+#include <linux/kernel.h>
+#include <bcmdefs.h>
 #include <bcmutils.h>
 
 #include <bcmsrom_fmt.h>
@@ -27,7 +28,7 @@
 #define PHYHAL_TRACE	0x0002
 #define PHYHAL_INFORM	0x0004
 
-extern uint32 phyhal_msg_level;
+extern u32 phyhal_msg_level;
 
 #define PHY_INFORM_ON()		(phyhal_msg_level & PHYHAL_INFORM)
 #define PHY_THERMAL_ON()	(phyhal_msg_level & PHYHAL_THERMAL)
@@ -46,12 +47,12 @@ typedef struct phy_info phy_info_t;
 typedef void (*initfn_t) (phy_info_t *);
 typedef void (*chansetfn_t) (phy_info_t *, chanspec_t);
 typedef int (*longtrnfn_t) (phy_info_t *, int);
-typedef void (*txiqccgetfn_t) (phy_info_t *, uint16 *, uint16 *);
-typedef void (*txiqccsetfn_t) (phy_info_t *, uint16, uint16);
-typedef uint16(*txloccgetfn_t) (phy_info_t *);
-typedef void (*radioloftgetfn_t) (phy_info_t *, uint8 *, uint8 *, uint8 *,
-				  uint8 *);
-typedef int32(*rxsigpwrfn_t) (phy_info_t *, int32);
+typedef void (*txiqccgetfn_t) (phy_info_t *, u16 *, u16 *);
+typedef void (*txiqccsetfn_t) (phy_info_t *, u16, u16);
+typedef u16(*txloccgetfn_t) (phy_info_t *);
+typedef void (*radioloftgetfn_t) (phy_info_t *, u8 *, u8 *, u8 *,
+				  u8 *);
+typedef s32(*rxsigpwrfn_t) (phy_info_t *, s32);
 typedef void (*detachfn_t) (phy_info_t *);
 
 #undef ISNPHY
@@ -226,7 +227,7 @@ typedef enum {
 
 #define RDR_NTIERS  1
 #define RDR_TIER_SIZE 64
-#define RDR_LIST_SIZE 512/3
+#define RDR_LIST_SIZE (512/3)
 #define RDR_EPOCH_SIZE 40
 #define RDR_NANTENNAS 2
 #define RDR_NTIER_SIZE  RDR_LIST_SIZE
@@ -241,13 +242,13 @@ typedef enum {
 
 #define CORDIC_AG	39797
 #define	CORDIC_NI	18
-#define	FIXED(X)	((int32)((X) << 16))
+#define	FIXED(X)	((s32)((X) << 16))
 #define	FLOAT(X)	(((X) >= 0) ? ((((X) >> 15) + 1) >> 1) : -((((-(X)) >> 15) + 1) >> 1))
 
 #define PHY_CHAIN_TX_DISABLE_TEMP	115
 #define PHY_HYSTERESIS_DELTATEMP	5
 
-#define PHY_BITSCNT(x)	bcm_bitcount((uint8 *)&(x), sizeof(uint8))
+#define PHY_BITSCNT(x)	bcm_bitcount((u8 *)&(x), sizeof(u8))
 
 #define MOD_PHY_REG(pi, phy_type, reg_name, field, value) \
 	mod_phy_reg(pi, phy_type##_##reg_name, phy_type##_##reg_name##_##field##_MASK, \
@@ -264,8 +265,8 @@ typedef enum {
 #define VALID_LCN_RADIO(radioid)	(radioid == BCM2064_ID)
 
 #define	VALID_RADIO(pi, radioid)	(\
-	(ISNPHY(pi) ? VALID_N_RADIO(radioid) : FALSE) || \
-	(ISLCNPHY(pi) ? VALID_LCN_RADIO(radioid) : FALSE))
+	(ISNPHY(pi) ? VALID_N_RADIO(radioid) : false) || \
+	(ISLCNPHY(pi) ? VALID_LCN_RADIO(radioid) : false))
 
 #define SCAN_INPROG_PHY(pi)	(mboolisset(pi->measure_hold, PHY_HOLD_FOR_SCAN))
 #define RM_INPROG_PHY(pi)	(mboolisset(pi->measure_hold, PHY_HOLD_FOR_RM))
@@ -282,7 +283,7 @@ typedef enum {
 #endif
 
 #define PHY_LTRN_LIST_LEN	64
-extern uint16 ltrn_list[PHY_LTRN_LIST_LEN];
+extern u16 ltrn_list[PHY_LTRN_LIST_LEN];
 
 typedef struct _phy_table_info {
 	uint table;
@@ -292,192 +293,192 @@ typedef struct _phy_table_info {
 
 typedef struct phytbl_info {
 	const void *tbl_ptr;
-	uint32 tbl_len;
-	uint32 tbl_id;
-	uint32 tbl_offset;
-	uint32 tbl_width;
+	u32 tbl_len;
+	u32 tbl_id;
+	u32 tbl_offset;
+	u32 tbl_width;
 } phytbl_info_t;
 
 typedef struct {
-	uint8 curr_home_channel;
-	uint16 crsminpwrthld_40_stored;
-	uint16 crsminpwrthld_20L_stored;
-	uint16 crsminpwrthld_20U_stored;
-	uint16 init_gain_code_core1_stored;
-	uint16 init_gain_code_core2_stored;
-	uint16 init_gain_codeb_core1_stored;
-	uint16 init_gain_codeb_core2_stored;
-	uint16 init_gain_table_stored[4];
-
-	uint16 clip1_hi_gain_code_core1_stored;
-	uint16 clip1_hi_gain_code_core2_stored;
-	uint16 clip1_hi_gain_codeb_core1_stored;
-	uint16 clip1_hi_gain_codeb_core2_stored;
-	uint16 nb_clip_thresh_core1_stored;
-	uint16 nb_clip_thresh_core2_stored;
-	uint16 init_ofdmlna2gainchange_stored[4];
-	uint16 init_ccklna2gainchange_stored[4];
-	uint16 clip1_lo_gain_code_core1_stored;
-	uint16 clip1_lo_gain_code_core2_stored;
-	uint16 clip1_lo_gain_codeb_core1_stored;
-	uint16 clip1_lo_gain_codeb_core2_stored;
-	uint16 w1_clip_thresh_core1_stored;
-	uint16 w1_clip_thresh_core2_stored;
-	uint16 radio_2056_core1_rssi_gain_stored;
-	uint16 radio_2056_core2_rssi_gain_stored;
-	uint16 energy_drop_timeout_len_stored;
-
-	uint16 ed_crs40_assertthld0_stored;
-	uint16 ed_crs40_assertthld1_stored;
-	uint16 ed_crs40_deassertthld0_stored;
-	uint16 ed_crs40_deassertthld1_stored;
-	uint16 ed_crs20L_assertthld0_stored;
-	uint16 ed_crs20L_assertthld1_stored;
-	uint16 ed_crs20L_deassertthld0_stored;
-	uint16 ed_crs20L_deassertthld1_stored;
-	uint16 ed_crs20U_assertthld0_stored;
-	uint16 ed_crs20U_assertthld1_stored;
-	uint16 ed_crs20U_deassertthld0_stored;
-	uint16 ed_crs20U_deassertthld1_stored;
-
-	uint16 badplcp_ma;
-	uint16 badplcp_ma_previous;
-	uint16 badplcp_ma_total;
-	uint16 badplcp_ma_list[MA_WINDOW_SZ];
+	u8 curr_home_channel;
+	u16 crsminpwrthld_40_stored;
+	u16 crsminpwrthld_20L_stored;
+	u16 crsminpwrthld_20U_stored;
+	u16 init_gain_code_core1_stored;
+	u16 init_gain_code_core2_stored;
+	u16 init_gain_codeb_core1_stored;
+	u16 init_gain_codeb_core2_stored;
+	u16 init_gain_table_stored[4];
+
+	u16 clip1_hi_gain_code_core1_stored;
+	u16 clip1_hi_gain_code_core2_stored;
+	u16 clip1_hi_gain_codeb_core1_stored;
+	u16 clip1_hi_gain_codeb_core2_stored;
+	u16 nb_clip_thresh_core1_stored;
+	u16 nb_clip_thresh_core2_stored;
+	u16 init_ofdmlna2gainchange_stored[4];
+	u16 init_ccklna2gainchange_stored[4];
+	u16 clip1_lo_gain_code_core1_stored;
+	u16 clip1_lo_gain_code_core2_stored;
+	u16 clip1_lo_gain_codeb_core1_stored;
+	u16 clip1_lo_gain_codeb_core2_stored;
+	u16 w1_clip_thresh_core1_stored;
+	u16 w1_clip_thresh_core2_stored;
+	u16 radio_2056_core1_rssi_gain_stored;
+	u16 radio_2056_core2_rssi_gain_stored;
+	u16 energy_drop_timeout_len_stored;
+
+	u16 ed_crs40_assertthld0_stored;
+	u16 ed_crs40_assertthld1_stored;
+	u16 ed_crs40_deassertthld0_stored;
+	u16 ed_crs40_deassertthld1_stored;
+	u16 ed_crs20L_assertthld0_stored;
+	u16 ed_crs20L_assertthld1_stored;
+	u16 ed_crs20L_deassertthld0_stored;
+	u16 ed_crs20L_deassertthld1_stored;
+	u16 ed_crs20U_assertthld0_stored;
+	u16 ed_crs20U_assertthld1_stored;
+	u16 ed_crs20U_deassertthld0_stored;
+	u16 ed_crs20U_deassertthld1_stored;
+
+	u16 badplcp_ma;
+	u16 badplcp_ma_previous;
+	u16 badplcp_ma_total;
+	u16 badplcp_ma_list[MA_WINDOW_SZ];
 	int badplcp_ma_index;
-	int16 pre_badplcp_cnt;
-	int16 bphy_pre_badplcp_cnt;
-
-	uint16 init_gain_core1;
-	uint16 init_gain_core2;
-	uint16 init_gainb_core1;
-	uint16 init_gainb_core2;
-	uint16 init_gain_rfseq[4];
-
-	uint16 crsminpwr0;
-	uint16 crsminpwrl0;
-	uint16 crsminpwru0;
-
-	int16 crsminpwr_index;
-
-	uint16 radio_2057_core1_rssi_wb1a_gc_stored;
-	uint16 radio_2057_core2_rssi_wb1a_gc_stored;
-	uint16 radio_2057_core1_rssi_wb1g_gc_stored;
-	uint16 radio_2057_core2_rssi_wb1g_gc_stored;
-	uint16 radio_2057_core1_rssi_wb2_gc_stored;
-	uint16 radio_2057_core2_rssi_wb2_gc_stored;
-	uint16 radio_2057_core1_rssi_nb_gc_stored;
-	uint16 radio_2057_core2_rssi_nb_gc_stored;
+	s16 pre_badplcp_cnt;
+	s16 bphy_pre_badplcp_cnt;
+
+	u16 init_gain_core1;
+	u16 init_gain_core2;
+	u16 init_gainb_core1;
+	u16 init_gainb_core2;
+	u16 init_gain_rfseq[4];
+
+	u16 crsminpwr0;
+	u16 crsminpwrl0;
+	u16 crsminpwru0;
+
+	s16 crsminpwr_index;
+
+	u16 radio_2057_core1_rssi_wb1a_gc_stored;
+	u16 radio_2057_core2_rssi_wb1a_gc_stored;
+	u16 radio_2057_core1_rssi_wb1g_gc_stored;
+	u16 radio_2057_core2_rssi_wb1g_gc_stored;
+	u16 radio_2057_core1_rssi_wb2_gc_stored;
+	u16 radio_2057_core2_rssi_wb2_gc_stored;
+	u16 radio_2057_core1_rssi_nb_gc_stored;
+	u16 radio_2057_core2_rssi_nb_gc_stored;
 
 } interference_info_t;
 
 typedef struct {
-	uint16 rc_cal_ovr;
-	uint16 phycrsth1;
-	uint16 phycrsth2;
-	uint16 init_n1p1_gain;
-	uint16 p1_p2_gain;
-	uint16 n1_n2_gain;
-	uint16 n1_p1_gain;
-	uint16 div_search_gain;
-	uint16 div_p1_p2_gain;
-	uint16 div_search_gn_change;
-	uint16 table_7_2;
-	uint16 table_7_3;
-	uint16 cckshbits_gnref;
-	uint16 clip_thresh;
-	uint16 clip2_thresh;
-	uint16 clip3_thresh;
-	uint16 clip_p2_thresh;
-	uint16 clip_pwdn_thresh;
-	uint16 clip_n1p1_thresh;
-	uint16 clip_n1_pwdn_thresh;
-	uint16 bbconfig;
-	uint16 cthr_sthr_shdin;
-	uint16 energy;
-	uint16 clip_p1_p2_thresh;
-	uint16 threshold;
-	uint16 reg15;
-	uint16 reg16;
-	uint16 reg17;
-	uint16 div_srch_idx;
-	uint16 div_srch_p1_p2;
-	uint16 div_srch_gn_back;
-	uint16 ant_dwell;
-	uint16 ant_wr_settle;
+	u16 rc_cal_ovr;
+	u16 phycrsth1;
+	u16 phycrsth2;
+	u16 init_n1p1_gain;
+	u16 p1_p2_gain;
+	u16 n1_n2_gain;
+	u16 n1_p1_gain;
+	u16 div_search_gain;
+	u16 div_p1_p2_gain;
+	u16 div_search_gn_change;
+	u16 table_7_2;
+	u16 table_7_3;
+	u16 cckshbits_gnref;
+	u16 clip_thresh;
+	u16 clip2_thresh;
+	u16 clip3_thresh;
+	u16 clip_p2_thresh;
+	u16 clip_pwdn_thresh;
+	u16 clip_n1p1_thresh;
+	u16 clip_n1_pwdn_thresh;
+	u16 bbconfig;
+	u16 cthr_sthr_shdin;
+	u16 energy;
+	u16 clip_p1_p2_thresh;
+	u16 threshold;
+	u16 reg15;
+	u16 reg16;
+	u16 reg17;
+	u16 div_srch_idx;
+	u16 div_srch_p1_p2;
+	u16 div_srch_gn_back;
+	u16 ant_dwell;
+	u16 ant_wr_settle;
 } aci_save_gphy_t;
 
 typedef struct _lo_complex_t {
-	int8 i;
-	int8 q;
+	s8 i;
+	s8 q;
 } lo_complex_abgphy_info_t;
 
 typedef struct _nphy_iq_comp {
-	int16 a0;
-	int16 b0;
-	int16 a1;
-	int16 b1;
+	s16 a0;
+	s16 b0;
+	s16 a1;
+	s16 b1;
 } nphy_iq_comp_t;
 
 typedef struct _nphy_txpwrindex {
-	int8 index;
-	int8 index_internal;
-	int8 index_internal_save;
-	uint16 AfectrlOverride;
-	uint16 AfeCtrlDacGain;
-	uint16 rad_gain;
-	uint8 bbmult;
-	uint16 iqcomp_a;
-	uint16 iqcomp_b;
-	uint16 locomp;
+	s8 index;
+	s8 index_internal;
+	s8 index_internal_save;
+	u16 AfectrlOverride;
+	u16 AfeCtrlDacGain;
+	u16 rad_gain;
+	u8 bbmult;
+	u16 iqcomp_a;
+	u16 iqcomp_b;
+	u16 locomp;
 } phy_txpwrindex_t;
 
 typedef struct {
 
-	uint16 txcal_coeffs_2G[8];
-	uint16 txcal_radio_regs_2G[8];
+	u16 txcal_coeffs_2G[8];
+	u16 txcal_radio_regs_2G[8];
 	nphy_iq_comp_t rxcal_coeffs_2G;
 
-	uint16 txcal_coeffs_5G[8];
-	uint16 txcal_radio_regs_5G[8];
+	u16 txcal_coeffs_5G[8];
+	u16 txcal_radio_regs_5G[8];
 	nphy_iq_comp_t rxcal_coeffs_5G;
 } txiqcal_cache_t;
 
 typedef struct _nphy_pwrctrl {
-	int8 max_pwr_2g;
-	int8 idle_targ_2g;
-	int16 pwrdet_2g_a1;
-	int16 pwrdet_2g_b0;
-	int16 pwrdet_2g_b1;
-	int8 max_pwr_5gm;
-	int8 idle_targ_5gm;
-	int8 max_pwr_5gh;
-	int8 max_pwr_5gl;
-	int16 pwrdet_5gm_a1;
-	int16 pwrdet_5gm_b0;
-	int16 pwrdet_5gm_b1;
-	int16 pwrdet_5gl_a1;
-	int16 pwrdet_5gl_b0;
-	int16 pwrdet_5gl_b1;
-	int16 pwrdet_5gh_a1;
-	int16 pwrdet_5gh_b0;
-	int16 pwrdet_5gh_b1;
-	int8 idle_targ_5gl;
-	int8 idle_targ_5gh;
-	int8 idle_tssi_2g;
-	int8 idle_tssi_5g;
-	int8 idle_tssi;
-	int16 a1;
-	int16 b0;
-	int16 b1;
+	s8 max_pwr_2g;
+	s8 idle_targ_2g;
+	s16 pwrdet_2g_a1;
+	s16 pwrdet_2g_b0;
+	s16 pwrdet_2g_b1;
+	s8 max_pwr_5gm;
+	s8 idle_targ_5gm;
+	s8 max_pwr_5gh;
+	s8 max_pwr_5gl;
+	s16 pwrdet_5gm_a1;
+	s16 pwrdet_5gm_b0;
+	s16 pwrdet_5gm_b1;
+	s16 pwrdet_5gl_a1;
+	s16 pwrdet_5gl_b0;
+	s16 pwrdet_5gl_b1;
+	s16 pwrdet_5gh_a1;
+	s16 pwrdet_5gh_b0;
+	s16 pwrdet_5gh_b1;
+	s8 idle_targ_5gl;
+	s8 idle_targ_5gh;
+	s8 idle_tssi_2g;
+	s8 idle_tssi_5g;
+	s8 idle_tssi;
+	s16 a1;
+	s16 b0;
+	s16 b1;
 } phy_pwrctrl_t;
 
 typedef struct _nphy_txgains {
-	uint16 txlpf[2];
-	uint16 txgm[2];
-	uint16 pga[2];
-	uint16 pad[2];
-	uint16 ipa[2];
+	u16 txlpf[2];
+	u16 txgm[2];
+	u16 pga[2];
+	u16 pad[2];
+	u16 ipa[2];
 } nphy_txgains_t;
 
 #define PHY_NOISEVAR_BUFSIZE 10
@@ -485,42 +486,42 @@ typedef struct _nphy_txgains {
 typedef struct _nphy_noisevar_buf {
 	int bufcount;
 	int tone_id[PHY_NOISEVAR_BUFSIZE];
-	uint32 noise_vars[PHY_NOISEVAR_BUFSIZE];
-	uint32 min_noise_vars[PHY_NOISEVAR_BUFSIZE];
+	u32 noise_vars[PHY_NOISEVAR_BUFSIZE];
+	u32 min_noise_vars[PHY_NOISEVAR_BUFSIZE];
 } phy_noisevar_buf_t;
 
 typedef struct {
-	uint16 rssical_radio_regs_2G[2];
-	uint16 rssical_phyregs_2G[12];
+	u16 rssical_radio_regs_2G[2];
+	u16 rssical_phyregs_2G[12];
 
-	uint16 rssical_radio_regs_5G[2];
-	uint16 rssical_phyregs_5G[12];
+	u16 rssical_radio_regs_5G[2];
+	u16 rssical_phyregs_5G[12];
 } rssical_cache_t;
 
 typedef struct {
 
-	uint16 txiqlocal_a;
-	uint16 txiqlocal_b;
-	uint16 txiqlocal_didq;
-	uint8 txiqlocal_ei0;
-	uint8 txiqlocal_eq0;
-	uint8 txiqlocal_fi0;
-	uint8 txiqlocal_fq0;
-
-	uint16 txiqlocal_bestcoeffs[11];
-	uint16 txiqlocal_bestcoeffs_valid;
-
-	uint32 papd_eps_tbl[PHY_PAPD_EPS_TBL_SIZE_LCNPHY];
-	uint16 analog_gain_ref;
-	uint16 lut_begin;
-	uint16 lut_end;
-	uint16 lut_step;
-	uint16 rxcompdbm;
-	uint16 papdctrl;
-	uint16 sslpnCalibClkEnCtrl;
-
-	uint16 rxiqcal_coeff_a0;
-	uint16 rxiqcal_coeff_b0;
+	u16 txiqlocal_a;
+	u16 txiqlocal_b;
+	u16 txiqlocal_didq;
+	u8 txiqlocal_ei0;
+	u8 txiqlocal_eq0;
+	u8 txiqlocal_fi0;
+	u8 txiqlocal_fq0;
+
+	u16 txiqlocal_bestcoeffs[11];
+	u16 txiqlocal_bestcoeffs_valid;
+
+	u32 papd_eps_tbl[PHY_PAPD_EPS_TBL_SIZE_LCNPHY];
+	u16 analog_gain_ref;
+	u16 lut_begin;
+	u16 lut_end;
+	u16 lut_step;
+	u16 rxcompdbm;
+	u16 papdctrl;
+	u16 sslpnCalibClkEnCtrl;
+
+	u16 rxiqcal_coeff_a0;
+	u16 rxiqcal_coeff_b0;
 } lcnphy_cal_results_t;
 
 struct shared_phy {
@@ -530,12 +531,12 @@ struct shared_phy {
 	si_t *sih;
 	void *physhim;
 	uint corerev;
-	uint32 machwcap;
+	u32 machwcap;
 	bool up;
 	bool clk;
 	uint now;
-	uint16 vid;
-	uint16 did;
+	u16 vid;
+	u16 did;
 	uint chip;
 	uint chiprev;
 	uint chippkg;
@@ -543,31 +544,31 @@ struct shared_phy {
 	uint boardtype;
 	uint boardrev;
 	uint boardvendor;
-	uint32 boardflags;
-	uint32 boardflags2;
+	u32 boardflags;
+	u32 boardflags2;
 	uint bustype;
 	uint buscorerev;
 	uint fast_timer;
 	uint slow_timer;
 	uint glacial_timer;
-	uint8 rx_antdiv;
-	int8 phy_noise_window[MA_WINDOW_SZ];
+	u8 rx_antdiv;
+	s8 phy_noise_window[MA_WINDOW_SZ];
 	uint phy_noise_index;
-	uint8 hw_phytxchain;
-	uint8 hw_phyrxchain;
-	uint8 phytxchain;
-	uint8 phyrxchain;
-	uint8 rssi_mode;
+	u8 hw_phytxchain;
+	u8 hw_phyrxchain;
+	u8 phytxchain;
+	u8 phyrxchain;
+	u8 rssi_mode;
 	bool _rifs_phy;
 };
 
 struct phy_pub {
 	uint phy_type;
 	uint phy_rev;
-	uint8 phy_corenum;
-	uint16 radioid;
-	uint8 radiorev;
-	uint8 radiover;
+	u8 phy_corenum;
+	u16 radioid;
+	u8 radiorev;
+	u8 radiover;
 
 	uint coreflags;
 	uint ana_rev;
@@ -617,9 +618,9 @@ struct phy_info {
 	bool ofdm_rateset_war;
 	bool bf_preempt_4306;
 	chanspec_t radio_chanspec;
-	uint8 antsel_type;
-	uint16 bw;
-	uint8 txpwr_percent;
+	u8 antsel_type;
+	u16 bw;
+	u8 txpwr_percent;
 	bool phy_init_por;
 
 	bool init_in_progress;
@@ -627,146 +628,146 @@ struct phy_info {
 	bool sbtml_gm;
 	uint refcnt;
 	bool watchdog_override;
-	uint8 phynoise_state;
+	u8 phynoise_state;
 	uint phynoise_now;
 	int phynoise_chan_watchdog;
 	bool phynoise_polling;
 	bool disable_percal;
 	mbool measure_hold;
 
-	int16 txpa_2g[PWRTBL_NUM_COEFF];
-	int16 txpa_2g_low_temp[PWRTBL_NUM_COEFF];
-	int16 txpa_2g_high_temp[PWRTBL_NUM_COEFF];
-	int16 txpa_5g_low[PWRTBL_NUM_COEFF];
-	int16 txpa_5g_mid[PWRTBL_NUM_COEFF];
-	int16 txpa_5g_hi[PWRTBL_NUM_COEFF];
-
-	uint8 tx_srom_max_2g;
-	uint8 tx_srom_max_5g_low;
-	uint8 tx_srom_max_5g_mid;
-	uint8 tx_srom_max_5g_hi;
-	uint8 tx_srom_max_rate_2g[TXP_NUM_RATES];
-	uint8 tx_srom_max_rate_5g_low[TXP_NUM_RATES];
-	uint8 tx_srom_max_rate_5g_mid[TXP_NUM_RATES];
-	uint8 tx_srom_max_rate_5g_hi[TXP_NUM_RATES];
-	uint8 tx_user_target[TXP_NUM_RATES];
-	int8 tx_power_offset[TXP_NUM_RATES];
-	uint8 tx_power_target[TXP_NUM_RATES];
+	s16 txpa_2g[PWRTBL_NUM_COEFF];
+	s16 txpa_2g_low_temp[PWRTBL_NUM_COEFF];
+	s16 txpa_2g_high_temp[PWRTBL_NUM_COEFF];
+	s16 txpa_5g_low[PWRTBL_NUM_COEFF];
+	s16 txpa_5g_mid[PWRTBL_NUM_COEFF];
+	s16 txpa_5g_hi[PWRTBL_NUM_COEFF];
+
+	u8 tx_srom_max_2g;
+	u8 tx_srom_max_5g_low;
+	u8 tx_srom_max_5g_mid;
+	u8 tx_srom_max_5g_hi;
+	u8 tx_srom_max_rate_2g[TXP_NUM_RATES];
+	u8 tx_srom_max_rate_5g_low[TXP_NUM_RATES];
+	u8 tx_srom_max_rate_5g_mid[TXP_NUM_RATES];
+	u8 tx_srom_max_rate_5g_hi[TXP_NUM_RATES];
+	u8 tx_user_target[TXP_NUM_RATES];
+	s8 tx_power_offset[TXP_NUM_RATES];
+	u8 tx_power_target[TXP_NUM_RATES];
 
 	srom_fem_t srom_fem2g;
 	srom_fem_t srom_fem5g;
 
-	uint8 tx_power_max;
-	uint8 tx_power_max_rate_ind;
+	u8 tx_power_max;
+	u8 tx_power_max_rate_ind;
 	bool hwpwrctrl;
-	uint8 nphy_txpwrctrl;
-	int8 nphy_txrx_chain;
+	u8 nphy_txpwrctrl;
+	s8 nphy_txrx_chain;
 	bool phy_5g_pwrgain;
 
-	uint16 phy_wreg;
-	uint16 phy_wreg_limit;
+	u16 phy_wreg;
+	u16 phy_wreg_limit;
 
-	int8 n_preamble_override;
-	uint8 antswitch;
-	uint8 aa2g, aa5g;
+	s8 n_preamble_override;
+	u8 antswitch;
+	u8 aa2g, aa5g;
 
-	int8 idle_tssi[CH_5G_GROUP];
-	int8 target_idle_tssi;
-	int8 txpwr_est_Pout;
-	uint8 tx_power_min;
-	uint8 txpwr_limit[TXP_NUM_RATES];
-	uint8 txpwr_env_limit[TXP_NUM_RATES];
-	uint8 adj_pwr_tbl_nphy[ADJ_PWR_TBL_LEN];
+	s8 idle_tssi[CH_5G_GROUP];
+	s8 target_idle_tssi;
+	s8 txpwr_est_Pout;
+	u8 tx_power_min;
+	u8 txpwr_limit[TXP_NUM_RATES];
+	u8 txpwr_env_limit[TXP_NUM_RATES];
+	u8 adj_pwr_tbl_nphy[ADJ_PWR_TBL_LEN];
 
 	bool channel_14_wide_filter;
 
 	bool txpwroverride;
 	bool txpwridx_override_aphy;
-	int16 radiopwr_override;
-	uint16 hwpwr_txcur;
-	uint8 saved_txpwr_idx;
+	s16 radiopwr_override;
+	u16 hwpwr_txcur;
+	u8 saved_txpwr_idx;
 
 	bool edcrs_threshold_lock;
 
-	uint32 tr_R_gain_val;
-	uint32 tr_T_gain_val;
+	u32 tr_R_gain_val;
+	u32 tr_T_gain_val;
 
-	int16 ofdm_analog_filt_bw_override;
-	int16 cck_analog_filt_bw_override;
-	int16 ofdm_rccal_override;
-	int16 cck_rccal_override;
-	uint16 extlna_type;
+	s16 ofdm_analog_filt_bw_override;
+	s16 cck_analog_filt_bw_override;
+	s16 ofdm_rccal_override;
+	s16 cck_rccal_override;
+	u16 extlna_type;
 
 	uint interference_mode_crs_time;
-	uint16 crsglitch_prev;
+	u16 crsglitch_prev;
 	bool interference_mode_crs;
 
-	uint32 phy_tx_tone_freq;
+	u32 phy_tx_tone_freq;
 	uint phy_lastcal;
 	bool phy_forcecal;
 	bool phy_fixed_noise;
-	uint32 xtalfreq;
-	uint8 pdiv;
-	int8 carrier_suppr_disable;
+	u32 xtalfreq;
+	u8 pdiv;
+	s8 carrier_suppr_disable;
 
 	bool phy_bphy_evm;
 	bool phy_bphy_rfcs;
-	int8 phy_scraminit;
-	uint8 phy_gpiosel;
+	s8 phy_scraminit;
+	u8 phy_gpiosel;
 
-	int16 phy_txcore_disable_temp;
-	int16 phy_txcore_enable_temp;
-	int8 phy_tempsense_offset;
+	s16 phy_txcore_disable_temp;
+	s16 phy_txcore_enable_temp;
+	s8 phy_tempsense_offset;
 	bool phy_txcore_heatedup;
 
-	uint16 radiopwr;
-	uint16 bb_atten;
-	uint16 txctl1;
+	u16 radiopwr;
+	u16 bb_atten;
+	u16 txctl1;
 
-	uint16 mintxbias;
-	uint16 mintxmag;
+	u16 mintxbias;
+	u16 mintxmag;
 	lo_complex_abgphy_info_t gphy_locomp_iq[STATIC_NUM_RF][STATIC_NUM_BB];
-	int8 stats_11b_txpower[STATIC_NUM_RF][STATIC_NUM_BB];
-	uint16 gain_table[TX_GAIN_TABLE_LENGTH];
+	s8 stats_11b_txpower[STATIC_NUM_RF][STATIC_NUM_BB];
+	u16 gain_table[TX_GAIN_TABLE_LENGTH];
 	bool loopback_gain;
-	int16 max_lpback_gain_hdB;
-	int16 trsw_rx_gain_hdB;
-	uint8 power_vec[8];
+	s16 max_lpback_gain_hdB;
+	s16 trsw_rx_gain_hdB;
+	u8 power_vec[8];
 
-	uint16 rc_cal;
+	u16 rc_cal;
 	int nrssi_table_delta;
 	int nrssi_slope_scale;
 	int nrssi_slope_offset;
 	int min_rssi;
 	int max_rssi;
 
-	int8 txpwridx;
-	uint8 min_txpower;
+	s8 txpwridx;
+	u8 min_txpower;
 
-	uint8 a_band_high_disable;
+	u8 a_band_high_disable;
 
-	uint16 tx_vos;
-	uint16 global_tx_bb_dc_bias_loft;
+	u16 tx_vos;
+	u16 global_tx_bb_dc_bias_loft;
 
 	int rf_max;
 	int bb_max;
 	int rf_list_size;
 	int bb_list_size;
-	uint16 *rf_attn_list;
-	uint16 *bb_attn_list;
-	uint16 padmix_mask;
-	uint16 padmix_reg;
-	uint16 *txmag_list;
+	u16 *rf_attn_list;
+	u16 *bb_attn_list;
+	u16 padmix_mask;
+	u16 padmix_reg;
+	u16 *txmag_list;
 	uint txmag_len;
 	bool txmag_enable;
 
-	int8 *a_tssi_to_dbm;
-	int8 *m_tssi_to_dbm;
-	int8 *l_tssi_to_dbm;
-	int8 *h_tssi_to_dbm;
-	uint8 *hwtxpwr;
+	s8 *a_tssi_to_dbm;
+	s8 *m_tssi_to_dbm;
+	s8 *l_tssi_to_dbm;
+	s8 *h_tssi_to_dbm;
+	u8 *hwtxpwr;
 
-	uint16 freqtrack_saved_regs[2];
+	u16 freqtrack_saved_regs[2];
 	int cur_interference_mode;
 	bool hwpwrctrl_capable;
 	bool temppwrctrl_capable;
@@ -776,73 +777,72 @@ struct phy_info {
 	uint phycal_mlo;
 	uint phycal_txpower;
 
-	bool pkteng_in_progress;
-	uint8 phy_aa2g;
+	u8 phy_aa2g;
 
 	bool nphy_tableloaded;
-	int8 nphy_rssisel;
-	uint32 nphy_bb_mult_save;
-	uint16 nphy_txiqlocal_bestc[11];
+	s8 nphy_rssisel;
+	u32 nphy_bb_mult_save;
+	u16 nphy_txiqlocal_bestc[11];
 	bool nphy_txiqlocal_coeffsvalid;
 	phy_txpwrindex_t nphy_txpwrindex[PHY_CORE_NUM_2];
 	phy_pwrctrl_t nphy_pwrctrl_info[PHY_CORE_NUM_2];
-	uint16 cck2gpo;
-	uint32 ofdm2gpo;
-	uint32 ofdm5gpo;
-	uint32 ofdm5glpo;
-	uint32 ofdm5ghpo;
-	uint8 bw402gpo;
-	uint8 bw405gpo;
-	uint8 bw405glpo;
-	uint8 bw405ghpo;
-	uint8 cdd2gpo;
-	uint8 cdd5gpo;
-	uint8 cdd5glpo;
-	uint8 cdd5ghpo;
-	uint8 stbc2gpo;
-	uint8 stbc5gpo;
-	uint8 stbc5glpo;
-	uint8 stbc5ghpo;
-	uint8 bwdup2gpo;
-	uint8 bwdup5gpo;
-	uint8 bwdup5glpo;
-	uint8 bwdup5ghpo;
-	uint16 mcs2gpo[8];
-	uint16 mcs5gpo[8];
-	uint16 mcs5glpo[8];
-	uint16 mcs5ghpo[8];
-	uint32 nphy_rxcalparams;
-
-	uint8 phy_spuravoid;
+	u16 cck2gpo;
+	u32 ofdm2gpo;
+	u32 ofdm5gpo;
+	u32 ofdm5glpo;
+	u32 ofdm5ghpo;
+	u8 bw402gpo;
+	u8 bw405gpo;
+	u8 bw405glpo;
+	u8 bw405ghpo;
+	u8 cdd2gpo;
+	u8 cdd5gpo;
+	u8 cdd5glpo;
+	u8 cdd5ghpo;
+	u8 stbc2gpo;
+	u8 stbc5gpo;
+	u8 stbc5glpo;
+	u8 stbc5ghpo;
+	u8 bwdup2gpo;
+	u8 bwdup5gpo;
+	u8 bwdup5glpo;
+	u8 bwdup5ghpo;
+	u16 mcs2gpo[8];
+	u16 mcs5gpo[8];
+	u16 mcs5glpo[8];
+	u16 mcs5ghpo[8];
+	u32 nphy_rxcalparams;
+
+	u8 phy_spuravoid;
 	bool phy_isspuravoid;
 
-	uint8 phy_pabias;
-	uint8 nphy_papd_skip;
-	uint8 nphy_tssi_slope;
+	u8 phy_pabias;
+	u8 nphy_papd_skip;
+	u8 nphy_tssi_slope;
 
-	int16 nphy_noise_win[PHY_CORE_MAX][PHY_NOISE_WINDOW_SZ];
-	uint8 nphy_noise_index;
+	s16 nphy_noise_win[PHY_CORE_MAX][PHY_NOISE_WINDOW_SZ];
+	u8 nphy_noise_index;
 
-	uint8 nphy_txpid2g[PHY_CORE_NUM_2];
-	uint8 nphy_txpid5g[PHY_CORE_NUM_2];
-	uint8 nphy_txpid5gl[PHY_CORE_NUM_2];
-	uint8 nphy_txpid5gh[PHY_CORE_NUM_2];
+	u8 nphy_txpid2g[PHY_CORE_NUM_2];
+	u8 nphy_txpid5g[PHY_CORE_NUM_2];
+	u8 nphy_txpid5gl[PHY_CORE_NUM_2];
+	u8 nphy_txpid5gh[PHY_CORE_NUM_2];
 
 	bool nphy_gain_boost;
 	bool nphy_elna_gain_config;
-	uint16 old_bphy_test;
-	uint16 old_bphy_testcontrol;
+	u16 old_bphy_test;
+	u16 old_bphy_testcontrol;
 
 	bool phyhang_avoid;
 
 	bool rssical_nphy;
-	uint8 nphy_perical;
+	u8 nphy_perical;
 	uint nphy_perical_last;
-	uint8 cal_type_override;
-	uint8 mphase_cal_phase_id;
-	uint8 mphase_txcal_cmdidx;
-	uint8 mphase_txcal_numcmds;
-	uint16 mphase_txcal_bestcoeffs[11];
+	u8 cal_type_override;
+	u8 mphase_cal_phase_id;
+	u8 mphase_txcal_cmdidx;
+	u8 mphase_txcal_numcmds;
+	u16 mphase_txcal_bestcoeffs[11];
 	chanspec_t nphy_txiqlocal_chanspec;
 	chanspec_t nphy_iqcal_chanspec_2G;
 	chanspec_t nphy_iqcal_chanspec_5G;
@@ -851,121 +851,121 @@ struct phy_info {
 	struct wlapi_timer *phycal_timer;
 	bool use_int_tx_iqlo_cal_nphy;
 	bool internal_tx_iqlo_cal_tapoff_intpa_nphy;
-	int16 nphy_lastcal_temp;
+	s16 nphy_lastcal_temp;
 
 	txiqcal_cache_t calibration_cache;
 	rssical_cache_t rssical_cache;
 
-	uint8 nphy_txpwr_idx[2];
-	uint8 nphy_papd_cal_type;
+	u8 nphy_txpwr_idx[2];
+	u8 nphy_papd_cal_type;
 	uint nphy_papd_last_cal;
-	uint16 nphy_papd_tx_gain_at_last_cal[2];
-	uint8 nphy_papd_cal_gain_index[2];
-	int16 nphy_papd_epsilon_offset[2];
+	u16 nphy_papd_tx_gain_at_last_cal[2];
+	u8 nphy_papd_cal_gain_index[2];
+	s16 nphy_papd_epsilon_offset[2];
 	bool nphy_papd_recal_enable;
-	uint32 nphy_papd_recal_counter;
+	u32 nphy_papd_recal_counter;
 	bool nphy_force_papd_cal;
 	bool nphy_papdcomp;
 	bool ipa2g_on;
 	bool ipa5g_on;
 
-	uint16 classifier_state;
-	uint16 clip_state[2];
+	u16 classifier_state;
+	u16 clip_state[2];
 	uint nphy_deaf_count;
-	uint8 rxiq_samps;
-	uint8 rxiq_antsel;
+	u8 rxiq_samps;
+	u8 rxiq_antsel;
 
-	uint16 rfctrlIntc1_save;
-	uint16 rfctrlIntc2_save;
+	u16 rfctrlIntc1_save;
+	u16 rfctrlIntc2_save;
 	bool first_cal_after_assoc;
-	uint16 tx_rx_cal_radio_saveregs[22];
-	uint16 tx_rx_cal_phy_saveregs[15];
+	u16 tx_rx_cal_radio_saveregs[22];
+	u16 tx_rx_cal_phy_saveregs[15];
 
-	uint8 nphy_cal_orig_pwr_idx[2];
-	uint8 nphy_txcal_pwr_idx[2];
-	uint8 nphy_rxcal_pwr_idx[2];
-	uint16 nphy_cal_orig_tx_gain[2];
+	u8 nphy_cal_orig_pwr_idx[2];
+	u8 nphy_txcal_pwr_idx[2];
+	u8 nphy_rxcal_pwr_idx[2];
+	u16 nphy_cal_orig_tx_gain[2];
 	nphy_txgains_t nphy_cal_target_gain;
-	uint16 nphy_txcal_bbmult;
-	uint16 nphy_gmval;
+	u16 nphy_txcal_bbmult;
+	u16 nphy_gmval;
 
-	uint16 nphy_saved_bbconf;
+	u16 nphy_saved_bbconf;
 
 	bool nphy_gband_spurwar_en;
 	bool nphy_gband_spurwar2_en;
 	bool nphy_aband_spurwar_en;
-	uint16 nphy_rccal_value;
-	uint16 nphy_crsminpwr[3];
+	u16 nphy_rccal_value;
+	u16 nphy_crsminpwr[3];
 	phy_noisevar_buf_t nphy_saved_noisevars;
 	bool nphy_anarxlpf_adjusted;
 	bool nphy_crsminpwr_adjusted;
 	bool nphy_noisevars_adjusted;
 
 	bool nphy_rxcal_active;
-	uint16 radar_percal_mask;
+	u16 radar_percal_mask;
 	bool dfs_lp_buffer_nphy;
 
-	uint16 nphy_fineclockgatecontrol;
+	u16 nphy_fineclockgatecontrol;
 
-	int8 rx2tx_biasentry;
+	s8 rx2tx_biasentry;
 
-	uint16 crsminpwr0;
-	uint16 crsminpwrl0;
-	uint16 crsminpwru0;
-	int16 noise_crsminpwr_index;
-	uint16 init_gain_core1;
-	uint16 init_gain_core2;
-	uint16 init_gainb_core1;
-	uint16 init_gainb_core2;
-	uint8 aci_noise_curr_channel;
-	uint16 init_gain_rfseq[4];
+	u16 crsminpwr0;
+	u16 crsminpwrl0;
+	u16 crsminpwru0;
+	s16 noise_crsminpwr_index;
+	u16 init_gain_core1;
+	u16 init_gain_core2;
+	u16 init_gainb_core1;
+	u16 init_gainb_core2;
+	u8 aci_noise_curr_channel;
+	u16 init_gain_rfseq[4];
 
 	bool radio_is_on;
 
 	bool nphy_sample_play_lpf_bw_ctl_ovr;
 
-	uint16 tbl_data_hi;
-	uint16 tbl_data_lo;
-	uint16 tbl_addr;
+	u16 tbl_data_hi;
+	u16 tbl_data_lo;
+	u16 tbl_addr;
 
 	uint tbl_save_id;
 	uint tbl_save_offset;
 
-	uint8 txpwrctrl;
-	int8 txpwrindex[PHY_CORE_MAX];
+	u8 txpwrctrl;
+	s8 txpwrindex[PHY_CORE_MAX];
 
-	uint8 phycal_tempdelta;
-	uint32 mcs20_po;
-	uint32 mcs40_po;
+	u8 phycal_tempdelta;
+	u32 mcs20_po;
+	u32 mcs40_po;
 };
 
-typedef int32 fixed;
+typedef s32 fixed;
 
-typedef struct _cint32 {
+typedef struct _cs32 {
 	fixed q;
 	fixed i;
-} cint32;
+} cs32;
 
 typedef struct radio_regs {
-	uint16 address;
-	uint32 init_a;
-	uint32 init_g;
-	uint8 do_init_a;
-	uint8 do_init_g;
+	u16 address;
+	u32 init_a;
+	u32 init_g;
+	u8 do_init_a;
+	u8 do_init_g;
 } radio_regs_t;
 
 typedef struct radio_20xx_regs {
-	uint16 address;
-	uint8 init;
-	uint8 do_init;
+	u16 address;
+	u8 init;
+	u8 do_init;
 } radio_20xx_regs_t;
 
 typedef struct lcnphy_radio_regs {
-	uint16 address;
-	uint8 init_a;
-	uint8 init_g;
-	uint8 do_init_a;
-	uint8 do_init_g;
+	u16 address;
+	u8 init_a;
+	u8 init_g;
+	u8 do_init_a;
+	u8 do_init_g;
 } lcnphy_radio_regs_t;
 
 extern lcnphy_radio_regs_t lcnphy_radio_regs_2064[];
@@ -984,118 +984,118 @@ extern radio_regs_t regs_SYN_2056_rev8[], regs_TX_2056_rev8[],
 extern radio_20xx_regs_t regs_2057_rev4[], regs_2057_rev5[], regs_2057_rev5v1[];
 extern radio_20xx_regs_t regs_2057_rev7[], regs_2057_rev8[];
 
-extern char *phy_getvar(phy_info_t * pi, const char *name);
-extern int phy_getintvar(phy_info_t * pi, const char *name);
+extern char *phy_getvar(phy_info_t *pi, const char *name);
+extern int phy_getintvar(phy_info_t *pi, const char *name);
 #define PHY_GETVAR(pi, name)	phy_getvar(pi, name)
 #define PHY_GETINTVAR(pi, name)	phy_getintvar(pi, name)
 
-extern uint16 read_phy_reg(phy_info_t * pi, uint16 addr);
-extern void write_phy_reg(phy_info_t * pi, uint16 addr, uint16 val);
-extern void and_phy_reg(phy_info_t * pi, uint16 addr, uint16 val);
-extern void or_phy_reg(phy_info_t * pi, uint16 addr, uint16 val);
-extern void mod_phy_reg(phy_info_t * pi, uint16 addr, uint16 mask, uint16 val);
-
-extern uint16 read_radio_reg(phy_info_t * pi, uint16 addr);
-extern void or_radio_reg(phy_info_t * pi, uint16 addr, uint16 val);
-extern void and_radio_reg(phy_info_t * pi, uint16 addr, uint16 val);
-extern void mod_radio_reg(phy_info_t * pi, uint16 addr, uint16 mask,
-			  uint16 val);
-extern void xor_radio_reg(phy_info_t * pi, uint16 addr, uint16 mask);
-
-extern void write_radio_reg(phy_info_t * pi, uint16 addr, uint16 val);
-
-extern void wlc_phyreg_enter(wlc_phy_t * pih);
-extern void wlc_phyreg_exit(wlc_phy_t * pih);
-extern void wlc_radioreg_enter(wlc_phy_t * pih);
-extern void wlc_radioreg_exit(wlc_phy_t * pih);
-
-extern void wlc_phy_read_table(phy_info_t * pi, const phytbl_info_t * ptbl_info,
-			       uint16 tblAddr, uint16 tblDataHi,
-			       uint16 tblDatalo);
-extern void wlc_phy_write_table(phy_info_t * pi,
-				const phytbl_info_t * ptbl_info, uint16 tblAddr,
-				uint16 tblDataHi, uint16 tblDatalo);
-extern void wlc_phy_table_addr(phy_info_t * pi, uint tbl_id, uint tbl_offset,
-			       uint16 tblAddr, uint16 tblDataHi,
-			       uint16 tblDataLo);
-extern void wlc_phy_table_data_write(phy_info_t * pi, uint width, uint32 val);
-
-extern void write_phy_channel_reg(phy_info_t * pi, uint val);
-extern void wlc_phy_txpower_update_shm(phy_info_t * pi);
-
-extern void wlc_phy_cordic(fixed theta, cint32 * val);
-extern uint8 wlc_phy_nbits(int32 value);
-extern uint32 wlc_phy_sqrt_int(uint32 value);
-extern void wlc_phy_compute_dB(uint32 * cmplx_pwr, int8 * p_dB, uint8 core);
-
-extern uint wlc_phy_init_radio_regs_allbands(phy_info_t * pi,
-					     radio_20xx_regs_t * radioregs);
-extern uint wlc_phy_init_radio_regs(phy_info_t * pi, radio_regs_t * radioregs,
-				    uint16 core_offset);
-
-extern void wlc_phy_txpower_ipa_upd(phy_info_t * pi);
-
-extern void wlc_phy_do_dummy_tx(phy_info_t * pi, bool ofdm, bool pa_on);
-extern void wlc_phy_papd_decode_epsilon(uint32 epsilon, int32 * eps_real,
-					int32 * eps_imag);
-
-extern void wlc_phy_cal_perical_mphase_reset(phy_info_t * pi);
-extern void wlc_phy_cal_perical_mphase_restart(phy_info_t * pi);
-
-extern bool wlc_phy_attach_nphy(phy_info_t * pi);
-extern bool wlc_phy_attach_lcnphy(phy_info_t * pi);
-
-extern void wlc_phy_detach_lcnphy(phy_info_t * pi);
-
-extern void wlc_phy_init_nphy(phy_info_t * pi);
-extern void wlc_phy_init_lcnphy(phy_info_t * pi);
-
-extern void wlc_phy_cal_init_nphy(phy_info_t * pi);
-extern void wlc_phy_cal_init_lcnphy(phy_info_t * pi);
-
-extern void wlc_phy_chanspec_set_nphy(phy_info_t * pi, chanspec_t chanspec);
-extern void wlc_phy_chanspec_set_lcnphy(phy_info_t * pi, chanspec_t chanspec);
-extern void wlc_phy_chanspec_set_fixup_lcnphy(phy_info_t * pi,
+extern u16 read_phy_reg(phy_info_t *pi, u16 addr);
+extern void write_phy_reg(phy_info_t *pi, u16 addr, u16 val);
+extern void and_phy_reg(phy_info_t *pi, u16 addr, u16 val);
+extern void or_phy_reg(phy_info_t *pi, u16 addr, u16 val);
+extern void mod_phy_reg(phy_info_t *pi, u16 addr, u16 mask, u16 val);
+
+extern u16 read_radio_reg(phy_info_t *pi, u16 addr);
+extern void or_radio_reg(phy_info_t *pi, u16 addr, u16 val);
+extern void and_radio_reg(phy_info_t *pi, u16 addr, u16 val);
+extern void mod_radio_reg(phy_info_t *pi, u16 addr, u16 mask,
+			  u16 val);
+extern void xor_radio_reg(phy_info_t *pi, u16 addr, u16 mask);
+
+extern void write_radio_reg(phy_info_t *pi, u16 addr, u16 val);
+
+extern void wlc_phyreg_enter(wlc_phy_t *pih);
+extern void wlc_phyreg_exit(wlc_phy_t *pih);
+extern void wlc_radioreg_enter(wlc_phy_t *pih);
+extern void wlc_radioreg_exit(wlc_phy_t *pih);
+
+extern void wlc_phy_read_table(phy_info_t *pi, const phytbl_info_t *ptbl_info,
+			       u16 tblAddr, u16 tblDataHi,
+			       u16 tblDatalo);
+extern void wlc_phy_write_table(phy_info_t *pi,
+				const phytbl_info_t *ptbl_info, u16 tblAddr,
+				u16 tblDataHi, u16 tblDatalo);
+extern void wlc_phy_table_addr(phy_info_t *pi, uint tbl_id, uint tbl_offset,
+			       u16 tblAddr, u16 tblDataHi,
+			       u16 tblDataLo);
+extern void wlc_phy_table_data_write(phy_info_t *pi, uint width, u32 val);
+
+extern void write_phy_channel_reg(phy_info_t *pi, uint val);
+extern void wlc_phy_txpower_update_shm(phy_info_t *pi);
+
+extern void wlc_phy_cordic(fixed theta, cs32 *val);
+extern u8 wlc_phy_nbits(s32 value);
+extern u32 wlc_phy_sqrt_int(u32 value);
+extern void wlc_phy_compute_dB(u32 *cmplx_pwr, s8 *p_dB, u8 core);
+
+extern uint wlc_phy_init_radio_regs_allbands(phy_info_t *pi,
+					     radio_20xx_regs_t *radioregs);
+extern uint wlc_phy_init_radio_regs(phy_info_t *pi, radio_regs_t *radioregs,
+				    u16 core_offset);
+
+extern void wlc_phy_txpower_ipa_upd(phy_info_t *pi);
+
+extern void wlc_phy_do_dummy_tx(phy_info_t *pi, bool ofdm, bool pa_on);
+extern void wlc_phy_papd_decode_epsilon(u32 epsilon, s32 *eps_real,
+					s32 *eps_imag);
+
+extern void wlc_phy_cal_perical_mphase_reset(phy_info_t *pi);
+extern void wlc_phy_cal_perical_mphase_restart(phy_info_t *pi);
+
+extern bool wlc_phy_attach_nphy(phy_info_t *pi);
+extern bool wlc_phy_attach_lcnphy(phy_info_t *pi);
+
+extern void wlc_phy_detach_lcnphy(phy_info_t *pi);
+
+extern void wlc_phy_init_nphy(phy_info_t *pi);
+extern void wlc_phy_init_lcnphy(phy_info_t *pi);
+
+extern void wlc_phy_cal_init_nphy(phy_info_t *pi);
+extern void wlc_phy_cal_init_lcnphy(phy_info_t *pi);
+
+extern void wlc_phy_chanspec_set_nphy(phy_info_t *pi, chanspec_t chanspec);
+extern void wlc_phy_chanspec_set_lcnphy(phy_info_t *pi, chanspec_t chanspec);
+extern void wlc_phy_chanspec_set_fixup_lcnphy(phy_info_t *pi,
 					      chanspec_t chanspec);
 extern int wlc_phy_channel2freq(uint channel);
 extern int wlc_phy_chanspec_freq2bandrange_lpssn(uint);
 extern int wlc_phy_chanspec_bandrange_get(phy_info_t *, chanspec_t);
 
-extern void wlc_lcnphy_set_tx_pwr_ctrl(phy_info_t * pi, uint16 mode);
-extern int8 wlc_lcnphy_get_current_tx_pwr_idx(phy_info_t * pi);
-
-extern void wlc_phy_txpower_recalc_target_nphy(phy_info_t * pi);
-extern void wlc_lcnphy_txpower_recalc_target(phy_info_t * pi);
-extern void wlc_phy_txpower_recalc_target_lcnphy(phy_info_t * pi);
-
-extern void wlc_lcnphy_set_tx_pwr_by_index(phy_info_t * pi, int index);
-extern void wlc_lcnphy_tx_pu(phy_info_t * pi, bool bEnable);
-extern void wlc_lcnphy_stop_tx_tone(phy_info_t * pi);
-extern void wlc_lcnphy_start_tx_tone(phy_info_t * pi, int32 f_kHz,
-				     uint16 max_val, bool iqcalmode);
-
-extern void wlc_phy_txpower_sromlimit_get_nphy(phy_info_t * pi, uint chan,
-					       uint8 * max_pwr, uint8 rate_id);
-extern void wlc_phy_ofdm_to_mcs_powers_nphy(uint8 * power, uint8 rate_mcs_start,
-					    uint8 rate_mcs_end,
-					    uint8 rate_ofdm_start);
-extern void wlc_phy_mcs_to_ofdm_powers_nphy(uint8 * power,
-					    uint8 rate_ofdm_start,
-					    uint8 rate_ofdm_end,
-					    uint8 rate_mcs_start);
-
-extern uint16 wlc_lcnphy_tempsense(phy_info_t * pi, bool mode);
-extern int16 wlc_lcnphy_tempsense_new(phy_info_t * pi, bool mode);
-extern int8 wlc_lcnphy_tempsense_degree(phy_info_t * pi, bool mode);
-extern int8 wlc_lcnphy_vbatsense(phy_info_t * pi, bool mode);
-extern void wlc_phy_carrier_suppress_lcnphy(phy_info_t * pi);
-extern void wlc_lcnphy_crsuprs(phy_info_t * pi, int channel);
-extern void wlc_lcnphy_epa_switch(phy_info_t * pi, bool mode);
-extern void wlc_2064_vco_cal(phy_info_t * pi);
-
-extern void wlc_phy_txpower_recalc_target(phy_info_t * pi);
-extern uint32 wlc_phy_qdiv_roundup(uint32 dividend, uint32 divisor,
-				   uint8 precision);
+extern void wlc_lcnphy_set_tx_pwr_ctrl(phy_info_t *pi, u16 mode);
+extern s8 wlc_lcnphy_get_current_tx_pwr_idx(phy_info_t *pi);
+
+extern void wlc_phy_txpower_recalc_target_nphy(phy_info_t *pi);
+extern void wlc_lcnphy_txpower_recalc_target(phy_info_t *pi);
+extern void wlc_phy_txpower_recalc_target_lcnphy(phy_info_t *pi);
+
+extern void wlc_lcnphy_set_tx_pwr_by_index(phy_info_t *pi, int index);
+extern void wlc_lcnphy_tx_pu(phy_info_t *pi, bool bEnable);
+extern void wlc_lcnphy_stop_tx_tone(phy_info_t *pi);
+extern void wlc_lcnphy_start_tx_tone(phy_info_t *pi, s32 f_kHz,
+				     u16 max_val, bool iqcalmode);
+
+extern void wlc_phy_txpower_sromlimit_get_nphy(phy_info_t *pi, uint chan,
+					       u8 *max_pwr, u8 rate_id);
+extern void wlc_phy_ofdm_to_mcs_powers_nphy(u8 *power, u8 rate_mcs_start,
+					    u8 rate_mcs_end,
+					    u8 rate_ofdm_start);
+extern void wlc_phy_mcs_to_ofdm_powers_nphy(u8 *power,
+					    u8 rate_ofdm_start,
+					    u8 rate_ofdm_end,
+					    u8 rate_mcs_start);
+
+extern u16 wlc_lcnphy_tempsense(phy_info_t *pi, bool mode);
+extern s16 wlc_lcnphy_tempsense_new(phy_info_t *pi, bool mode);
+extern s8 wlc_lcnphy_tempsense_degree(phy_info_t *pi, bool mode);
+extern s8 wlc_lcnphy_vbatsense(phy_info_t *pi, bool mode);
+extern void wlc_phy_carrier_suppress_lcnphy(phy_info_t *pi);
+extern void wlc_lcnphy_crsuprs(phy_info_t *pi, int channel);
+extern void wlc_lcnphy_epa_switch(phy_info_t *pi, bool mode);
+extern void wlc_2064_vco_cal(phy_info_t *pi);
+
+extern void wlc_phy_txpower_recalc_target(phy_info_t *pi);
+extern u32 wlc_phy_qdiv_roundup(u32 dividend, u32 divisor,
+				   u8 precision);
 
 #define LCNPHY_TBL_ID_PAPDCOMPDELTATBL	0x18
 #define LCNPHY_TX_POWER_TABLE_SIZE	128
@@ -1109,36 +1109,36 @@ extern uint32 wlc_phy_qdiv_roundup(uint32 dividend, uint32 divisor,
 
 #define LCNPHY_TX_PWR_CTRL_TEMPBASED	0xE001
 
-extern void wlc_lcnphy_write_table(phy_info_t * pi, const phytbl_info_t * pti);
-extern void wlc_lcnphy_read_table(phy_info_t * pi, phytbl_info_t * pti);
-extern void wlc_lcnphy_set_tx_iqcc(phy_info_t * pi, uint16 a, uint16 b);
-extern void wlc_lcnphy_set_tx_locc(phy_info_t * pi, uint16 didq);
-extern void wlc_lcnphy_get_tx_iqcc(phy_info_t * pi, uint16 * a, uint16 * b);
-extern uint16 wlc_lcnphy_get_tx_locc(phy_info_t * pi);
-extern void wlc_lcnphy_get_radio_loft(phy_info_t * pi, uint8 * ei0,
-				      uint8 * eq0, uint8 * fi0, uint8 * fq0);
-extern void wlc_lcnphy_calib_modes(phy_info_t * pi, uint mode);
-extern void wlc_lcnphy_deaf_mode(phy_info_t * pi, bool mode);
-extern bool wlc_phy_tpc_isenabled_lcnphy(phy_info_t * pi);
-extern void wlc_lcnphy_tx_pwr_update_npt(phy_info_t * pi);
-extern int32 wlc_lcnphy_tssi2dbm(int32 tssi, int32 a1, int32 b0, int32 b1);
-extern void wlc_lcnphy_get_tssi(phy_info_t * pi, int8 * ofdm_pwr,
-				int8 * cck_pwr);
-extern void wlc_lcnphy_tx_power_adjustment(wlc_phy_t * ppi);
-
-extern int32 wlc_lcnphy_rx_signal_power(phy_info_t * pi, int32 gain_index);
+extern void wlc_lcnphy_write_table(phy_info_t *pi, const phytbl_info_t *pti);
+extern void wlc_lcnphy_read_table(phy_info_t *pi, phytbl_info_t *pti);
+extern void wlc_lcnphy_set_tx_iqcc(phy_info_t *pi, u16 a, u16 b);
+extern void wlc_lcnphy_set_tx_locc(phy_info_t *pi, u16 didq);
+extern void wlc_lcnphy_get_tx_iqcc(phy_info_t *pi, u16 *a, u16 *b);
+extern u16 wlc_lcnphy_get_tx_locc(phy_info_t *pi);
+extern void wlc_lcnphy_get_radio_loft(phy_info_t *pi, u8 *ei0,
+				      u8 *eq0, u8 *fi0, u8 *fq0);
+extern void wlc_lcnphy_calib_modes(phy_info_t *pi, uint mode);
+extern void wlc_lcnphy_deaf_mode(phy_info_t *pi, bool mode);
+extern bool wlc_phy_tpc_isenabled_lcnphy(phy_info_t *pi);
+extern void wlc_lcnphy_tx_pwr_update_npt(phy_info_t *pi);
+extern s32 wlc_lcnphy_tssi2dbm(s32 tssi, s32 a1, s32 b0, s32 b1);
+extern void wlc_lcnphy_get_tssi(phy_info_t *pi, s8 *ofdm_pwr,
+				s8 *cck_pwr);
+extern void wlc_lcnphy_tx_power_adjustment(wlc_phy_t *ppi);
+
+extern s32 wlc_lcnphy_rx_signal_power(phy_info_t *pi, s32 gain_index);
 
 #define NPHY_MAX_HPVGA1_INDEX		10
 #define NPHY_DEF_HPVGA1_INDEXLIMIT	7
 
 typedef struct _phy_iq_est {
-	int32 iq_prod;
-	uint32 i_pwr;
-	uint32 q_pwr;
+	s32 iq_prod;
+	u32 i_pwr;
+	u32 q_pwr;
 } phy_iq_est_t;
 
-extern void wlc_phy_stay_in_carriersearch_nphy(phy_info_t * pi, bool enable);
-extern void wlc_nphy_deaf_mode(phy_info_t * pi, bool mode);
+extern void wlc_phy_stay_in_carriersearch_nphy(phy_info_t *pi, bool enable);
+extern void wlc_nphy_deaf_mode(phy_info_t *pi, bool mode);
 
 #define wlc_phy_write_table_nphy(pi, pti)	wlc_phy_write_table(pi, pti, 0x72, \
 	0x74, 0x73)
@@ -1148,10 +1148,10 @@ extern void wlc_nphy_deaf_mode(phy_info_t * pi, bool mode);
 	0x72, 0x74, 0x73)
 #define wlc_nphy_table_data_write(pi, w, v)	wlc_phy_table_data_write((pi), (w), (v))
 
-extern void wlc_phy_table_read_nphy(phy_info_t * pi, uint32, uint32 l, uint32 o,
-				    uint32 w, void *d);
-extern void wlc_phy_table_write_nphy(phy_info_t * pi, uint32, uint32, uint32,
-				     uint32, const void *);
+extern void wlc_phy_table_read_nphy(phy_info_t *pi, u32, u32 l, u32 o,
+				    u32 w, void *d);
+extern void wlc_phy_table_write_nphy(phy_info_t *pi, u32, u32, u32,
+				     u32, const void *);
 
 #define	PHY_IPA(pi) \
 	((pi->ipa2g_on && CHSPEC_IS2G(pi->radio_chanspec)) || \
@@ -1161,69 +1161,69 @@ extern void wlc_phy_table_write_nphy(phy_info_t * pi, uint32, uint32, uint32,
 	if ((BUSTYPE((pi)->sh->bustype) == PCI_BUS) && NREV_LT((pi)->pubpi.phy_rev, 3)) \
 		(void)R_REG((pi)->sh->osh, &(pi)->regs->maccontrol)
 
-extern void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype);
-extern void wlc_phy_aci_reset_nphy(phy_info_t * pi);
-extern void wlc_phy_pa_override_nphy(phy_info_t * pi, bool en);
+extern void wlc_phy_cal_perical_nphy_run(phy_info_t *pi, u8 caltype);
+extern void wlc_phy_aci_reset_nphy(phy_info_t *pi);
+extern void wlc_phy_pa_override_nphy(phy_info_t *pi, bool en);
 
-extern uint8 wlc_phy_get_chan_freq_range_nphy(phy_info_t * pi, uint chan);
-extern void wlc_phy_switch_radio_nphy(phy_info_t * pi, bool on);
+extern u8 wlc_phy_get_chan_freq_range_nphy(phy_info_t *pi, uint chan);
+extern void wlc_phy_switch_radio_nphy(phy_info_t *pi, bool on);
 
-extern void wlc_phy_stf_chain_upd_nphy(phy_info_t * pi);
+extern void wlc_phy_stf_chain_upd_nphy(phy_info_t *pi);
 
-extern void wlc_phy_force_rfseq_nphy(phy_info_t * pi, uint8 cmd);
-extern int16 wlc_phy_tempsense_nphy(phy_info_t * pi);
+extern void wlc_phy_force_rfseq_nphy(phy_info_t *pi, u8 cmd);
+extern s16 wlc_phy_tempsense_nphy(phy_info_t *pi);
 
-extern uint16 wlc_phy_classifier_nphy(phy_info_t * pi, uint16 mask, uint16 val);
+extern u16 wlc_phy_classifier_nphy(phy_info_t *pi, u16 mask, u16 val);
 
-extern void wlc_phy_rx_iq_est_nphy(phy_info_t * pi, phy_iq_est_t * est,
-				   uint16 num_samps, uint8 wait_time,
-				   uint8 wait_for_crs);
+extern void wlc_phy_rx_iq_est_nphy(phy_info_t *pi, phy_iq_est_t *est,
+				   u16 num_samps, u8 wait_time,
+				   u8 wait_for_crs);
 
-extern void wlc_phy_rx_iq_coeffs_nphy(phy_info_t * pi, uint8 write,
-				      nphy_iq_comp_t * comp);
-extern void wlc_phy_aci_and_noise_reduction_nphy(phy_info_t * pi);
+extern void wlc_phy_rx_iq_coeffs_nphy(phy_info_t *pi, u8 write,
+				      nphy_iq_comp_t *comp);
+extern void wlc_phy_aci_and_noise_reduction_nphy(phy_info_t *pi);
 
-extern void wlc_phy_rxcore_setstate_nphy(wlc_phy_t * pih, uint8 rxcore_bitmask);
-extern uint8 wlc_phy_rxcore_getstate_nphy(wlc_phy_t * pih);
+extern void wlc_phy_rxcore_setstate_nphy(wlc_phy_t *pih, u8 rxcore_bitmask);
+extern u8 wlc_phy_rxcore_getstate_nphy(wlc_phy_t *pih);
 
-extern void wlc_phy_txpwrctrl_enable_nphy(phy_info_t * pi, uint8 ctrl_type);
-extern void wlc_phy_txpwr_fixpower_nphy(phy_info_t * pi);
-extern void wlc_phy_txpwr_apply_nphy(phy_info_t * pi);
-extern void wlc_phy_txpwr_papd_cal_nphy(phy_info_t * pi);
-extern uint16 wlc_phy_txpwr_idx_get_nphy(phy_info_t * pi);
+extern void wlc_phy_txpwrctrl_enable_nphy(phy_info_t *pi, u8 ctrl_type);
+extern void wlc_phy_txpwr_fixpower_nphy(phy_info_t *pi);
+extern void wlc_phy_txpwr_apply_nphy(phy_info_t *pi);
+extern void wlc_phy_txpwr_papd_cal_nphy(phy_info_t *pi);
+extern u16 wlc_phy_txpwr_idx_get_nphy(phy_info_t *pi);
 
-extern nphy_txgains_t wlc_phy_get_tx_gain_nphy(phy_info_t * pi);
-extern int wlc_phy_cal_txiqlo_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
+extern nphy_txgains_t wlc_phy_get_tx_gain_nphy(phy_info_t *pi);
+extern int wlc_phy_cal_txiqlo_nphy(phy_info_t *pi, nphy_txgains_t target_gain,
 				   bool full, bool m);
-extern int wlc_phy_cal_rxiq_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
-				 uint8 type, bool d);
-extern void wlc_phy_txpwr_index_nphy(phy_info_t * pi, uint8 core_mask,
-				     int8 txpwrindex, bool res);
-extern void wlc_phy_rssisel_nphy(phy_info_t * pi, uint8 core, uint8 rssi_type);
-extern int wlc_phy_poll_rssi_nphy(phy_info_t * pi, uint8 rssi_type,
-				  int32 * rssi_buf, uint8 nsamps);
-extern void wlc_phy_rssi_cal_nphy(phy_info_t * pi);
-extern int wlc_phy_aci_scan_nphy(phy_info_t * pi);
-extern void wlc_phy_cal_txgainctrl_nphy(phy_info_t * pi, int32 dBm_targetpower,
+extern int wlc_phy_cal_rxiq_nphy(phy_info_t *pi, nphy_txgains_t target_gain,
+				 u8 type, bool d);
+extern void wlc_phy_txpwr_index_nphy(phy_info_t *pi, u8 core_mask,
+				     s8 txpwrindex, bool res);
+extern void wlc_phy_rssisel_nphy(phy_info_t *pi, u8 core, u8 rssi_type);
+extern int wlc_phy_poll_rssi_nphy(phy_info_t *pi, u8 rssi_type,
+				  s32 *rssi_buf, u8 nsamps);
+extern void wlc_phy_rssi_cal_nphy(phy_info_t *pi);
+extern int wlc_phy_aci_scan_nphy(phy_info_t *pi);
+extern void wlc_phy_cal_txgainctrl_nphy(phy_info_t *pi, s32 dBm_targetpower,
 					bool debug);
-extern int wlc_phy_tx_tone_nphy(phy_info_t * pi, uint32 f_kHz, uint16 max_val,
-				uint8 mode, uint8, bool);
-extern void wlc_phy_stopplayback_nphy(phy_info_t * pi);
-extern void wlc_phy_est_tonepwr_nphy(phy_info_t * pi, int32 * qdBm_pwrbuf,
-				     uint8 num_samps);
-extern void wlc_phy_radio205x_vcocal_nphy(phy_info_t * pi);
+extern int wlc_phy_tx_tone_nphy(phy_info_t *pi, u32 f_kHz, u16 max_val,
+				u8 mode, u8, bool);
+extern void wlc_phy_stopplayback_nphy(phy_info_t *pi);
+extern void wlc_phy_est_tonepwr_nphy(phy_info_t *pi, s32 *qdBm_pwrbuf,
+				     u8 num_samps);
+extern void wlc_phy_radio205x_vcocal_nphy(phy_info_t *pi);
 
-extern int wlc_phy_rssi_compute_nphy(phy_info_t * pi, wlc_d11rxhdr_t * wlc_rxh);
+extern int wlc_phy_rssi_compute_nphy(phy_info_t *pi, wlc_d11rxhdr_t *wlc_rxh);
 
 #define NPHY_TESTPATTERN_BPHY_EVM   0
 #define NPHY_TESTPATTERN_BPHY_RFCS  1
 
-extern void wlc_phy_nphy_tkip_rifs_war(phy_info_t * pi, uint8 rifs);
+extern void wlc_phy_nphy_tkip_rifs_war(phy_info_t *pi, u8 rifs);
 
-void wlc_phy_get_pwrdet_offsets(phy_info_t * pi, int8 * cckoffset,
-				int8 * ofdmoffset);
-extern int8 wlc_phy_upd_rssi_offset(phy_info_t * pi, int8 rssi,
+void wlc_phy_get_pwrdet_offsets(phy_info_t *pi, s8 *cckoffset,
+				s8 *ofdmoffset);
+extern s8 wlc_phy_upd_rssi_offset(phy_info_t *pi, s8 rssi,
 				    chanspec_t chanspec);
 
-extern bool wlc_phy_n_txpower_ipa_ison(phy_info_t * pih);
+extern bool wlc_phy_n_txpower_ipa_ison(phy_info_t *pih);
 #endif				/* _wlc_phy_int_h_ */
diff --git a/drivers/staging/brcm80211/phy/wlc_phy_lcn.c b/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
index 5953841..3d3112e 100644
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
@@ -14,11 +14,14 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/bitops.h>
 #include <wlc_cfg.h>
 #include <qmath.h>
 #include <osl.h>
+#include <linuxver.h>
 #include <siutils.h>
-#include <bitfuncs.h>
 #include <hndpmu.h>
 
 #include <wlc_phy_radio.h>
@@ -79,9 +82,9 @@
 	(0x7f << LCNPHY_stxtxgainctrlovrval1_pagain_ovr_val1_SHIFT)
 
 #define wlc_lcnphy_enable_tx_gain_override(pi) \
-	wlc_lcnphy_set_tx_gain_override(pi, TRUE)
+	wlc_lcnphy_set_tx_gain_override(pi, true)
 #define wlc_lcnphy_disable_tx_gain_override(pi) \
-	wlc_lcnphy_set_tx_gain_override(pi, FALSE)
+	wlc_lcnphy_set_tx_gain_override(pi, false)
 
 #define wlc_lcnphy_iqcal_active(pi)	\
 	(read_phy_reg((pi), 0x451) & \
@@ -137,13 +140,13 @@
 	(0 != (read_phy_reg((pi), 0x43b) & (0x1 << 6)))
 
 #define wlc_lcnphy_total_tx_frames(pi) \
-	wlapi_bmac_read_shm((pi)->sh->physhim, M_UCODE_MACSTAT + OFFSETOF(macstat_t, txallfrm))
+	wlapi_bmac_read_shm((pi)->sh->physhim, M_UCODE_MACSTAT + offsetof(macstat_t, txallfrm))
 
 typedef struct {
-	uint16 gm_gain;
-	uint16 pga_gain;
-	uint16 pad_gain;
-	uint16 dac_gain;
+	u16 gm_gain;
+	u16 pga_gain;
+	u16 pad_gain;
+	u16 dac_gain;
 } lcnphy_txgains_t;
 
 typedef enum {
@@ -157,34 +160,34 @@ typedef enum {
 typedef struct {
 	lcnphy_txgains_t gains;
 	bool useindex;
-	uint8 index;
+	u8 index;
 } lcnphy_txcalgains_t;
 
 typedef struct {
-	uint8 chan;
-	int16 a;
-	int16 b;
+	u8 chan;
+	s16 a;
+	s16 b;
 } lcnphy_rx_iqcomp_t;
 
 typedef struct {
-	int16 re;
-	int16 im;
+	s16 re;
+	s16 im;
 } lcnphy_spb_tone_t;
 
 typedef struct {
-	uint16 re;
-	uint16 im;
+	u16 re;
+	u16 im;
 } lcnphy_unsign16_struct;
 
 typedef struct {
-	uint32 iq_prod;
-	uint32 i_pwr;
-	uint32 q_pwr;
+	u32 iq_prod;
+	u32 i_pwr;
+	u32 q_pwr;
 } lcnphy_iq_est_t;
 
 typedef struct {
-	uint16 ptcentreTs20;
-	uint16 ptcentreFactor;
+	u16 ptcentreTs20;
+	u16 ptcentreFactor;
 } lcnphy_sfo_cfg_t;
 
 typedef enum {
@@ -192,7 +195,7 @@ typedef enum {
 	LCNPHY_PAPD_CAL_OFDM
 } lcnphy_papd_cal_type_t;
 
-typedef uint16 iqcal_gain_params_lcnphy[9];
+typedef u16 iqcal_gain_params_lcnphy[9];
 
 static const iqcal_gain_params_lcnphy tbl_iqcal_gainparams_lcnphy_2G[] = {
 	{0, 0, 0, 0, 0, 0, 0, 0, 0},
@@ -202,7 +205,7 @@ static const iqcal_gain_params_lcnphy *tbl_iqcal_gainparams_lcnphy[1] = {
 	tbl_iqcal_gainparams_lcnphy_2G,
 };
 
-static const uint16 iqcal_gainparams_numgains_lcnphy[1] = {
+static const u16 iqcal_gainparams_numgains_lcnphy[1] = {
 	sizeof(tbl_iqcal_gainparams_lcnphy_2G) /
 	    sizeof(*tbl_iqcal_gainparams_lcnphy_2G),
 };
@@ -225,7 +228,7 @@ static const lcnphy_sfo_cfg_t lcnphy_sfo_cfg[] = {
 };
 
 static const
-uint16 lcnphy_iqcal_loft_gainladder[] = {
+u16 lcnphy_iqcal_loft_gainladder[] = {
 	((2 << 8) | 0),
 	((3 << 8) | 0),
 	((4 << 8) | 0),
@@ -249,7 +252,7 @@ uint16 lcnphy_iqcal_loft_gainladder[] = {
 };
 
 static const
-uint16 lcnphy_iqcal_ir_gainladder[] = {
+u16 lcnphy_iqcal_ir_gainladder[] = {
 	((1 << 8) | 0),
 	((2 << 8) | 0),
 	((4 << 8) | 0),
@@ -309,7 +312,7 @@ lcnphy_spb_tone_t lcnphy_spb_tone_3750[] = {
 };
 
 static const
-uint16 iqlo_loopback_rf_regs[20] = {
+u16 iqlo_loopback_rf_regs[20] = {
 	RADIO_2064_REG036,
 	RADIO_2064_REG11A,
 	RADIO_2064_REG03A,
@@ -333,7 +336,7 @@ uint16 iqlo_loopback_rf_regs[20] = {
 };
 
 static const
-uint16 tempsense_phy_regs[14] = {
+u16 tempsense_phy_regs[14] = {
 	0x503,
 	0x4a4,
 	0x4d0,
@@ -351,7 +354,7 @@ uint16 tempsense_phy_regs[14] = {
 };
 
 static const
-uint16 rxiq_cal_rf_reg[11] = {
+u16 rxiq_cal_rf_reg[11] = {
 	RADIO_2064_REG098,
 	RADIO_2064_REG116,
 	RADIO_2064_REG12C,
@@ -420,7 +423,7 @@ lcnphy_rx_iqcomp_t lcnphy_rx_iqcomp_table_rev0[] = {
 	{216, 0, 0},
 };
 
-static const uint32 lcnphy_23bitgaincode_table[] = {
+static const u32 lcnphy_23bitgaincode_table[] = {
 	0x200100,
 	0x200200,
 	0x200004,
@@ -460,7 +463,7 @@ static const uint32 lcnphy_23bitgaincode_table[] = {
 	0x04464f,
 };
 
-static const int8 lcnphy_gain_table[] = {
+static const s8 lcnphy_gain_table[] = {
 	-16,
 	-13,
 	10,
@@ -500,7 +503,7 @@ static const int8 lcnphy_gain_table[] = {
 	92,
 };
 
-static const int8 lcnphy_gain_index_offset_for_rssi[] = {
+static const s8 lcnphy_gain_index_offset_for_rssi[] = {
 	7,
 	7,
 	7,
@@ -541,23 +544,23 @@ static const int8 lcnphy_gain_index_offset_for_rssi[] = {
 	-2
 };
 
-extern CONST uint8 spur_tbl_rev0[];
-extern CONST uint32 dot11lcnphytbl_rx_gain_info_sz_rev1;
-extern CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_rev1[];
-extern CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_bt_epa;
-extern CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_bt_epa_p250;
+extern const u8 spur_tbl_rev0[];
+extern const u32 dot11lcnphytbl_rx_gain_info_sz_rev1;
+extern const dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_rev1[];
+extern const dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_bt_epa;
+extern const dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_bt_epa_p250;
 
 typedef struct _chan_info_2064_lcnphy {
 	uint chan;
 	uint freq;
-	uint8 logen_buftune;
-	uint8 logen_rccr_tx;
-	uint8 txrf_mix_tune_ctrl;
-	uint8 pa_input_tune_g;
-	uint8 logen_rccr_rx;
-	uint8 pa_rxrf_lna1_freq_tune;
-	uint8 pa_rxrf_lna2_freq_tune;
-	uint8 rxrf_rxrf_spare1;
+	u8 logen_buftune;
+	u8 logen_rccr_tx;
+	u8 txrf_mix_tune_ctrl;
+	u8 pa_input_tune_g;
+	u8 logen_rccr_rx;
+	u8 pa_rxrf_lna1_freq_tune;
+	u8 pa_rxrf_lna2_freq_tune;
+	u8 rxrf_rxrf_spare1;
 } chan_info_2064_lcnphy_t;
 
 static chan_info_2064_lcnphy_t chan_info_2064_lcnphy[] = {
@@ -889,7 +892,7 @@ lcnphy_radio_regs_t lcnphy_radio_regs_2064[] = {
 #define LCNPHY_NUM_DIG_FILT_COEFFS 16
 #define LCNPHY_NUM_TX_DIG_FILTERS_CCK 13
 
-uint16
+u16
     LCNPHY_txdigfiltcoeffs_cck[LCNPHY_NUM_TX_DIG_FILTERS_CCK]
     [LCNPHY_NUM_DIG_FILT_COEFFS + 1] = {
 	{0, 1, 415, 1874, 64, 128, 64, 792, 1656, 64, 128, 64, 778, 1582, 64,
@@ -921,7 +924,7 @@ uint16
 };
 
 #define LCNPHY_NUM_TX_DIG_FILTERS_OFDM 3
-uint16
+u16
     LCNPHY_txdigfiltcoeffs_ofdm[LCNPHY_NUM_TX_DIG_FILTERS_OFDM]
     [LCNPHY_NUM_DIG_FILT_COEFFS + 1] = {
 	{0, 0, 0xa2, 0x0, 0x100, 0x100, 0x0, 0x0, 0x0, 0x100, 0x0, 0x0,
@@ -935,12 +938,12 @@ uint16
 #define wlc_lcnphy_set_start_tx_pwr_idx(pi, idx) \
 	mod_phy_reg(pi, 0x4a4, \
 		(0x1ff << 0), \
-		(uint16)(idx) << 0)
+		(u16)(idx) << 0)
 
 #define wlc_lcnphy_set_tx_pwr_npt(pi, npt) \
 	mod_phy_reg(pi, 0x4a5, \
 		(0x7 << 8), \
-		(uint16)(npt) << 8)
+		(u16)(npt) << 8)
 
 #define wlc_lcnphy_get_tx_pwr_ctrl(pi) \
 	(read_phy_reg((pi), 0x4a4) & \
@@ -964,90 +967,87 @@ uint16
 #define wlc_lcnphy_set_target_tx_pwr(pi, target) \
 	mod_phy_reg(pi, 0x4a7, \
 		(0xff << 0), \
-		(uint16)(target) << 0)
+		(u16)(target) << 0)
 
 #define wlc_radio_2064_rcal_done(pi) (0 != (read_radio_reg(pi, RADIO_2064_REG05C) & 0x20))
 #define tempsense_done(pi) (0x8000 == (read_phy_reg(pi, 0x476) & 0x8000))
 
-#define LCNPHY_IQLOCC_READ(val) ((uint8)(-(int8)(((val) & 0xf0) >> 4) + (int8)((val) & 0x0f)))
+#define LCNPHY_IQLOCC_READ(val) ((u8)(-(s8)(((val) & 0xf0) >> 4) + (s8)((val) & 0x0f)))
 #define FIXED_TXPWR 78
-#define LCNPHY_TEMPSENSE(val) ((int16)((val > 255)?(val - 512):val))
-
-static uint32 wlc_lcnphy_qdiv_roundup(uint32 divident, uint32 divisor,
-				      uint8 precision);
-static void wlc_lcnphy_set_rx_gain_by_distribution(phy_info_t * pi,
-						   uint16 ext_lna, uint16 trsw,
-						   uint16 biq2, uint16 biq1,
-						   uint16 tia, uint16 lna2,
-						   uint16 lna1);
-static void wlc_lcnphy_clear_tx_power_offsets(phy_info_t * pi);
-static void wlc_lcnphy_set_pa_gain(phy_info_t * pi, uint16 gain);
-static void wlc_lcnphy_set_trsw_override(phy_info_t * pi, bool tx, bool rx);
-static void wlc_lcnphy_set_bbmult(phy_info_t * pi, uint8 m0);
-static uint8 wlc_lcnphy_get_bbmult(phy_info_t * pi);
-static void wlc_lcnphy_get_tx_gain(phy_info_t * pi, lcnphy_txgains_t * gains);
-static void wlc_lcnphy_set_tx_gain_override(phy_info_t * pi, bool bEnable);
-static void wlc_lcnphy_toggle_afe_pwdn(phy_info_t * pi);
-static void wlc_lcnphy_rx_gain_override_enable(phy_info_t * pi, bool enable);
-static void wlc_lcnphy_set_tx_gain(phy_info_t * pi,
-				   lcnphy_txgains_t * target_gains);
-static bool wlc_lcnphy_rx_iq_est(phy_info_t * pi, uint16 num_samps,
-				 uint8 wait_time, lcnphy_iq_est_t * iq_est);
-static bool wlc_lcnphy_calc_rx_iq_comp(phy_info_t * pi, uint16 num_samps);
-static uint16 wlc_lcnphy_get_pa_gain(phy_info_t * pi);
-static void wlc_lcnphy_afe_clk_init(phy_info_t * pi, uint8 mode);
-extern void wlc_lcnphy_tx_pwr_ctrl_init(wlc_phy_t * ppi);
-extern void wlc_lcnphy_pktengtx(wlc_phy_t * ppi, wl_pkteng_t * pkteng,
-				uint8 rate, struct ether_addr *sa,
-				uint32 wait_delay);
-static void wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t * pi,
-						    uint8 channel);
-
-static void wlc_lcnphy_load_tx_gain_table(phy_info_t * pi,
-					  const lcnphy_tx_gain_tbl_entry * g);
-
-static void wlc_lcnphy_samp_cap(phy_info_t * pi, int clip_detect_algo,
-				uint16 thresh, int16 * ptr, int mode);
-static int wlc_lcnphy_calc_floor(int16 coeff, int type);
-static void wlc_lcnphy_tx_iqlo_loopback(phy_info_t * pi,
-					uint16 * values_to_save);
-static void wlc_lcnphy_tx_iqlo_loopback_cleanup(phy_info_t * pi,
-						uint16 * values_to_save);
-static void wlc_lcnphy_set_cc(phy_info_t * pi, int cal_type, int16 coeff_x,
-			      int16 coeff_y);
-static lcnphy_unsign16_struct wlc_lcnphy_get_cc(phy_info_t * pi, int cal_type);
-static void wlc_lcnphy_a1(phy_info_t * pi, int cal_type,
+#define LCNPHY_TEMPSENSE(val) ((s16)((val > 255) ? (val - 512) : val))
+
+static u32 wlc_lcnphy_qdiv_roundup(u32 divident, u32 divisor,
+				      u8 precision);
+static void wlc_lcnphy_set_rx_gain_by_distribution(phy_info_t *pi,
+						   u16 ext_lna, u16 trsw,
+						   u16 biq2, u16 biq1,
+						   u16 tia, u16 lna2,
+						   u16 lna1);
+static void wlc_lcnphy_clear_tx_power_offsets(phy_info_t *pi);
+static void wlc_lcnphy_set_pa_gain(phy_info_t *pi, u16 gain);
+static void wlc_lcnphy_set_trsw_override(phy_info_t *pi, bool tx, bool rx);
+static void wlc_lcnphy_set_bbmult(phy_info_t *pi, u8 m0);
+static u8 wlc_lcnphy_get_bbmult(phy_info_t *pi);
+static void wlc_lcnphy_get_tx_gain(phy_info_t *pi, lcnphy_txgains_t *gains);
+static void wlc_lcnphy_set_tx_gain_override(phy_info_t *pi, bool bEnable);
+static void wlc_lcnphy_toggle_afe_pwdn(phy_info_t *pi);
+static void wlc_lcnphy_rx_gain_override_enable(phy_info_t *pi, bool enable);
+static void wlc_lcnphy_set_tx_gain(phy_info_t *pi,
+				   lcnphy_txgains_t *target_gains);
+static bool wlc_lcnphy_rx_iq_est(phy_info_t *pi, u16 num_samps,
+				 u8 wait_time, lcnphy_iq_est_t *iq_est);
+static bool wlc_lcnphy_calc_rx_iq_comp(phy_info_t *pi, u16 num_samps);
+static u16 wlc_lcnphy_get_pa_gain(phy_info_t *pi);
+static void wlc_lcnphy_afe_clk_init(phy_info_t *pi, u8 mode);
+extern void wlc_lcnphy_tx_pwr_ctrl_init(wlc_phy_t *ppi);
+static void wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t *pi,
+						    u8 channel);
+
+static void wlc_lcnphy_load_tx_gain_table(phy_info_t *pi,
+					  const lcnphy_tx_gain_tbl_entry *g);
+
+static void wlc_lcnphy_samp_cap(phy_info_t *pi, int clip_detect_algo,
+				u16 thresh, s16 *ptr, int mode);
+static int wlc_lcnphy_calc_floor(s16 coeff, int type);
+static void wlc_lcnphy_tx_iqlo_loopback(phy_info_t *pi,
+					u16 *values_to_save);
+static void wlc_lcnphy_tx_iqlo_loopback_cleanup(phy_info_t *pi,
+						u16 *values_to_save);
+static void wlc_lcnphy_set_cc(phy_info_t *pi, int cal_type, s16 coeff_x,
+			      s16 coeff_y);
+static lcnphy_unsign16_struct wlc_lcnphy_get_cc(phy_info_t *pi, int cal_type);
+static void wlc_lcnphy_a1(phy_info_t *pi, int cal_type,
 			  int num_levels, int step_size_lg2);
-static void wlc_lcnphy_tx_iqlo_soft_cal_full(phy_info_t * pi);
+static void wlc_lcnphy_tx_iqlo_soft_cal_full(phy_info_t *pi);
 
-static void wlc_lcnphy_set_chanspec_tweaks(phy_info_t * pi,
+static void wlc_lcnphy_set_chanspec_tweaks(phy_info_t *pi,
 					   chanspec_t chanspec);
-static void wlc_lcnphy_agc_temp_init(phy_info_t * pi);
-static void wlc_lcnphy_temp_adj(phy_info_t * pi);
-static void wlc_lcnphy_clear_papd_comptable(phy_info_t * pi);
-static void wlc_lcnphy_baseband_init(phy_info_t * pi);
-static void wlc_lcnphy_radio_init(phy_info_t * pi);
-static void wlc_lcnphy_rc_cal(phy_info_t * pi);
-static void wlc_lcnphy_rcal(phy_info_t * pi);
-static void wlc_lcnphy_txrx_spur_avoidance_mode(phy_info_t * pi, bool enable);
-static int wlc_lcnphy_load_tx_iir_filter(phy_info_t * pi, bool is_ofdm,
-					 int16 filt_type);
-static void wlc_lcnphy_set_rx_iq_comp(phy_info_t * pi, uint16 a, uint16 b);
-
-void wlc_lcnphy_write_table(phy_info_t * pi, const phytbl_info_t * pti)
+static void wlc_lcnphy_agc_temp_init(phy_info_t *pi);
+static void wlc_lcnphy_temp_adj(phy_info_t *pi);
+static void wlc_lcnphy_clear_papd_comptable(phy_info_t *pi);
+static void wlc_lcnphy_baseband_init(phy_info_t *pi);
+static void wlc_lcnphy_radio_init(phy_info_t *pi);
+static void wlc_lcnphy_rc_cal(phy_info_t *pi);
+static void wlc_lcnphy_rcal(phy_info_t *pi);
+static void wlc_lcnphy_txrx_spur_avoidance_mode(phy_info_t *pi, bool enable);
+static int wlc_lcnphy_load_tx_iir_filter(phy_info_t *pi, bool is_ofdm,
+					 s16 filt_type);
+static void wlc_lcnphy_set_rx_iq_comp(phy_info_t *pi, u16 a, u16 b);
+
+void wlc_lcnphy_write_table(phy_info_t *pi, const phytbl_info_t *pti)
 {
 	wlc_phy_write_table(pi, pti, 0x455, 0x457, 0x456);
 }
 
-void wlc_lcnphy_read_table(phy_info_t * pi, phytbl_info_t * pti)
+void wlc_lcnphy_read_table(phy_info_t *pi, phytbl_info_t *pti)
 {
 	wlc_phy_read_table(pi, pti, 0x455, 0x457, 0x456);
 }
 
 static void
-wlc_lcnphy_common_read_table(phy_info_t * pi, uint32 tbl_id,
-			     CONST void *tbl_ptr, uint32 tbl_len,
-			     uint32 tbl_width, uint32 tbl_offset)
+wlc_lcnphy_common_read_table(phy_info_t *pi, u32 tbl_id,
+			     const void *tbl_ptr, u32 tbl_len,
+			     u32 tbl_width, u32 tbl_offset)
 {
 	phytbl_info_t tab;
 	tab.tbl_id = tbl_id;
@@ -1059,9 +1059,9 @@ wlc_lcnphy_common_read_table(phy_info_t * pi, uint32 tbl_id,
 }
 
 static void
-wlc_lcnphy_common_write_table(phy_info_t * pi, uint32 tbl_id,
-			      CONST void *tbl_ptr, uint32 tbl_len,
-			      uint32 tbl_width, uint32 tbl_offset)
+wlc_lcnphy_common_write_table(phy_info_t *pi, u32 tbl_id,
+			      const void *tbl_ptr, u32 tbl_len,
+			      u32 tbl_width, u32 tbl_offset)
 {
 
 	phytbl_info_t tab;
@@ -1073,10 +1073,10 @@ wlc_lcnphy_common_write_table(phy_info_t * pi, uint32 tbl_id,
 	wlc_lcnphy_write_table(pi, &tab);
 }
 
-static uint32
-wlc_lcnphy_qdiv_roundup(uint32 dividend, uint32 divisor, uint8 precision)
+static u32
+wlc_lcnphy_qdiv_roundup(u32 dividend, u32 divisor, u8 precision)
 {
-	uint32 quotient, remainder, roundup, rbit;
+	u32 quotient, remainder, roundup, rbit;
 
 	ASSERT(divisor);
 
@@ -1101,7 +1101,7 @@ wlc_lcnphy_qdiv_roundup(uint32 dividend, uint32 divisor, uint8 precision)
 	return quotient;
 }
 
-static int wlc_lcnphy_calc_floor(int16 coeff_x, int type)
+static int wlc_lcnphy_calc_floor(s16 coeff_x, int type)
 {
 	int k;
 	k = 0;
@@ -1121,23 +1121,23 @@ static int wlc_lcnphy_calc_floor(int16 coeff_x, int type)
 	return k;
 }
 
-int8 wlc_lcnphy_get_current_tx_pwr_idx(phy_info_t * pi)
+s8 wlc_lcnphy_get_current_tx_pwr_idx(phy_info_t *pi)
 {
-	int8 index;
+	s8 index;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	if (txpwrctrl_off(pi))
 		index = pi_lcn->lcnphy_current_index;
 	else if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi))
 		index =
-		    (int8) (wlc_lcnphy_get_current_tx_pwr_idx_if_pwrctrl_on(pi)
+		    (s8) (wlc_lcnphy_get_current_tx_pwr_idx_if_pwrctrl_on(pi)
 			    / 2);
 	else
 		index = pi_lcn->lcnphy_current_index;
 	return index;
 }
 
-static uint32 wlc_lcnphy_measure_digital_power(phy_info_t * pi, uint16 nsamples)
+static u32 wlc_lcnphy_measure_digital_power(phy_info_t *pi, u16 nsamples)
 {
 	lcnphy_iq_est_t iq_est = { 0, 0, 0 };
 
@@ -1146,9 +1146,9 @@ static uint32 wlc_lcnphy_measure_digital_power(phy_info_t * pi, uint16 nsamples)
 	return (iq_est.i_pwr + iq_est.q_pwr) / nsamples;
 }
 
-void wlc_lcnphy_crsuprs(phy_info_t * pi, int channel)
+void wlc_lcnphy_crsuprs(phy_info_t *pi, int channel)
 {
-	uint16 afectrlovr, afectrlovrval;
+	u16 afectrlovr, afectrlovrval;
 	afectrlovr = read_phy_reg(pi, 0x43b);
 	afectrlovrval = read_phy_reg(pi, 0x43c);
 	if (channel != 0) {
@@ -1177,9 +1177,9 @@ void wlc_lcnphy_crsuprs(phy_info_t * pi, int channel)
 	}
 }
 
-static void wlc_lcnphy_toggle_afe_pwdn(phy_info_t * pi)
+static void wlc_lcnphy_toggle_afe_pwdn(phy_info_t *pi)
 {
-	uint16 save_AfeCtrlOvrVal, save_AfeCtrlOvr;
+	u16 save_AfeCtrlOvrVal, save_AfeCtrlOvr;
 
 	save_AfeCtrlOvrVal = read_phy_reg(pi, 0x43c);
 	save_AfeCtrlOvr = read_phy_reg(pi, 0x43b);
@@ -1194,7 +1194,7 @@ static void wlc_lcnphy_toggle_afe_pwdn(phy_info_t * pi)
 	write_phy_reg(pi, 0x43b, save_AfeCtrlOvr);
 }
 
-static void wlc_lcnphy_txrx_spur_avoidance_mode(phy_info_t * pi, bool enable)
+static void wlc_lcnphy_txrx_spur_avoidance_mode(phy_info_t *pi, bool enable)
 {
 	if (enable) {
 		write_phy_reg(pi, 0x942, 0x7);
@@ -1213,9 +1213,9 @@ static void wlc_lcnphy_txrx_spur_avoidance_mode(phy_info_t * pi, bool enable)
 	wlapi_switch_macfreq(pi->sh->physhim, enable);
 }
 
-void wlc_phy_chanspec_set_lcnphy(phy_info_t * pi, chanspec_t chanspec)
+void wlc_phy_chanspec_set_lcnphy(phy_info_t *pi, chanspec_t chanspec)
 {
-	uint8 channel = CHSPEC_CHANNEL(chanspec);
+	u8 channel = CHSPEC_CHANNEL(chanspec);
 
 	wlc_phy_chanspec_radio_set((wlc_phy_t *) pi, chanspec);
 
@@ -1226,7 +1226,7 @@ void wlc_phy_chanspec_set_lcnphy(phy_info_t * pi, chanspec_t chanspec)
 
 	if (!NORADIO_ENAB(pi->pubpi)) {
 		wlc_lcnphy_radio_2064_channel_tune_4313(pi, channel);
-		OSL_DELAY(1000);
+		udelay(1000);
 	}
 
 	wlc_lcnphy_toggle_afe_pwdn(pi);
@@ -1237,22 +1237,22 @@ void wlc_phy_chanspec_set_lcnphy(phy_info_t * pi, chanspec_t chanspec)
 	if (CHSPEC_CHANNEL(pi->radio_chanspec) == 14) {
 		mod_phy_reg(pi, 0x448, (0x3 << 8), (2) << 8);
 
-		wlc_lcnphy_load_tx_iir_filter(pi, FALSE, 3);
+		wlc_lcnphy_load_tx_iir_filter(pi, false, 3);
 	} else {
 		mod_phy_reg(pi, 0x448, (0x3 << 8), (1) << 8);
 
-		wlc_lcnphy_load_tx_iir_filter(pi, FALSE, 2);
+		wlc_lcnphy_load_tx_iir_filter(pi, false, 2);
 	}
 
-	wlc_lcnphy_load_tx_iir_filter(pi, TRUE, 0);
+	wlc_lcnphy_load_tx_iir_filter(pi, true, 0);
 
 	mod_phy_reg(pi, 0x4eb, (0x7 << 3), (1) << 3);
 
 }
 
-static void wlc_lcnphy_set_dac_gain(phy_info_t * pi, uint16 dac_gain)
+static void wlc_lcnphy_set_dac_gain(phy_info_t *pi, u16 dac_gain)
 {
-	uint16 dac_ctrl;
+	u16 dac_ctrl;
 
 	dac_ctrl = (read_phy_reg(pi, 0x439) >> 0);
 	dac_ctrl = dac_ctrl & 0xc7f;
@@ -1261,9 +1261,9 @@ static void wlc_lcnphy_set_dac_gain(phy_info_t * pi, uint16 dac_gain)
 
 }
 
-static void wlc_lcnphy_set_tx_gain_override(phy_info_t * pi, bool bEnable)
+static void wlc_lcnphy_set_tx_gain_override(phy_info_t *pi, bool bEnable)
 {
-	uint16 bit = bEnable ? 1 : 0;
+	u16 bit = bEnable ? 1 : 0;
 
 	mod_phy_reg(pi, 0x4b0, (0x1 << 7), bit << 7);
 
@@ -1272,9 +1272,9 @@ static void wlc_lcnphy_set_tx_gain_override(phy_info_t * pi, bool bEnable)
 	mod_phy_reg(pi, 0x43b, (0x1 << 6), bit << 6);
 }
 
-static uint16 wlc_lcnphy_get_pa_gain(phy_info_t * pi)
+static u16 wlc_lcnphy_get_pa_gain(phy_info_t *pi)
 {
-	uint16 pa_gain;
+	u16 pa_gain;
 
 	pa_gain = (read_phy_reg(pi, 0x4fb) &
 		   LCNPHY_txgainctrlovrval1_pagain_ovr_val1_MASK) >>
@@ -1284,9 +1284,9 @@ static uint16 wlc_lcnphy_get_pa_gain(phy_info_t * pi)
 }
 
 static void
-wlc_lcnphy_set_tx_gain(phy_info_t * pi, lcnphy_txgains_t * target_gains)
+wlc_lcnphy_set_tx_gain(phy_info_t *pi, lcnphy_txgains_t *target_gains)
 {
-	uint16 pa_gain = wlc_lcnphy_get_pa_gain(pi);
+	u16 pa_gain = wlc_lcnphy_get_pa_gain(pi);
 
 	mod_phy_reg(pi, 0x4b5,
 		    (0xffff << 0),
@@ -1309,9 +1309,9 @@ wlc_lcnphy_set_tx_gain(phy_info_t * pi, lcnphy_txgains_t * target_gains)
 	wlc_lcnphy_enable_tx_gain_override(pi);
 }
 
-static void wlc_lcnphy_set_bbmult(phy_info_t * pi, uint8 m0)
+static void wlc_lcnphy_set_bbmult(phy_info_t *pi, u8 m0)
 {
-	uint16 m0m1 = (uint16) m0 << 8;
+	u16 m0m1 = (u16) m0 << 8;
 	phytbl_info_t tab;
 
 	tab.tbl_ptr = &m0m1;
@@ -1322,9 +1322,9 @@ static void wlc_lcnphy_set_bbmult(phy_info_t * pi, uint8 m0)
 	wlc_lcnphy_write_table(pi, &tab);
 }
 
-static void wlc_lcnphy_clear_tx_power_offsets(phy_info_t * pi)
+static void wlc_lcnphy_clear_tx_power_offsets(phy_info_t *pi)
 {
-	uint32 data_buf[64];
+	u32 data_buf[64];
 	phytbl_info_t tab;
 
 	bzero(data_buf, sizeof(data_buf));
@@ -1351,7 +1351,7 @@ typedef enum {
 	LCNPHY_TSSI_EXT
 } lcnphy_tssi_mode_t;
 
-static void wlc_lcnphy_set_tssi_mux(phy_info_t * pi, lcnphy_tssi_mode_t pos)
+static void wlc_lcnphy_set_tssi_mux(phy_info_t *pi, lcnphy_tssi_mode_t pos)
 {
 	mod_phy_reg(pi, 0x4d7, (0x1 << 0), (0x1) << 0);
 
@@ -1390,9 +1390,9 @@ static void wlc_lcnphy_set_tssi_mux(phy_info_t * pi, lcnphy_tssi_mode_t pos)
 	}
 }
 
-static uint16 wlc_lcnphy_rfseq_tbl_adc_pwrup(phy_info_t * pi)
+static u16 wlc_lcnphy_rfseq_tbl_adc_pwrup(phy_info_t *pi)
 {
-	uint16 N1, N2, N3, N4, N5, N6, N;
+	u16 N1, N2, N3, N4, N5, N6, N;
 	N1 = ((read_phy_reg(pi, 0x4a5) & (0xff << 0))
 	      >> 0);
 	N2 = 1 << ((read_phy_reg(pi, 0x4a5) & (0x7 << 12))
@@ -1411,9 +1411,9 @@ static uint16 wlc_lcnphy_rfseq_tbl_adc_pwrup(phy_info_t * pi)
 	return N;
 }
 
-static void wlc_lcnphy_pwrctrl_rssiparams(phy_info_t * pi)
+static void wlc_lcnphy_pwrctrl_rssiparams(phy_info_t *pi)
 {
-	uint16 auxpga_vmid, auxpga_vmid_temp, auxpga_gain_temp;
+	u16 auxpga_vmid, auxpga_vmid_temp, auxpga_gain_temp;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	auxpga_vmid =
@@ -1455,10 +1455,10 @@ static void wlc_lcnphy_pwrctrl_rssiparams(phy_info_t * pi)
 	mod_radio_reg(pi, RADIO_2064_REG082, (1 << 5), (1 << 5));
 }
 
-static void wlc_lcnphy_tssi_setup(phy_info_t * pi)
+static void wlc_lcnphy_tssi_setup(phy_info_t *pi)
 {
 	phytbl_info_t tab;
-	uint32 rfseq, ind;
+	u32 rfseq, ind;
 
 	tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
 	tab.tbl_width = 32;
@@ -1569,9 +1569,9 @@ static void wlc_lcnphy_tssi_setup(phy_info_t * pi)
 	wlc_lcnphy_pwrctrl_rssiparams(pi);
 }
 
-void wlc_lcnphy_tx_pwr_update_npt(phy_info_t * pi)
+void wlc_lcnphy_tx_pwr_update_npt(phy_info_t *pi)
 {
-	uint16 tx_cnt, tx_total, npt;
+	u16 tx_cnt, tx_total, npt;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	tx_total = wlc_lcnphy_total_tx_frames(pi);
@@ -1588,9 +1588,9 @@ void wlc_lcnphy_tx_pwr_update_npt(phy_info_t * pi)
 	}
 }
 
-int32 wlc_lcnphy_tssi2dbm(int32 tssi, int32 a1, int32 b0, int32 b1)
+s32 wlc_lcnphy_tssi2dbm(s32 tssi, s32 a1, s32 b0, s32 b1)
 {
-	int32 a, b, p;
+	s32 a, b, p;
 
 	a = 32768 + (a1 * tssi);
 	b = (1024 * b0) + (64 * b1 * tssi);
@@ -1599,7 +1599,7 @@ int32 wlc_lcnphy_tssi2dbm(int32 tssi, int32 a1, int32 b0, int32 b1)
 	return p;
 }
 
-static void wlc_lcnphy_txpower_reset_npt(phy_info_t * pi)
+static void wlc_lcnphy_txpower_reset_npt(phy_info_t *pi)
 {
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi))
@@ -1609,26 +1609,26 @@ static void wlc_lcnphy_txpower_reset_npt(phy_info_t * pi)
 	pi_lcn->lcnphy_tssi_npt = LCNPHY_TX_PWR_CTRL_START_NPT;
 }
 
-void wlc_lcnphy_txpower_recalc_target(phy_info_t * pi)
+void wlc_lcnphy_txpower_recalc_target(phy_info_t *pi)
 {
 	phytbl_info_t tab;
-	uint32 rate_table[WLC_NUM_RATES_CCK + WLC_NUM_RATES_OFDM +
+	u32 rate_table[WLC_NUM_RATES_CCK + WLC_NUM_RATES_OFDM +
 			  WLC_NUM_RATES_MCS_1_STREAM];
 	uint i, j;
 	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi))
 		return;
 
-	for (i = 0, j = 0; i < ARRAYSIZE(rate_table); i++, j++) {
+	for (i = 0, j = 0; i < ARRAY_SIZE(rate_table); i++, j++) {
 
 		if (i == WLC_NUM_RATES_CCK + WLC_NUM_RATES_OFDM)
 			j = TXP_FIRST_MCS_20_SISO;
 
-		rate_table[i] = (uint32) ((int32) (-pi->tx_power_offset[j]));
+		rate_table[i] = (u32) ((s32) (-pi->tx_power_offset[j]));
 	}
 
 	tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
 	tab.tbl_width = 32;
-	tab.tbl_len = ARRAYSIZE(rate_table);
+	tab.tbl_len = ARRAY_SIZE(rate_table);
 	tab.tbl_ptr = rate_table;
 	tab.tbl_offset = LCNPHY_TX_PWR_CTRL_RATE_OFFSET;
 	wlc_lcnphy_write_table(pi, &tab);
@@ -1640,12 +1640,12 @@ void wlc_lcnphy_txpower_recalc_target(phy_info_t * pi)
 	}
 }
 
-static void wlc_lcnphy_set_tx_pwr_soft_ctrl(phy_info_t * pi, int8 index)
+static void wlc_lcnphy_set_tx_pwr_soft_ctrl(phy_info_t *pi, s8 index)
 {
-	uint32 cck_offset[4] = { 22, 22, 22, 22 };
-	uint32 ofdm_offset, reg_offset_cck;
+	u32 cck_offset[4] = { 22, 22, 22, 22 };
+	u32 ofdm_offset, reg_offset_cck;
 	int i;
-	uint16 index2;
+	u16 index2;
 	phytbl_info_t tab;
 
 	if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi))
@@ -1686,19 +1686,19 @@ static void wlc_lcnphy_set_tx_pwr_soft_ctrl(phy_info_t * pi, int8 index)
 
 	mod_phy_reg(pi, 0x4a9, (0x1 << 15), (1) << 15);
 
-	index2 = (uint16) (index * 2);
+	index2 = (u16) (index * 2);
 	mod_phy_reg(pi, 0x4a9, (0x1ff << 0), (index2) << 0);
 
 	mod_phy_reg(pi, 0x6a3, (0x1 << 4), (0) << 4);
 
 }
 
-static int8 wlc_lcnphy_tempcompensated_txpwrctrl(phy_info_t * pi)
+static s8 wlc_lcnphy_tempcompensated_txpwrctrl(phy_info_t *pi)
 {
-	int8 index, delta_brd, delta_temp, new_index, tempcorrx;
-	int16 manp, meas_temp, temp_diff;
+	s8 index, delta_brd, delta_temp, new_index, tempcorrx;
+	s16 manp, meas_temp, temp_diff;
 	bool neg = 0;
-	uint16 temp;
+	u16 temp;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi))
@@ -1712,7 +1712,7 @@ static int8 wlc_lcnphy_tempcompensated_txpwrctrl(phy_info_t * pi)
 	if (pi_lcn->lcnphy_tempsense_slope == 0) {
 		return index;
 	}
-	temp = (uint16) wlc_lcnphy_tempsense(pi, 0);
+	temp = (u16) wlc_lcnphy_tempsense(pi, 0);
 	meas_temp = LCNPHY_TEMPSENSE(temp);
 
 	if (pi->tx_power_min != 0) {
@@ -1730,8 +1730,8 @@ static int8 wlc_lcnphy_tempcompensated_txpwrctrl(phy_info_t * pi)
 		temp_diff = -temp_diff;
 	}
 
-	delta_temp = (int8) wlc_lcnphy_qdiv_roundup((uint32) (temp_diff * 192),
-						    (uint32) (pi_lcn->
+	delta_temp = (s8) wlc_lcnphy_qdiv_roundup((u32) (temp_diff * 192),
+						    (u32) (pi_lcn->
 							      lcnphy_tempsense_slope
 							      * 10), 0);
 	if (neg)
@@ -1741,9 +1741,9 @@ static int8 wlc_lcnphy_tempcompensated_txpwrctrl(phy_info_t * pi)
 	    && LCNREV_IS(pi->pubpi.phy_rev, 0))
 		delta_temp = 0;
 	if (pi_lcn->lcnphy_tempcorrx > 31)
-		tempcorrx = (int8) (pi_lcn->lcnphy_tempcorrx - 64);
+		tempcorrx = (s8) (pi_lcn->lcnphy_tempcorrx - 64);
 	else
-		tempcorrx = (int8) pi_lcn->lcnphy_tempcorrx;
+		tempcorrx = (s8) pi_lcn->lcnphy_tempcorrx;
 	if (LCNREV_IS(pi->pubpi.phy_rev, 1))
 		tempcorrx = 4;
 	new_index =
@@ -1758,10 +1758,10 @@ static int8 wlc_lcnphy_tempcompensated_txpwrctrl(phy_info_t * pi)
 	return new_index;
 }
 
-static uint16 wlc_lcnphy_set_tx_pwr_ctrl_mode(phy_info_t * pi, uint16 mode)
+static u16 wlc_lcnphy_set_tx_pwr_ctrl_mode(phy_info_t *pi, u16 mode)
 {
 
-	uint16 current_mode = mode;
+	u16 current_mode = mode;
 	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi) &&
 	    mode == LCNPHY_TX_PWR_CTRL_HW)
 		current_mode = LCNPHY_TX_PWR_CTRL_TEMPBASED;
@@ -1771,10 +1771,10 @@ static uint16 wlc_lcnphy_set_tx_pwr_ctrl_mode(phy_info_t * pi, uint16 mode)
 	return current_mode;
 }
 
-void wlc_lcnphy_set_tx_pwr_ctrl(phy_info_t * pi, uint16 mode)
+void wlc_lcnphy_set_tx_pwr_ctrl(phy_info_t *pi, u16 mode)
 {
-	uint16 old_mode = wlc_lcnphy_get_tx_pwr_ctrl(pi);
-	int8 index;
+	u16 old_mode = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	s8 index;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	ASSERT((LCNPHY_TX_PWR_CTRL_OFF == mode) ||
@@ -1821,18 +1821,18 @@ void wlc_lcnphy_set_tx_pwr_ctrl(phy_info_t * pi, uint16 mode)
 		if (mode == LCNPHY_TX_PWR_CTRL_TEMPBASED) {
 			index = wlc_lcnphy_tempcompensated_txpwrctrl(pi);
 			wlc_lcnphy_set_tx_pwr_soft_ctrl(pi, index);
-			pi_lcn->lcnphy_current_index = (int8)
+			pi_lcn->lcnphy_current_index = (s8)
 			    ((read_phy_reg(pi, 0x4a9) & 0xFF) / 2);
 		}
 	}
 }
 
-static bool wlc_lcnphy_iqcal_wait(phy_info_t * pi)
+static bool wlc_lcnphy_iqcal_wait(phy_info_t *pi)
 {
 	uint delay_count = 0;
 
 	while (wlc_lcnphy_iqcal_active(pi)) {
-		OSL_DELAY(100);
+		udelay(100);
 		delay_count++;
 
 		if (delay_count > (10 * 500))
@@ -1843,46 +1843,47 @@ static bool wlc_lcnphy_iqcal_wait(phy_info_t * pi)
 }
 
 static void
-wlc_lcnphy_tx_iqlo_cal(phy_info_t * pi,
-		       lcnphy_txgains_t * target_gains,
+wlc_lcnphy_tx_iqlo_cal(phy_info_t *pi,
+		       lcnphy_txgains_t *target_gains,
 		       lcnphy_cal_mode_t cal_mode, bool keep_tone)
 {
 
 	lcnphy_txgains_t cal_gains, temp_gains;
-	uint16 hash;
-	uint8 band_idx;
+	u16 hash;
+	u8 band_idx;
 	int j;
-	uint16 ncorr_override[5];
-	uint16 syst_coeffs[] = { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	u16 ncorr_override[5];
+	u16 syst_coeffs[] = { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 		0x0000, 0x0000, 0x0000, 0x0000, 0x0000
 	};
 
-	uint16 commands_fullcal[] =
-	    { 0x8434, 0x8334, 0x8084, 0x8267, 0x8056, 0x8234 };
+	u16 commands_fullcal[] = {
+		0x8434, 0x8334, 0x8084, 0x8267, 0x8056, 0x8234 };
 
-	uint16 commands_recal[] =
-	    { 0x8434, 0x8334, 0x8084, 0x8267, 0x8056, 0x8234 };
+	u16 commands_recal[] = {
+		0x8434, 0x8334, 0x8084, 0x8267, 0x8056, 0x8234 };
 
-	uint16 command_nums_fullcal[] =
-	    { 0x7a97, 0x7a97, 0x7a97, 0x7a87, 0x7a87, 0x7b97 };
+	u16 command_nums_fullcal[] = {
+		0x7a97, 0x7a97, 0x7a97, 0x7a87, 0x7a87, 0x7b97 };
 
-	uint16 command_nums_recal[] =
-	    { 0x7a97, 0x7a97, 0x7a97, 0x7a87, 0x7a87, 0x7b97 };
-	uint16 *command_nums = command_nums_fullcal;
+	u16 command_nums_recal[] = {
+		0x7a97, 0x7a97, 0x7a97, 0x7a87, 0x7a87, 0x7b97 };
+	u16 *command_nums = command_nums_fullcal;
 
-	uint16 *start_coeffs = NULL, *cal_cmds = NULL, cal_type, diq_start;
-	uint16 tx_pwr_ctrl_old, save_txpwrctrlrfctrl2;
-	uint16 save_sslpnCalibClkEnCtrl, save_sslpnRxFeClkEnCtrl;
+	u16 *start_coeffs = NULL, *cal_cmds = NULL, cal_type, diq_start;
+	u16 tx_pwr_ctrl_old, save_txpwrctrlrfctrl2;
+	u16 save_sslpnCalibClkEnCtrl, save_sslpnRxFeClkEnCtrl;
 	bool tx_gain_override_old;
 	lcnphy_txgains_t old_gains;
 	uint i, n_cal_cmds = 0, n_cal_start = 0;
-	uint16 *values_to_save;
+	u16 *values_to_save;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
 
-	if (NULL == (values_to_save = MALLOC(pi->sh->osh, sizeof(uint16) * 20))) {
+	values_to_save = kmalloc(sizeof(u16) * 20, GFP_ATOMIC);
+	if (NULL == values_to_save) {
 		return;
 	}
 
@@ -1896,7 +1897,7 @@ wlc_lcnphy_tx_iqlo_cal(phy_info_t * pi,
 	case LCNPHY_CAL_FULL:
 		start_coeffs = syst_coeffs;
 		cal_cmds = commands_fullcal;
-		n_cal_cmds = ARRAYSIZE(commands_fullcal);
+		n_cal_cmds = ARRAY_SIZE(commands_fullcal);
 		break;
 
 	case LCNPHY_CAL_RECAL:
@@ -1905,11 +1906,11 @@ wlc_lcnphy_tx_iqlo_cal(phy_info_t * pi,
 		start_coeffs = syst_coeffs;
 
 		cal_cmds = commands_recal;
-		n_cal_cmds = ARRAYSIZE(commands_recal);
+		n_cal_cmds = ARRAY_SIZE(commands_recal);
 		command_nums = command_nums_recal;
 		break;
 	default:
-		ASSERT(FALSE);
+		ASSERT(false);
 	}
 
 	wlc_lcnphy_common_write_table(pi, LCNPHY_TBL_ID_IQLOCAL,
@@ -1971,20 +1972,20 @@ wlc_lcnphy_tx_iqlo_cal(phy_info_t * pi,
 	write_phy_reg(pi, 0x93d, 0xc0);
 
 	wlc_lcnphy_common_write_table(pi, LCNPHY_TBL_ID_IQLOCAL,
-				      (CONST void *)
+				      (const void *)
 				      lcnphy_iqcal_loft_gainladder,
-				      ARRAYSIZE(lcnphy_iqcal_loft_gainladder),
+				      ARRAY_SIZE(lcnphy_iqcal_loft_gainladder),
 				      16, 0);
 
 	wlc_lcnphy_common_write_table(pi, LCNPHY_TBL_ID_IQLOCAL,
-				      (CONST void *)lcnphy_iqcal_ir_gainladder,
-				      ARRAYSIZE(lcnphy_iqcal_ir_gainladder), 16,
+				      (const void *)lcnphy_iqcal_ir_gainladder,
+				      ARRAY_SIZE(lcnphy_iqcal_ir_gainladder), 16,
 				      32);
 
 	if (pi->phy_tx_tone_freq) {
 
 		wlc_lcnphy_stop_tx_tone(pi);
-		OSL_DELAY(5);
+		udelay(5);
 		wlc_lcnphy_start_tx_tone(pi, 3750, 88, 1);
 	} else {
 		wlc_lcnphy_start_tx_tone(pi, 3750, 88, 1);
@@ -1993,9 +1994,9 @@ wlc_lcnphy_tx_iqlo_cal(phy_info_t * pi,
 	write_phy_reg(pi, 0x6da, 0xffff);
 
 	for (i = n_cal_start; i < n_cal_cmds; i++) {
-		uint16 zero_diq = 0;
-		uint16 best_coeffs[11];
-		uint16 command_num;
+		u16 zero_diq = 0;
+		u16 best_coeffs[11];
+		u16 command_num;
 
 		cal_type = (cal_cmds[i] & 0x0f00) >> 8;
 
@@ -2025,10 +2026,10 @@ wlc_lcnphy_tx_iqlo_cal(phy_info_t * pi,
 
 		wlc_lcnphy_common_read_table(pi, LCNPHY_TBL_ID_IQLOCAL,
 					     best_coeffs,
-					     ARRAYSIZE(best_coeffs), 16, 96);
+					     ARRAY_SIZE(best_coeffs), 16, 96);
 		wlc_lcnphy_common_write_table(pi, LCNPHY_TBL_ID_IQLOCAL,
 					      best_coeffs,
-					      ARRAYSIZE(best_coeffs), 16, 64);
+					      ARRAY_SIZE(best_coeffs), 16, 64);
 
 		if ((cal_type == 3) || (cal_type == 4)) {
 			wlc_lcnphy_common_write_table(pi, LCNPHY_TBL_ID_IQLOCAL,
@@ -2037,7 +2038,7 @@ wlc_lcnphy_tx_iqlo_cal(phy_info_t * pi,
 		wlc_lcnphy_common_read_table(pi, LCNPHY_TBL_ID_IQLOCAL,
 					     pi_lcn->lcnphy_cal_results.
 					     txiqlocal_bestcoeffs,
-					     ARRAYSIZE(pi_lcn->
+					     ARRAY_SIZE(pi_lcn->
 						       lcnphy_cal_results.
 						       txiqlocal_bestcoeffs),
 					     16, 96);
@@ -2046,9 +2047,9 @@ wlc_lcnphy_tx_iqlo_cal(phy_info_t * pi,
 	wlc_lcnphy_common_read_table(pi, LCNPHY_TBL_ID_IQLOCAL,
 				     pi_lcn->lcnphy_cal_results.
 				     txiqlocal_bestcoeffs,
-				     ARRAYSIZE(pi_lcn->lcnphy_cal_results.
+				     ARRAY_SIZE(pi_lcn->lcnphy_cal_results.
 					       txiqlocal_bestcoeffs), 16, 96);
-	pi_lcn->lcnphy_cal_results.txiqlocal_bestcoeffs_valid = TRUE;
+	pi_lcn->lcnphy_cal_results.txiqlocal_bestcoeffs_valid = true;
 
 	wlc_lcnphy_common_write_table(pi, LCNPHY_TBL_ID_IQLOCAL,
 				      &pi_lcn->lcnphy_cal_results.
@@ -2060,7 +2061,7 @@ wlc_lcnphy_tx_iqlo_cal(phy_info_t * pi,
 
  cleanup:
 	wlc_lcnphy_tx_iqlo_loopback_cleanup(pi, values_to_save);
-	MFREE(pi->sh->osh, values_to_save, 20 * sizeof(uint16));
+	kfree(values_to_save);
 
 	if (!keep_tone)
 		wlc_lcnphy_stop_tx_tone(pi);
@@ -2078,19 +2079,19 @@ wlc_lcnphy_tx_iqlo_cal(phy_info_t * pi,
 
 }
 
-static void wlc_lcnphy_idle_tssi_est(wlc_phy_t * ppi)
+static void wlc_lcnphy_idle_tssi_est(wlc_phy_t *ppi)
 {
 	bool suspend, tx_gain_override_old;
 	lcnphy_txgains_t old_gains;
 	phy_info_t *pi = (phy_info_t *) ppi;
-	uint16 idleTssi, idleTssi0_2C, idleTssi0_OB, idleTssi0_regvalue_OB,
+	u16 idleTssi, idleTssi0_2C, idleTssi0_OB, idleTssi0_regvalue_OB,
 	    idleTssi0_regvalue_2C;
-	uint16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
-	uint16 SAVE_lpfgain = read_radio_reg(pi, RADIO_2064_REG112);
-	uint16 SAVE_jtag_bb_afe_switch =
+	u16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	u16 SAVE_lpfgain = read_radio_reg(pi, RADIO_2064_REG112);
+	u16 SAVE_jtag_bb_afe_switch =
 	    read_radio_reg(pi, RADIO_2064_REG007) & 1;
-	uint16 SAVE_jtag_auxpga = read_radio_reg(pi, RADIO_2064_REG0FF) & 0x10;
-	uint16 SAVE_iqadc_aux_en = read_radio_reg(pi, RADIO_2064_REG11F) & 4;
+	u16 SAVE_jtag_auxpga = read_radio_reg(pi, RADIO_2064_REG0FF) & 0x10;
+	u16 SAVE_iqadc_aux_en = read_radio_reg(pi, RADIO_2064_REG11F) & 4;
 	idleTssi = read_phy_reg(pi, 0x4ab);
 	suspend =
 	    (0 ==
@@ -2110,7 +2111,7 @@ static void wlc_lcnphy_idle_tssi_est(wlc_phy_t * ppi)
 	mod_radio_reg(pi, RADIO_2064_REG0FF, 0x10, 1 << 4);
 	mod_radio_reg(pi, RADIO_2064_REG11F, 0x4, 1 << 2);
 	wlc_lcnphy_tssi_setup(pi);
-	wlc_phy_do_dummy_tx(pi, TRUE, OFF);
+	wlc_phy_do_dummy_tx(pi, true, OFF);
 	idleTssi = ((read_phy_reg(pi, 0x4ab) & (0x1ff << 0))
 		    >> 0);
 
@@ -2144,28 +2145,28 @@ static void wlc_lcnphy_idle_tssi_est(wlc_phy_t * ppi)
 		wlapi_enable_mac(pi->sh->physhim);
 }
 
-static void wlc_lcnphy_vbat_temp_sense_setup(phy_info_t * pi, uint8 mode)
+static void wlc_lcnphy_vbat_temp_sense_setup(phy_info_t *pi, u8 mode)
 {
 	bool suspend;
-	uint16 save_txpwrCtrlEn;
-	uint8 auxpga_vmidcourse, auxpga_vmidfine, auxpga_gain;
-	uint16 auxpga_vmid;
+	u16 save_txpwrCtrlEn;
+	u8 auxpga_vmidcourse, auxpga_vmidfine, auxpga_gain;
+	u16 auxpga_vmid;
 	phytbl_info_t tab;
-	uint32 val;
-	uint8 save_reg007, save_reg0FF, save_reg11F, save_reg005, save_reg025,
+	u32 val;
+	u8 save_reg007, save_reg0FF, save_reg11F, save_reg005, save_reg025,
 	    save_reg112;
-	uint16 values_to_save[14];
-	int8 index;
+	u16 values_to_save[14];
+	s8 index;
 	int i;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
-	OSL_DELAY(999);
+	udelay(999);
 
-	save_reg007 = (uint8) read_radio_reg(pi, RADIO_2064_REG007);
-	save_reg0FF = (uint8) read_radio_reg(pi, RADIO_2064_REG0FF);
-	save_reg11F = (uint8) read_radio_reg(pi, RADIO_2064_REG11F);
-	save_reg005 = (uint8) read_radio_reg(pi, RADIO_2064_REG005);
-	save_reg025 = (uint8) read_radio_reg(pi, RADIO_2064_REG025);
-	save_reg112 = (uint8) read_radio_reg(pi, RADIO_2064_REG112);
+	save_reg007 = (u8) read_radio_reg(pi, RADIO_2064_REG007);
+	save_reg0FF = (u8) read_radio_reg(pi, RADIO_2064_REG0FF);
+	save_reg11F = (u8) read_radio_reg(pi, RADIO_2064_REG11F);
+	save_reg005 = (u8) read_radio_reg(pi, RADIO_2064_REG005);
+	save_reg025 = (u8) read_radio_reg(pi, RADIO_2064_REG025);
+	save_reg112 = (u8) read_radio_reg(pi, RADIO_2064_REG112);
 
 	for (i = 0; i < 14; i++)
 		values_to_save[i] = read_phy_reg(pi, tempsense_phy_regs[i]);
@@ -2253,7 +2254,7 @@ static void wlc_lcnphy_vbat_temp_sense_setup(phy_info_t * pi, uint8 mode)
 		auxpga_gain = 2;
 	}
 	auxpga_vmid =
-	    (uint16) ((2 << 8) | (auxpga_vmidcourse << 4) | auxpga_vmidfine);
+	    (u16) ((2 << 8) | (auxpga_vmidcourse << 4) | auxpga_vmidfine);
 	mod_phy_reg(pi, 0x4d8, (0x1 << 0), (1) << 0);
 
 	mod_phy_reg(pi, 0x4d8, (0x3ff << 2), (auxpga_vmid) << 2);
@@ -2266,16 +2267,16 @@ static void wlc_lcnphy_vbat_temp_sense_setup(phy_info_t * pi, uint8 mode)
 
 	write_radio_reg(pi, RADIO_2064_REG112, 0x6);
 
-	wlc_phy_do_dummy_tx(pi, TRUE, OFF);
+	wlc_phy_do_dummy_tx(pi, true, OFF);
 	if (!tempsense_done(pi))
-		OSL_DELAY(10);
-
-	write_radio_reg(pi, RADIO_2064_REG007, (uint16) save_reg007);
-	write_radio_reg(pi, RADIO_2064_REG0FF, (uint16) save_reg0FF);
-	write_radio_reg(pi, RADIO_2064_REG11F, (uint16) save_reg11F);
-	write_radio_reg(pi, RADIO_2064_REG005, (uint16) save_reg005);
-	write_radio_reg(pi, RADIO_2064_REG025, (uint16) save_reg025);
-	write_radio_reg(pi, RADIO_2064_REG112, (uint16) save_reg112);
+		udelay(10);
+
+	write_radio_reg(pi, RADIO_2064_REG007, (u16) save_reg007);
+	write_radio_reg(pi, RADIO_2064_REG0FF, (u16) save_reg0FF);
+	write_radio_reg(pi, RADIO_2064_REG11F, (u16) save_reg11F);
+	write_radio_reg(pi, RADIO_2064_REG005, (u16) save_reg005);
+	write_radio_reg(pi, RADIO_2064_REG025, (u16) save_reg025);
+	write_radio_reg(pi, RADIO_2064_REG112, (u16) save_reg112);
 	for (i = 0; i < 14; i++)
 		write_phy_reg(pi, tempsense_phy_regs[i], values_to_save[i]);
 	wlc_lcnphy_set_tx_pwr_by_index(pi, (int)index);
@@ -2283,15 +2284,16 @@ static void wlc_lcnphy_vbat_temp_sense_setup(phy_info_t * pi, uint8 mode)
 	write_radio_reg(pi, 0x4a4, save_txpwrCtrlEn);
 	if (!suspend)
 		wlapi_enable_mac(pi->sh->physhim);
-	OSL_DELAY(999);
+	udelay(999);
 }
 
-void WLBANDINITFN(wlc_lcnphy_tx_pwr_ctrl_init) (wlc_phy_t * ppi) {
+void WLBANDINITFN(wlc_lcnphy_tx_pwr_ctrl_init) (wlc_phy_t *ppi)
+{
 	lcnphy_txgains_t tx_gains;
-	uint8 bbmult;
+	u8 bbmult;
 	phytbl_info_t tab;
-	int32 a1, b0, b1;
-	int32 tssi, pwr, maxtargetpwr, mintargetpwr;
+	s32 a1, b0, b1;
+	s32 tssi, pwr, maxtargetpwr, mintargetpwr;
 	bool suspend;
 	phy_info_t *pi = (phy_info_t *) ppi;
 
@@ -2363,9 +2365,9 @@ void WLBANDINITFN(wlc_lcnphy_tx_pwr_ctrl_init) (wlc_phy_t * ppi) {
 		wlapi_enable_mac(pi->sh->physhim);
 }
 
-static uint8 wlc_lcnphy_get_bbmult(phy_info_t * pi)
+static u8 wlc_lcnphy_get_bbmult(phy_info_t *pi)
 {
-	uint16 m0m1;
+	u16 m0m1;
 	phytbl_info_t tab;
 
 	tab.tbl_ptr = &m0m1;
@@ -2375,10 +2377,10 @@ static uint8 wlc_lcnphy_get_bbmult(phy_info_t * pi)
 	tab.tbl_width = 16;
 	wlc_lcnphy_read_table(pi, &tab);
 
-	return (uint8) ((m0m1 & 0xff00) >> 8);
+	return (u8) ((m0m1 & 0xff00) >> 8);
 }
 
-static void wlc_lcnphy_set_pa_gain(phy_info_t * pi, uint16 gain)
+static void wlc_lcnphy_set_pa_gain(phy_info_t *pi, u16 gain)
 {
 	mod_phy_reg(pi, 0x4fb,
 		    LCNPHY_txgainctrlovrval1_pagain_ovr_val1_MASK,
@@ -2389,8 +2391,8 @@ static void wlc_lcnphy_set_pa_gain(phy_info_t * pi, uint16 gain)
 }
 
 void
-wlc_lcnphy_get_radio_loft(phy_info_t * pi,
-			  uint8 * ei0, uint8 * eq0, uint8 * fi0, uint8 * fq0)
+wlc_lcnphy_get_radio_loft(phy_info_t *pi,
+			  u8 *ei0, u8 *eq0, u8 *fi0, u8 *fq0)
 {
 	*ei0 = LCNPHY_IQLOCC_READ(read_radio_reg(pi, RADIO_2064_REG089));
 	*eq0 = LCNPHY_IQLOCC_READ(read_radio_reg(pi, RADIO_2064_REG08A));
@@ -2398,15 +2400,15 @@ wlc_lcnphy_get_radio_loft(phy_info_t * pi,
 	*fq0 = LCNPHY_IQLOCC_READ(read_radio_reg(pi, RADIO_2064_REG08C));
 }
 
-static void wlc_lcnphy_get_tx_gain(phy_info_t * pi, lcnphy_txgains_t * gains)
+static void wlc_lcnphy_get_tx_gain(phy_info_t *pi, lcnphy_txgains_t *gains)
 {
-	uint16 dac_gain;
+	u16 dac_gain;
 
 	dac_gain = read_phy_reg(pi, 0x439) >> 0;
 	gains->dac_gain = (dac_gain & 0x380) >> 7;
 
 	{
-		uint16 rfgain0, rfgain1;
+		u16 rfgain0, rfgain1;
 
 		rfgain0 = (read_phy_reg(pi, 0x4b5) & (0xffff << 0)) >> 0;
 		rfgain1 = (read_phy_reg(pi, 0x4fb) & (0x7fff << 0)) >> 0;
@@ -2417,10 +2419,10 @@ static void wlc_lcnphy_get_tx_gain(phy_info_t * pi, lcnphy_txgains_t * gains)
 	}
 }
 
-void wlc_lcnphy_set_tx_iqcc(phy_info_t * pi, uint16 a, uint16 b)
+void wlc_lcnphy_set_tx_iqcc(phy_info_t *pi, u16 a, u16 b)
 {
 	phytbl_info_t tab;
-	uint16 iqcc[2];
+	u16 iqcc[2];
 
 	iqcc[0] = a;
 	iqcc[1] = b;
@@ -2433,7 +2435,7 @@ void wlc_lcnphy_set_tx_iqcc(phy_info_t * pi, uint16 a, uint16 b)
 	wlc_lcnphy_write_table(pi, &tab);
 }
 
-void wlc_lcnphy_set_tx_locc(phy_info_t * pi, uint16 didq)
+void wlc_lcnphy_set_tx_locc(phy_info_t *pi, u16 didq)
 {
 	phytbl_info_t tab;
 
@@ -2445,19 +2447,19 @@ void wlc_lcnphy_set_tx_locc(phy_info_t * pi, uint16 didq)
 	wlc_lcnphy_write_table(pi, &tab);
 }
 
-void wlc_lcnphy_set_tx_pwr_by_index(phy_info_t * pi, int index)
+void wlc_lcnphy_set_tx_pwr_by_index(phy_info_t *pi, int index)
 {
 	phytbl_info_t tab;
-	uint16 a, b;
-	uint8 bb_mult;
-	uint32 bbmultiqcomp, txgain, locoeffs, rfpower;
+	u16 a, b;
+	u8 bb_mult;
+	u32 bbmultiqcomp, txgain, locoeffs, rfpower;
 	lcnphy_txgains_t gains;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	ASSERT(index <= LCNPHY_MAX_TX_POWER_INDEX);
 
-	pi_lcn->lcnphy_tx_power_idx_override = (int8) index;
-	pi_lcn->lcnphy_current_index = (uint8) index;
+	pi_lcn->lcnphy_tx_power_idx_override = (s8) index;
+	pi_lcn->lcnphy_current_index = (u8) index;
 
 	tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
 	tab.tbl_width = 32;
@@ -2474,29 +2476,29 @@ void wlc_lcnphy_set_tx_pwr_by_index(phy_info_t * pi, int index)
 	tab.tbl_ptr = &txgain;
 	wlc_lcnphy_read_table(pi, &tab);
 
-	gains.gm_gain = (uint16) (txgain & 0xff);
-	gains.pga_gain = (uint16) (txgain >> 8) & 0xff;
-	gains.pad_gain = (uint16) (txgain >> 16) & 0xff;
-	gains.dac_gain = (uint16) (bbmultiqcomp >> 28) & 0x07;
+	gains.gm_gain = (u16) (txgain & 0xff);
+	gains.pga_gain = (u16) (txgain >> 8) & 0xff;
+	gains.pad_gain = (u16) (txgain >> 16) & 0xff;
+	gains.dac_gain = (u16) (bbmultiqcomp >> 28) & 0x07;
 	wlc_lcnphy_set_tx_gain(pi, &gains);
-	wlc_lcnphy_set_pa_gain(pi, (uint16) (txgain >> 24) & 0x7f);
+	wlc_lcnphy_set_pa_gain(pi, (u16) (txgain >> 24) & 0x7f);
 
-	bb_mult = (uint8) ((bbmultiqcomp >> 20) & 0xff);
+	bb_mult = (u8) ((bbmultiqcomp >> 20) & 0xff);
 	wlc_lcnphy_set_bbmult(pi, bb_mult);
 
 	wlc_lcnphy_enable_tx_gain_override(pi);
 
 	if (!wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi)) {
 
-		a = (uint16) ((bbmultiqcomp >> 10) & 0x3ff);
-		b = (uint16) (bbmultiqcomp & 0x3ff);
+		a = (u16) ((bbmultiqcomp >> 10) & 0x3ff);
+		b = (u16) (bbmultiqcomp & 0x3ff);
 		wlc_lcnphy_set_tx_iqcc(pi, a, b);
 
 		tab.tbl_offset = LCNPHY_TX_PWR_CTRL_LO_OFFSET + index;
 		tab.tbl_ptr = &locoeffs;
 		wlc_lcnphy_read_table(pi, &tab);
 
-		wlc_lcnphy_set_tx_locc(pi, (uint16) locoeffs);
+		wlc_lcnphy_set_tx_locc(pi, (u16) locoeffs);
 
 		tab.tbl_offset = LCNPHY_TX_PWR_CTRL_PWR_OFFSET + index;
 		tab.tbl_ptr = &rfpower;
@@ -2506,7 +2508,7 @@ void wlc_lcnphy_set_tx_pwr_by_index(phy_info_t * pi, int index)
 	}
 }
 
-static void wlc_lcnphy_set_trsw_override(phy_info_t * pi, bool tx, bool rx)
+static void wlc_lcnphy_set_trsw_override(phy_info_t *pi, bool tx, bool rx)
 {
 
 	mod_phy_reg(pi, 0x44d,
@@ -2516,11 +2518,11 @@ static void wlc_lcnphy_set_trsw_override(phy_info_t * pi, bool tx, bool rx)
 	or_phy_reg(pi, 0x44c, (0x1 << 1) | (0x1 << 0));
 }
 
-static void wlc_lcnphy_clear_papd_comptable(phy_info_t * pi)
+static void wlc_lcnphy_clear_papd_comptable(phy_info_t *pi)
 {
-	uint32 j;
+	u32 j;
 	phytbl_info_t tab;
-	uint32 temp_offset[128];
+	u32 temp_offset[128];
 	tab.tbl_ptr = temp_offset;
 	tab.tbl_len = 128;
 	tab.tbl_id = LCNPHY_TBL_ID_PAPDCOMPDELTATBL;
@@ -2536,14 +2538,14 @@ static void wlc_lcnphy_clear_papd_comptable(phy_info_t * pi)
 }
 
 static void
-wlc_lcnphy_set_rx_gain_by_distribution(phy_info_t * pi,
-				       uint16 trsw,
-				       uint16 ext_lna,
-				       uint16 biq2,
-				       uint16 biq1,
-				       uint16 tia, uint16 lna2, uint16 lna1)
+wlc_lcnphy_set_rx_gain_by_distribution(phy_info_t *pi,
+				       u16 trsw,
+				       u16 ext_lna,
+				       u16 biq2,
+				       u16 biq1,
+				       u16 tia, u16 lna2, u16 lna1)
 {
-	uint16 gain0_15, gain16_19;
+	u16 gain0_15, gain16_19;
 
 	gain16_19 = biq2 & 0xf;
 	gain0_15 = ((biq1 & 0xf) << 12) |
@@ -2570,9 +2572,9 @@ wlc_lcnphy_set_rx_gain_by_distribution(phy_info_t * pi,
 
 }
 
-static void wlc_lcnphy_rx_gain_override_enable(phy_info_t * pi, bool enable)
+static void wlc_lcnphy_rx_gain_override_enable(phy_info_t *pi, bool enable)
 {
-	uint16 ebit = enable ? 1 : 0;
+	u16 ebit = enable ? 1 : 0;
 
 	mod_phy_reg(pi, 0x4b0, (0x1 << 8), ebit << 8);
 
@@ -2595,31 +2597,31 @@ static void wlc_lcnphy_rx_gain_override_enable(phy_info_t * pi, bool enable)
 	}
 }
 
-void wlc_lcnphy_tx_pu(phy_info_t * pi, bool bEnable)
+void wlc_lcnphy_tx_pu(phy_info_t *pi, bool bEnable)
 {
 	if (!bEnable) {
 
-		and_phy_reg(pi, 0x43b, ~(uint16) ((0x1 << 1) | (0x1 << 4)));
+		and_phy_reg(pi, 0x43b, ~(u16) ((0x1 << 1) | (0x1 << 4)));
 
 		mod_phy_reg(pi, 0x43c, (0x1 << 1), 1 << 1);
 
 		and_phy_reg(pi, 0x44c,
-			    ~(uint16) ((0x1 << 3) |
+			    ~(u16) ((0x1 << 3) |
 				       (0x1 << 5) |
 				       (0x1 << 12) |
 				       (0x1 << 0) | (0x1 << 1) | (0x1 << 2)));
 
 		and_phy_reg(pi, 0x44d,
-			    ~(uint16) ((0x1 << 3) | (0x1 << 5) | (0x1 << 14)));
+			    ~(u16) ((0x1 << 3) | (0x1 << 5) | (0x1 << 14)));
 		mod_phy_reg(pi, 0x44d, (0x1 << 2), 1 << 2);
 
 		mod_phy_reg(pi, 0x44d, (0x1 << 1) | (0x1 << 0), (0x1 << 0));
 
 		and_phy_reg(pi, 0x4f9,
-			    ~(uint16) ((0x1 << 0) | (0x1 << 1) | (0x1 << 2)));
+			    ~(u16) ((0x1 << 0) | (0x1 << 1) | (0x1 << 2)));
 
 		and_phy_reg(pi, 0x4fa,
-			    ~(uint16) ((0x1 << 0) | (0x1 << 1) | (0x1 << 2)));
+			    ~(u16) ((0x1 << 0) | (0x1 << 1) | (0x1 << 2)));
 	} else {
 
 		mod_phy_reg(pi, 0x43b, (0x1 << 1), 1 << 1);
@@ -2631,7 +2633,7 @@ void wlc_lcnphy_tx_pu(phy_info_t * pi, bool bEnable)
 		mod_phy_reg(pi, 0x44c, (0x1 << 12), 1 << 12);
 		mod_phy_reg(pi, 0x44d, (0x1 << 14), 1 << 14);
 
-		wlc_lcnphy_set_trsw_override(pi, TRUE, FALSE);
+		wlc_lcnphy_set_trsw_override(pi, true, false);
 
 		mod_phy_reg(pi, 0x44d, (0x1 << 2), 0 << 2);
 		mod_phy_reg(pi, 0x44c, (0x1 << 2), 1 << 2);
@@ -2673,9 +2675,9 @@ void wlc_lcnphy_tx_pu(phy_info_t * pi, bool bEnable)
 }
 
 static void
-wlc_lcnphy_run_samples(phy_info_t * pi,
-		       uint16 num_samps,
-		       uint16 num_loops, uint16 wait, bool iqcalmode)
+wlc_lcnphy_run_samples(phy_info_t *pi,
+		       u16 num_samps,
+		       u16 num_loops, u16 wait, bool iqcalmode)
 {
 
 	or_phy_reg(pi, 0x6da, 0x8080);
@@ -2689,7 +2691,7 @@ wlc_lcnphy_run_samples(phy_info_t * pi,
 
 	if (iqcalmode) {
 
-		and_phy_reg(pi, 0x453, (uint16) ~ (0x1 << 15));
+		and_phy_reg(pi, 0x453, (u16) ~(0x1 << 15));
 		or_phy_reg(pi, 0x453, (0x1 << 15));
 	} else {
 		write_phy_reg(pi, 0x63f, 1);
@@ -2699,10 +2701,10 @@ wlc_lcnphy_run_samples(phy_info_t * pi,
 	or_radio_reg(pi, RADIO_2064_REG112, 0x6);
 }
 
-void wlc_lcnphy_deaf_mode(phy_info_t * pi, bool mode)
+void wlc_lcnphy_deaf_mode(phy_info_t *pi, bool mode)
 {
 
-	uint8 phybw40;
+	u8 phybw40;
 	phybw40 = CHSPEC_IS40(pi->radio_chanspec);
 
 	if (LCNREV_LT(pi->pubpi.phy_rev, 2)) {
@@ -2724,29 +2726,29 @@ void wlc_lcnphy_deaf_mode(phy_info_t * pi, bool mode)
 }
 
 void
-wlc_lcnphy_start_tx_tone(phy_info_t * pi, int32 f_kHz, uint16 max_val,
+wlc_lcnphy_start_tx_tone(phy_info_t *pi, s32 f_kHz, u16 max_val,
 			 bool iqcalmode)
 {
-	uint8 phy_bw;
-	uint16 num_samps, t, k;
-	uint32 bw;
+	u8 phy_bw;
+	u16 num_samps, t, k;
+	u32 bw;
 	fixed theta = 0, rot = 0;
-	cint32 tone_samp;
-	uint32 data_buf[64];
-	uint16 i_samp, q_samp;
+	cs32 tone_samp;
+	u32 data_buf[64];
+	u16 i_samp, q_samp;
 	phytbl_info_t tab;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	pi->phy_tx_tone_freq = f_kHz;
 
-	wlc_lcnphy_deaf_mode(pi, TRUE);
+	wlc_lcnphy_deaf_mode(pi, true);
 
 	phy_bw = 40;
 	if (pi_lcn->lcnphy_spurmod) {
 		write_phy_reg(pi, 0x942, 0x2);
 		write_phy_reg(pi, 0x93b, 0x0);
 		write_phy_reg(pi, 0x93c, 0x0);
-		wlc_lcnphy_txrx_spur_avoidance_mode(pi, FALSE);
+		wlc_lcnphy_txrx_spur_avoidance_mode(pi, false);
 	}
 
 	if (f_kHz) {
@@ -2754,9 +2756,9 @@ wlc_lcnphy_start_tx_tone(phy_info_t * pi, int32 f_kHz, uint16 max_val,
 		do {
 			bw = phy_bw * 1000 * k;
 			num_samps = bw / ABS(f_kHz);
-			ASSERT(num_samps <= ARRAYSIZE(data_buf));
+			ASSERT(num_samps <= ARRAY_SIZE(data_buf));
 			k++;
-		} while ((num_samps * (uint32) (ABS(f_kHz))) != bw);
+		} while ((num_samps * (u32) (ABS(f_kHz))) != bw);
 	} else
 		num_samps = 2;
 
@@ -2769,8 +2771,8 @@ wlc_lcnphy_start_tx_tone(phy_info_t * pi, int32 f_kHz, uint16 max_val,
 
 		theta += rot;
 
-		i_samp = (uint16) (FLOAT(tone_samp.i * max_val) & 0x3ff);
-		q_samp = (uint16) (FLOAT(tone_samp.q * max_val) & 0x3ff);
+		i_samp = (u16) (FLOAT(tone_samp.i * max_val) & 0x3ff);
+		q_samp = (u16) (FLOAT(tone_samp.q * max_val) & 0x3ff);
 		data_buf[t] = (i_samp << 10) | q_samp;
 	}
 
@@ -2788,9 +2790,9 @@ wlc_lcnphy_start_tx_tone(phy_info_t * pi, int32 f_kHz, uint16 max_val,
 	wlc_lcnphy_run_samples(pi, num_samps, 0xffff, 0, iqcalmode);
 }
 
-void wlc_lcnphy_stop_tx_tone(phy_info_t * pi)
+void wlc_lcnphy_stop_tx_tone(phy_info_t *pi)
 {
-	int16 playback_status;
+	s16 playback_status;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	pi->phy_tx_tone_freq = 0;
@@ -2798,7 +2800,7 @@ void wlc_lcnphy_stop_tx_tone(phy_info_t * pi)
 		write_phy_reg(pi, 0x942, 0x7);
 		write_phy_reg(pi, 0x93b, 0x2017);
 		write_phy_reg(pi, 0x93c, 0x27c5);
-		wlc_lcnphy_txrx_spur_avoidance_mode(pi, TRUE);
+		wlc_lcnphy_txrx_spur_avoidance_mode(pi, true);
 	}
 
 	playback_status = read_phy_reg(pi, 0x644);
@@ -2816,18 +2818,18 @@ void wlc_lcnphy_stop_tx_tone(phy_info_t * pi)
 
 	and_radio_reg(pi, RADIO_2064_REG112, 0xFFF9);
 
-	wlc_lcnphy_deaf_mode(pi, FALSE);
+	wlc_lcnphy_deaf_mode(pi, false);
 }
 
-static void wlc_lcnphy_clear_trsw_override(phy_info_t * pi)
+static void wlc_lcnphy_clear_trsw_override(phy_info_t *pi)
 {
 
-	and_phy_reg(pi, 0x44c, (uint16) ~ ((0x1 << 1) | (0x1 << 0)));
+	and_phy_reg(pi, 0x44c, (u16) ~((0x1 << 1) | (0x1 << 0)));
 }
 
-void wlc_lcnphy_get_tx_iqcc(phy_info_t * pi, uint16 * a, uint16 * b)
+void wlc_lcnphy_get_tx_iqcc(phy_info_t *pi, u16 *a, u16 *b)
 {
-	uint16 iqcc[2];
+	u16 iqcc[2];
 	phytbl_info_t tab;
 
 	tab.tbl_ptr = iqcc;
@@ -2841,10 +2843,10 @@ void wlc_lcnphy_get_tx_iqcc(phy_info_t * pi, uint16 * a, uint16 * b)
 	*b = iqcc[1];
 }
 
-uint16 wlc_lcnphy_get_tx_locc(phy_info_t * pi)
+u16 wlc_lcnphy_get_tx_locc(phy_info_t *pi)
 {
 	phytbl_info_t tab;
-	uint16 didq;
+	u16 didq;
 
 	tab.tbl_id = 0;
 	tab.tbl_width = 16;
@@ -2856,17 +2858,17 @@ uint16 wlc_lcnphy_get_tx_locc(phy_info_t * pi)
 	return didq;
 }
 
-static void wlc_lcnphy_txpwrtbl_iqlo_cal(phy_info_t * pi)
+static void wlc_lcnphy_txpwrtbl_iqlo_cal(phy_info_t *pi)
 {
 
 	lcnphy_txgains_t target_gains, old_gains;
-	uint8 save_bb_mult;
-	uint16 a, b, didq, save_pa_gain = 0;
+	u8 save_bb_mult;
+	u16 a, b, didq, save_pa_gain = 0;
 	uint idx, SAVE_txpwrindex = 0xFF;
-	uint32 val;
-	uint16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	u32 val;
+	u16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
 	phytbl_info_t tab;
-	uint8 ei0, eq0, fi0, fq0;
+	u8 ei0, eq0, fi0, fq0;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	wlc_lcnphy_get_tx_gain(pi, &old_gains);
@@ -2893,14 +2895,14 @@ static void wlc_lcnphy_txpwrtbl_iqlo_cal(phy_info_t * pi)
 		wlc_lcnphy_tx_iqlo_cal(pi, &target_gains,
 				       (pi_lcn->
 					lcnphy_recal ? LCNPHY_CAL_RECAL :
-					LCNPHY_CAL_FULL), FALSE);
+					LCNPHY_CAL_FULL), false);
 	} else {
 
 		wlc_lcnphy_tx_iqlo_soft_cal_full(pi);
 	}
 
 	wlc_lcnphy_get_radio_loft(pi, &ei0, &eq0, &fi0, &fq0);
-	if ((ABS((int8) fi0) == 15) && (ABS((int8) fq0) == 15)) {
+	if ((ABS((s8) fi0) == 15) && (ABS((s8) fq0) == 15)) {
 		if (CHSPEC_IS5G(pi->radio_chanspec)) {
 			target_gains.gm_gain = 255;
 			target_gains.pga_gain = 255;
@@ -2920,7 +2922,7 @@ static void wlc_lcnphy_txpwrtbl_iqlo_cal(phy_info_t * pi)
 			target_gains.pad_gain = 30;
 			wlc_lcnphy_set_tx_pwr_by_index(pi, 16);
 			wlc_lcnphy_tx_iqlo_cal(pi, &target_gains,
-					       LCNPHY_CAL_FULL, FALSE);
+					       LCNPHY_CAL_FULL, false);
 		} else {
 
 			wlc_lcnphy_tx_iqlo_soft_cal_full(pi);
@@ -2944,7 +2946,7 @@ static void wlc_lcnphy_txpwrtbl_iqlo_cal(phy_info_t * pi)
 
 		wlc_lcnphy_read_table(pi, &tab);
 		val = (val & 0xfff00000) |
-		    ((uint32) (a & 0x3FF) << 10) | (b & 0x3ff);
+		    ((u32) (a & 0x3FF) << 10) | (b & 0x3ff);
 		wlc_lcnphy_write_table(pi, &tab);
 
 		val = didq;
@@ -2970,10 +2972,10 @@ static void wlc_lcnphy_txpwrtbl_iqlo_cal(phy_info_t * pi)
 		wlc_lcnphy_set_tx_pwr_by_index(pi, SAVE_txpwrindex);
 }
 
-int16 wlc_lcnphy_tempsense_new(phy_info_t * pi, bool mode)
+s16 wlc_lcnphy_tempsense_new(phy_info_t *pi, bool mode)
 {
-	uint16 tempsenseval1, tempsenseval2;
-	int16 avg = 0;
+	u16 tempsenseval1, tempsenseval2;
+	s16 avg = 0;
 	bool suspend = 0;
 
 	if (NORADIO_ENAB(pi->pubpi))
@@ -2991,14 +2993,14 @@ int16 wlc_lcnphy_tempsense_new(phy_info_t * pi, bool mode)
 	tempsenseval2 = read_phy_reg(pi, 0x477) & 0x1FF;
 
 	if (tempsenseval1 > 255)
-		avg = (int16) (tempsenseval1 - 512);
+		avg = (s16) (tempsenseval1 - 512);
 	else
-		avg = (int16) tempsenseval1;
+		avg = (s16) tempsenseval1;
 
 	if (tempsenseval2 > 255)
-		avg += (int16) (tempsenseval2 - 512);
+		avg += (s16) (tempsenseval2 - 512);
 	else
-		avg += (int16) tempsenseval2;
+		avg += (s16) tempsenseval2;
 
 	avg /= 2;
 
@@ -3006,7 +3008,7 @@ int16 wlc_lcnphy_tempsense_new(phy_info_t * pi, bool mode)
 
 		mod_phy_reg(pi, 0x448, (0x1 << 14), (1) << 14);
 
-		OSL_DELAY(100);
+		udelay(100);
 		mod_phy_reg(pi, 0x448, (0x1 << 14), (0) << 14);
 
 		if (!suspend)
@@ -3015,12 +3017,12 @@ int16 wlc_lcnphy_tempsense_new(phy_info_t * pi, bool mode)
 	return avg;
 }
 
-uint16 wlc_lcnphy_tempsense(phy_info_t * pi, bool mode)
+u16 wlc_lcnphy_tempsense(phy_info_t *pi, bool mode)
 {
-	uint16 tempsenseval1, tempsenseval2;
-	int32 avg = 0;
+	u16 tempsenseval1, tempsenseval2;
+	s32 avg = 0;
 	bool suspend = 0;
-	uint16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	u16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	if (NORADIO_ENAB(pi->pubpi))
@@ -3067,28 +3069,28 @@ uint16 wlc_lcnphy_tempsense(phy_info_t * pi, bool mode)
 
 		mod_phy_reg(pi, 0x448, (0x1 << 14), (1) << 14);
 
-		OSL_DELAY(100);
+		udelay(100);
 		mod_phy_reg(pi, 0x448, (0x1 << 14), (0) << 14);
 
 		if (!suspend)
 			wlapi_enable_mac(pi->sh->physhim);
 	}
-	return (uint16) avg;
+	return (u16) avg;
 }
 
-int8 wlc_lcnphy_tempsense_degree(phy_info_t * pi, bool mode)
+s8 wlc_lcnphy_tempsense_degree(phy_info_t *pi, bool mode)
 {
-	int32 degree = wlc_lcnphy_tempsense_new(pi, mode);
+	s32 degree = wlc_lcnphy_tempsense_new(pi, mode);
 	degree =
 	    ((degree << 10) + LCN_TEMPSENSE_OFFSET + (LCN_TEMPSENSE_DEN >> 1))
 	    / LCN_TEMPSENSE_DEN;
-	return (int8) degree;
+	return (s8) degree;
 }
 
-int8 wlc_lcnphy_vbatsense(phy_info_t * pi, bool mode)
+s8 wlc_lcnphy_vbatsense(phy_info_t *pi, bool mode)
 {
-	uint16 vbatsenseval;
-	int32 avg = 0;
+	u16 vbatsenseval;
+	s32 avg = 0;
 	bool suspend = 0;
 
 	if (NORADIO_ENAB(pi->pubpi))
@@ -3106,9 +3108,9 @@ int8 wlc_lcnphy_vbatsense(phy_info_t * pi, bool mode)
 	vbatsenseval = read_phy_reg(pi, 0x475) & 0x1FF;
 
 	if (vbatsenseval > 255)
-		avg = (int32) (vbatsenseval - 512);
+		avg = (s32) (vbatsenseval - 512);
 	else
-		avg = (int32) vbatsenseval;
+		avg = (s32) vbatsenseval;
 
 	avg =
 	    (avg * LCN_VBAT_SCALE_NOM +
@@ -3118,12 +3120,12 @@ int8 wlc_lcnphy_vbatsense(phy_info_t * pi, bool mode)
 		if (!suspend)
 			wlapi_enable_mac(pi->sh->physhim);
 	}
-	return (int8) avg;
+	return (s8) avg;
 }
 
-static void wlc_lcnphy_afe_clk_init(phy_info_t * pi, uint8 mode)
+static void wlc_lcnphy_afe_clk_init(phy_info_t *pi, u8 mode)
 {
-	uint8 phybw40;
+	u8 phybw40;
 	phybw40 = CHSPEC_IS40(pi->radio_chanspec);
 
 	mod_phy_reg(pi, 0x6d1, (0x1 << 7), (1) << 7);
@@ -3136,13 +3138,13 @@ static void wlc_lcnphy_afe_clk_init(phy_info_t * pi, uint8 mode)
 }
 
 static bool
-wlc_lcnphy_rx_iq_est(phy_info_t * pi,
-		     uint16 num_samps,
-		     uint8 wait_time, lcnphy_iq_est_t * iq_est)
+wlc_lcnphy_rx_iq_est(phy_info_t *pi,
+		     u16 num_samps,
+		     u8 wait_time, lcnphy_iq_est_t *iq_est)
 {
 	int wait_count = 0;
-	bool result = TRUE;
-	uint8 phybw40;
+	bool result = true;
+	u8 phybw40;
 	phybw40 = CHSPEC_IS40(pi->radio_chanspec);
 
 	mod_phy_reg(pi, 0x6da, (0x1 << 5), (1) << 5);
@@ -3151,7 +3153,7 @@ wlc_lcnphy_rx_iq_est(phy_info_t * pi,
 
 	mod_phy_reg(pi, 0x482, (0xffff << 0), (num_samps) << 0);
 
-	mod_phy_reg(pi, 0x481, (0xff << 0), ((uint16) wait_time) << 0);
+	mod_phy_reg(pi, 0x481, (0xff << 0), ((u16) wait_time) << 0);
 
 	mod_phy_reg(pi, 0x481, (0x1 << 8), (0) << 8);
 
@@ -3160,19 +3162,19 @@ wlc_lcnphy_rx_iq_est(phy_info_t * pi,
 	while (read_phy_reg(pi, 0x481) & (0x1 << 9)) {
 
 		if (wait_count > (10 * 500)) {
-			result = FALSE;
+			result = false;
 			goto cleanup;
 		}
-		OSL_DELAY(100);
+		udelay(100);
 		wait_count++;
 	}
 
-	iq_est->iq_prod = ((uint32) read_phy_reg(pi, 0x483) << 16) |
-	    (uint32) read_phy_reg(pi, 0x484);
-	iq_est->i_pwr = ((uint32) read_phy_reg(pi, 0x485) << 16) |
-	    (uint32) read_phy_reg(pi, 0x486);
-	iq_est->q_pwr = ((uint32) read_phy_reg(pi, 0x487) << 16) |
-	    (uint32) read_phy_reg(pi, 0x488);
+	iq_est->iq_prod = ((u32) read_phy_reg(pi, 0x483) << 16) |
+	    (u32) read_phy_reg(pi, 0x484);
+	iq_est->i_pwr = ((u32) read_phy_reg(pi, 0x485) << 16) |
+	    (u32) read_phy_reg(pi, 0x486);
+	iq_est->q_pwr = ((u32) read_phy_reg(pi, 0x487) << 16) |
+	    (u32) read_phy_reg(pi, 0x488);
 
  cleanup:
 	mod_phy_reg(pi, 0x410, (0x1 << 3), (1) << 3);
@@ -3182,16 +3184,16 @@ wlc_lcnphy_rx_iq_est(phy_info_t * pi,
 	return result;
 }
 
-static bool wlc_lcnphy_calc_rx_iq_comp(phy_info_t * pi, uint16 num_samps)
+static bool wlc_lcnphy_calc_rx_iq_comp(phy_info_t *pi, u16 num_samps)
 {
 #define LCNPHY_MIN_RXIQ_PWR 2
 	bool result;
-	uint16 a0_new, b0_new;
+	u16 a0_new, b0_new;
 	lcnphy_iq_est_t iq_est = { 0, 0, 0 };
-	int32 a, b, temp;
-	int16 iq_nbits, qq_nbits, arsh, brsh;
-	int32 iq;
-	uint32 ii, qq;
+	s32 a, b, temp;
+	s16 iq_nbits, qq_nbits, arsh, brsh;
+	s32 iq;
+	u32 ii, qq;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	a0_new = ((read_phy_reg(pi, 0x645) & (0x3ff << 0)) >> 0);
@@ -3202,15 +3204,16 @@ static bool wlc_lcnphy_calc_rx_iq_comp(phy_info_t * pi, uint16 num_samps)
 
 	wlc_lcnphy_set_rx_iq_comp(pi, 0, 0);
 
-	if (!(result = wlc_lcnphy_rx_iq_est(pi, num_samps, 32, &iq_est)))
+	result = wlc_lcnphy_rx_iq_est(pi, num_samps, 32, &iq_est);
+	if (!result)
 		goto cleanup;
 
-	iq = (int32) iq_est.iq_prod;
+	iq = (s32) iq_est.iq_prod;
 	ii = iq_est.i_pwr;
 	qq = iq_est.q_pwr;
 
 	if ((ii + qq) < LCNPHY_MIN_RXIQ_PWR) {
-		result = FALSE;
+		result = false;
 		goto cleanup;
 	}
 
@@ -3220,38 +3223,38 @@ static bool wlc_lcnphy_calc_rx_iq_comp(phy_info_t * pi, uint16 num_samps)
 	arsh = 10 - (30 - iq_nbits);
 	if (arsh >= 0) {
 		a = (-(iq << (30 - iq_nbits)) + (ii >> (1 + arsh)));
-		temp = (int32) (ii >> arsh);
+		temp = (s32) (ii >> arsh);
 		if (temp == 0) {
-			return FALSE;
+			return false;
 		}
 	} else {
 		a = (-(iq << (30 - iq_nbits)) + (ii << (-1 - arsh)));
-		temp = (int32) (ii << -arsh);
+		temp = (s32) (ii << -arsh);
 		if (temp == 0) {
-			return FALSE;
+			return false;
 		}
 	}
 	a /= temp;
 	brsh = qq_nbits - 31 + 20;
 	if (brsh >= 0) {
 		b = (qq << (31 - qq_nbits));
-		temp = (int32) (ii >> brsh);
+		temp = (s32) (ii >> brsh);
 		if (temp == 0) {
-			return FALSE;
+			return false;
 		}
 	} else {
 		b = (qq << (31 - qq_nbits));
-		temp = (int32) (ii << -brsh);
+		temp = (s32) (ii << -brsh);
 		if (temp == 0) {
-			return FALSE;
+			return false;
 		}
 	}
 	b /= temp;
 	b -= a * a;
-	b = (int32) wlc_phy_sqrt_int((uint32) b);
+	b = (s32) wlc_phy_sqrt_int((u32) b);
 	b -= (1 << 10);
-	a0_new = (uint16) (a & 0x3ff);
-	b0_new = (uint16) (b & 0x3ff);
+	a0_new = (u16) (a & 0x3ff);
+	b0_new = (u16) (b & 0x3ff);
  cleanup:
 
 	wlc_lcnphy_set_rx_iq_comp(pi, a0_new, b0_new);
@@ -3267,27 +3270,28 @@ static bool wlc_lcnphy_calc_rx_iq_comp(phy_info_t * pi, uint16 num_samps)
 }
 
 static bool
-wlc_lcnphy_rx_iq_cal(phy_info_t * pi, const lcnphy_rx_iqcomp_t * iqcomp,
+wlc_lcnphy_rx_iq_cal(phy_info_t *pi, const lcnphy_rx_iqcomp_t *iqcomp,
 		     int iqcomp_sz, bool tx_switch, bool rx_switch, int module,
 		     int tx_gain_idx)
 {
 	lcnphy_txgains_t old_gains;
-	uint16 tx_pwr_ctrl;
-	uint8 tx_gain_index_old = 0;
-	bool result = FALSE, tx_gain_override_old = FALSE;
-	uint16 i, Core1TxControl_old, RFOverride0_old,
+	u16 tx_pwr_ctrl;
+	u8 tx_gain_index_old = 0;
+	bool result = false, tx_gain_override_old = false;
+	u16 i, Core1TxControl_old, RFOverride0_old,
 	    RFOverrideVal0_old, rfoverride2_old, rfoverride2val_old,
 	    rfoverride3_old, rfoverride3val_old, rfoverride4_old,
 	    rfoverride4val_old, afectrlovr_old, afectrlovrval_old;
 	int tia_gain;
-	uint32 received_power, rx_pwr_threshold;
-	uint16 old_sslpnCalibClkEnCtrl, old_sslpnRxFeClkEnCtrl;
-	uint16 values_to_save[11];
-	int16 *ptr;
+	u32 received_power, rx_pwr_threshold;
+	u16 old_sslpnCalibClkEnCtrl, old_sslpnRxFeClkEnCtrl;
+	u16 values_to_save[11];
+	s16 *ptr;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
-	if (NULL == (ptr = MALLOC(pi->sh->osh, sizeof(int16) * 131))) {
-		return FALSE;
+	ptr = kmalloc(sizeof(s16) * 131, GFP_ATOMIC);
+	if (NULL == ptr) {
+		return false;
 	}
 	if (module == 2) {
 		ASSERT(iqcomp_sz);
@@ -3297,11 +3301,11 @@ wlc_lcnphy_rx_iq_cal(phy_info_t * pi, const lcnphy_rx_iqcomp_t * iqcomp,
 			    CHSPEC_CHANNEL(pi->radio_chanspec)) {
 
 				wlc_lcnphy_set_rx_iq_comp(pi,
-							  (uint16)
+							  (u16)
 							  iqcomp[iqcomp_sz].a,
-							  (uint16)
+							  (u16)
 							  iqcomp[iqcomp_sz].b);
-				result = TRUE;
+				result = true;
 				break;
 			}
 		}
@@ -3378,7 +3382,7 @@ wlc_lcnphy_rx_iq_cal(phy_info_t * pi, const lcnphy_rx_iqcomp_t * iqcomp,
 		write_phy_reg(pi, 0x6da, 0xffff);
 		or_phy_reg(pi, 0x6db, 0x3);
 		wlc_lcnphy_set_trsw_override(pi, tx_switch, rx_switch);
-		wlc_lcnphy_rx_gain_override_enable(pi, TRUE);
+		wlc_lcnphy_rx_gain_override_enable(pi, true);
 
 		tia_gain = 8;
 		rx_pwr_threshold = 950;
@@ -3386,9 +3390,9 @@ wlc_lcnphy_rx_iq_cal(phy_info_t * pi, const lcnphy_rx_iqcomp_t * iqcomp,
 			tia_gain -= 1;
 			wlc_lcnphy_set_rx_gain_by_distribution(pi,
 							       0, 0, 2, 2,
-							       (uint16)
+							       (u16)
 							       tia_gain, 1, 0);
-			OSL_DELAY(500);
+			udelay(500);
 
 			received_power =
 			    wlc_lcnphy_measure_digital_power(pi, 2000);
@@ -3429,62 +3433,62 @@ wlc_lcnphy_rx_iq_cal(phy_info_t * pi, const lcnphy_rx_iqcomp_t * iqcomp,
 			wlc_lcnphy_disable_tx_gain_override(pi);
 		wlc_lcnphy_set_tx_pwr_ctrl(pi, tx_pwr_ctrl);
 
-		wlc_lcnphy_rx_gain_override_enable(pi, FALSE);
+		wlc_lcnphy_rx_gain_override_enable(pi, false);
 	}
 
  cal_done:
-	MFREE(pi->sh->osh, ptr, 131 * sizeof(int16));
+	kfree(ptr);
 	return result;
 }
 
-static void wlc_lcnphy_temp_adj(phy_info_t * pi)
+static void wlc_lcnphy_temp_adj(phy_info_t *pi)
 {
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
 }
 
-static void wlc_lcnphy_glacial_timer_based_cal(phy_info_t * pi)
+static void wlc_lcnphy_glacial_timer_based_cal(phy_info_t *pi)
 {
 	bool suspend;
-	int8 index;
-	uint16 SAVE_pwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	s8 index;
+	u16 SAVE_pwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 	suspend =
 	    (0 == (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
 	if (!suspend)
 		wlapi_suspend_mac_and_wait(pi->sh->physhim);
-	wlc_lcnphy_deaf_mode(pi, TRUE);
+	wlc_lcnphy_deaf_mode(pi, true);
 	pi->phy_lastcal = pi->sh->now;
-	pi->phy_forcecal = FALSE;
+	pi->phy_forcecal = false;
 	index = pi_lcn->lcnphy_current_index;
 
 	wlc_lcnphy_txpwrtbl_iqlo_cal(pi);
 
 	wlc_lcnphy_set_tx_pwr_by_index(pi, index);
 	wlc_lcnphy_set_tx_pwr_ctrl(pi, SAVE_pwrctrl);
-	wlc_lcnphy_deaf_mode(pi, FALSE);
+	wlc_lcnphy_deaf_mode(pi, false);
 	if (!suspend)
 		wlapi_enable_mac(pi->sh->physhim);
 
 }
 
-static void wlc_lcnphy_periodic_cal(phy_info_t * pi)
+static void wlc_lcnphy_periodic_cal(phy_info_t *pi)
 {
 	bool suspend, full_cal;
 	const lcnphy_rx_iqcomp_t *rx_iqcomp;
 	int rx_iqcomp_sz;
-	uint16 SAVE_pwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
-	int8 index;
+	u16 SAVE_pwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	s8 index;
 	phytbl_info_t tab;
-	int32 a1, b0, b1;
-	int32 tssi, pwr, maxtargetpwr, mintargetpwr;
+	s32 a1, b0, b1;
+	s32 tssi, pwr, maxtargetpwr, mintargetpwr;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
 
 	pi->phy_lastcal = pi->sh->now;
-	pi->phy_forcecal = FALSE;
+	pi->phy_forcecal = false;
 	full_cal =
 	    (pi_lcn->lcnphy_full_cal_channel !=
 	     CHSPEC_CHANNEL(pi->radio_chanspec));
@@ -3498,17 +3502,17 @@ static void wlc_lcnphy_periodic_cal(phy_info_t * pi)
 		wlapi_bmac_write_shm(pi->sh->physhim, M_CTS_DURATION, 10000);
 		wlapi_suspend_mac_and_wait(pi->sh->physhim);
 	}
-	wlc_lcnphy_deaf_mode(pi, TRUE);
+	wlc_lcnphy_deaf_mode(pi, true);
 
 	wlc_lcnphy_txpwrtbl_iqlo_cal(pi);
 
 	rx_iqcomp = lcnphy_rx_iqcomp_table_rev0;
-	rx_iqcomp_sz = ARRAYSIZE(lcnphy_rx_iqcomp_table_rev0);
+	rx_iqcomp_sz = ARRAY_SIZE(lcnphy_rx_iqcomp_table_rev0);
 
 	if (LCNREV_IS(pi->pubpi.phy_rev, 1))
-		wlc_lcnphy_rx_iq_cal(pi, NULL, 0, TRUE, FALSE, 1, 40);
+		wlc_lcnphy_rx_iq_cal(pi, NULL, 0, true, false, 1, 40);
 	else
-		wlc_lcnphy_rx_iq_cal(pi, NULL, 0, TRUE, FALSE, 1, 127);
+		wlc_lcnphy_rx_iq_cal(pi, NULL, 0, true, false, 1, 127);
 
 	if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi)) {
 
@@ -3535,14 +3539,14 @@ static void wlc_lcnphy_periodic_cal(phy_info_t * pi)
 
 	wlc_lcnphy_set_tx_pwr_by_index(pi, index);
 	wlc_lcnphy_set_tx_pwr_ctrl(pi, SAVE_pwrctrl);
-	wlc_lcnphy_deaf_mode(pi, FALSE);
+	wlc_lcnphy_deaf_mode(pi, false);
 	if (!suspend)
 		wlapi_enable_mac(pi->sh->physhim);
 }
 
-void wlc_lcnphy_calib_modes(phy_info_t * pi, uint mode)
+void wlc_lcnphy_calib_modes(phy_info_t *pi, uint mode)
 {
-	uint16 temp_new;
+	u16 temp_new;
 	int temp1, temp2, temp_diff;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
@@ -3582,13 +3586,14 @@ void wlc_lcnphy_calib_modes(phy_info_t * pi, uint mode)
 	}
 }
 
-void wlc_lcnphy_get_tssi(phy_info_t * pi, int8 * ofdm_pwr, int8 * cck_pwr)
+void wlc_lcnphy_get_tssi(phy_info_t *pi, s8 *ofdm_pwr, s8 *cck_pwr)
 {
-	int8 cck_offset;
-	uint16 status;
+	s8 cck_offset;
+	u16 status;
+	status = (read_phy_reg(pi, 0x4ab));
 	if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi) &&
-	    ((status = (read_phy_reg(pi, 0x4ab))) & (0x1 << 15))) {
-		*ofdm_pwr = (int8) (((read_phy_reg(pi, 0x4ab) & (0x1ff << 0))
+	    (status  & (0x1 << 15))) {
+		*ofdm_pwr = (s8) (((read_phy_reg(pi, 0x4ab) & (0x1ff << 0))
 				     >> 0) >> 1);
 
 		if (wlc_phy_tpc_isenabled_lcnphy(pi))
@@ -3603,14 +3608,15 @@ void wlc_lcnphy_get_tssi(phy_info_t * pi, int8 * ofdm_pwr, int8 * cck_pwr)
 	}
 }
 
-void WLBANDINITFN(wlc_phy_cal_init_lcnphy) (phy_info_t * pi) {
+void WLBANDINITFN(wlc_phy_cal_init_lcnphy) (phy_info_t *pi)
+{
 	return;
 
 }
 
-static void wlc_lcnphy_set_chanspec_tweaks(phy_info_t * pi, chanspec_t chanspec)
+static void wlc_lcnphy_set_chanspec_tweaks(phy_info_t *pi, chanspec_t chanspec)
 {
-	uint8 channel = CHSPEC_CHANNEL(chanspec);
+	u8 channel = CHSPEC_CHANNEL(chanspec);
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	if (NORADIO_ENAB(pi->pubpi))
@@ -3636,7 +3642,7 @@ static void wlc_lcnphy_set_chanspec_tweaks(phy_info_t * pi, chanspec_t chanspec)
 
 		si_pmu_pllupd(pi->sh->sih);
 		write_phy_reg(pi, 0x942, 0);
-		wlc_lcnphy_txrx_spur_avoidance_mode(pi, FALSE);
+		wlc_lcnphy_txrx_spur_avoidance_mode(pi, false);
 		pi_lcn->lcnphy_spurmod = 0;
 		mod_phy_reg(pi, 0x424, (0xff << 8), (0x1b) << 8);
 
@@ -3648,7 +3654,7 @@ static void wlc_lcnphy_set_chanspec_tweaks(phy_info_t * pi, chanspec_t chanspec)
 
 		si_pmu_pllupd(pi->sh->sih);
 		write_phy_reg(pi, 0x942, 0);
-		wlc_lcnphy_txrx_spur_avoidance_mode(pi, TRUE);
+		wlc_lcnphy_txrx_spur_avoidance_mode(pi, true);
 
 		pi_lcn->lcnphy_spurmod = 0;
 		mod_phy_reg(pi, 0x424, (0xff << 8), (0x1f) << 8);
@@ -3660,30 +3666,24 @@ static void wlc_lcnphy_set_chanspec_tweaks(phy_info_t * pi, chanspec_t chanspec)
 	write_phy_reg(pi, 0x44a, 0x80);
 }
 
-void
-wlc_lcnphy_pktengtx(wlc_phy_t * ppi, wl_pkteng_t * pkteng, uint8 rate,
-		    struct ether_addr *sa, uint32 wait_delay)
-{
-}
-
-void wlc_lcnphy_tx_power_adjustment(wlc_phy_t * ppi)
+void wlc_lcnphy_tx_power_adjustment(wlc_phy_t *ppi)
 {
-	int8 index;
-	uint16 index2;
+	s8 index;
+	u16 index2;
 	phy_info_t *pi = (phy_info_t *) ppi;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
-	uint16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	u16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
 	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi) && SAVE_txpwrctrl) {
 		index = wlc_lcnphy_tempcompensated_txpwrctrl(pi);
-		index2 = (uint16) (index * 2);
+		index2 = (u16) (index * 2);
 		mod_phy_reg(pi, 0x4a9, (0x1ff << 0), (index2) << 0);
 
-		pi_lcn->lcnphy_current_index = (int8)
+		pi_lcn->lcnphy_current_index = (s8)
 		    ((read_phy_reg(pi, 0x4a9) & 0xFF) / 2);
 	}
 }
 
-static void wlc_lcnphy_set_rx_iq_comp(phy_info_t * pi, uint16 a, uint16 b)
+static void wlc_lcnphy_set_rx_iq_comp(phy_info_t *pi, u16 a, u16 b)
 {
 	mod_phy_reg(pi, 0x645, (0x3ff << 0), (a) << 0);
 
@@ -3699,8 +3699,9 @@ static void wlc_lcnphy_set_rx_iq_comp(phy_info_t * pi, uint16 a, uint16 b)
 
 }
 
-void WLBANDINITFN(wlc_phy_init_lcnphy) (phy_info_t * pi) {
-	uint8 phybw40;
+void WLBANDINITFN(wlc_phy_init_lcnphy) (phy_info_t *pi)
+{
+	u8 phybw40;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 	phybw40 = CHSPEC_IS40(pi->radio_chanspec);
 
@@ -3739,7 +3740,7 @@ void WLBANDINITFN(wlc_phy_init_lcnphy) (phy_info_t * pi) {
 
 	mod_phy_reg(pi, 0x448, (0x1 << 14), (1) << 14);
 
-	OSL_DELAY(100);
+	udelay(100);
 	mod_phy_reg(pi, 0x448, (0x1 << 14), (0) << 14);
 
 	wlc_lcnphy_set_tx_pwr_ctrl(pi, LCNPHY_TX_PWR_CTRL_HW);
@@ -3748,9 +3749,9 @@ void WLBANDINITFN(wlc_phy_init_lcnphy) (phy_info_t * pi) {
 }
 
 static void
-wlc_lcnphy_tx_iqlo_loopback(phy_info_t * pi, uint16 * values_to_save)
+wlc_lcnphy_tx_iqlo_loopback(phy_info_t *pi, u16 *values_to_save)
 {
-	uint16 vmid;
+	u16 vmid;
 	int i;
 	for (i = 0; i < 20; i++) {
 		values_to_save[i] =
@@ -3777,7 +3778,7 @@ wlc_lcnphy_tx_iqlo_loopback(phy_info_t * pi, uint16 * values_to_save)
 
 	or_radio_reg(pi, RADIO_2064_REG036, 0x01);
 	or_radio_reg(pi, RADIO_2064_REG11A, 0x18);
-	OSL_DELAY(20);
+	udelay(20);
 
 	if (LCNREV_IS(pi->pubpi.phy_rev, 2)) {
 		if (CHSPEC_IS5G(pi->radio_chanspec))
@@ -3791,7 +3792,7 @@ wlc_lcnphy_tx_iqlo_loopback(phy_info_t * pi, uint16 * values_to_save)
 			or_radio_reg(pi, RADIO_2064_REG03A, 0x3);
 	}
 
-	OSL_DELAY(20);
+	udelay(20);
 
 	write_radio_reg(pi, RADIO_2064_REG025, 0xF);
 	if (LCNREV_IS(pi->pubpi.phy_rev, 2)) {
@@ -3806,31 +3807,31 @@ wlc_lcnphy_tx_iqlo_loopback(phy_info_t * pi, uint16 * values_to_save)
 			mod_radio_reg(pi, RADIO_2064_REG028, 0x1e, 0x6 << 1);
 	}
 
-	OSL_DELAY(20);
+	udelay(20);
 
 	write_radio_reg(pi, RADIO_2064_REG005, 0x8);
 	or_radio_reg(pi, RADIO_2064_REG112, 0x80);
-	OSL_DELAY(20);
+	udelay(20);
 
 	or_radio_reg(pi, RADIO_2064_REG0FF, 0x10);
 	or_radio_reg(pi, RADIO_2064_REG11F, 0x44);
-	OSL_DELAY(20);
+	udelay(20);
 
 	or_radio_reg(pi, RADIO_2064_REG00B, 0x7);
 	or_radio_reg(pi, RADIO_2064_REG113, 0x10);
-	OSL_DELAY(20);
+	udelay(20);
 
 	write_radio_reg(pi, RADIO_2064_REG007, 0x1);
-	OSL_DELAY(20);
+	udelay(20);
 
 	vmid = 0x2A6;
 	mod_radio_reg(pi, RADIO_2064_REG0FC, 0x3 << 0, (vmid >> 8) & 0x3);
 	write_radio_reg(pi, RADIO_2064_REG0FD, (vmid & 0xff));
 	or_radio_reg(pi, RADIO_2064_REG11F, 0x44);
-	OSL_DELAY(20);
+	udelay(20);
 
 	or_radio_reg(pi, RADIO_2064_REG0FF, 0x10);
-	OSL_DELAY(20);
+	udelay(20);
 	write_radio_reg(pi, RADIO_2064_REG012, 0x02);
 	or_radio_reg(pi, RADIO_2064_REG112, 0x06);
 	write_radio_reg(pi, RADIO_2064_REG036, 0x11);
@@ -3841,13 +3842,13 @@ wlc_lcnphy_tx_iqlo_loopback(phy_info_t * pi, uint16 * values_to_save)
 }
 
 static void
-wlc_lcnphy_samp_cap(phy_info_t * pi, int clip_detect_algo, uint16 thresh,
-		    int16 * ptr, int mode)
+wlc_lcnphy_samp_cap(phy_info_t *pi, int clip_detect_algo, u16 thresh,
+		    s16 *ptr, int mode)
 {
-	uint32 curval1, curval2, stpptr, curptr, strptr, val;
-	uint16 sslpnCalibClkEnCtrl, timer;
-	uint16 old_sslpnCalibClkEnCtrl;
-	int16 imag, real;
+	u32 curval1, curval2, stpptr, curptr, strptr, val;
+	u16 sslpnCalibClkEnCtrl, timer;
+	u16 old_sslpnCalibClkEnCtrl;
+	s16 imag, real;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	timer = 0;
@@ -3859,14 +3860,14 @@ wlc_lcnphy_samp_cap(phy_info_t * pi, int clip_detect_algo, uint16 thresh,
 
 	W_REG(pi->sh->osh, &pi->regs->smpl_clct_strptr, 0x7E00);
 	W_REG(pi->sh->osh, &pi->regs->smpl_clct_stpptr, 0x8000);
-	OSL_DELAY(20);
+	udelay(20);
 	curval2 = R_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param);
 	W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, curval2 | 0x30);
 
 	write_phy_reg(pi, 0x555, 0x0);
 	write_phy_reg(pi, 0x5a6, 0x5);
 
-	write_phy_reg(pi, 0x5a2, (uint16) (mode | mode << 6));
+	write_phy_reg(pi, 0x5a2, (u16) (mode | mode << 6));
 	write_phy_reg(pi, 0x5cf, 3);
 	write_phy_reg(pi, 0x5a5, 0x3);
 	write_phy_reg(pi, 0x583, 0x0);
@@ -3877,11 +3878,11 @@ wlc_lcnphy_samp_cap(phy_info_t * pi, int clip_detect_algo, uint16 thresh,
 	write_phy_reg(pi, 0x580, 0x4501);
 
 	sslpnCalibClkEnCtrl = read_phy_reg(pi, 0x6da);
-	write_phy_reg(pi, 0x6da, (uint32) (sslpnCalibClkEnCtrl | 0x2008));
+	write_phy_reg(pi, 0x6da, (u32) (sslpnCalibClkEnCtrl | 0x2008));
 	stpptr = R_REG(pi->sh->osh, &pi->regs->smpl_clct_stpptr);
 	curptr = R_REG(pi->sh->osh, &pi->regs->smpl_clct_curptr);
 	do {
-		OSL_DELAY(10);
+		udelay(10);
 		curptr = R_REG(pi->sh->osh, &pi->regs->smpl_clct_curptr);
 		timer++;
 	} while ((curptr != stpptr) && (timer < 500));
@@ -3917,7 +3918,7 @@ wlc_lcnphy_samp_cap(phy_info_t * pi, int clip_detect_algo, uint16 thresh,
 	W_REG(pi->sh->osh, &pi->regs->psm_corectlsts, curval1);
 }
 
-static void wlc_lcnphy_tx_iqlo_soft_cal_full(phy_info_t * pi)
+static void wlc_lcnphy_tx_iqlo_soft_cal_full(phy_info_t *pi)
 {
 	lcnphy_unsign16_struct iqcc0, locc2, locc3, locc4;
 
@@ -3940,10 +3941,10 @@ static void wlc_lcnphy_tx_iqlo_soft_cal_full(phy_info_t * pi)
 }
 
 static void
-wlc_lcnphy_set_cc(phy_info_t * pi, int cal_type, int16 coeff_x, int16 coeff_y)
+wlc_lcnphy_set_cc(phy_info_t *pi, int cal_type, s16 coeff_x, s16 coeff_y)
 {
-	uint16 di0dq0;
-	uint16 x, y, data_rf;
+	u16 di0dq0;
+	u16 x, y, data_rf;
 	int k;
 	switch (cal_type) {
 	case 0:
@@ -3984,10 +3985,10 @@ wlc_lcnphy_set_cc(phy_info_t * pi, int cal_type, int16 coeff_x, int16 coeff_y)
 	}
 }
 
-static lcnphy_unsign16_struct wlc_lcnphy_get_cc(phy_info_t * pi, int cal_type)
+static lcnphy_unsign16_struct wlc_lcnphy_get_cc(phy_info_t *pi, int cal_type)
 {
-	uint16 a, b, didq;
-	uint8 di0, dq0, ei, eq, fi, fq;
+	u16 a, b, didq;
+	u8 di0, dq0, ei, eq, fi, fq;
 	lcnphy_unsign16_struct cc;
 	cc.re = 0;
 	cc.im = 0;
@@ -4001,47 +4002,49 @@ static lcnphy_unsign16_struct wlc_lcnphy_get_cc(phy_info_t * pi, int cal_type)
 		didq = wlc_lcnphy_get_tx_locc(pi);
 		di0 = (((didq & 0xff00) << 16) >> 24);
 		dq0 = (((didq & 0x00ff) << 24) >> 24);
-		cc.re = (uint16) di0;
-		cc.im = (uint16) dq0;
+		cc.re = (u16) di0;
+		cc.im = (u16) dq0;
 		break;
 	case 3:
 		wlc_lcnphy_get_radio_loft(pi, &ei, &eq, &fi, &fq);
-		cc.re = (uint16) ei;
-		cc.im = (uint16) eq;
+		cc.re = (u16) ei;
+		cc.im = (u16) eq;
 		break;
 	case 4:
 		wlc_lcnphy_get_radio_loft(pi, &ei, &eq, &fi, &fq);
-		cc.re = (uint16) fi;
-		cc.im = (uint16) fq;
+		cc.re = (u16) fi;
+		cc.im = (u16) fq;
 		break;
 	}
 	return cc;
 }
 
 static void
-wlc_lcnphy_a1(phy_info_t * pi, int cal_type, int num_levels, int step_size_lg2)
+wlc_lcnphy_a1(phy_info_t *pi, int cal_type, int num_levels, int step_size_lg2)
 {
 	const lcnphy_spb_tone_t *phy_c1;
 	lcnphy_spb_tone_t phy_c2;
 	lcnphy_unsign16_struct phy_c3;
 	int phy_c4, phy_c5, k, l, j, phy_c6;
-	uint16 phy_c7, phy_c8, phy_c9;
-	int16 phy_c10, phy_c11, phy_c12, phy_c13, phy_c14, phy_c15, phy_c16;
-	int16 *ptr, phy_c17;
-	int32 phy_c18, phy_c19;
-	uint32 phy_c20, phy_c21;
+	u16 phy_c7, phy_c8, phy_c9;
+	s16 phy_c10, phy_c11, phy_c12, phy_c13, phy_c14, phy_c15, phy_c16;
+	s16 *ptr, phy_c17;
+	s32 phy_c18, phy_c19;
+	u32 phy_c20, phy_c21;
 	bool phy_c22, phy_c23, phy_c24, phy_c25;
-	uint16 phy_c26, phy_c27;
-	uint16 phy_c28, phy_c29, phy_c30;
-	uint16 phy_c31;
-	uint16 *phy_c32;
+	u16 phy_c26, phy_c27;
+	u16 phy_c28, phy_c29, phy_c30;
+	u16 phy_c31;
+	u16 *phy_c32;
 	phy_c21 = 0;
 	phy_c10 = phy_c13 = phy_c14 = phy_c8 = 0;
-	if (NULL == (ptr = MALLOC(pi->sh->osh, sizeof(int16) * 131))) {
+	ptr = kmalloc(sizeof(s16) * 131, GFP_ATOMIC);
+	if (NULL == ptr) {
 		return;
 	}
 
-	if (NULL == (phy_c32 = MALLOC(pi->sh->osh, sizeof(uint16) * 20))) {
+	phy_c32 = kmalloc(sizeof(u16) * 20, GFP_ATOMIC);
+	if (NULL == phy_c32) {
 		return;
 	}
 	phy_c26 = read_phy_reg(pi, 0x6da);
@@ -4054,7 +4057,7 @@ wlc_lcnphy_a1(phy_info_t * pi, int cal_type, int num_levels, int step_size_lg2)
 	or_phy_reg(pi, 0x6db, 0x3);
 
 	wlc_lcnphy_tx_iqlo_loopback(pi, phy_c32);
-	OSL_DELAY(500);
+	udelay(500);
 	phy_c28 = read_phy_reg(pi, 0x938);
 	phy_c29 = read_phy_reg(pi, 0x4d7);
 	phy_c30 = read_phy_reg(pi, 0x4d8);
@@ -4086,8 +4089,8 @@ wlc_lcnphy_a1(phy_info_t * pi, int cal_type, int num_levels, int step_size_lg2)
 
 	phy_c7 = (1 << step_size_lg2);
 	phy_c3 = wlc_lcnphy_get_cc(pi, cal_type);
-	phy_c15 = (int16) phy_c3.re;
-	phy_c16 = (int16) phy_c3.im;
+	phy_c15 = (s16) phy_c3.re;
+	phy_c16 = (s16) phy_c3.im;
 	if (cal_type == 2) {
 		if (phy_c3.re > 127)
 			phy_c15 = phy_c3.re - 256;
@@ -4095,7 +4098,7 @@ wlc_lcnphy_a1(phy_info_t * pi, int cal_type, int num_levels, int step_size_lg2)
 			phy_c16 = phy_c3.im - 256;
 	}
 	wlc_lcnphy_set_cc(pi, cal_type, phy_c15, phy_c16);
-	OSL_DELAY(20);
+	udelay(20);
 	for (phy_c8 = 0; phy_c7 != 0 && phy_c8 < num_levels; phy_c8++) {
 		phy_c23 = 1;
 		phy_c22 = 0;
@@ -4122,7 +4125,7 @@ wlc_lcnphy_a1(phy_info_t * pi, int cal_type, int num_levels, int step_size_lg2)
 		while (1) {
 			write_radio_reg(pi, RADIO_2064_REG026,
 					(phy_c5 & 0x7) | ((phy_c5 & 0x7) << 4));
-			OSL_DELAY(50);
+			udelay(50);
 			phy_c22 = 0;
 			ptr[130] = 0;
 			wlc_lcnphy_samp_cap(pi, 1, phy_c9, &ptr[0], 2);
@@ -4160,7 +4163,7 @@ wlc_lcnphy_a1(phy_info_t * pi, int cal_type, int num_levels, int step_size_lg2)
 					phy_c12 = phy_c10;
 				wlc_lcnphy_set_cc(pi, cal_type, phy_c11,
 						  phy_c12);
-				OSL_DELAY(20);
+				udelay(20);
 				wlc_lcnphy_samp_cap(pi, 0, 0, ptr, 2);
 
 				phy_c18 = 0;
@@ -4196,7 +4199,7 @@ wlc_lcnphy_a1(phy_info_t * pi, int cal_type, int num_levels, int step_size_lg2)
 		phy_c16 = phy_c14;
 		phy_c7 = phy_c7 >> 1;
 		wlc_lcnphy_set_cc(pi, cal_type, phy_c15, phy_c16);
-		OSL_DELAY(20);
+		udelay(20);
 	}
 	goto cleanup;
  cleanup:
@@ -4209,12 +4212,12 @@ wlc_lcnphy_a1(phy_info_t * pi, int cal_type, int num_levels, int step_size_lg2)
 	write_phy_reg(pi, 0x4d8, phy_c30);
 	write_radio_reg(pi, RADIO_2064_REG026, phy_c31);
 
-	MFREE(pi->sh->osh, phy_c32, 20 * sizeof(uint16));
-	MFREE(pi->sh->osh, ptr, 131 * sizeof(int16));
+	kfree(phy_c32);
+	kfree(ptr);
 }
 
 static void
-wlc_lcnphy_tx_iqlo_loopback_cleanup(phy_info_t * pi, uint16 * values_to_save)
+wlc_lcnphy_tx_iqlo_loopback_cleanup(phy_info_t *pi, u16 *values_to_save)
 {
 	int i;
 
@@ -4229,14 +4232,14 @@ wlc_lcnphy_tx_iqlo_loopback_cleanup(phy_info_t * pi, uint16 * values_to_save)
 }
 
 static void
-WLBANDINITFN(wlc_lcnphy_load_tx_gain_table) (phy_info_t * pi,
+WLBANDINITFN(wlc_lcnphy_load_tx_gain_table) (phy_info_t *pi,
 					     const lcnphy_tx_gain_tbl_entry *
 					     gain_table) {
-	uint32 j;
+	u32 j;
 	phytbl_info_t tab;
-	uint32 val;
-	uint16 pa_gain;
-	uint16 gm_gain;
+	u32 val;
+	u16 pa_gain;
+	u16 gm_gain;
 
 	if (CHSPEC_IS5G(pi->radio_chanspec))
 		pa_gain = 0x70;
@@ -4252,7 +4255,7 @@ WLBANDINITFN(wlc_lcnphy_load_tx_gain_table) (phy_info_t * pi,
 
 	for (j = 0; j < 128; j++) {
 		gm_gain = gain_table[j].gm;
-		val = (((uint32) pa_gain << 24) |
+		val = (((u32) pa_gain << 24) |
 		       (gain_table[j].pad << 16) |
 		       (gain_table[j].pga << 8) | gm_gain);
 
@@ -4265,13 +4268,13 @@ WLBANDINITFN(wlc_lcnphy_load_tx_gain_table) (phy_info_t * pi,
 	}
 }
 
-static void wlc_lcnphy_load_rfpower(phy_info_t * pi)
+static void wlc_lcnphy_load_rfpower(phy_info_t *pi)
 {
 	phytbl_info_t tab;
-	uint32 val, bbmult, rfgain;
-	uint8 index;
-	uint8 scale_factor = 1;
-	int16 temp, temp1, temp2, qQ, qQ1, qQ2, shift;
+	u32 val, bbmult, rfgain;
+	u8 index;
+	u8 scale_factor = 1;
+	s16 temp, temp1, temp2, qQ, qQ1, qQ2, shift;
 
 	tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
 	tab.tbl_width = 32;
@@ -4287,8 +4290,8 @@ static void wlc_lcnphy_load_rfpower(phy_info_t * pi)
 		tab.tbl_offset = LCNPHY_TX_PWR_CTRL_GAIN_OFFSET + index;
 		wlc_lcnphy_read_table(pi, &tab);
 
-		qm_log10((int32) (bbmult), 0, &temp1, &qQ1);
-		qm_log10((int32) (1 << 6), 0, &temp2, &qQ2);
+		qm_log10((s32) (bbmult), 0, &temp1, &qQ1);
+		qm_log10((s32) (1 << 6), 0, &temp2, &qQ2);
 
 		if (qQ1 < qQ2) {
 			temp2 = qm_shr16(temp2, qQ2 - qQ1);
@@ -4314,11 +4317,12 @@ static void wlc_lcnphy_load_rfpower(phy_info_t * pi)
 	}
 }
 
-static void WLBANDINITFN(wlc_lcnphy_tbl_init) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_lcnphy_tbl_init) (phy_info_t *pi)
+{
 	uint idx;
-	uint8 phybw40;
+	u8 phybw40;
 	phytbl_info_t tab;
-	uint32 val;
+	u32 val;
 
 	phybw40 = CHSPEC_IS40(pi->radio_chanspec);
 
@@ -4408,8 +4412,9 @@ static void WLBANDINITFN(wlc_lcnphy_tbl_init) (phy_info_t * pi) {
 	wlc_lcnphy_clear_papd_comptable(pi);
 }
 
-static void WLBANDINITFN(wlc_lcnphy_rev0_baseband_init) (phy_info_t * pi) {
-	uint16 afectrl1;
+static void WLBANDINITFN(wlc_lcnphy_rev0_baseband_init) (phy_info_t *pi)
+{
+	u16 afectrl1;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	write_radio_reg(pi, RADIO_2064_REG11C, 0x0);
@@ -4434,7 +4439,7 @@ static void WLBANDINITFN(wlc_lcnphy_rev0_baseband_init) (phy_info_t * pi) {
 
 	if (0) {
 		afectrl1 = 0;
-		afectrl1 = (uint16) ((pi_lcn->lcnphy_rssi_vf) |
+		afectrl1 = (u16) ((pi_lcn->lcnphy_rssi_vf) |
 				     (pi_lcn->lcnphy_rssi_vc << 4) | (pi_lcn->
 								      lcnphy_rssi_gs
 								      << 10));
@@ -4454,7 +4459,8 @@ static void WLBANDINITFN(wlc_lcnphy_rev0_baseband_init) (phy_info_t * pi) {
 
 }
 
-static void WLBANDINITFN(wlc_lcnphy_rev2_baseband_init) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_lcnphy_rev2_baseband_init) (phy_info_t *pi)
+{
 	if (CHSPEC_IS5G(pi->radio_chanspec)) {
 		mod_phy_reg(pi, 0x416, (0xff << 0), 80 << 0);
 
@@ -4462,17 +4468,17 @@ static void WLBANDINITFN(wlc_lcnphy_rev2_baseband_init) (phy_info_t * pi) {
 	}
 }
 
-static void wlc_lcnphy_agc_temp_init(phy_info_t * pi)
+static void wlc_lcnphy_agc_temp_init(phy_info_t *pi)
 {
-	int16 temp;
+	s16 temp;
 	phytbl_info_t tab;
-	uint32 tableBuffer[2];
+	u32 tableBuffer[2];
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
 
-	temp = (int16) read_phy_reg(pi, 0x4df);
+	temp = (s16) read_phy_reg(pi, 0x4df);
 	pi_lcn->lcnphy_ofdmgainidxtableoffset = (temp & (0xff << 0)) >> 0;
 
 	if (pi_lcn->lcnphy_ofdmgainidxtableoffset > 127)
@@ -4498,11 +4504,11 @@ static void wlc_lcnphy_agc_temp_init(phy_info_t * pi)
 		tableBuffer[1] -= 128;
 	pi_lcn->lcnphy_tr_T_gain_val = tableBuffer[1];
 
-	temp = (int16) (read_phy_reg(pi, 0x434)
+	temp = (s16) (read_phy_reg(pi, 0x434)
 			& (0xff << 0));
 	if (temp > 127)
 		temp -= 256;
-	pi_lcn->lcnphy_input_pwr_offset_db = (int8) temp;
+	pi_lcn->lcnphy_input_pwr_offset_db = (s8) temp;
 
 	pi_lcn->lcnphy_Med_Low_Gain_db = (read_phy_reg(pi, 0x424)
 					  & (0xff << 8))
@@ -4523,7 +4529,8 @@ static void wlc_lcnphy_agc_temp_init(phy_info_t * pi)
 
 }
 
-static void WLBANDINITFN(wlc_lcnphy_bu_tweaks) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_lcnphy_bu_tweaks) (phy_info_t *pi)
+{
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
 
@@ -4577,7 +4584,8 @@ static void WLBANDINITFN(wlc_lcnphy_bu_tweaks) (phy_info_t * pi) {
 	}
 }
 
-static void WLBANDINITFN(wlc_lcnphy_baseband_init) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_lcnphy_baseband_init) (phy_info_t *pi)
+{
 
 	wlc_lcnphy_tbl_init(pi);
 	wlc_lcnphy_rev0_baseband_init(pi);
@@ -4586,8 +4594,9 @@ static void WLBANDINITFN(wlc_lcnphy_baseband_init) (phy_info_t * pi) {
 	wlc_lcnphy_bu_tweaks(pi);
 }
 
-static void WLBANDINITFN(wlc_radio_2064_init) (phy_info_t * pi) {
-	uint32 i;
+static void WLBANDINITFN(wlc_radio_2064_init) (phy_info_t *pi)
+{
+	u32 i;
 	lcnphy_radio_regs_t *lcnphyregs = NULL;
 
 	lcnphyregs = lcnphy_radio_regs_2064;
@@ -4597,12 +4606,12 @@ static void WLBANDINITFN(wlc_radio_2064_init) (phy_info_t * pi) {
 			write_radio_reg(pi,
 					((lcnphyregs[i].address & 0x3fff) |
 					 RADIO_DEFAULT_CORE),
-					(uint16) lcnphyregs[i].init_a);
+					(u16) lcnphyregs[i].init_a);
 		else if (lcnphyregs[i].do_init_g)
 			write_radio_reg(pi,
 					((lcnphyregs[i].address & 0x3fff) |
 					 RADIO_DEFAULT_CORE),
-					(uint16) lcnphyregs[i].init_g);
+					(u16) lcnphyregs[i].init_g);
 
 	write_radio_reg(pi, RADIO_2064_REG032, 0x62);
 	write_radio_reg(pi, RADIO_2064_REG033, 0x19);
@@ -4646,16 +4655,17 @@ static void WLBANDINITFN(wlc_radio_2064_init) (phy_info_t * pi) {
 	wlc_lcnphy_rc_cal(pi);
 }
 
-static void WLBANDINITFN(wlc_lcnphy_radio_init) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_lcnphy_radio_init) (phy_info_t *pi)
+{
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
 
 	wlc_radio_2064_init(pi);
 }
 
-static void wlc_lcnphy_rcal(phy_info_t * pi)
+static void wlc_lcnphy_rcal(phy_info_t *pi)
 {
-	uint8 rcal_value;
+	u8 rcal_value;
 
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
@@ -4671,11 +4681,11 @@ static void wlc_lcnphy_rcal(phy_info_t * pi)
 	or_radio_reg(pi, RADIO_2064_REG057, 0x01);
 
 	or_radio_reg(pi, RADIO_2064_REG05B, 0x02);
-	OSL_DELAY(5000);
+	mdelay(5);
 	SPINWAIT(!wlc_radio_2064_rcal_done(pi), 10 * 1000 * 1000);
 
 	if (wlc_radio_2064_rcal_done(pi)) {
-		rcal_value = (uint8) read_radio_reg(pi, RADIO_2064_REG05C);
+		rcal_value = (u8) read_radio_reg(pi, RADIO_2064_REG05C);
 		rcal_value = rcal_value & 0x1f;
 	}
 
@@ -4684,10 +4694,10 @@ static void wlc_lcnphy_rcal(phy_info_t * pi)
 	and_radio_reg(pi, RADIO_2064_REG057, 0xFE);
 }
 
-static void wlc_lcnphy_rc_cal(phy_info_t * pi)
+static void wlc_lcnphy_rc_cal(phy_info_t *pi)
 {
-	uint8 dflt_rc_cal_val;
-	uint16 flt_val;
+	u8 dflt_rc_cal_val;
+	u16 flt_val;
 
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
@@ -4707,28 +4717,29 @@ static void wlc_lcnphy_rc_cal(phy_info_t * pi)
 	return;
 }
 
-static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_lcnphy) (phy_info_t * pi) {
-	int8 txpwr = 0;
+static bool wlc_phy_txpwr_srom_read_lcnphy(phy_info_t *pi)
+{
+	s8 txpwr = 0;
 	int i;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	if (CHSPEC_IS2G(pi->radio_chanspec)) {
-		uint16 cckpo = 0;
-		uint32 offset_ofdm, offset_mcs;
+		u16 cckpo = 0;
+		u32 offset_ofdm, offset_mcs;
 
 		pi_lcn->lcnphy_tr_isolation_mid =
-		    (uint8) PHY_GETINTVAR(pi, "triso2g");
+		    (u8) PHY_GETINTVAR(pi, "triso2g");
 
 		pi_lcn->lcnphy_rx_power_offset =
-		    (uint8) PHY_GETINTVAR(pi, "rxpo2g");
+		    (u8) PHY_GETINTVAR(pi, "rxpo2g");
 
-		pi->txpa_2g[0] = (int16) PHY_GETINTVAR(pi, "pa0b0");
-		pi->txpa_2g[1] = (int16) PHY_GETINTVAR(pi, "pa0b1");
-		pi->txpa_2g[2] = (int16) PHY_GETINTVAR(pi, "pa0b2");
+		pi->txpa_2g[0] = (s16) PHY_GETINTVAR(pi, "pa0b0");
+		pi->txpa_2g[1] = (s16) PHY_GETINTVAR(pi, "pa0b1");
+		pi->txpa_2g[2] = (s16) PHY_GETINTVAR(pi, "pa0b2");
 
-		pi_lcn->lcnphy_rssi_vf = (uint8) PHY_GETINTVAR(pi, "rssismf2g");
-		pi_lcn->lcnphy_rssi_vc = (uint8) PHY_GETINTVAR(pi, "rssismc2g");
-		pi_lcn->lcnphy_rssi_gs = (uint8) PHY_GETINTVAR(pi, "rssisav2g");
+		pi_lcn->lcnphy_rssi_vf = (u8) PHY_GETINTVAR(pi, "rssismf2g");
+		pi_lcn->lcnphy_rssi_vc = (u8) PHY_GETINTVAR(pi, "rssismc2g");
+		pi_lcn->lcnphy_rssi_gs = (u8) PHY_GETINTVAR(pi, "rssisav2g");
 
 		{
 			pi_lcn->lcnphy_rssi_vf_lowtemp = pi_lcn->lcnphy_rssi_vf;
@@ -4743,7 +4754,7 @@ static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_lcnphy) (phy_info_t * pi) {
 			    pi_lcn->lcnphy_rssi_gs;
 		}
 
-		txpwr = (int8) PHY_GETINTVAR(pi, "maxp2ga0");
+		txpwr = (s8) PHY_GETINTVAR(pi, "maxp2ga0");
 		pi->tx_srom_max_2g = txpwr;
 
 		for (i = 0; i < PWRTBL_NUM_COEFF; i++) {
@@ -4751,7 +4762,7 @@ static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_lcnphy) (phy_info_t * pi) {
 			pi->txpa_2g_high_temp[i] = pi->txpa_2g[i];
 		}
 
-		cckpo = (uint16) PHY_GETINTVAR(pi, "cck2gpo");
+		cckpo = (u16) PHY_GETINTVAR(pi, "cck2gpo");
 		if (cckpo) {
 			uint max_pwr_chan = txpwr;
 
@@ -4761,22 +4772,22 @@ static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_lcnphy) (phy_info_t * pi) {
 				cckpo >>= 4;
 			}
 
-			offset_ofdm = (uint32) PHY_GETINTVAR(pi, "ofdm2gpo");
+			offset_ofdm = (u32) PHY_GETINTVAR(pi, "ofdm2gpo");
 			for (i = TXP_FIRST_OFDM; i <= TXP_LAST_OFDM; i++) {
 				pi->tx_srom_max_rate_2g[i] = max_pwr_chan -
 				    ((offset_ofdm & 0xf) * 2);
 				offset_ofdm >>= 4;
 			}
 		} else {
-			uint8 opo = 0;
+			u8 opo = 0;
 
-			opo = (uint8) PHY_GETINTVAR(pi, "opo");
+			opo = (u8) PHY_GETINTVAR(pi, "opo");
 
 			for (i = TXP_FIRST_CCK; i <= TXP_LAST_CCK; i++) {
 				pi->tx_srom_max_rate_2g[i] = txpwr;
 			}
 
-			offset_ofdm = (uint32) PHY_GETINTVAR(pi, "ofdm2gpo");
+			offset_ofdm = (u32) PHY_GETINTVAR(pi, "ofdm2gpo");
 
 			for (i = TXP_FIRST_OFDM; i <= TXP_LAST_OFDM; i++) {
 				pi->tx_srom_max_rate_2g[i] = txpwr -
@@ -4784,8 +4795,8 @@ static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_lcnphy) (phy_info_t * pi) {
 				offset_ofdm >>= 4;
 			}
 			offset_mcs =
-			    ((uint16) PHY_GETINTVAR(pi, "mcs2gpo1") << 16) |
-			    (uint16) PHY_GETINTVAR(pi, "mcs2gpo0");
+			    ((u16) PHY_GETINTVAR(pi, "mcs2gpo1") << 16) |
+			    (u16) PHY_GETINTVAR(pi, "mcs2gpo0");
 			pi_lcn->lcnphy_mcs20_po = offset_mcs;
 			for (i = TXP_FIRST_SISO_MCS_20;
 			     i <= TXP_LAST_SISO_MCS_20; i++) {
@@ -4796,64 +4807,64 @@ static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_lcnphy) (phy_info_t * pi) {
 		}
 
 		pi_lcn->lcnphy_rawtempsense =
-		    (uint16) PHY_GETINTVAR(pi, "rawtempsense");
+		    (u16) PHY_GETINTVAR(pi, "rawtempsense");
 		pi_lcn->lcnphy_measPower =
-		    (uint8) PHY_GETINTVAR(pi, "measpower");
+		    (u8) PHY_GETINTVAR(pi, "measpower");
 		pi_lcn->lcnphy_tempsense_slope =
-		    (uint8) PHY_GETINTVAR(pi, "tempsense_slope");
+		    (u8) PHY_GETINTVAR(pi, "tempsense_slope");
 		pi_lcn->lcnphy_hw_iqcal_en =
 		    (bool) PHY_GETINTVAR(pi, "hw_iqcal_en");
 		pi_lcn->lcnphy_iqcal_swp_dis =
 		    (bool) PHY_GETINTVAR(pi, "iqcal_swp_dis");
 		pi_lcn->lcnphy_tempcorrx =
-		    (uint8) PHY_GETINTVAR(pi, "tempcorrx");
+		    (u8) PHY_GETINTVAR(pi, "tempcorrx");
 		pi_lcn->lcnphy_tempsense_option =
-		    (uint8) PHY_GETINTVAR(pi, "tempsense_option");
+		    (u8) PHY_GETINTVAR(pi, "tempsense_option");
 		pi_lcn->lcnphy_freqoffset_corr =
-		    (uint8) PHY_GETINTVAR(pi, "freqoffset_corr");
-		if ((uint8) getintvar(pi->vars, "aa2g") > 1)
+		    (u8) PHY_GETINTVAR(pi, "freqoffset_corr");
+		if ((u8) getintvar(pi->vars, "aa2g") > 1)
 			wlc_phy_ant_rxdiv_set((wlc_phy_t *) pi,
-					      (uint8) getintvar(pi->vars,
+					      (u8) getintvar(pi->vars,
 								"aa2g"));
 	}
 	pi_lcn->lcnphy_cck_dig_filt_type = -1;
 	if (PHY_GETVAR(pi, "cckdigfilttype")) {
-		int16 temp;
-		temp = (int16) PHY_GETINTVAR(pi, "cckdigfilttype");
+		s16 temp;
+		temp = (s16) PHY_GETINTVAR(pi, "cckdigfilttype");
 		if (temp >= 0) {
 			pi_lcn->lcnphy_cck_dig_filt_type = temp;
 		}
 	}
 
-	return TRUE;
+	return true;
 }
 
-void wlc_2064_vco_cal(phy_info_t * pi)
+void wlc_2064_vco_cal(phy_info_t *pi)
 {
-	uint8 calnrst;
+	u8 calnrst;
 
 	mod_radio_reg(pi, RADIO_2064_REG057, 1 << 3, 1 << 3);
-	calnrst = (uint8) read_radio_reg(pi, RADIO_2064_REG056) & 0xf8;
+	calnrst = (u8) read_radio_reg(pi, RADIO_2064_REG056) & 0xf8;
 	write_radio_reg(pi, RADIO_2064_REG056, calnrst);
-	OSL_DELAY(1);
+	udelay(1);
 	write_radio_reg(pi, RADIO_2064_REG056, calnrst | 0x03);
-	OSL_DELAY(1);
+	udelay(1);
 	write_radio_reg(pi, RADIO_2064_REG056, calnrst | 0x07);
-	OSL_DELAY(300);
+	udelay(300);
 	mod_radio_reg(pi, RADIO_2064_REG057, 1 << 3, 0);
 }
 
 static void
-wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t * pi, uint8 channel)
+wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t *pi, u8 channel)
 {
 	uint i;
 	const chan_info_2064_lcnphy_t *ci;
-	uint8 rfpll_doubler = 0;
-	uint8 pll_pwrup, pll_pwrup_ovr;
+	u8 rfpll_doubler = 0;
+	u8 pll_pwrup, pll_pwrup_ovr;
 	fixed qFxtal, qFref, qFvco, qFcal;
-	uint8 d15, d16, f16, e44, e45;
-	uint32 div_int, div_frac, fvco3, fpfd, fref3, fcal_div;
-	uint16 loop_bw, d30, setCount;
+	u8 d15, d16, f16, e44, e45;
+	u32 div_int, div_frac, fvco3, fpfd, fref3, fcal_div;
+	u16 loop_bw, d30, setCount;
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
 	ci = &chan_info_2064_lcnphy[0];
@@ -4871,11 +4882,11 @@ wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t * pi, uint8 channel)
 	}
 
 	if (CHSPEC_IS2G(pi->radio_chanspec)) {
-		for (i = 0; i < ARRAYSIZE(chan_info_2064_lcnphy); i++)
+		for (i = 0; i < ARRAY_SIZE(chan_info_2064_lcnphy); i++)
 			if (chan_info_2064_lcnphy[i].chan == channel)
 				break;
 
-		if (i >= ARRAYSIZE(chan_info_2064_lcnphy)) {
+		if (i >= ARRAY_SIZE(chan_info_2064_lcnphy)) {
 			return;
 		}
 
@@ -4900,8 +4911,8 @@ wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t * pi, uint8 channel)
 
 	write_radio_reg(pi, RADIO_2064_REG06C, ci->rxrf_rxrf_spare1);
 
-	pll_pwrup = (uint8) read_radio_reg(pi, RADIO_2064_REG044);
-	pll_pwrup_ovr = (uint8) read_radio_reg(pi, RADIO_2064_REG12B);
+	pll_pwrup = (u8) read_radio_reg(pi, RADIO_2064_REG044);
+	pll_pwrup_ovr = (u8) read_radio_reg(pi, RADIO_2064_REG12B);
 
 	or_radio_reg(pi, RADIO_2064_REG044, 0x07);
 
@@ -4940,10 +4951,10 @@ wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t * pi, uint8 channel)
 	f16 = ((d16 + 1) * (d15 + 1)) / qFcal;
 	setCount = f16 * 3 * (ci->freq) / 32 - 1;
 	mod_radio_reg(pi, RADIO_2064_REG053, (0x0f << 0),
-		      (uint8) (setCount >> 8));
+		      (u8) (setCount >> 8));
 
 	or_radio_reg(pi, RADIO_2064_REG053, 0x10);
-	write_radio_reg(pi, RADIO_2064_REG054, (uint8) (setCount & 0xff));
+	write_radio_reg(pi, RADIO_2064_REG054, (u8) (setCount & 0xff));
 
 	div_int = ((fvco3 * (PLL_2064_MHZ >> 4)) / fref3) << 4;
 
@@ -4955,13 +4966,13 @@ wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t * pi, uint8 channel)
 	div_frac = wlc_lcnphy_qdiv_roundup(div_frac, fref3, 20);
 
 	mod_radio_reg(pi, RADIO_2064_REG045, (0x1f << 0),
-		      (uint8) (div_int >> 4));
+		      (u8) (div_int >> 4));
 	mod_radio_reg(pi, RADIO_2064_REG046, (0x1f << 4),
-		      (uint8) (div_int << 4));
+		      (u8) (div_int << 4));
 	mod_radio_reg(pi, RADIO_2064_REG046, (0x0f << 0),
-		      (uint8) (div_frac >> 16));
-	write_radio_reg(pi, RADIO_2064_REG047, (uint8) (div_frac >> 8) & 0xff);
-	write_radio_reg(pi, RADIO_2064_REG048, (uint8) div_frac & 0xff);
+		      (u8) (div_frac >> 16));
+	write_radio_reg(pi, RADIO_2064_REG047, (u8) (div_frac >> 8) & 0xff);
+	write_radio_reg(pi, RADIO_2064_REG048, (u8) div_frac & 0xff);
 
 	write_radio_reg(pi, RADIO_2064_REG040, 0xfb);
 
@@ -4970,8 +4981,8 @@ wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t * pi, uint8 channel)
 	write_radio_reg(pi, RADIO_2064_REG043, 0x0C);
 
 	{
-		uint8 h29, h23, c28, d29, h28_ten, e30, h30_ten, cp_current;
-		uint16 c29, c38, c30, g30, d28;
+		u8 h29, h23, c28, d29, h28_ten, e30, h30_ten, cp_current;
+		u16 c29, c38, c30, g30, d28;
 		c29 = loop_bw;
 		d29 = 200;
 		c38 = 1250;
@@ -4997,7 +5008,7 @@ wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t * pi, uint8 channel)
 	write_radio_reg(pi, RADIO_2064_REG03D, 0x3);
 
 	mod_radio_reg(pi, RADIO_2064_REG044, 0x0c, 0x0c);
-	OSL_DELAY(1);
+	udelay(1);
 
 	wlc_2064_vco_cal(pi);
 
@@ -5009,7 +5020,7 @@ wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t * pi, uint8 channel)
 	}
 }
 
-bool wlc_phy_tpc_isenabled_lcnphy(phy_info_t * pi)
+bool wlc_phy_tpc_isenabled_lcnphy(phy_info_t *pi)
 {
 	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi))
 		return 0;
@@ -5018,9 +5029,9 @@ bool wlc_phy_tpc_isenabled_lcnphy(phy_info_t * pi)
 			wlc_lcnphy_get_tx_pwr_ctrl((pi)));
 }
 
-void wlc_phy_txpower_recalc_target_lcnphy(phy_info_t * pi)
+void wlc_phy_txpower_recalc_target_lcnphy(phy_info_t *pi)
 {
-	uint16 pwr_ctrl;
+	u16 pwr_ctrl;
 	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi)) {
 		wlc_lcnphy_calib_modes(pi, LCNPHY_PERICAL_TEMPBASED_TXPWRCTRL);
 	} else if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi)) {
@@ -5034,28 +5045,25 @@ void wlc_phy_txpower_recalc_target_lcnphy(phy_info_t * pi)
 		return;
 }
 
-void wlc_phy_detach_lcnphy(phy_info_t * pi)
+void wlc_phy_detach_lcnphy(phy_info_t *pi)
 {
-	MFREE(pi->sh->osh, pi->u.pi_lcnphy, sizeof(phy_info_lcnphy_t));
+	kfree(pi->u.pi_lcnphy);
 }
 
-bool wlc_phy_attach_lcnphy(phy_info_t * pi)
+bool wlc_phy_attach_lcnphy(phy_info_t *pi)
 {
 	phy_info_lcnphy_t *pi_lcn;
 
-	pi->u.pi_lcnphy =
-	    (phy_info_lcnphy_t *) MALLOC(pi->sh->osh,
-					 sizeof(phy_info_lcnphy_t));
+	pi->u.pi_lcnphy = kzalloc(sizeof(phy_info_lcnphy_t), GFP_ATOMIC);
 	if (pi->u.pi_lcnphy == NULL) {
-		return FALSE;
+		return false;
 	}
-	bzero((char *)pi->u.pi_lcnphy, sizeof(phy_info_lcnphy_t));
 
 	pi_lcn = pi->u.pi_lcnphy;
 
 	if ((0 == (pi->sh->boardflags & BFL_NOPA)) && !NORADIO_ENAB(pi->pubpi)) {
-		pi->hwpwrctrl = TRUE;
-		pi->hwpwrctrl_capable = TRUE;
+		pi->hwpwrctrl = true;
+		pi->hwpwrctrl_capable = true;
 	}
 
 	pi->xtalfreq = si_alp_clock(pi->sh->sih);
@@ -5074,36 +5082,36 @@ bool wlc_phy_attach_lcnphy(phy_info_t * pi)
 	pi->pi_fptr.detach = wlc_phy_detach_lcnphy;
 
 	if (!wlc_phy_txpwr_srom_read_lcnphy(pi))
-		return FALSE;
+		return false;
 
 	if ((pi->sh->boardflags & BFL_FEM) && (LCNREV_IS(pi->pubpi.phy_rev, 1))) {
 		if (pi_lcn->lcnphy_tempsense_option == 3) {
-			pi->hwpwrctrl = TRUE;
-			pi->hwpwrctrl_capable = TRUE;
-			pi->temppwrctrl_capable = FALSE;
+			pi->hwpwrctrl = true;
+			pi->hwpwrctrl_capable = true;
+			pi->temppwrctrl_capable = false;
 		} else {
-			pi->hwpwrctrl = FALSE;
-			pi->hwpwrctrl_capable = FALSE;
-			pi->temppwrctrl_capable = TRUE;
+			pi->hwpwrctrl = false;
+			pi->hwpwrctrl_capable = false;
+			pi->temppwrctrl_capable = true;
 		}
 	}
 
-	return TRUE;
+	return true;
 }
 
-static void wlc_lcnphy_set_rx_gain(phy_info_t * pi, uint32 gain)
+static void wlc_lcnphy_set_rx_gain(phy_info_t *pi, u32 gain)
 {
-	uint16 trsw, ext_lna, lna1, lna2, tia, biq0, biq1, gain0_15, gain16_19;
+	u16 trsw, ext_lna, lna1, lna2, tia, biq0, biq1, gain0_15, gain16_19;
 
-	trsw = (gain & ((uint32) 1 << 28)) ? 0 : 1;
-	ext_lna = (uint16) (gain >> 29) & 0x01;
-	lna1 = (uint16) (gain >> 0) & 0x0f;
-	lna2 = (uint16) (gain >> 4) & 0x0f;
-	tia = (uint16) (gain >> 8) & 0xf;
-	biq0 = (uint16) (gain >> 12) & 0xf;
-	biq1 = (uint16) (gain >> 16) & 0xf;
+	trsw = (gain & ((u32) 1 << 28)) ? 0 : 1;
+	ext_lna = (u16) (gain >> 29) & 0x01;
+	lna1 = (u16) (gain >> 0) & 0x0f;
+	lna2 = (u16) (gain >> 4) & 0x0f;
+	tia = (u16) (gain >> 8) & 0xf;
+	biq0 = (u16) (gain >> 12) & 0xf;
+	biq1 = (u16) (gain >> 16) & 0xf;
 
-	gain0_15 = (uint16) ((lna1 & 0x3) | ((lna1 & 0x3) << 2) |
+	gain0_15 = (u16) ((lna1 & 0x3) | ((lna1 & 0x3) << 2) |
 			     ((lna2 & 0x3) << 4) | ((lna2 & 0x3) << 6) |
 			     ((tia & 0xf) << 8) | ((biq0 & 0xf) << 12));
 	gain16_19 = biq1;
@@ -5118,14 +5126,14 @@ static void wlc_lcnphy_set_rx_gain(phy_info_t * pi, uint32 gain)
 		mod_phy_reg(pi, 0x4b1, (0x3 << 11), lna1 << 11);
 		mod_phy_reg(pi, 0x4e6, (0x3 << 3), lna1 << 3);
 	}
-	wlc_lcnphy_rx_gain_override_enable(pi, TRUE);
+	wlc_lcnphy_rx_gain_override_enable(pi, true);
 }
 
-static uint32 wlc_lcnphy_get_receive_power(phy_info_t * pi, int32 * gain_index)
+static u32 wlc_lcnphy_get_receive_power(phy_info_t *pi, s32 *gain_index)
 {
-	uint32 received_power = 0;
-	int32 max_index = 0;
-	uint32 gain_code = 0;
+	u32 received_power = 0;
+	s32 max_index = 0;
+	u32 gain_code = 0;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	max_index = 36;
@@ -5134,7 +5142,7 @@ static uint32 wlc_lcnphy_get_receive_power(phy_info_t * pi, int32 * gain_index)
 
 	if (-1 == *gain_index) {
 		*gain_index = 0;
-		while ((*gain_index <= (int32) max_index)
+		while ((*gain_index <= (s32) max_index)
 		       && (received_power < 700)) {
 			wlc_lcnphy_set_rx_gain(pi,
 					       lcnphy_23bitgaincode_table
@@ -5157,13 +5165,13 @@ static uint32 wlc_lcnphy_get_receive_power(phy_info_t * pi, int32 * gain_index)
 	return received_power;
 }
 
-int32 wlc_lcnphy_rx_signal_power(phy_info_t * pi, int32 gain_index)
+s32 wlc_lcnphy_rx_signal_power(phy_info_t *pi, s32 gain_index)
 {
-	int32 gain = 0;
-	int32 nominal_power_db;
-	int32 log_val, gain_mismatch, desired_gain, input_power_offset_db,
+	s32 gain = 0;
+	s32 nominal_power_db;
+	s32 log_val, gain_mismatch, desired_gain, input_power_offset_db,
 	    input_power_db;
-	int32 received_power, temperature;
+	s32 received_power, temperature;
 	uint freq;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
@@ -5174,9 +5182,9 @@ int32 wlc_lcnphy_rx_signal_power(phy_info_t * pi, int32 gain_index)
 	nominal_power_db = read_phy_reg(pi, 0x425) >> 8;
 
 	{
-		uint32 power = (received_power * 16);
-		uint32 msb1, msb2, val1, val2, diff1, diff2;
-		msb1 = find_msbit(power);
+		u32 power = (received_power * 16);
+		u32 msb1, msb2, val1, val2, diff1, diff2;
+		msb1 = ffs(power) - 1;
 		msb2 = msb1 + 1;
 		val1 = 1 << msb1;
 		val2 = 1 << msb2;
@@ -5229,12 +5237,12 @@ int32 wlc_lcnphy_rx_signal_power(phy_info_t * pi, int32 gain_index)
 }
 
 static int
-wlc_lcnphy_load_tx_iir_filter(phy_info_t * pi, bool is_ofdm, int16 filt_type)
+wlc_lcnphy_load_tx_iir_filter(phy_info_t *pi, bool is_ofdm, s16 filt_type)
 {
-	int16 filt_index = -1;
+	s16 filt_index = -1;
 	int j;
 
-	uint16 addr[] = {
+	u16 addr[] = {
 		0x910,
 		0x91e,
 		0x91f,
@@ -5253,7 +5261,7 @@ wlc_lcnphy_load_tx_iir_filter(phy_info_t * pi, bool is_ofdm, int16 filt_type)
 		0x932
 	};
 
-	uint16 addr_ofdm[] = {
+	u16 addr_ofdm[] = {
 		0x90f,
 		0x900,
 		0x901,
@@ -5275,13 +5283,13 @@ wlc_lcnphy_load_tx_iir_filter(phy_info_t * pi, bool is_ofdm, int16 filt_type)
 	if (!is_ofdm) {
 		for (j = 0; j < LCNPHY_NUM_TX_DIG_FILTERS_CCK; j++) {
 			if (filt_type == LCNPHY_txdigfiltcoeffs_cck[j][0]) {
-				filt_index = (int16) j;
+				filt_index = (s16) j;
 				break;
 			}
 		}
 
 		if (filt_index == -1) {
-			ASSERT(FALSE);
+			ASSERT(false);
 		} else {
 			for (j = 0; j < LCNPHY_NUM_DIG_FILT_COEFFS; j++) {
 				write_phy_reg(pi, addr[j],
@@ -5292,13 +5300,13 @@ wlc_lcnphy_load_tx_iir_filter(phy_info_t * pi, bool is_ofdm, int16 filt_type)
 	} else {
 		for (j = 0; j < LCNPHY_NUM_TX_DIG_FILTERS_OFDM; j++) {
 			if (filt_type == LCNPHY_txdigfiltcoeffs_ofdm[j][0]) {
-				filt_index = (int16) j;
+				filt_index = (s16) j;
 				break;
 			}
 		}
 
 		if (filt_index == -1) {
-			ASSERT(FALSE);
+			ASSERT(false);
 		} else {
 			for (j = 0; j < LCNPHY_NUM_DIG_FILT_COEFFS; j++) {
 				write_phy_reg(pi, addr_ofdm[j],
diff --git a/drivers/staging/brcm80211/phy/wlc_phy_lcn.h b/drivers/staging/brcm80211/phy/wlc_phy_lcn.h
index e278a2c..b7bfc72 100644
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.h
@@ -17,105 +17,103 @@
 #ifndef _wlc_phy_lcn_h_
 #define _wlc_phy_lcn_h_
 
-#include <typedefs.h>
-
 struct phy_info_lcnphy {
 	int lcnphy_txrf_sp_9_override;
-	uint8 lcnphy_full_cal_channel;
-	uint8 lcnphy_cal_counter;
-	uint16 lcnphy_cal_temper;
+	u8 lcnphy_full_cal_channel;
+	u8 lcnphy_cal_counter;
+	u16 lcnphy_cal_temper;
 	bool lcnphy_recal;
 
-	uint8 lcnphy_rc_cap;
-	uint32 lcnphy_mcs20_po;
+	u8 lcnphy_rc_cap;
+	u32 lcnphy_mcs20_po;
 
-	uint8 lcnphy_tr_isolation_mid;
-	uint8 lcnphy_tr_isolation_low;
-	uint8 lcnphy_tr_isolation_hi;
+	u8 lcnphy_tr_isolation_mid;
+	u8 lcnphy_tr_isolation_low;
+	u8 lcnphy_tr_isolation_hi;
 
-	uint8 lcnphy_bx_arch;
-	uint8 lcnphy_rx_power_offset;
-	uint8 lcnphy_rssi_vf;
-	uint8 lcnphy_rssi_vc;
-	uint8 lcnphy_rssi_gs;
-	uint8 lcnphy_tssi_val;
-	uint8 lcnphy_rssi_vf_lowtemp;
-	uint8 lcnphy_rssi_vc_lowtemp;
-	uint8 lcnphy_rssi_gs_lowtemp;
+	u8 lcnphy_bx_arch;
+	u8 lcnphy_rx_power_offset;
+	u8 lcnphy_rssi_vf;
+	u8 lcnphy_rssi_vc;
+	u8 lcnphy_rssi_gs;
+	u8 lcnphy_tssi_val;
+	u8 lcnphy_rssi_vf_lowtemp;
+	u8 lcnphy_rssi_vc_lowtemp;
+	u8 lcnphy_rssi_gs_lowtemp;
 
-	uint8 lcnphy_rssi_vf_hightemp;
-	uint8 lcnphy_rssi_vc_hightemp;
-	uint8 lcnphy_rssi_gs_hightemp;
+	u8 lcnphy_rssi_vf_hightemp;
+	u8 lcnphy_rssi_vc_hightemp;
+	u8 lcnphy_rssi_gs_hightemp;
 
-	int16 lcnphy_pa0b0;
-	int16 lcnphy_pa0b1;
-	int16 lcnphy_pa0b2;
+	s16 lcnphy_pa0b0;
+	s16 lcnphy_pa0b1;
+	s16 lcnphy_pa0b2;
 
-	uint16 lcnphy_rawtempsense;
-	uint8 lcnphy_measPower;
-	uint8 lcnphy_tempsense_slope;
-	uint8 lcnphy_freqoffset_corr;
-	uint8 lcnphy_tempsense_option;
-	uint8 lcnphy_tempcorrx;
+	u16 lcnphy_rawtempsense;
+	u8 lcnphy_measPower;
+	u8 lcnphy_tempsense_slope;
+	u8 lcnphy_freqoffset_corr;
+	u8 lcnphy_tempsense_option;
+	u8 lcnphy_tempcorrx;
 	bool lcnphy_iqcal_swp_dis;
 	bool lcnphy_hw_iqcal_en;
 	uint lcnphy_bandedge_corr;
 	bool lcnphy_spurmod;
-	uint16 lcnphy_tssi_tx_cnt;
-	uint16 lcnphy_tssi_idx;
-	uint16 lcnphy_tssi_npt;
+	u16 lcnphy_tssi_tx_cnt;
+	u16 lcnphy_tssi_idx;
+	u16 lcnphy_tssi_npt;
 
-	uint16 lcnphy_target_tx_freq;
-	int8 lcnphy_tx_power_idx_override;
-	uint16 lcnphy_noise_samples;
+	u16 lcnphy_target_tx_freq;
+	s8 lcnphy_tx_power_idx_override;
+	u16 lcnphy_noise_samples;
 
-	uint32 lcnphy_papdRxGnIdx;
-	uint32 lcnphy_papd_rxGnCtrl_init;
+	u32 lcnphy_papdRxGnIdx;
+	u32 lcnphy_papd_rxGnCtrl_init;
 
-	uint32 lcnphy_gain_idx_14_lowword;
-	uint32 lcnphy_gain_idx_14_hiword;
-	uint32 lcnphy_gain_idx_27_lowword;
-	uint32 lcnphy_gain_idx_27_hiword;
-	int16 lcnphy_ofdmgainidxtableoffset;
-	int16 lcnphy_dsssgainidxtableoffset;
-	uint32 lcnphy_tr_R_gain_val;
-	uint32 lcnphy_tr_T_gain_val;
-	int8 lcnphy_input_pwr_offset_db;
-	uint16 lcnphy_Med_Low_Gain_db;
-	uint16 lcnphy_Very_Low_Gain_db;
-	int8 lcnphy_lastsensed_temperature;
-	int8 lcnphy_pkteng_rssi_slope;
-	uint8 lcnphy_saved_tx_user_target[TXP_NUM_RATES];
-	uint8 lcnphy_volt_winner;
-	uint8 lcnphy_volt_low;
-	uint8 lcnphy_54_48_36_24mbps_backoff;
-	uint8 lcnphy_11n_backoff;
-	uint8 lcnphy_lowerofdm;
-	uint8 lcnphy_cck;
-	uint8 lcnphy_psat_2pt3_detected;
-	int32 lcnphy_lowest_Re_div_Im;
-	int8 lcnphy_final_papd_cal_idx;
-	uint16 lcnphy_extstxctrl4;
-	uint16 lcnphy_extstxctrl0;
-	uint16 lcnphy_extstxctrl1;
-	int16 lcnphy_cck_dig_filt_type;
-	int16 lcnphy_ofdm_dig_filt_type;
+	u32 lcnphy_gain_idx_14_lowword;
+	u32 lcnphy_gain_idx_14_hiword;
+	u32 lcnphy_gain_idx_27_lowword;
+	u32 lcnphy_gain_idx_27_hiword;
+	s16 lcnphy_ofdmgainidxtableoffset;
+	s16 lcnphy_dsssgainidxtableoffset;
+	u32 lcnphy_tr_R_gain_val;
+	u32 lcnphy_tr_T_gain_val;
+	s8 lcnphy_input_pwr_offset_db;
+	u16 lcnphy_Med_Low_Gain_db;
+	u16 lcnphy_Very_Low_Gain_db;
+	s8 lcnphy_lastsensed_temperature;
+	s8 lcnphy_pkteng_rssi_slope;
+	u8 lcnphy_saved_tx_user_target[TXP_NUM_RATES];
+	u8 lcnphy_volt_winner;
+	u8 lcnphy_volt_low;
+	u8 lcnphy_54_48_36_24mbps_backoff;
+	u8 lcnphy_11n_backoff;
+	u8 lcnphy_lowerofdm;
+	u8 lcnphy_cck;
+	u8 lcnphy_psat_2pt3_detected;
+	s32 lcnphy_lowest_Re_div_Im;
+	s8 lcnphy_final_papd_cal_idx;
+	u16 lcnphy_extstxctrl4;
+	u16 lcnphy_extstxctrl0;
+	u16 lcnphy_extstxctrl1;
+	s16 lcnphy_cck_dig_filt_type;
+	s16 lcnphy_ofdm_dig_filt_type;
 	lcnphy_cal_results_t lcnphy_cal_results;
 
-	uint8 lcnphy_psat_pwr;
-	uint8 lcnphy_psat_indx;
-	int32 lcnphy_min_phase;
-	uint8 lcnphy_final_idx;
-	uint8 lcnphy_start_idx;
-	uint8 lcnphy_current_index;
-	uint16 lcnphy_logen_buf_1;
-	uint16 lcnphy_local_ovr_2;
-	uint16 lcnphy_local_oval_6;
-	uint16 lcnphy_local_oval_5;
-	uint16 lcnphy_logen_mixer_1;
+	u8 lcnphy_psat_pwr;
+	u8 lcnphy_psat_indx;
+	s32 lcnphy_min_phase;
+	u8 lcnphy_final_idx;
+	u8 lcnphy_start_idx;
+	u8 lcnphy_current_index;
+	u16 lcnphy_logen_buf_1;
+	u16 lcnphy_local_ovr_2;
+	u16 lcnphy_local_oval_6;
+	u16 lcnphy_local_oval_5;
+	u16 lcnphy_logen_mixer_1;
 
-	uint8 lcnphy_aci_stat;
+	u8 lcnphy_aci_stat;
 	uint lcnphy_aci_start_time;
-	int8 lcnphy_tx_power_offset[TXP_NUM_RATES];
+	s8 lcnphy_tx_power_offset[TXP_NUM_RATES];
 };
 #endif				/* _wlc_phy_lcn_h_ */
diff --git a/drivers/staging/brcm80211/phy/wlc_phy_n.c b/drivers/staging/brcm80211/phy/wlc_phy_n.c
index 950dfc6..950008f 100644
--- a/drivers/staging/brcm80211/phy/wlc_phy_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_n.c
@@ -14,11 +14,14 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <bcmdefs.h>
 #include <wlc_cfg.h>
+#include <linuxver.h>
 #include <osl.h>
 #include <siutils.h>
 #include <sbchipc.h>
-#include <bitfuncs.h>
 #include <hndpmu.h>
 #include <bcmendian.h>
 
@@ -105,7 +108,7 @@
 #define NPHY_CALSANITY_RSSI_W1_MAX_NEG (NPHY_RSSICAL_W1_TARGET - NPHY_RSSICAL_MAXREAD)
 #define NPHY_CALSANITY_RSSI_W2_MAX_POS  NPHY_CALSANITY_RSSI_W1_MAX_POS
 #define NPHY_CALSANITY_RSSI_W2_MAX_NEG (NPHY_RSSICAL_W2_TARGET - NPHY_RSSICAL_MAXREAD)
-#define NPHY_RSSI_SXT(x) ((int8) (-((x) & 0x20) + ((x) & 0x1f)))
+#define NPHY_RSSI_SXT(x) ((s8) (-((x) & 0x20) + ((x) & 0x1f)))
 #define NPHY_RSSI_NB_VIOL(x)  (((x) > NPHY_CALSANITY_RSSI_NB_MAX_POS) || \
 			       ((x) < NPHY_CALSANITY_RSSI_NB_MAX_NEG))
 #define NPHY_RSSI_W1_VIOL(x)  (((x) > NPHY_CALSANITY_RSSI_W1_MAX_POS) || \
@@ -137,44 +140,44 @@
 #define NPHY_ADJUSTED_MINCRSPOWER 0x1e
 
 typedef struct _nphy_iqcal_params {
-	uint16 txlpf;
-	uint16 txgm;
-	uint16 pga;
-	uint16 pad;
-	uint16 ipa;
-	uint16 cal_gain;
-	uint16 ncorr[5];
+	u16 txlpf;
+	u16 txgm;
+	u16 pga;
+	u16 pad;
+	u16 ipa;
+	u16 cal_gain;
+	u16 ncorr[5];
 } nphy_iqcal_params_t;
 
 typedef struct _nphy_txiqcal_ladder {
-	uint8 percent;
-	uint8 g_env;
+	u8 percent;
+	u8 g_env;
 } nphy_txiqcal_ladder_t;
 
 typedef struct {
 	nphy_txgains_t gains;
 	bool useindex;
-	uint8 index;
+	u8 index;
 } nphy_ipa_txcalgains_t;
 
 typedef struct nphy_papd_restore_state_t {
-	uint16 fbmix[2];
-	uint16 vga_master[2];
-	uint16 intpa_master[2];
-	uint16 afectrl[2];
-	uint16 afeoverride[2];
-	uint16 pwrup[2];
-	uint16 atten[2];
-	uint16 mm;
+	u16 fbmix[2];
+	u16 vga_master[2];
+	u16 intpa_master[2];
+	u16 afectrl[2];
+	u16 afeoverride[2];
+	u16 pwrup[2];
+	u16 atten[2];
+	u16 mm;
 } nphy_papd_restore_state;
 
 typedef struct _nphy_ipa_txrxgain {
-	uint16 hpvga;
-	uint16 lpf_biq1;
-	uint16 lpf_biq0;
-	uint16 lna2;
-	uint16 lna1;
-	int8 txpwrindex;
+	u16 hpvga;
+	u16 lpf_biq1;
+	u16 lpf_biq0;
+	u16 lna2;
+	u16 lna1;
+	s8 txpwrindex;
 } nphy_ipa_txrxgain_t;
 
 #define NPHY_IPA_RXCAL_MAXGAININDEX (6 - 1)
@@ -233,7 +236,7 @@ enum {
 #define TXFILT_DEFAULT_OFDM20   3
 #define TXFILT_DEFAULT_OFDM40   4
 
-uint16 NPHY_IPA_REV4_txdigi_filtcoeffs[][NPHY_NUM_DIG_FILT_COEFFS] = {
+u16 NPHY_IPA_REV4_txdigi_filtcoeffs[][NPHY_NUM_DIG_FILT_COEFFS] = {
 	{-377, 137, -407, 208, -1527, 956, 93, 186, 93,
 	 230, -44, 230, 201, -191, 201},
 	{-77, 20, -98, 49, -93, 60, 56, 111, 56, 26, -5,
@@ -251,162 +254,162 @@ uint16 NPHY_IPA_REV4_txdigi_filtcoeffs[][NPHY_NUM_DIG_FILT_COEFFS] = {
 };
 
 typedef struct _chan_info_nphy_2055 {
-	uint16 chan;
-	uint16 freq;
+	u16 chan;
+	u16 freq;
 	uint unknown;
-	uint8 RF_pll_ref;
-	uint8 RF_rf_pll_mod1;
-	uint8 RF_rf_pll_mod0;
-	uint8 RF_vco_cap_tail;
-	uint8 RF_vco_cal1;
-	uint8 RF_vco_cal2;
-	uint8 RF_pll_lf_c1;
-	uint8 RF_pll_lf_r1;
-	uint8 RF_pll_lf_c2;
-	uint8 RF_lgbuf_cen_buf;
-	uint8 RF_lgen_tune1;
-	uint8 RF_lgen_tune2;
-	uint8 RF_core1_lgbuf_a_tune;
-	uint8 RF_core1_lgbuf_g_tune;
-	uint8 RF_core1_rxrf_reg1;
-	uint8 RF_core1_tx_pga_pad_tn;
-	uint8 RF_core1_tx_mx_bgtrim;
-	uint8 RF_core2_lgbuf_a_tune;
-	uint8 RF_core2_lgbuf_g_tune;
-	uint8 RF_core2_rxrf_reg1;
-	uint8 RF_core2_tx_pga_pad_tn;
-	uint8 RF_core2_tx_mx_bgtrim;
-	uint16 PHY_BW1a;
-	uint16 PHY_BW2;
-	uint16 PHY_BW3;
-	uint16 PHY_BW4;
-	uint16 PHY_BW5;
-	uint16 PHY_BW6;
+	u8 RF_pll_ref;
+	u8 RF_rf_pll_mod1;
+	u8 RF_rf_pll_mod0;
+	u8 RF_vco_cap_tail;
+	u8 RF_vco_cal1;
+	u8 RF_vco_cal2;
+	u8 RF_pll_lf_c1;
+	u8 RF_pll_lf_r1;
+	u8 RF_pll_lf_c2;
+	u8 RF_lgbuf_cen_buf;
+	u8 RF_lgen_tune1;
+	u8 RF_lgen_tune2;
+	u8 RF_core1_lgbuf_a_tune;
+	u8 RF_core1_lgbuf_g_tune;
+	u8 RF_core1_rxrf_reg1;
+	u8 RF_core1_tx_pga_pad_tn;
+	u8 RF_core1_tx_mx_bgtrim;
+	u8 RF_core2_lgbuf_a_tune;
+	u8 RF_core2_lgbuf_g_tune;
+	u8 RF_core2_rxrf_reg1;
+	u8 RF_core2_tx_pga_pad_tn;
+	u8 RF_core2_tx_mx_bgtrim;
+	u16 PHY_BW1a;
+	u16 PHY_BW2;
+	u16 PHY_BW3;
+	u16 PHY_BW4;
+	u16 PHY_BW5;
+	u16 PHY_BW6;
 } chan_info_nphy_2055_t;
 
 typedef struct _chan_info_nphy_radio205x {
-	uint16 chan;
-	uint16 freq;
-	uint8 RF_SYN_pll_vcocal1;
-	uint8 RF_SYN_pll_vcocal2;
-	uint8 RF_SYN_pll_refdiv;
-	uint8 RF_SYN_pll_mmd2;
-	uint8 RF_SYN_pll_mmd1;
-	uint8 RF_SYN_pll_loopfilter1;
-	uint8 RF_SYN_pll_loopfilter2;
-	uint8 RF_SYN_pll_loopfilter3;
-	uint8 RF_SYN_pll_loopfilter4;
-	uint8 RF_SYN_pll_loopfilter5;
-	uint8 RF_SYN_reserved_addr27;
-	uint8 RF_SYN_reserved_addr28;
-	uint8 RF_SYN_reserved_addr29;
-	uint8 RF_SYN_logen_VCOBUF1;
-	uint8 RF_SYN_logen_MIXER2;
-	uint8 RF_SYN_logen_BUF3;
-	uint8 RF_SYN_logen_BUF4;
-	uint8 RF_RX0_lnaa_tune;
-	uint8 RF_RX0_lnag_tune;
-	uint8 RF_TX0_intpaa_boost_tune;
-	uint8 RF_TX0_intpag_boost_tune;
-	uint8 RF_TX0_pada_boost_tune;
-	uint8 RF_TX0_padg_boost_tune;
-	uint8 RF_TX0_pgaa_boost_tune;
-	uint8 RF_TX0_pgag_boost_tune;
-	uint8 RF_TX0_mixa_boost_tune;
-	uint8 RF_TX0_mixg_boost_tune;
-	uint8 RF_RX1_lnaa_tune;
-	uint8 RF_RX1_lnag_tune;
-	uint8 RF_TX1_intpaa_boost_tune;
-	uint8 RF_TX1_intpag_boost_tune;
-	uint8 RF_TX1_pada_boost_tune;
-	uint8 RF_TX1_padg_boost_tune;
-	uint8 RF_TX1_pgaa_boost_tune;
-	uint8 RF_TX1_pgag_boost_tune;
-	uint8 RF_TX1_mixa_boost_tune;
-	uint8 RF_TX1_mixg_boost_tune;
-	uint16 PHY_BW1a;
-	uint16 PHY_BW2;
-	uint16 PHY_BW3;
-	uint16 PHY_BW4;
-	uint16 PHY_BW5;
-	uint16 PHY_BW6;
+	u16 chan;
+	u16 freq;
+	u8 RF_SYN_pll_vcocal1;
+	u8 RF_SYN_pll_vcocal2;
+	u8 RF_SYN_pll_refdiv;
+	u8 RF_SYN_pll_mmd2;
+	u8 RF_SYN_pll_mmd1;
+	u8 RF_SYN_pll_loopfilter1;
+	u8 RF_SYN_pll_loopfilter2;
+	u8 RF_SYN_pll_loopfilter3;
+	u8 RF_SYN_pll_loopfilter4;
+	u8 RF_SYN_pll_loopfilter5;
+	u8 RF_SYN_reserved_addr27;
+	u8 RF_SYN_reserved_addr28;
+	u8 RF_SYN_reserved_addr29;
+	u8 RF_SYN_logen_VCOBUF1;
+	u8 RF_SYN_logen_MIXER2;
+	u8 RF_SYN_logen_BUF3;
+	u8 RF_SYN_logen_BUF4;
+	u8 RF_RX0_lnaa_tune;
+	u8 RF_RX0_lnag_tune;
+	u8 RF_TX0_intpaa_boost_tune;
+	u8 RF_TX0_intpag_boost_tune;
+	u8 RF_TX0_pada_boost_tune;
+	u8 RF_TX0_padg_boost_tune;
+	u8 RF_TX0_pgaa_boost_tune;
+	u8 RF_TX0_pgag_boost_tune;
+	u8 RF_TX0_mixa_boost_tune;
+	u8 RF_TX0_mixg_boost_tune;
+	u8 RF_RX1_lnaa_tune;
+	u8 RF_RX1_lnag_tune;
+	u8 RF_TX1_intpaa_boost_tune;
+	u8 RF_TX1_intpag_boost_tune;
+	u8 RF_TX1_pada_boost_tune;
+	u8 RF_TX1_padg_boost_tune;
+	u8 RF_TX1_pgaa_boost_tune;
+	u8 RF_TX1_pgag_boost_tune;
+	u8 RF_TX1_mixa_boost_tune;
+	u8 RF_TX1_mixg_boost_tune;
+	u16 PHY_BW1a;
+	u16 PHY_BW2;
+	u16 PHY_BW3;
+	u16 PHY_BW4;
+	u16 PHY_BW5;
+	u16 PHY_BW6;
 } chan_info_nphy_radio205x_t;
 
 typedef struct _chan_info_nphy_radio2057 {
-	uint16 chan;
-	uint16 freq;
-	uint8 RF_vcocal_countval0;
-	uint8 RF_vcocal_countval1;
-	uint8 RF_rfpll_refmaster_sparextalsize;
-	uint8 RF_rfpll_loopfilter_r1;
-	uint8 RF_rfpll_loopfilter_c2;
-	uint8 RF_rfpll_loopfilter_c1;
-	uint8 RF_cp_kpd_idac;
-	uint8 RF_rfpll_mmd0;
-	uint8 RF_rfpll_mmd1;
-	uint8 RF_vcobuf_tune;
-	uint8 RF_logen_mx2g_tune;
-	uint8 RF_logen_mx5g_tune;
-	uint8 RF_logen_indbuf2g_tune;
-	uint8 RF_logen_indbuf5g_tune;
-	uint8 RF_txmix2g_tune_boost_pu_core0;
-	uint8 RF_pad2g_tune_pus_core0;
-	uint8 RF_pga_boost_tune_core0;
-	uint8 RF_txmix5g_boost_tune_core0;
-	uint8 RF_pad5g_tune_misc_pus_core0;
-	uint8 RF_lna2g_tune_core0;
-	uint8 RF_lna5g_tune_core0;
-	uint8 RF_txmix2g_tune_boost_pu_core1;
-	uint8 RF_pad2g_tune_pus_core1;
-	uint8 RF_pga_boost_tune_core1;
-	uint8 RF_txmix5g_boost_tune_core1;
-	uint8 RF_pad5g_tune_misc_pus_core1;
-	uint8 RF_lna2g_tune_core1;
-	uint8 RF_lna5g_tune_core1;
-	uint16 PHY_BW1a;
-	uint16 PHY_BW2;
-	uint16 PHY_BW3;
-	uint16 PHY_BW4;
-	uint16 PHY_BW5;
-	uint16 PHY_BW6;
+	u16 chan;
+	u16 freq;
+	u8 RF_vcocal_countval0;
+	u8 RF_vcocal_countval1;
+	u8 RF_rfpll_refmaster_sparextalsize;
+	u8 RF_rfpll_loopfilter_r1;
+	u8 RF_rfpll_loopfilter_c2;
+	u8 RF_rfpll_loopfilter_c1;
+	u8 RF_cp_kpd_idac;
+	u8 RF_rfpll_mmd0;
+	u8 RF_rfpll_mmd1;
+	u8 RF_vcobuf_tune;
+	u8 RF_logen_mx2g_tune;
+	u8 RF_logen_mx5g_tune;
+	u8 RF_logen_indbuf2g_tune;
+	u8 RF_logen_indbuf5g_tune;
+	u8 RF_txmix2g_tune_boost_pu_core0;
+	u8 RF_pad2g_tune_pus_core0;
+	u8 RF_pga_boost_tune_core0;
+	u8 RF_txmix5g_boost_tune_core0;
+	u8 RF_pad5g_tune_misc_pus_core0;
+	u8 RF_lna2g_tune_core0;
+	u8 RF_lna5g_tune_core0;
+	u8 RF_txmix2g_tune_boost_pu_core1;
+	u8 RF_pad2g_tune_pus_core1;
+	u8 RF_pga_boost_tune_core1;
+	u8 RF_txmix5g_boost_tune_core1;
+	u8 RF_pad5g_tune_misc_pus_core1;
+	u8 RF_lna2g_tune_core1;
+	u8 RF_lna5g_tune_core1;
+	u16 PHY_BW1a;
+	u16 PHY_BW2;
+	u16 PHY_BW3;
+	u16 PHY_BW4;
+	u16 PHY_BW5;
+	u16 PHY_BW6;
 } chan_info_nphy_radio2057_t;
 
 typedef struct _chan_info_nphy_radio2057_rev5 {
-	uint16 chan;
-	uint16 freq;
-	uint8 RF_vcocal_countval0;
-	uint8 RF_vcocal_countval1;
-	uint8 RF_rfpll_refmaster_sparextalsize;
-	uint8 RF_rfpll_loopfilter_r1;
-	uint8 RF_rfpll_loopfilter_c2;
-	uint8 RF_rfpll_loopfilter_c1;
-	uint8 RF_cp_kpd_idac;
-	uint8 RF_rfpll_mmd0;
-	uint8 RF_rfpll_mmd1;
-	uint8 RF_vcobuf_tune;
-	uint8 RF_logen_mx2g_tune;
-	uint8 RF_logen_indbuf2g_tune;
-	uint8 RF_txmix2g_tune_boost_pu_core0;
-	uint8 RF_pad2g_tune_pus_core0;
-	uint8 RF_lna2g_tune_core0;
-	uint8 RF_txmix2g_tune_boost_pu_core1;
-	uint8 RF_pad2g_tune_pus_core1;
-	uint8 RF_lna2g_tune_core1;
-	uint16 PHY_BW1a;
-	uint16 PHY_BW2;
-	uint16 PHY_BW3;
-	uint16 PHY_BW4;
-	uint16 PHY_BW5;
-	uint16 PHY_BW6;
+	u16 chan;
+	u16 freq;
+	u8 RF_vcocal_countval0;
+	u8 RF_vcocal_countval1;
+	u8 RF_rfpll_refmaster_sparextalsize;
+	u8 RF_rfpll_loopfilter_r1;
+	u8 RF_rfpll_loopfilter_c2;
+	u8 RF_rfpll_loopfilter_c1;
+	u8 RF_cp_kpd_idac;
+	u8 RF_rfpll_mmd0;
+	u8 RF_rfpll_mmd1;
+	u8 RF_vcobuf_tune;
+	u8 RF_logen_mx2g_tune;
+	u8 RF_logen_indbuf2g_tune;
+	u8 RF_txmix2g_tune_boost_pu_core0;
+	u8 RF_pad2g_tune_pus_core0;
+	u8 RF_lna2g_tune_core0;
+	u8 RF_txmix2g_tune_boost_pu_core1;
+	u8 RF_pad2g_tune_pus_core1;
+	u8 RF_lna2g_tune_core1;
+	u16 PHY_BW1a;
+	u16 PHY_BW2;
+	u16 PHY_BW3;
+	u16 PHY_BW4;
+	u16 PHY_BW5;
+	u16 PHY_BW6;
 } chan_info_nphy_radio2057_rev5_t;
 
 typedef struct nphy_sfo_cfg {
-	uint16 PHY_BW1a;
-	uint16 PHY_BW2;
-	uint16 PHY_BW3;
-	uint16 PHY_BW4;
-	uint16 PHY_BW5;
-	uint16 PHY_BW6;
+	u16 PHY_BW1a;
+	u16 PHY_BW2;
+	u16 PHY_BW3;
+	u16 PHY_BW4;
+	u16 PHY_BW5;
+	u16 PHY_BW6;
 } nphy_sfo_cfg_t;
 
 static chan_info_nphy_2055_t chan_info_nphy_2055[] = {
@@ -13276,12 +13279,12 @@ radio_20xx_regs_t regs_2057_rev8[] = {
 	{0xFFFF, 0, 0}
 };
 
-static int16 nphy_def_lnagains[] = { -2, 10, 19, 25 };
+static s16 nphy_def_lnagains[] = { -2, 10, 19, 25 };
 
-static int32 nphy_lnagain_est0[] = { -315, 40370 };
-static int32 nphy_lnagain_est1[] = { -224, 23242 };
+static s32 nphy_lnagain_est0[] = { -315, 40370 };
+static s32 nphy_lnagain_est1[] = { -224, 23242 };
 
-static const uint16 tbl_iqcal_gainparams_nphy[2][NPHY_IQCAL_NUMGAINS][8] = {
+static const u16 tbl_iqcal_gainparams_nphy[2][NPHY_IQCAL_NUMGAINS][8] = {
 	{
 	 {0x000, 0, 0, 2, 0x69, 0x69, 0x69, 0x69},
 	 {0x700, 7, 0, 0, 0x69, 0x69, 0x69, 0x69},
@@ -13306,7 +13309,7 @@ static const uint16 tbl_iqcal_gainparams_nphy[2][NPHY_IQCAL_NUMGAINS][8] = {
 	 }
 };
 
-static const uint32 nphy_tpc_txgain[] = {
+static const u32 nphy_tpc_txgain[] = {
 	0x03cc2b44, 0x03cc2b42, 0x03cc2a44, 0x03cc2a42,
 	0x03cc2944, 0x03c82b44, 0x03c82b42, 0x03c82a44,
 	0x03c82a42, 0x03c82944, 0x03c82942, 0x03c82844,
@@ -13341,7 +13344,7 @@ static const uint32 nphy_tpc_txgain[] = {
 	0x03801442, 0x03801344, 0x03801342, 0x00002b00
 };
 
-static const uint16 nphy_tpc_loscale[] = {
+static const u16 nphy_tpc_loscale[] = {
 	256, 256, 271, 271, 287, 256, 256, 271,
 	271, 287, 287, 304, 304, 256, 256, 271,
 	271, 287, 287, 304, 304, 322, 322, 341,
@@ -13360,7 +13363,7 @@ static const uint16 nphy_tpc_loscale[] = {
 	858, 908, 908, 962, 962, 1019, 1019, 256
 };
 
-static uint32 nphy_tpc_txgain_ipa[] = {
+static u32 nphy_tpc_txgain_ipa[] = {
 	0x5ff7002d, 0x5ff7002b, 0x5ff7002a, 0x5ff70029,
 	0x5ff70028, 0x5ff70027, 0x5ff70026, 0x5ff70025,
 	0x5ef7002d, 0x5ef7002b, 0x5ef7002a, 0x5ef70029,
@@ -13395,7 +13398,7 @@ static uint32 nphy_tpc_txgain_ipa[] = {
 	0x50f70028, 0x50f70027, 0x50f70026, 0x50f70025
 };
 
-static uint32 nphy_tpc_txgain_ipa_rev5[] = {
+static u32 nphy_tpc_txgain_ipa_rev5[] = {
 	0x1ff7002d, 0x1ff7002b, 0x1ff7002a, 0x1ff70029,
 	0x1ff70028, 0x1ff70027, 0x1ff70026, 0x1ff70025,
 	0x1ef7002d, 0x1ef7002b, 0x1ef7002a, 0x1ef70029,
@@ -13430,7 +13433,7 @@ static uint32 nphy_tpc_txgain_ipa_rev5[] = {
 	0x10f70028, 0x10f70027, 0x10f70026, 0x10f70025
 };
 
-static uint32 nphy_tpc_txgain_ipa_rev6[] = {
+static u32 nphy_tpc_txgain_ipa_rev6[] = {
 	0x0ff7002d, 0x0ff7002b, 0x0ff7002a, 0x0ff70029,
 	0x0ff70028, 0x0ff70027, 0x0ff70026, 0x0ff70025,
 	0x0ef7002d, 0x0ef7002b, 0x0ef7002a, 0x0ef70029,
@@ -13465,7 +13468,7 @@ static uint32 nphy_tpc_txgain_ipa_rev6[] = {
 	0x00f70028, 0x00f70027, 0x00f70026, 0x00f70025
 };
 
-static uint32 nphy_tpc_txgain_ipa_2g_2057rev3[] = {
+static u32 nphy_tpc_txgain_ipa_2g_2057rev3[] = {
 	0x70ff0040, 0x70f7003e, 0x70ef003b, 0x70e70039,
 	0x70df0037, 0x70d70036, 0x70cf0033, 0x70c70032,
 	0x70bf0031, 0x70b7002f, 0x70af002e, 0x70a7002d,
@@ -13500,7 +13503,7 @@ static uint32 nphy_tpc_txgain_ipa_2g_2057rev3[] = {
 	0x700f0001, 0x700f0001, 0x700f0001, 0x700f0001
 };
 
-static uint32 nphy_tpc_txgain_ipa_2g_2057rev4n6[] = {
+static u32 nphy_tpc_txgain_ipa_2g_2057rev4n6[] = {
 	0xf0ff0040, 0xf0f7003e, 0xf0ef003b, 0xf0e70039,
 	0xf0df0037, 0xf0d70036, 0xf0cf0033, 0xf0c70032,
 	0xf0bf0031, 0xf0b7002f, 0xf0af002e, 0xf0a7002d,
@@ -13535,7 +13538,7 @@ static uint32 nphy_tpc_txgain_ipa_2g_2057rev4n6[] = {
 	0xf00f0001, 0xf00f0001, 0xf00f0001, 0xf00f0001
 };
 
-static uint32 nphy_tpc_txgain_ipa_2g_2057rev5[] = {
+static u32 nphy_tpc_txgain_ipa_2g_2057rev5[] = {
 	0x30ff0031, 0x30e70031, 0x30e7002e, 0x30cf002e,
 	0x30bf002e, 0x30af002e, 0x309f002f, 0x307f0033,
 	0x307f0031, 0x307f002e, 0x3077002e, 0x306f002e,
@@ -13570,7 +13573,7 @@ static uint32 nphy_tpc_txgain_ipa_2g_2057rev5[] = {
 	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715
 };
 
-static uint32 nphy_tpc_txgain_ipa_2g_2057rev7[] = {
+static u32 nphy_tpc_txgain_ipa_2g_2057rev7[] = {
 	0x30ff0031, 0x30e70031, 0x30e7002e, 0x30cf002e,
 	0x30bf002e, 0x30af002e, 0x309f002f, 0x307f0033,
 	0x307f0031, 0x307f002e, 0x3077002e, 0x306f002e,
@@ -13605,7 +13608,7 @@ static uint32 nphy_tpc_txgain_ipa_2g_2057rev7[] = {
 	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715
 };
 
-static uint32 nphy_tpc_txgain_ipa_5g[] = {
+static u32 nphy_tpc_txgain_ipa_5g[] = {
 	0x7ff70035, 0x7ff70033, 0x7ff70032, 0x7ff70031,
 	0x7ff7002f, 0x7ff7002e, 0x7ff7002d, 0x7ff7002b,
 	0x7ff7002a, 0x7ff70029, 0x7ff70028, 0x7ff70027,
@@ -13640,7 +13643,7 @@ static uint32 nphy_tpc_txgain_ipa_5g[] = {
 	0x70f70021, 0x70f70020, 0x70f70020, 0x70f7001f
 };
 
-static uint32 nphy_tpc_txgain_ipa_5g_2057[] = {
+static u32 nphy_tpc_txgain_ipa_5g_2057[] = {
 	0x7f7f0044, 0x7f7f0040, 0x7f7f003c, 0x7f7f0039,
 	0x7f7f0036, 0x7e7f003c, 0x7e7f0038, 0x7e7f0035,
 	0x7d7f003c, 0x7d7f0039, 0x7d7f0036, 0x7d7f0033,
@@ -13675,7 +13678,7 @@ static uint32 nphy_tpc_txgain_ipa_5g_2057[] = {
 	0x707f0001, 0x707f0001, 0x707f0001, 0x707f0001
 };
 
-static uint32 nphy_tpc_txgain_ipa_5g_2057rev7[] = {
+static u32 nphy_tpc_txgain_ipa_5g_2057rev7[] = {
 	0x6f7f0031, 0x6f7f002e, 0x6f7f002c, 0x6f7f002a,
 	0x6f7f0027, 0x6e7f002e, 0x6e7f002c, 0x6e7f002a,
 	0x6d7f0030, 0x6d7f002d, 0x6d7f002a, 0x6d7f0028,
@@ -13710,69 +13713,69 @@ static uint32 nphy_tpc_txgain_ipa_5g_2057rev7[] = {
 	0x607f0001, 0x607f0001, 0x607f0001, 0x607f0001
 };
 
-static int8 nphy_papd_pga_gain_delta_ipa_2g[] = {
+static s8 nphy_papd_pga_gain_delta_ipa_2g[] = {
 	-114, -108, -98, -91, -84, -78, -70, -62,
 	-54, -46, -39, -31, -23, -15, -8, 0
 };
 
-static int8 nphy_papd_pga_gain_delta_ipa_5g[] = {
+static s8 nphy_papd_pga_gain_delta_ipa_5g[] = {
 	-100, -95, -89, -83, -77, -70, -63, -56,
 	-48, -41, -33, -25, -19, -12, -6, 0
 };
 
-static int16 nphy_papd_padgain_dlt_2g_2057rev3n4[] = {
+static s16 nphy_papd_padgain_dlt_2g_2057rev3n4[] = {
 	-159, -113, -86, -72, -62, -54, -48, -43,
 	-39, -35, -31, -28, -25, -23, -20, -18,
 	-17, -15, -13, -11, -10, -8, -7, -6,
 	-5, -4, -3, -3, -2, -1, -1, 0
 };
 
-static int16 nphy_papd_padgain_dlt_2g_2057rev5[] = {
+static s16 nphy_papd_padgain_dlt_2g_2057rev5[] = {
 	-109, -109, -82, -68, -58, -50, -44, -39,
 	-35, -31, -28, -26, -23, -21, -19, -17,
 	-16, -14, -13, -11, -10, -9, -8, -7,
 	-5, -5, -4, -3, -2, -1, -1, 0
 };
 
-static int16 nphy_papd_padgain_dlt_2g_2057rev7[] = {
+static s16 nphy_papd_padgain_dlt_2g_2057rev7[] = {
 	-122, -122, -95, -80, -69, -61, -54, -49,
 	-43, -39, -35, -32, -28, -26, -23, -21,
 	-18, -16, -15, -13, -11, -10, -8, -7,
 	-6, -5, -4, -3, -2, -1, -1, 0
 };
 
-static int8 nphy_papd_pgagain_dlt_5g_2057[] = {
+static s8 nphy_papd_pgagain_dlt_5g_2057[] = {
 	-107, -101, -92, -85, -78, -71, -62, -55,
 	-47, -39, -32, -24, -19, -12, -6, 0
 };
 
-static int8 nphy_papd_pgagain_dlt_5g_2057rev7[] = {
+static s8 nphy_papd_pgagain_dlt_5g_2057rev7[] = {
 	-110, -104, -95, -88, -81, -74, -66, -58,
 	-50, -44, -36, -28, -23, -15, -8, 0
 };
 
-static uint8 pad_gain_codes_used_2057rev5[] = {
+static u8 pad_gain_codes_used_2057rev5[] = {
 	20, 19, 18, 17, 16, 15, 14, 13, 12, 11,
 	10, 9, 8, 7, 6, 5, 4, 3, 2, 1
 };
 
-static uint8 pad_gain_codes_used_2057rev7[] = {
+static u8 pad_gain_codes_used_2057rev7[] = {
 	15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
 	5, 4, 3, 2, 1
 };
 
-static uint8 pad_all_gain_codes_2057[] = {
+static u8 pad_all_gain_codes_2057[] = {
 	31, 30, 29, 28, 27, 26, 25, 24, 23, 22,
 	21, 20, 19, 18, 17, 16, 15, 14, 13, 12,
 	11, 10, 9, 8, 7, 6, 5, 4, 3, 2,
 	1, 0
 };
 
-static uint8 pga_all_gain_codes_2057[] = {
+static u8 pga_all_gain_codes_2057[] = {
 	15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
 };
 
-static uint32 nphy_papd_scaltbl[] = {
+static u32 nphy_papd_scaltbl[] = {
 	0x0ae2002f, 0x0a3b0032, 0x09a70035, 0x09220038,
 	0x0887003c, 0x081f003f, 0x07a20043, 0x07340047,
 	0x06d2004b, 0x067a004f, 0x06170054, 0x05bf0059,
@@ -13791,7 +13794,7 @@ static uint32 nphy_papd_scaltbl[] = {
 	0x005805d7, 0x0053062f, 0x004e068d, 0x004a06f1
 };
 
-static uint32 nphy_tpc_txgain_rev3[] = {
+static u32 nphy_tpc_txgain_rev3[] = {
 	0x1f410044, 0x1f410042, 0x1f410040, 0x1f41003e,
 	0x1f41003c, 0x1f41003b, 0x1f410039, 0x1f410037,
 	0x1e410044, 0x1e410042, 0x1e410040, 0x1e41003e,
@@ -13826,7 +13829,7 @@ static uint32 nphy_tpc_txgain_rev3[] = {
 	0x1041003c, 0x1041003b, 0x10410039, 0x10410037
 };
 
-static uint32 nphy_tpc_txgain_HiPwrEPA[] = {
+static u32 nphy_tpc_txgain_HiPwrEPA[] = {
 	0x0f410044, 0x0f410042, 0x0f410040, 0x0f41003e,
 	0x0f41003c, 0x0f41003b, 0x0f410039, 0x0f410037,
 	0x0e410044, 0x0e410042, 0x0e410040, 0x0e41003e,
@@ -13861,7 +13864,7 @@ static uint32 nphy_tpc_txgain_HiPwrEPA[] = {
 	0x0041003c, 0x0041003b, 0x00410039, 0x00410037
 };
 
-static uint32 nphy_tpc_txgain_epa_2057rev3[] = {
+static u32 nphy_tpc_txgain_epa_2057rev3[] = {
 	0x80f90040, 0x80e10040, 0x80e1003c, 0x80c9003d,
 	0x80b9003c, 0x80a9003d, 0x80a1003c, 0x8099003b,
 	0x8091003b, 0x8089003a, 0x8081003a, 0x80790039,
@@ -13896,7 +13899,7 @@ static uint32 nphy_tpc_txgain_epa_2057rev3[] = {
 	0x8009071d, 0x8009071d, 0x8009071d, 0x8009071d
 };
 
-static uint32 nphy_tpc_txgain_epa_2057rev5[] = {
+static u32 nphy_tpc_txgain_epa_2057rev5[] = {
 	0x10f90040, 0x10e10040, 0x10e1003c, 0x10c9003d,
 	0x10b9003c, 0x10a9003d, 0x10a1003c, 0x1099003b,
 	0x1091003b, 0x1089003a, 0x1081003a, 0x10790039,
@@ -13931,7 +13934,7 @@ static uint32 nphy_tpc_txgain_epa_2057rev5[] = {
 	0x10090001, 0x10090001, 0x10090001, 0x10090001
 };
 
-static uint32 nphy_tpc_5GHz_txgain_rev3[] = {
+static u32 nphy_tpc_5GHz_txgain_rev3[] = {
 	0xcff70044, 0xcff70042, 0xcff70040, 0xcff7003e,
 	0xcff7003c, 0xcff7003b, 0xcff70039, 0xcff70037,
 	0xcef70044, 0xcef70042, 0xcef70040, 0xcef7003e,
@@ -13966,7 +13969,7 @@ static uint32 nphy_tpc_5GHz_txgain_rev3[] = {
 	0xc0f7003c, 0xc0f7003b, 0xc0f70039, 0xc0f70037
 };
 
-static uint32 nphy_tpc_5GHz_txgain_rev4[] = {
+static u32 nphy_tpc_5GHz_txgain_rev4[] = {
 	0x2ff20044, 0x2ff20042, 0x2ff20040, 0x2ff2003e,
 	0x2ff2003c, 0x2ff2003b, 0x2ff20039, 0x2ff20037,
 	0x2ef20044, 0x2ef20042, 0x2ef20040, 0x2ef2003e,
@@ -14001,7 +14004,7 @@ static uint32 nphy_tpc_5GHz_txgain_rev4[] = {
 	0x20d2003a, 0x20d20038, 0x20d20036, 0x20d20034
 };
 
-static uint32 nphy_tpc_5GHz_txgain_rev5[] = {
+static u32 nphy_tpc_5GHz_txgain_rev5[] = {
 	0x0f62004a, 0x0f620048, 0x0f620046, 0x0f620044,
 	0x0f620042, 0x0f620040, 0x0f62003e, 0x0f62003c,
 	0x0e620044, 0x0e620042, 0x0e620040, 0x0e62003e,
@@ -14036,7 +14039,7 @@ static uint32 nphy_tpc_5GHz_txgain_rev5[] = {
 	0x0062003b, 0x00620039, 0x00620037, 0x00620035
 };
 
-static uint32 nphy_tpc_5GHz_txgain_HiPwrEPA[] = {
+static u32 nphy_tpc_5GHz_txgain_HiPwrEPA[] = {
 	0x2ff10044, 0x2ff10042, 0x2ff10040, 0x2ff1003e,
 	0x2ff1003c, 0x2ff1003b, 0x2ff10039, 0x2ff10037,
 	0x2ef10044, 0x2ef10042, 0x2ef10040, 0x2ef1003e,
@@ -14071,129 +14074,129 @@ static uint32 nphy_tpc_5GHz_txgain_HiPwrEPA[] = {
 	0x20d1003a, 0x20d10038, 0x20d10036, 0x20d10034
 };
 
-static uint8 ant_sw_ctrl_tbl_rev8_2o3[] = { 0x14, 0x18 };
-static uint8 ant_sw_ctrl_tbl_rev8[] = { 0x4, 0x8, 0x4, 0x8, 0x11, 0x12 };
-static uint8 ant_sw_ctrl_tbl_rev8_2057v7_core0[] =
-    { 0x09, 0x0a, 0x15, 0x16, 0x09, 0x0a };
-static uint8 ant_sw_ctrl_tbl_rev8_2057v7_core1[] =
-    { 0x09, 0x0a, 0x09, 0x0a, 0x15, 0x16 };
-
-static bool wlc_phy_chan2freq_nphy(phy_info_t * pi, uint channel, int *f,
-				   chan_info_nphy_radio2057_t ** t0,
-				   chan_info_nphy_radio205x_t ** t1,
-				   chan_info_nphy_radio2057_rev5_t ** t2,
-				   chan_info_nphy_2055_t ** t3);
-static void wlc_phy_chanspec_nphy_setup(phy_info_t * pi, chanspec_t chans,
-					const nphy_sfo_cfg_t * c);
-
-static void wlc_phy_adjust_rx_analpfbw_nphy(phy_info_t * pi,
-					    uint16 reduction_factr);
-static void wlc_phy_adjust_min_noisevar_nphy(phy_info_t * pi, int ntones, int *,
-					     uint32 * buf);
-static void wlc_phy_adjust_crsminpwr_nphy(phy_info_t * pi, uint8 minpwr);
-static void wlc_phy_txlpfbw_nphy(phy_info_t * pi);
-static void wlc_phy_spurwar_nphy(phy_info_t * pi);
-
-static void wlc_phy_radio_preinit_2055(phy_info_t * pi);
-static void wlc_phy_radio_init_2055(phy_info_t * pi);
-static void wlc_phy_radio_postinit_2055(phy_info_t * pi);
-static void wlc_phy_radio_preinit_205x(phy_info_t * pi);
-static void wlc_phy_radio_init_2056(phy_info_t * pi);
-static void wlc_phy_radio_postinit_2056(phy_info_t * pi);
-static void wlc_phy_radio_init_2057(phy_info_t * pi);
-static void wlc_phy_radio_postinit_2057(phy_info_t * pi);
-static void wlc_phy_workarounds_nphy(phy_info_t * pi);
-static void wlc_phy_workarounds_nphy_gainctrl(phy_info_t * pi);
-static void wlc_phy_workarounds_nphy_gainctrl_2057_rev5(phy_info_t * pi);
-static void wlc_phy_workarounds_nphy_gainctrl_2057_rev6(phy_info_t * pi);
-static void wlc_phy_adjust_lnagaintbl_nphy(phy_info_t * pi);
-
-static void wlc_phy_restore_rssical_nphy(phy_info_t * pi);
-static void wlc_phy_reapply_txcal_coeffs_nphy(phy_info_t * pi);
-static void wlc_phy_tx_iq_war_nphy(phy_info_t * pi);
-static int wlc_phy_cal_rxiq_nphy_rev3(phy_info_t * pi, nphy_txgains_t tg,
-				      uint8 type, bool d);
-static void wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t * pi, uint8 rxcore,
-					     uint16 * rg, uint8 type);
-static void wlc_phy_update_mimoconfig_nphy(phy_info_t * pi, int32 preamble);
-static void wlc_phy_savecal_nphy(phy_info_t * pi);
-static void wlc_phy_restorecal_nphy(phy_info_t * pi);
-static void wlc_phy_resetcca_nphy(phy_info_t * pi);
-
-static void wlc_phy_txpwrctrl_config_nphy(phy_info_t * pi);
-static void wlc_phy_internal_cal_txgain_nphy(phy_info_t * pi);
-static void wlc_phy_precal_txgain_nphy(phy_info_t * pi);
-static void wlc_phy_update_txcal_ladder_nphy(phy_info_t * pi, uint16 core);
-
-static void wlc_phy_extpa_set_tx_digi_filts_nphy(phy_info_t * pi);
-static void wlc_phy_ipa_set_tx_digi_filts_nphy(phy_info_t * pi);
-static void wlc_phy_ipa_restore_tx_digi_filts_nphy(phy_info_t * pi);
-static uint16 wlc_phy_ipa_get_bbmult_nphy(phy_info_t * pi);
-static void wlc_phy_ipa_set_bbmult_nphy(phy_info_t * pi, uint8 m0, uint8 m1);
-static uint32 *wlc_phy_get_ipa_gaintbl_nphy(phy_info_t * pi);
-
-static void wlc_phy_a1_nphy(phy_info_t * pi, uint8 core, uint32 winsz, uint32,
-			    uint32 e);
-static uint8 wlc_phy_a3_nphy(phy_info_t * pi, uint8 start_gain, uint8 core);
-static void wlc_phy_a2_nphy(phy_info_t * pi, nphy_ipa_txcalgains_t *,
-			    phy_cal_mode_t, uint8);
-static void wlc_phy_papd_cal_cleanup_nphy(phy_info_t * pi,
-					  nphy_papd_restore_state * state);
-static void wlc_phy_papd_cal_setup_nphy(phy_info_t * pi,
-					nphy_papd_restore_state * state, uint8);
-
-static void wlc_phy_clip_det_nphy(phy_info_t * pi, uint8 write, uint16 * vals);
-
-static void wlc_phy_set_rfseq_nphy(phy_info_t * pi, uint8 cmd, uint8 * evts,
-				   uint8 * dlys, uint8 len);
-
-static uint16 wlc_phy_read_lpf_bw_ctl_nphy(phy_info_t * pi, uint16 offset);
+static u8 ant_sw_ctrl_tbl_rev8_2o3[] = { 0x14, 0x18 };
+static u8 ant_sw_ctrl_tbl_rev8[] = { 0x4, 0x8, 0x4, 0x8, 0x11, 0x12 };
+static u8 ant_sw_ctrl_tbl_rev8_2057v7_core0[] = {
+	0x09, 0x0a, 0x15, 0x16, 0x09, 0x0a };
+static u8 ant_sw_ctrl_tbl_rev8_2057v7_core1[] = {
+	0x09, 0x0a, 0x09, 0x0a, 0x15, 0x16 };
+
+static bool wlc_phy_chan2freq_nphy(phy_info_t *pi, uint channel, int *f,
+				   chan_info_nphy_radio2057_t **t0,
+				   chan_info_nphy_radio205x_t **t1,
+				   chan_info_nphy_radio2057_rev5_t **t2,
+				   chan_info_nphy_2055_t **t3);
+static void wlc_phy_chanspec_nphy_setup(phy_info_t *pi, chanspec_t chans,
+					const nphy_sfo_cfg_t *c);
+
+static void wlc_phy_adjust_rx_analpfbw_nphy(phy_info_t *pi,
+					    u16 reduction_factr);
+static void wlc_phy_adjust_min_noisevar_nphy(phy_info_t *pi, int ntones, int *,
+					     u32 *buf);
+static void wlc_phy_adjust_crsminpwr_nphy(phy_info_t *pi, u8 minpwr);
+static void wlc_phy_txlpfbw_nphy(phy_info_t *pi);
+static void wlc_phy_spurwar_nphy(phy_info_t *pi);
+
+static void wlc_phy_radio_preinit_2055(phy_info_t *pi);
+static void wlc_phy_radio_init_2055(phy_info_t *pi);
+static void wlc_phy_radio_postinit_2055(phy_info_t *pi);
+static void wlc_phy_radio_preinit_205x(phy_info_t *pi);
+static void wlc_phy_radio_init_2056(phy_info_t *pi);
+static void wlc_phy_radio_postinit_2056(phy_info_t *pi);
+static void wlc_phy_radio_init_2057(phy_info_t *pi);
+static void wlc_phy_radio_postinit_2057(phy_info_t *pi);
+static void wlc_phy_workarounds_nphy(phy_info_t *pi);
+static void wlc_phy_workarounds_nphy_gainctrl(phy_info_t *pi);
+static void wlc_phy_workarounds_nphy_gainctrl_2057_rev5(phy_info_t *pi);
+static void wlc_phy_workarounds_nphy_gainctrl_2057_rev6(phy_info_t *pi);
+static void wlc_phy_adjust_lnagaintbl_nphy(phy_info_t *pi);
+
+static void wlc_phy_restore_rssical_nphy(phy_info_t *pi);
+static void wlc_phy_reapply_txcal_coeffs_nphy(phy_info_t *pi);
+static void wlc_phy_tx_iq_war_nphy(phy_info_t *pi);
+static int wlc_phy_cal_rxiq_nphy_rev3(phy_info_t *pi, nphy_txgains_t tg,
+				      u8 type, bool d);
+static void wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t *pi, u8 rxcore,
+					     u16 *rg, u8 type);
+static void wlc_phy_update_mimoconfig_nphy(phy_info_t *pi, s32 preamble);
+static void wlc_phy_savecal_nphy(phy_info_t *pi);
+static void wlc_phy_restorecal_nphy(phy_info_t *pi);
+static void wlc_phy_resetcca_nphy(phy_info_t *pi);
+
+static void wlc_phy_txpwrctrl_config_nphy(phy_info_t *pi);
+static void wlc_phy_internal_cal_txgain_nphy(phy_info_t *pi);
+static void wlc_phy_precal_txgain_nphy(phy_info_t *pi);
+static void wlc_phy_update_txcal_ladder_nphy(phy_info_t *pi, u16 core);
+
+static void wlc_phy_extpa_set_tx_digi_filts_nphy(phy_info_t *pi);
+static void wlc_phy_ipa_set_tx_digi_filts_nphy(phy_info_t *pi);
+static void wlc_phy_ipa_restore_tx_digi_filts_nphy(phy_info_t *pi);
+static u16 wlc_phy_ipa_get_bbmult_nphy(phy_info_t *pi);
+static void wlc_phy_ipa_set_bbmult_nphy(phy_info_t *pi, u8 m0, u8 m1);
+static u32 *wlc_phy_get_ipa_gaintbl_nphy(phy_info_t *pi);
+
+static void wlc_phy_a1_nphy(phy_info_t *pi, u8 core, u32 winsz, u32,
+			    u32 e);
+static u8 wlc_phy_a3_nphy(phy_info_t *pi, u8 start_gain, u8 core);
+static void wlc_phy_a2_nphy(phy_info_t *pi, nphy_ipa_txcalgains_t *,
+			    phy_cal_mode_t, u8);
+static void wlc_phy_papd_cal_cleanup_nphy(phy_info_t *pi,
+					  nphy_papd_restore_state *state);
+static void wlc_phy_papd_cal_setup_nphy(phy_info_t *pi,
+					nphy_papd_restore_state *state, u8);
+
+static void wlc_phy_clip_det_nphy(phy_info_t *pi, u8 write, u16 *vals);
+
+static void wlc_phy_set_rfseq_nphy(phy_info_t *pi, u8 cmd, u8 *evts,
+				   u8 *dlys, u8 len);
+
+static u16 wlc_phy_read_lpf_bw_ctl_nphy(phy_info_t *pi, u16 offset);
 
 static void
-wlc_phy_rfctrl_override_nphy_rev7(phy_info_t * pi, uint16 field, uint16 value,
-				  uint8 core_mask, uint8 off,
-				  uint8 override_id);
-
-static void wlc_phy_rssi_cal_nphy_rev2(phy_info_t * pi, uint8 rssi_type);
-static void wlc_phy_rssi_cal_nphy_rev3(phy_info_t * pi);
-
-static bool wlc_phy_txpwr_srom_read_nphy(phy_info_t * pi);
-static void wlc_phy_txpwr_nphy_srom_convert(uint8 * srom_max,
-					    uint16 * pwr_offset,
-					    uint8 tmp_max_pwr, uint8 rate_start,
-					    uint8 rate_end);
-
-static void wlc_phy_txpwr_limit_to_tbl_nphy(phy_info_t * pi);
-static void wlc_phy_txpwrctrl_coeff_setup_nphy(phy_info_t * pi);
-static void wlc_phy_txpwrctrl_idle_tssi_nphy(phy_info_t * pi);
-static void wlc_phy_txpwrctrl_pwr_setup_nphy(phy_info_t * pi);
-
-static bool wlc_phy_txpwr_ison_nphy(phy_info_t * pi);
-static uint8 wlc_phy_txpwr_idx_cur_get_nphy(phy_info_t * pi, uint8 core);
-static void wlc_phy_txpwr_idx_cur_set_nphy(phy_info_t * pi, uint8 idx0,
-					   uint8 idx1);
-static void wlc_phy_a4(phy_info_t * pi, bool full_cal);
-
-static uint16 wlc_phy_radio205x_rcal(phy_info_t * pi);
-
-static uint16 wlc_phy_radio2057_rccal(phy_info_t * pi);
-
-static uint16 wlc_phy_gen_load_samples_nphy(phy_info_t * pi, uint32 f_kHz,
-					    uint16 max_val,
-					    uint8 dac_test_mode);
-static void wlc_phy_loadsampletable_nphy(phy_info_t * pi, cint32 * tone_buf,
-					 uint16 num_samps);
-static void wlc_phy_runsamples_nphy(phy_info_t * pi, uint16 n, uint16 lps,
-				    uint16 wait, uint8 iq, uint8 dac_test_mode,
+wlc_phy_rfctrl_override_nphy_rev7(phy_info_t *pi, u16 field, u16 value,
+				  u8 core_mask, u8 off,
+				  u8 override_id);
+
+static void wlc_phy_rssi_cal_nphy_rev2(phy_info_t *pi, u8 rssi_type);
+static void wlc_phy_rssi_cal_nphy_rev3(phy_info_t *pi);
+
+static bool wlc_phy_txpwr_srom_read_nphy(phy_info_t *pi);
+static void wlc_phy_txpwr_nphy_srom_convert(u8 *srom_max,
+					    u16 *pwr_offset,
+					    u8 tmp_max_pwr, u8 rate_start,
+					    u8 rate_end);
+
+static void wlc_phy_txpwr_limit_to_tbl_nphy(phy_info_t *pi);
+static void wlc_phy_txpwrctrl_coeff_setup_nphy(phy_info_t *pi);
+static void wlc_phy_txpwrctrl_idle_tssi_nphy(phy_info_t *pi);
+static void wlc_phy_txpwrctrl_pwr_setup_nphy(phy_info_t *pi);
+
+static bool wlc_phy_txpwr_ison_nphy(phy_info_t *pi);
+static u8 wlc_phy_txpwr_idx_cur_get_nphy(phy_info_t *pi, u8 core);
+static void wlc_phy_txpwr_idx_cur_set_nphy(phy_info_t *pi, u8 idx0,
+					   u8 idx1);
+static void wlc_phy_a4(phy_info_t *pi, bool full_cal);
+
+static u16 wlc_phy_radio205x_rcal(phy_info_t *pi);
+
+static u16 wlc_phy_radio2057_rccal(phy_info_t *pi);
+
+static u16 wlc_phy_gen_load_samples_nphy(phy_info_t *pi, u32 f_kHz,
+					    u16 max_val,
+					    u8 dac_test_mode);
+static void wlc_phy_loadsampletable_nphy(phy_info_t *pi, cs32 *tone_buf,
+					 u16 num_samps);
+static void wlc_phy_runsamples_nphy(phy_info_t *pi, u16 n, u16 lps,
+				    u16 wait, u8 iq, u8 dac_test_mode,
 				    bool modify_bbmult);
 
-bool wlc_phy_bist_check_phy(wlc_phy_t * pih)
+bool wlc_phy_bist_check_phy(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
-	uint32 phybist0, phybist1, phybist2, phybist3, phybist4;
+	u32 phybist0, phybist1, phybist2, phybist3, phybist4;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 16))
-		return TRUE;
+		return true;
 
 	phybist0 = read_phy_reg(pi, 0x0e);
 	phybist1 = read_phy_reg(pi, 0x0f);
@@ -14203,14 +14206,15 @@ bool wlc_phy_bist_check_phy(wlc_phy_t * pih)
 
 	if ((phybist0 == 0) && (phybist1 == 0x4000) && (phybist2 == 0x1fe0) &&
 	    (phybist3 == 0) && (phybist4 == 0)) {
-		return TRUE;
+		return true;
 	}
 
-	return FALSE;
+	return false;
 }
 
-static void WLBANDINITFN(wlc_phy_bphy_init_nphy) (phy_info_t * pi) {
-	uint16 addr, val;
+static void WLBANDINITFN(wlc_phy_bphy_init_nphy) (phy_info_t *pi)
+{
+	u16 addr, val;
 
 	ASSERT(ISNPHY(pi));
 
@@ -14239,8 +14243,8 @@ static void WLBANDINITFN(wlc_phy_bphy_init_nphy) (phy_info_t * pi) {
 }
 
 void
-wlc_phy_table_write_nphy(phy_info_t * pi, uint32 id, uint32 len, uint32 offset,
-			 uint32 width, const void *data)
+wlc_phy_table_write_nphy(phy_info_t *pi, u32 id, u32 len, u32 offset,
+			 u32 width, const void *data)
 {
 	mimophytbl_info_t tbl;
 
@@ -14253,8 +14257,8 @@ wlc_phy_table_write_nphy(phy_info_t * pi, uint32 id, uint32 len, uint32 offset,
 }
 
 void
-wlc_phy_table_read_nphy(phy_info_t * pi, uint32 id, uint32 len, uint32 offset,
-			uint32 width, void *data)
+wlc_phy_table_read_nphy(phy_info_t *pi, u32 id, u32 len, u32 offset,
+			u32 width, void *data)
 {
 	mimophytbl_info_t tbl;
 
@@ -14266,7 +14270,8 @@ wlc_phy_table_read_nphy(phy_info_t * pi, uint32 id, uint32 len, uint32 offset,
 	wlc_phy_read_table_nphy(pi, &tbl);
 }
 
-static void WLBANDINITFN(wlc_phy_static_table_download_nphy) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_phy_static_table_download_nphy) (phy_info_t *pi)
+{
 	uint idx;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 16)) {
@@ -14288,9 +14293,10 @@ static void WLBANDINITFN(wlc_phy_static_table_download_nphy) (phy_info_t * pi) {
 	}
 }
 
-static void WLBANDINITFN(wlc_phy_tbl_init_nphy) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_phy_tbl_init_nphy) (phy_info_t *pi)
+{
 	uint idx = 0;
-	uint8 antswctrllut;
+	u8 antswctrllut;
 
 	if (pi->phy_init_por)
 		wlc_phy_static_table_download_nphy(pi);
@@ -14413,15 +14419,15 @@ static void WLBANDINITFN(wlc_phy_tbl_init_nphy) (phy_info_t * pi) {
 }
 
 static void
-wlc_phy_write_txmacreg_nphy(phy_info_t * pi, uint16 holdoff, uint16 delay)
+wlc_phy_write_txmacreg_nphy(phy_info_t *pi, u16 holdoff, u16 delay)
 {
 	write_phy_reg(pi, 0x77, holdoff);
 	write_phy_reg(pi, 0xb4, delay);
 }
 
-void wlc_phy_nphy_tkip_rifs_war(phy_info_t * pi, uint8 rifs)
+void wlc_phy_nphy_tkip_rifs_war(phy_info_t *pi, u8 rifs)
 {
-	uint16 holdoff, delay;
+	u16 holdoff, delay;
 
 	if (rifs) {
 
@@ -14440,26 +14446,26 @@ void wlc_phy_nphy_tkip_rifs_war(phy_info_t * pi, uint8 rifs)
 	}
 }
 
-bool wlc_phy_attach_nphy(phy_info_t * pi)
+bool wlc_phy_attach_nphy(phy_info_t *pi)
 {
 	uint i;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LT(pi->pubpi.phy_rev, 6)) {
-		pi->phyhang_avoid = TRUE;
+		pi->phyhang_avoid = true;
 	}
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LT(pi->pubpi.phy_rev, 7)) {
 
-		pi->nphy_gband_spurwar_en = TRUE;
+		pi->nphy_gband_spurwar_en = true;
 
 		if (pi->sh->boardflags2 & BFL2_SPUR_WAR) {
-			pi->nphy_aband_spurwar_en = TRUE;
+			pi->nphy_aband_spurwar_en = true;
 		}
 	}
 	if (NREV_GE(pi->pubpi.phy_rev, 6) && NREV_LT(pi->pubpi.phy_rev, 7)) {
 
 		if (pi->sh->boardflags2 & BFL2_2G_SPUR_WAR) {
-			pi->nphy_gband_spurwar2_en = TRUE;
+			pi->nphy_gband_spurwar2_en = true;
 		}
 	}
 
@@ -14476,9 +14482,9 @@ bool wlc_phy_attach_nphy(phy_info_t * pi)
 	pi->mphase_cal_phase_id = MPHASE_CAL_STATE_IDLE;
 	pi->mphase_txcal_numcmds = MPHASE_TXCAL_NUMCMDS;
 
-	pi->nphy_gain_boost = TRUE;
-	pi->nphy_elna_gain_config = FALSE;
-	pi->radio_is_on = FALSE;
+	pi->nphy_gain_boost = true;
+	pi->nphy_elna_gain_config = false;
+	pi->radio_is_on = false;
 
 	for (i = 0; i < pi->pubpi.phy_corenum; i++) {
 		pi->nphy_txpwrindex[i].index = AUTO;
@@ -14486,7 +14492,7 @@ bool wlc_phy_attach_nphy(phy_info_t * pi)
 
 	wlc_phy_txpwrctrl_config_nphy(pi);
 	if (pi->nphy_txpwrctrl == PHY_TPC_HW_ON)
-		pi->hwpwrctrl_capable = TRUE;
+		pi->hwpwrctrl_capable = true;
 
 	pi->pi_fptr.init = wlc_phy_init_nphy;
 	pi->pi_fptr.calinit = wlc_phy_cal_init_nphy;
@@ -14494,40 +14500,42 @@ bool wlc_phy_attach_nphy(phy_info_t * pi)
 	pi->pi_fptr.txpwrrecalc = wlc_phy_txpower_recalc_target_nphy;
 
 	if (!wlc_phy_txpwr_srom_read_nphy(pi))
-		return FALSE;
+		return false;
 
-	return TRUE;
+	return true;
 }
 
-static void BCMATTACHFN(wlc_phy_txpwrctrl_config_nphy) (phy_info_t * pi) {
+static void wlc_phy_txpwrctrl_config_nphy(phy_info_t *pi)
+{
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		pi->nphy_txpwrctrl = PHY_TPC_HW_ON;
-		pi->phy_5g_pwrgain = TRUE;
+		pi->phy_5g_pwrgain = true;
 		return;
 	}
 
 	pi->nphy_txpwrctrl = PHY_TPC_HW_OFF;
-	pi->phy_5g_pwrgain = FALSE;
+	pi->phy_5g_pwrgain = false;
 
 	if ((pi->sh->boardflags2 & BFL2_TXPWRCTRL_EN) &&
 	    NREV_GE(pi->pubpi.phy_rev, 2) && (pi->sh->sromrev >= 4))
 		pi->nphy_txpwrctrl = PHY_TPC_HW_ON;
 	else if ((pi->sh->sromrev >= 4)
 		 && (pi->sh->boardflags2 & BFL2_5G_PWRGAIN))
-		pi->phy_5g_pwrgain = TRUE;
+		pi->phy_5g_pwrgain = true;
 }
 
-void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t * pi) {
-	uint16 val;
-	uint16 clip1_ths[2];
+void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t *pi)
+{
+	u16 val;
+	u16 clip1_ths[2];
 	nphy_txgains_t target_gain;
-	uint8 tx_pwr_ctrl_state;
-	bool do_nphy_cal = FALSE;
+	u8 tx_pwr_ctrl_state;
+	bool do_nphy_cal = false;
 	uint core;
 	uint origidx, intr_val;
 	d11regs_t *regs;
-	uint32 d11_clk_ctl_st;
+	u32 d11_clk_ctl_st;
 
 	core = 0;
 
@@ -14541,7 +14549,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t * pi) {
 		if ((pi->sh->boardflags & BFL_EXTLNA) &&
 		    (CHSPEC_IS2G(pi->radio_chanspec))) {
 			si_corereg(pi->sh->sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, chipcontrol), 0x40,
+				   offsetof(chipcregs_t, chipcontrol), 0x40,
 				   0x40);
 		}
 	}
@@ -14573,14 +14581,14 @@ void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t * pi) {
 	      (NREV_GE(pi->pubpi.phy_rev, 5)
 	       && pi->sh->boardflags2 & BFL2_INTERNDET_TXIQCAL)));
 
-	pi->internal_tx_iqlo_cal_tapoff_intpa_nphy = FALSE;
+	pi->internal_tx_iqlo_cal_tapoff_intpa_nphy = false;
 
 	pi->nphy_deaf_count = 0;
 
 	wlc_phy_tbl_init_nphy(pi);
 
-	pi->nphy_crsminpwr_adjusted = FALSE;
-	pi->nphy_noisevars_adjusted = FALSE;
+	pi->nphy_crsminpwr_adjusted = false;
+	pi->nphy_noisevars_adjusted = false;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		write_phy_reg(pi, 0xe7, 0);
@@ -14695,11 +14703,11 @@ void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t * pi) {
 	wlc_phy_txpwrctrl_pwr_setup_nphy(pi);
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
-		uint32 *tx_pwrctrl_tbl = NULL;
-		uint16 idx;
-		int16 pga_gn = 0;
-		int16 pad_gn = 0;
-		int32 rfpwr_offset = 0;
+		u32 *tx_pwrctrl_tbl = NULL;
+		u16 idx;
+		s16 pga_gn = 0;
+		s16 pad_gn = 0;
+		s32 rfpwr_offset = 0;
 
 		if (PHY_IPA(pi)) {
 			tx_pwrctrl_tbl = wlc_phy_get_ipa_gaintbl_nphy(pi);
@@ -14748,7 +14756,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t * pi) {
 		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_CORE2TXPWRCTL, 128,
 					 192, 32, tx_pwrctrl_tbl);
 
-		pi->nphy_gmval = (uint16) ((*tx_pwrctrl_tbl >> 16) & 0x7000);
+		pi->nphy_gmval = (u16) ((*tx_pwrctrl_tbl >> 16) & 0x7000);
 
 		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 
@@ -14760,17 +14768,17 @@ void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t * pi) {
 					if ((pi->pubpi.radiorev == 3) ||
 					    (pi->pubpi.radiorev == 4) ||
 					    (pi->pubpi.radiorev == 6)) {
-						rfpwr_offset = (int16)
+						rfpwr_offset = (s16)
 						    nphy_papd_padgain_dlt_2g_2057rev3n4
 						    [pad_gn];
 					} else if (pi->pubpi.radiorev == 5) {
-						rfpwr_offset = (int16)
+						rfpwr_offset = (s16)
 						    nphy_papd_padgain_dlt_2g_2057rev5
 						    [pad_gn];
 					} else if ((pi->pubpi.radiorev == 7)
 						   || (pi->pubpi.radiorev ==
 						       8)) {
-						rfpwr_offset = (int16)
+						rfpwr_offset = (s16)
 						    nphy_papd_padgain_dlt_2g_2057rev7
 						    [pad_gn];
 					} else {
@@ -14781,13 +14789,13 @@ void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t * pi) {
 					if ((pi->pubpi.radiorev == 3) ||
 					    (pi->pubpi.radiorev == 4) ||
 					    (pi->pubpi.radiorev == 6)) {
-						rfpwr_offset = (int16)
+						rfpwr_offset = (s16)
 						    nphy_papd_pgagain_dlt_5g_2057
 						    [pga_gn];
 					} else if ((pi->pubpi.radiorev == 7)
 						   || (pi->pubpi.radiorev ==
 						       8)) {
-						rfpwr_offset = (int16)
+						rfpwr_offset = (s16)
 						    nphy_papd_pgagain_dlt_5g_2057rev7
 						    [pga_gn];
 					} else {
@@ -14808,11 +14816,11 @@ void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t * pi) {
 			for (idx = 0; idx < 128; idx++) {
 				pga_gn = (tx_pwrctrl_tbl[idx] >> 24) & 0xf;
 				if (CHSPEC_IS2G(pi->radio_chanspec)) {
-					rfpwr_offset = (int16)
+					rfpwr_offset = (s16)
 					    nphy_papd_pga_gain_delta_ipa_2g
 					    [pga_gn];
 				} else {
-					rfpwr_offset = (int16)
+					rfpwr_offset = (s16)
 					    nphy_papd_pga_gain_delta_ipa_5g
 					    [pga_gn];
 				}
@@ -14846,7 +14854,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t * pi) {
 	}
 
 	if (!NORADIO_ENAB(pi->pubpi)) {
-		bool do_rssi_cal = FALSE;
+		bool do_rssi_cal = false;
 
 		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 			do_rssi_cal = (CHSPEC_IS2G(pi->radio_chanspec)) ?
@@ -14869,14 +14877,14 @@ void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t * pi) {
 		}
 
 		if (!pi->do_initcal)
-			do_nphy_cal = FALSE;
+			do_nphy_cal = false;
 
 		if (do_nphy_cal) {
 
 			target_gain = wlc_phy_get_tx_gain_nphy(pi);
 
 			if (pi->antsel_type == ANTSEL_2x3)
-				wlc_phy_antsel_init((wlc_phy_t *) pi, TRUE);
+				wlc_phy_antsel_init((wlc_phy_t *) pi, true);
 
 			if (pi->nphy_perical != PHY_PERICAL_MPHASE) {
 				wlc_phy_rssi_cal_nphy(pi);
@@ -14895,10 +14903,10 @@ void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t * pi) {
 				}
 
 				if (wlc_phy_cal_txiqlo_nphy
-				    (pi, target_gain, TRUE, FALSE) == BCME_OK) {
+				    (pi, target_gain, true, false) == BCME_OK) {
 					if (wlc_phy_cal_rxiq_nphy
 					    (pi, target_gain, 2,
-					     FALSE) == BCME_OK) {
+					     false) == BCME_OK) {
 						wlc_phy_savecal_nphy(pi);
 
 					}
@@ -14930,13 +14938,13 @@ void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t * pi) {
 
 }
 
-static void wlc_phy_update_mimoconfig_nphy(phy_info_t * pi, int32 preamble)
+static void wlc_phy_update_mimoconfig_nphy(phy_info_t *pi, s32 preamble)
 {
-	bool gf_preamble = FALSE;
-	uint16 val;
+	bool gf_preamble = false;
+	u16 val;
 
 	if (preamble == WLC_N_PREAMBLE_GF) {
-		gf_preamble = TRUE;
+		gf_preamble = true;
 	}
 
 	val = read_phy_reg(pi, 0xed);
@@ -14949,9 +14957,9 @@ static void wlc_phy_update_mimoconfig_nphy(phy_info_t * pi, int32 preamble)
 	write_phy_reg(pi, 0xed, val);
 }
 
-static void wlc_phy_resetcca_nphy(phy_info_t * pi)
+static void wlc_phy_resetcca_nphy(phy_info_t *pi)
 {
-	uint16 val;
+	u16 val;
 
 	ASSERT(0 == (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
 
@@ -14959,7 +14967,7 @@ static void wlc_phy_resetcca_nphy(phy_info_t * pi)
 
 	val = read_phy_reg(pi, 0x01);
 	write_phy_reg(pi, 0x01, val | BBCFG_RESETCCA);
-	OSL_DELAY(1);
+	udelay(1);
 	write_phy_reg(pi, 0x01, val & (~BBCFG_RESETCCA));
 
 	wlapi_bmac_phyclk_fgc(pi->sh->physhim, OFF);
@@ -14967,9 +14975,9 @@ static void wlc_phy_resetcca_nphy(phy_info_t * pi)
 	wlc_phy_force_rfseq_nphy(pi, NPHY_RFSEQ_RESET2RX);
 }
 
-void wlc_phy_pa_override_nphy(phy_info_t * pi, bool en)
+void wlc_phy_pa_override_nphy(phy_info_t *pi, bool en)
 {
-	uint16 rfctrlintc_override_val;
+	u16 rfctrlintc_override_val;
 
 	if (!en) {
 
@@ -14996,23 +15004,23 @@ void wlc_phy_pa_override_nphy(phy_info_t * pi, bool en)
 
 }
 
-void wlc_phy_stf_chain_upd_nphy(phy_info_t * pi)
+void wlc_phy_stf_chain_upd_nphy(phy_info_t *pi)
 {
 
-	uint16 txrx_chain =
+	u16 txrx_chain =
 	    (NPHY_RfseqCoreActv_TxRxChain0 | NPHY_RfseqCoreActv_TxRxChain1);
-	bool CoreActv_override = FALSE;
+	bool CoreActv_override = false;
 
 	if (pi->nphy_txrx_chain == WLC_N_TXRX_CHAIN0) {
 		txrx_chain = NPHY_RfseqCoreActv_TxRxChain0;
-		CoreActv_override = TRUE;
+		CoreActv_override = true;
 
 		if (NREV_LE(pi->pubpi.phy_rev, 2)) {
 			and_phy_reg(pi, 0xa0, ~0x20);
 		}
 	} else if (pi->nphy_txrx_chain == WLC_N_TXRX_CHAIN1) {
 		txrx_chain = NPHY_RfseqCoreActv_TxRxChain1;
-		CoreActv_override = TRUE;
+		CoreActv_override = true;
 
 		if (NREV_LE(pi->pubpi.phy_rev, 2)) {
 			or_phy_reg(pi, 0xa0, 0x20);
@@ -15031,13 +15039,13 @@ void wlc_phy_stf_chain_upd_nphy(phy_info_t * pi)
 	}
 }
 
-void wlc_phy_rxcore_setstate_nphy(wlc_phy_t * pih, uint8 rxcore_bitmask)
+void wlc_phy_rxcore_setstate_nphy(wlc_phy_t *pih, u8 rxcore_bitmask)
 {
-	uint16 regval;
-	uint16 tbl_buf[16];
+	u16 regval;
+	u16 tbl_buf[16];
 	uint i;
 	phy_info_t *pi = (phy_info_t *) pih;
-	uint16 tbl_opcode;
+	u16 tbl_opcode;
 	bool suspend;
 
 	pi->sh->phyrxchain = rxcore_bitmask;
@@ -15051,11 +15059,11 @@ void wlc_phy_rxcore_setstate_nphy(wlc_phy_t * pih, uint8 rxcore_bitmask)
 		wlapi_suspend_mac_and_wait(pi->sh->physhim);
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	regval = read_phy_reg(pi, 0xa2);
 	regval &= ~(0xf << 4);
-	regval |= ((uint16) (rxcore_bitmask & 0x3)) << 4;
+	regval |= ((u16) (rxcore_bitmask & 0x3)) << 4;
 	write_phy_reg(pi, 0xa2, regval);
 
 	if ((rxcore_bitmask & 0x3) != 0x3) {
@@ -15065,14 +15073,14 @@ void wlc_phy_rxcore_setstate_nphy(wlc_phy_t * pih, uint8 rxcore_bitmask)
 		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 			if (pi->rx2tx_biasentry == -1) {
 				wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ,
-							ARRAYSIZE(tbl_buf), 80,
+							ARRAY_SIZE(tbl_buf), 80,
 							16, tbl_buf);
 
-				for (i = 0; i < ARRAYSIZE(tbl_buf); i++) {
+				for (i = 0; i < ARRAY_SIZE(tbl_buf); i++) {
 					if (tbl_buf[i] ==
 					    NPHY_REV3_RFSEQ_CMD_CLR_RXRX_BIAS) {
 
-						pi->rx2tx_biasentry = (uint8) i;
+						pi->rx2tx_biasentry = (u8) i;
 						tbl_opcode =
 						    NPHY_REV3_RFSEQ_CMD_NOP;
 						wlc_phy_table_write_nphy(pi,
@@ -15106,31 +15114,31 @@ void wlc_phy_rxcore_setstate_nphy(wlc_phy_t * pih, uint8 rxcore_bitmask)
 	wlc_phy_force_rfseq_nphy(pi, NPHY_RFSEQ_RESET2RX);
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 
 	if (!suspend)
 		wlapi_enable_mac(pi->sh->physhim);
 }
 
-uint8 wlc_phy_rxcore_getstate_nphy(wlc_phy_t * pih)
+u8 wlc_phy_rxcore_getstate_nphy(wlc_phy_t *pih)
 {
-	uint16 regval, rxen_bits;
+	u16 regval, rxen_bits;
 	phy_info_t *pi = (phy_info_t *) pih;
 
 	regval = read_phy_reg(pi, 0xa2);
 	rxen_bits = (regval >> 4) & 0xf;
 
-	return ((uint8) rxen_bits);
+	return (u8) rxen_bits;
 }
 
-bool wlc_phy_n_txpower_ipa_ison(phy_info_t * pi)
+bool wlc_phy_n_txpower_ipa_ison(phy_info_t *pi)
 {
 	return PHY_IPA(pi);
 }
 
-static void wlc_phy_txpwr_limit_to_tbl_nphy(phy_info_t * pi)
+static void wlc_phy_txpwr_limit_to_tbl_nphy(phy_info_t *pi)
 {
-	uint8 idx, idx2, i, delta_ind;
+	u8 idx, idx2, i, delta_ind;
 
 	for (idx = TXP_FIRST_CCK; idx <= TXP_LAST_CCK; idx++) {
 		pi->adj_pwr_tbl_nphy[idx] = pi->tx_power_offset[idx];
@@ -15222,11 +15230,11 @@ static void wlc_phy_txpwr_limit_to_tbl_nphy(phy_info_t * pi)
 	}
 }
 
-void wlc_phy_cal_init_nphy(phy_info_t * pi)
+void wlc_phy_cal_init_nphy(phy_info_t *pi)
 {
 }
 
-static void wlc_phy_war_force_trsw_to_R_cliplo_nphy(phy_info_t * pi, uint8 core)
+static void wlc_phy_war_force_trsw_to_R_cliplo_nphy(phy_info_t *pi, u8 core)
 {
 	if (core == PHY_CORE_0) {
 		write_phy_reg(pi, 0x38, 0x4);
@@ -15245,9 +15253,9 @@ static void wlc_phy_war_force_trsw_to_R_cliplo_nphy(phy_info_t * pi, uint8 core)
 	}
 }
 
-static void wlc_phy_war_txchain_upd_nphy(phy_info_t * pi, uint8 txchain)
+static void wlc_phy_war_txchain_upd_nphy(phy_info_t *pi, u8 txchain)
 {
-	uint8 txchain0, txchain1;
+	u8 txchain0, txchain1;
 
 	txchain0 = txchain & 0x1;
 	txchain1 = (txchain & 0x2) >> 1;
@@ -15260,9 +15268,9 @@ static void wlc_phy_war_txchain_upd_nphy(phy_info_t * pi, uint8 txchain)
 	}
 }
 
-static void wlc_phy_workarounds_nphy(phy_info_t * pi)
+static void wlc_phy_workarounds_nphy(phy_info_t *pi)
 {
-	uint8 rfseq_rx2tx_events[] = {
+	u8 rfseq_rx2tx_events[] = {
 		NPHY_RFSEQ_CMD_NOP,
 		NPHY_RFSEQ_CMD_RXG_FBW,
 		NPHY_RFSEQ_CMD_TR_SWITCH,
@@ -15271,8 +15279,8 @@ static void wlc_phy_workarounds_nphy(phy_info_t * pi)
 		NPHY_RFSEQ_CMD_TX_GAIN,
 		NPHY_RFSEQ_CMD_EXT_PA
 	};
-	uint8 rfseq_rx2tx_dlys[] = { 8, 6, 6, 2, 4, 60, 1 };
-	uint8 rfseq_tx2rx_events[] = {
+	u8 rfseq_rx2tx_dlys[] = { 8, 6, 6, 2, 4, 60, 1 };
+	u8 rfseq_tx2rx_events[] = {
 		NPHY_RFSEQ_CMD_NOP,
 		NPHY_RFSEQ_CMD_EXT_PA,
 		NPHY_RFSEQ_CMD_TX_GAIN,
@@ -15281,8 +15289,8 @@ static void wlc_phy_workarounds_nphy(phy_info_t * pi)
 		NPHY_RFSEQ_CMD_RXG_FBW,
 		NPHY_RFSEQ_CMD_CLR_HIQ_DIS
 	};
-	uint8 rfseq_tx2rx_dlys[] = { 8, 6, 2, 4, 4, 6, 1 };
-	uint8 rfseq_tx2rx_events_rev3[] = {
+	u8 rfseq_tx2rx_dlys[] = { 8, 6, 2, 4, 4, 6, 1 };
+	u8 rfseq_tx2rx_events_rev3[] = {
 		NPHY_REV3_RFSEQ_CMD_EXT_PA,
 		NPHY_REV3_RFSEQ_CMD_INT_PA_PU,
 		NPHY_REV3_RFSEQ_CMD_TX_GAIN,
@@ -15292,8 +15300,8 @@ static void wlc_phy_workarounds_nphy(phy_info_t * pi)
 		NPHY_REV3_RFSEQ_CMD_CLR_HIQ_DIS,
 		NPHY_REV3_RFSEQ_CMD_END
 	};
-	uint8 rfseq_tx2rx_dlys_rev3[] = { 8, 4, 2, 2, 4, 4, 6, 1 };
-	uint8 rfseq_rx2tx_events_rev3[] = {
+	u8 rfseq_tx2rx_dlys_rev3[] = { 8, 4, 2, 2, 4, 4, 6, 1 };
+	u8 rfseq_rx2tx_events_rev3[] = {
 		NPHY_REV3_RFSEQ_CMD_NOP,
 		NPHY_REV3_RFSEQ_CMD_RXG_FBW,
 		NPHY_REV3_RFSEQ_CMD_TR_SWITCH,
@@ -15304,9 +15312,9 @@ static void wlc_phy_workarounds_nphy(phy_info_t * pi)
 		NPHY_REV3_RFSEQ_CMD_EXT_PA,
 		NPHY_REV3_RFSEQ_CMD_END
 	};
-	uint8 rfseq_rx2tx_dlys_rev3[] = { 8, 6, 6, 4, 4, 18, 42, 1, 1 };
+	u8 rfseq_rx2tx_dlys_rev3[] = { 8, 6, 6, 4, 4, 18, 42, 1, 1 };
 
-	uint8 rfseq_rx2tx_events_rev3_ipa[] = {
+	u8 rfseq_rx2tx_events_rev3_ipa[] = {
 		NPHY_REV3_RFSEQ_CMD_NOP,
 		NPHY_REV3_RFSEQ_CMD_RXG_FBW,
 		NPHY_REV3_RFSEQ_CMD_TR_SWITCH,
@@ -15317,57 +15325,57 @@ static void wlc_phy_workarounds_nphy(phy_info_t * pi)
 		NPHY_REV3_RFSEQ_CMD_INT_PA_PU,
 		NPHY_REV3_RFSEQ_CMD_END
 	};
-	uint8 rfseq_rx2tx_dlys_rev3_ipa[] = { 8, 6, 6, 4, 4, 16, 43, 1, 1 };
-	uint16 rfseq_rx2tx_dacbufpu_rev7[] = { 0x10f, 0x10f };
+	u8 rfseq_rx2tx_dlys_rev3_ipa[] = { 8, 6, 6, 4, 4, 16, 43, 1, 1 };
+	u16 rfseq_rx2tx_dacbufpu_rev7[] = { 0x10f, 0x10f };
 
-	int16 alpha0, alpha1, alpha2;
-	int16 beta0, beta1, beta2;
-	uint32 leg_data_weights, ht_data_weights, nss1_data_weights,
+	s16 alpha0, alpha1, alpha2;
+	s16 beta0, beta1, beta2;
+	u32 leg_data_weights, ht_data_weights, nss1_data_weights,
 	    stbc_data_weights;
-	uint8 chan_freq_range = 0;
-	uint16 dac_control = 0x0002;
-	uint16 aux_adc_vmid_rev7_core0[] = { 0x8e, 0x96, 0x96, 0x96 };
-	uint16 aux_adc_vmid_rev7_core1[] = { 0x8f, 0x9f, 0x9f, 0x96 };
-	uint16 aux_adc_vmid_rev4[] = { 0xa2, 0xb4, 0xb4, 0x89 };
-	uint16 aux_adc_vmid_rev3[] = { 0xa2, 0xb4, 0xb4, 0x89 };
-	uint16 *aux_adc_vmid;
-	uint16 aux_adc_gain_rev7[] = { 0x02, 0x02, 0x02, 0x02 };
-	uint16 aux_adc_gain_rev4[] = { 0x02, 0x02, 0x02, 0x00 };
-	uint16 aux_adc_gain_rev3[] = { 0x02, 0x02, 0x02, 0x00 };
-	uint16 *aux_adc_gain;
-	uint16 sk_adc_vmid[] = { 0xb4, 0xb4, 0xb4, 0x24 };
-	uint16 sk_adc_gain[] = { 0x02, 0x02, 0x02, 0x02 };
-	int32 min_nvar_val = 0x18d;
-	int32 min_nvar_offset_6mbps = 20;
-	uint8 pdetrange;
-	uint8 triso;
-	uint16 regval;
-	uint16 afectrl_adc_ctrl1_rev7 = 0x20;
-	uint16 afectrl_adc_ctrl2_rev7 = 0x0;
-	uint16 rfseq_rx2tx_lpf_h_hpc_rev7 = 0x77;
-	uint16 rfseq_tx2rx_lpf_h_hpc_rev7 = 0x77;
-	uint16 rfseq_pktgn_lpf_h_hpc_rev7 = 0x77;
-	uint16 rfseq_htpktgn_lpf_hpc_rev7[] = { 0x77, 0x11, 0x11 };
-	uint16 rfseq_pktgn_lpf_hpc_rev7[] = { 0x11, 0x11 };
-	uint16 rfseq_cckpktgn_lpf_hpc_rev7[] = { 0x11, 0x11 };
-	uint16 ipalvlshift_3p3_war_en = 0;
-	uint16 rccal_bcap_val, rccal_scap_val;
-	uint16 rccal_tx20_11b_bcap = 0;
-	uint16 rccal_tx20_11b_scap = 0;
-	uint16 rccal_tx20_11n_bcap = 0;
-	uint16 rccal_tx20_11n_scap = 0;
-	uint16 rccal_tx40_11n_bcap = 0;
-	uint16 rccal_tx40_11n_scap = 0;
-	uint16 rx2tx_lpf_rc_lut_tx20_11b = 0;
-	uint16 rx2tx_lpf_rc_lut_tx20_11n = 0;
-	uint16 rx2tx_lpf_rc_lut_tx40_11n = 0;
-	uint16 tx_lpf_bw_ofdm_20mhz = 0;
-	uint16 tx_lpf_bw_ofdm_40mhz = 0;
-	uint16 tx_lpf_bw_11b = 0;
-	uint16 ipa2g_mainbias, ipa2g_casconv, ipa2g_biasfilt;
-	uint16 txgm_idac_bleed = 0;
-	bool rccal_ovrd = FALSE;
-	uint16 freq;
+	u8 chan_freq_range = 0;
+	u16 dac_control = 0x0002;
+	u16 aux_adc_vmid_rev7_core0[] = { 0x8e, 0x96, 0x96, 0x96 };
+	u16 aux_adc_vmid_rev7_core1[] = { 0x8f, 0x9f, 0x9f, 0x96 };
+	u16 aux_adc_vmid_rev4[] = { 0xa2, 0xb4, 0xb4, 0x89 };
+	u16 aux_adc_vmid_rev3[] = { 0xa2, 0xb4, 0xb4, 0x89 };
+	u16 *aux_adc_vmid;
+	u16 aux_adc_gain_rev7[] = { 0x02, 0x02, 0x02, 0x02 };
+	u16 aux_adc_gain_rev4[] = { 0x02, 0x02, 0x02, 0x00 };
+	u16 aux_adc_gain_rev3[] = { 0x02, 0x02, 0x02, 0x00 };
+	u16 *aux_adc_gain;
+	u16 sk_adc_vmid[] = { 0xb4, 0xb4, 0xb4, 0x24 };
+	u16 sk_adc_gain[] = { 0x02, 0x02, 0x02, 0x02 };
+	s32 min_nvar_val = 0x18d;
+	s32 min_nvar_offset_6mbps = 20;
+	u8 pdetrange;
+	u8 triso;
+	u16 regval;
+	u16 afectrl_adc_ctrl1_rev7 = 0x20;
+	u16 afectrl_adc_ctrl2_rev7 = 0x0;
+	u16 rfseq_rx2tx_lpf_h_hpc_rev7 = 0x77;
+	u16 rfseq_tx2rx_lpf_h_hpc_rev7 = 0x77;
+	u16 rfseq_pktgn_lpf_h_hpc_rev7 = 0x77;
+	u16 rfseq_htpktgn_lpf_hpc_rev7[] = { 0x77, 0x11, 0x11 };
+	u16 rfseq_pktgn_lpf_hpc_rev7[] = { 0x11, 0x11 };
+	u16 rfseq_cckpktgn_lpf_hpc_rev7[] = { 0x11, 0x11 };
+	u16 ipalvlshift_3p3_war_en = 0;
+	u16 rccal_bcap_val, rccal_scap_val;
+	u16 rccal_tx20_11b_bcap = 0;
+	u16 rccal_tx20_11b_scap = 0;
+	u16 rccal_tx20_11n_bcap = 0;
+	u16 rccal_tx20_11n_scap = 0;
+	u16 rccal_tx40_11n_bcap = 0;
+	u16 rccal_tx40_11n_scap = 0;
+	u16 rx2tx_lpf_rc_lut_tx20_11b = 0;
+	u16 rx2tx_lpf_rc_lut_tx20_11n = 0;
+	u16 rx2tx_lpf_rc_lut_tx40_11n = 0;
+	u16 tx_lpf_bw_ofdm_20mhz = 0;
+	u16 tx_lpf_bw_ofdm_40mhz = 0;
+	u16 tx_lpf_bw_11b = 0;
+	u16 ipa2g_mainbias, ipa2g_casconv, ipa2g_biasfilt;
+	u16 txgm_idac_bleed = 0;
+	bool rccal_ovrd = false;
+	u16 freq;
 	int coreNum;
 
 	if (CHSPEC_IS5G(pi->radio_chanspec)) {
@@ -15377,7 +15385,7 @@ static void wlc_phy_workarounds_nphy(phy_info_t * pi)
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	if (!ISSIM_ENAB(pi->sh->sih)) {
 		or_phy_reg(pi, 0xb1, NPHY_IQFlip_ADC1 | NPHY_IQFlip_ADC2);
@@ -15475,7 +15483,7 @@ static void wlc_phy_workarounds_nphy(phy_info_t * pi)
 					rccal_tx40_11n_bcap = 0xc;
 					rccal_tx40_11n_scap = 0xc;
 
-					rccal_ovrd = TRUE;
+					rccal_ovrd = true;
 
 				} else if ((pi->pubpi.radiorev == 7)
 					   || (pi->pubpi.radiorev == 8)) {
@@ -15495,7 +15503,7 @@ static void wlc_phy_workarounds_nphy(phy_info_t * pi)
 						rccal_tx40_11n_scap = 0xf;
 					}
 
-					rccal_ovrd = TRUE;
+					rccal_ovrd = true;
 				}
 			}
 
@@ -15521,7 +15529,7 @@ static void wlc_phy_workarounds_nphy(phy_info_t * pi)
 				rccal_tx40_11n_bcap = 0x13;
 				rccal_tx40_11n_scap = 0x11;
 
-				rccal_ovrd = TRUE;
+				rccal_ovrd = true;
 			}
 		}
 
@@ -16038,8 +16046,8 @@ static void wlc_phy_workarounds_nphy(phy_info_t * pi)
 						 0x1c, 16, sk_adc_gain);
 		} else if (pdetrange == 2) {
 
-			uint16 bcm_adc_vmid[] = { 0xa2, 0xb4, 0xb4, 0x74 };
-			uint16 bcm_adc_gain[] = { 0x02, 0x02, 0x02, 0x04 };
+			u16 bcm_adc_vmid[] = { 0xa2, 0xb4, 0xb4, 0x74 };
+			u16 bcm_adc_gain[] = { 0x02, 0x02, 0x02, 0x04 };
 
 			if (NREV_GE(pi->pubpi.phy_rev, 6)) {
 				chan_freq_range =
@@ -16070,10 +16078,10 @@ static void wlc_phy_workarounds_nphy(phy_info_t * pi)
 			if ((NREV_GE(pi->pubpi.phy_rev, 4))
 			    && (chan_freq_range == WL_CHAN_FREQ_RANGE_2G)) {
 
-				uint16 auxadc_vmid[] =
-				    { 0xa2, 0xb4, 0xb4, 0x270 };
-				uint16 auxadc_gain[] =
-				    { 0x02, 0x02, 0x02, 0x00 };
+				u16 auxadc_vmid[] = {
+					0xa2, 0xb4, 0xb4, 0x270 };
+				u16 auxadc_gain[] = {
+					0x02, 0x02, 0x02, 0x00 };
 
 				wlc_phy_table_write_nphy(pi,
 							 NPHY_TBL_ID_AFECTRL, 4,
@@ -16089,9 +16097,9 @@ static void wlc_phy_workarounds_nphy(phy_info_t * pi)
 							 0x1c, 16, auxadc_gain);
 			}
 		} else if ((pdetrange == 4) || (pdetrange == 5)) {
-			uint16 bcm_adc_vmid[] = { 0xa2, 0xb4, 0xb4, 0x0 };
-			uint16 bcm_adc_gain[] = { 0x02, 0x02, 0x02, 0x0 };
-			uint16 Vmid[2], Av[2];
+			u16 bcm_adc_vmid[] = { 0xa2, 0xb4, 0xb4, 0x0 };
+			u16 bcm_adc_gain[] = { 0x02, 0x02, 0x02, 0x0 };
+			u16 Vmid[2], Av[2];
 
 			chan_freq_range =
 			    wlc_phy_get_chan_freq_range_nphy(pi, 0);
@@ -16235,8 +16243,8 @@ static void wlc_phy_workarounds_nphy(phy_info_t * pi)
 		if (pi->sh->boardflags2 & BFL2_SKWRKFEM_BRD ||
 		    (pi->sh->boardtype == 0x8b)) {
 			uint i;
-			uint8 war_dlys[] = { 1, 6, 6, 2, 4, 20, 1 };
-			for (i = 0; i < ARRAYSIZE(rfseq_rx2tx_dlys); i++)
+			u8 war_dlys[] = { 1, 6, 6, 2, 4, 20, 1 };
+			for (i = 0; i < ARRAY_SIZE(rfseq_rx2tx_dlys); i++)
 				rfseq_rx2tx_dlys[i] = war_dlys[i];
 		}
 
@@ -16334,163 +16342,163 @@ static void wlc_phy_workarounds_nphy(phy_info_t * pi)
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
-static void wlc_phy_workarounds_nphy_gainctrl(phy_info_t * pi)
+static void wlc_phy_workarounds_nphy_gainctrl(phy_info_t *pi)
 {
-	uint16 w1th, hpf_code, currband;
+	u16 w1th, hpf_code, currband;
 	int ctr;
-	uint8 rfseq_updategainu_events[] = {
+	u8 rfseq_updategainu_events[] = {
 		NPHY_RFSEQ_CMD_RX_GAIN,
 		NPHY_RFSEQ_CMD_CLR_HIQ_DIS,
 		NPHY_RFSEQ_CMD_SET_HPF_BW
 	};
-	uint8 rfseq_updategainu_dlys[] = { 10, 30, 1 };
-	int8 lna1G_gain_db[] = { 7, 11, 16, 23 };
-	int8 lna1G_gain_db_rev4[] = { 8, 12, 17, 25 };
-	int8 lna1G_gain_db_rev5[] = { 9, 13, 18, 26 };
-	int8 lna1G_gain_db_rev6[] = { 8, 13, 18, 25 };
-	int8 lna1G_gain_db_rev6_224B0[] = { 10, 14, 19, 27 };
-	int8 lna1A_gain_db[] = { 7, 11, 17, 23 };
-	int8 lna1A_gain_db_rev4[] = { 8, 12, 18, 23 };
-	int8 lna1A_gain_db_rev5[] = { 6, 10, 16, 21 };
-	int8 lna1A_gain_db_rev6[] = { 6, 10, 16, 21 };
-	int8 *lna1_gain_db = NULL;
-	int8 lna2G_gain_db[] = { -5, 6, 10, 14 };
-	int8 lna2G_gain_db_rev5[] = { -3, 7, 11, 16 };
-	int8 lna2G_gain_db_rev6[] = { -5, 6, 10, 14 };
-	int8 lna2G_gain_db_rev6_224B0[] = { -5, 6, 10, 15 };
-	int8 lna2A_gain_db[] = { -6, 2, 6, 10 };
-	int8 lna2A_gain_db_rev4[] = { -5, 2, 6, 10 };
-	int8 lna2A_gain_db_rev5[] = { -7, 0, 4, 8 };
-	int8 lna2A_gain_db_rev6[] = { -7, 0, 4, 8 };
-	int8 *lna2_gain_db = NULL;
-	int8 tiaG_gain_db[] =
-	    { 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A };
-	int8 tiaA_gain_db[] =
-	    { 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13 };
-	int8 tiaA_gain_db_rev4[] =
-	    { 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d };
-	int8 tiaA_gain_db_rev5[] =
-	    { 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d };
-	int8 tiaA_gain_db_rev6[] =
-	    { 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d };
-	int8 *tia_gain_db;
-	int8 tiaG_gainbits[] =
-	    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 };
-	int8 tiaA_gainbits[] =
-	    { 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06 };
-	int8 tiaA_gainbits_rev4[] =
-	    { 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04 };
-	int8 tiaA_gainbits_rev5[] =
-	    { 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04 };
-	int8 tiaA_gainbits_rev6[] =
-	    { 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04 };
-	int8 *tia_gainbits;
-	int8 lpf_gain_db[] = { 0x00, 0x06, 0x0c, 0x12, 0x12, 0x12 };
-	int8 lpf_gainbits[] = { 0x00, 0x01, 0x02, 0x03, 0x03, 0x03 };
-	uint16 rfseqG_init_gain[] = { 0x613f, 0x613f, 0x613f, 0x613f };
-	uint16 rfseqG_init_gain_rev4[] = { 0x513f, 0x513f, 0x513f, 0x513f };
-	uint16 rfseqG_init_gain_rev5[] = { 0x413f, 0x413f, 0x413f, 0x413f };
-	uint16 rfseqG_init_gain_rev5_elna[] =
-	    { 0x013f, 0x013f, 0x013f, 0x013f };
-	uint16 rfseqG_init_gain_rev6[] = { 0x513f, 0x513f };
-	uint16 rfseqG_init_gain_rev6_224B0[] = { 0x413f, 0x413f };
-	uint16 rfseqG_init_gain_rev6_elna[] = { 0x113f, 0x113f };
-	uint16 rfseqA_init_gain[] = { 0x516f, 0x516f, 0x516f, 0x516f };
-	uint16 rfseqA_init_gain_rev4[] = { 0x614f, 0x614f, 0x614f, 0x614f };
-	uint16 rfseqA_init_gain_rev4_elna[] =
-	    { 0x314f, 0x314f, 0x314f, 0x314f };
-	uint16 rfseqA_init_gain_rev5[] = { 0x714f, 0x714f, 0x714f, 0x714f };
-	uint16 rfseqA_init_gain_rev6[] = { 0x714f, 0x714f };
-	uint16 *rfseq_init_gain;
-	uint16 initG_gaincode = 0x627e;
-	uint16 initG_gaincode_rev4 = 0x527e;
-	uint16 initG_gaincode_rev5 = 0x427e;
-	uint16 initG_gaincode_rev5_elna = 0x027e;
-	uint16 initG_gaincode_rev6 = 0x527e;
-	uint16 initG_gaincode_rev6_224B0 = 0x427e;
-	uint16 initG_gaincode_rev6_elna = 0x127e;
-	uint16 initA_gaincode = 0x52de;
-	uint16 initA_gaincode_rev4 = 0x629e;
-	uint16 initA_gaincode_rev4_elna = 0x329e;
-	uint16 initA_gaincode_rev5 = 0x729e;
-	uint16 initA_gaincode_rev6 = 0x729e;
-	uint16 init_gaincode;
-	uint16 clip1hiG_gaincode = 0x107e;
-	uint16 clip1hiG_gaincode_rev4 = 0x007e;
-	uint16 clip1hiG_gaincode_rev5 = 0x1076;
-	uint16 clip1hiG_gaincode_rev6 = 0x007e;
-	uint16 clip1hiA_gaincode = 0x00de;
-	uint16 clip1hiA_gaincode_rev4 = 0x029e;
-	uint16 clip1hiA_gaincode_rev5 = 0x029e;
-	uint16 clip1hiA_gaincode_rev6 = 0x029e;
-	uint16 clip1hi_gaincode;
-	uint16 clip1mdG_gaincode = 0x0066;
-	uint16 clip1mdA_gaincode = 0x00ca;
-	uint16 clip1mdA_gaincode_rev4 = 0x1084;
-	uint16 clip1mdA_gaincode_rev5 = 0x2084;
-	uint16 clip1mdA_gaincode_rev6 = 0x2084;
-	uint16 clip1md_gaincode = 0;
-	uint16 clip1loG_gaincode = 0x0074;
-	uint16 clip1loG_gaincode_rev5[] = {
+	u8 rfseq_updategainu_dlys[] = { 10, 30, 1 };
+	s8 lna1G_gain_db[] = { 7, 11, 16, 23 };
+	s8 lna1G_gain_db_rev4[] = { 8, 12, 17, 25 };
+	s8 lna1G_gain_db_rev5[] = { 9, 13, 18, 26 };
+	s8 lna1G_gain_db_rev6[] = { 8, 13, 18, 25 };
+	s8 lna1G_gain_db_rev6_224B0[] = { 10, 14, 19, 27 };
+	s8 lna1A_gain_db[] = { 7, 11, 17, 23 };
+	s8 lna1A_gain_db_rev4[] = { 8, 12, 18, 23 };
+	s8 lna1A_gain_db_rev5[] = { 6, 10, 16, 21 };
+	s8 lna1A_gain_db_rev6[] = { 6, 10, 16, 21 };
+	s8 *lna1_gain_db = NULL;
+	s8 lna2G_gain_db[] = { -5, 6, 10, 14 };
+	s8 lna2G_gain_db_rev5[] = { -3, 7, 11, 16 };
+	s8 lna2G_gain_db_rev6[] = { -5, 6, 10, 14 };
+	s8 lna2G_gain_db_rev6_224B0[] = { -5, 6, 10, 15 };
+	s8 lna2A_gain_db[] = { -6, 2, 6, 10 };
+	s8 lna2A_gain_db_rev4[] = { -5, 2, 6, 10 };
+	s8 lna2A_gain_db_rev5[] = { -7, 0, 4, 8 };
+	s8 lna2A_gain_db_rev6[] = { -7, 0, 4, 8 };
+	s8 *lna2_gain_db = NULL;
+	s8 tiaG_gain_db[] = {
+		0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A };
+	s8 tiaA_gain_db[] = {
+		0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13 };
+	s8 tiaA_gain_db_rev4[] = {
+		0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d };
+	s8 tiaA_gain_db_rev5[] = {
+		0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d };
+	s8 tiaA_gain_db_rev6[] = {
+		0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d };
+	s8 *tia_gain_db;
+	s8 tiaG_gainbits[] = {
+		0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 };
+	s8 tiaA_gainbits[] = {
+		0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06 };
+	s8 tiaA_gainbits_rev4[] = {
+		0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04 };
+	s8 tiaA_gainbits_rev5[] = {
+		0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04 };
+	s8 tiaA_gainbits_rev6[] = {
+		0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04 };
+	s8 *tia_gainbits;
+	s8 lpf_gain_db[] = { 0x00, 0x06, 0x0c, 0x12, 0x12, 0x12 };
+	s8 lpf_gainbits[] = { 0x00, 0x01, 0x02, 0x03, 0x03, 0x03 };
+	u16 rfseqG_init_gain[] = { 0x613f, 0x613f, 0x613f, 0x613f };
+	u16 rfseqG_init_gain_rev4[] = { 0x513f, 0x513f, 0x513f, 0x513f };
+	u16 rfseqG_init_gain_rev5[] = { 0x413f, 0x413f, 0x413f, 0x413f };
+	u16 rfseqG_init_gain_rev5_elna[] = {
+		0x013f, 0x013f, 0x013f, 0x013f };
+	u16 rfseqG_init_gain_rev6[] = { 0x513f, 0x513f };
+	u16 rfseqG_init_gain_rev6_224B0[] = { 0x413f, 0x413f };
+	u16 rfseqG_init_gain_rev6_elna[] = { 0x113f, 0x113f };
+	u16 rfseqA_init_gain[] = { 0x516f, 0x516f, 0x516f, 0x516f };
+	u16 rfseqA_init_gain_rev4[] = { 0x614f, 0x614f, 0x614f, 0x614f };
+	u16 rfseqA_init_gain_rev4_elna[] = {
+		0x314f, 0x314f, 0x314f, 0x314f };
+	u16 rfseqA_init_gain_rev5[] = { 0x714f, 0x714f, 0x714f, 0x714f };
+	u16 rfseqA_init_gain_rev6[] = { 0x714f, 0x714f };
+	u16 *rfseq_init_gain;
+	u16 initG_gaincode = 0x627e;
+	u16 initG_gaincode_rev4 = 0x527e;
+	u16 initG_gaincode_rev5 = 0x427e;
+	u16 initG_gaincode_rev5_elna = 0x027e;
+	u16 initG_gaincode_rev6 = 0x527e;
+	u16 initG_gaincode_rev6_224B0 = 0x427e;
+	u16 initG_gaincode_rev6_elna = 0x127e;
+	u16 initA_gaincode = 0x52de;
+	u16 initA_gaincode_rev4 = 0x629e;
+	u16 initA_gaincode_rev4_elna = 0x329e;
+	u16 initA_gaincode_rev5 = 0x729e;
+	u16 initA_gaincode_rev6 = 0x729e;
+	u16 init_gaincode;
+	u16 clip1hiG_gaincode = 0x107e;
+	u16 clip1hiG_gaincode_rev4 = 0x007e;
+	u16 clip1hiG_gaincode_rev5 = 0x1076;
+	u16 clip1hiG_gaincode_rev6 = 0x007e;
+	u16 clip1hiA_gaincode = 0x00de;
+	u16 clip1hiA_gaincode_rev4 = 0x029e;
+	u16 clip1hiA_gaincode_rev5 = 0x029e;
+	u16 clip1hiA_gaincode_rev6 = 0x029e;
+	u16 clip1hi_gaincode;
+	u16 clip1mdG_gaincode = 0x0066;
+	u16 clip1mdA_gaincode = 0x00ca;
+	u16 clip1mdA_gaincode_rev4 = 0x1084;
+	u16 clip1mdA_gaincode_rev5 = 0x2084;
+	u16 clip1mdA_gaincode_rev6 = 0x2084;
+	u16 clip1md_gaincode = 0;
+	u16 clip1loG_gaincode = 0x0074;
+	u16 clip1loG_gaincode_rev5[] = {
 		0x0062, 0x0064, 0x006a, 0x106a, 0x106c, 0x1074, 0x107c, 0x207c
 	};
-	uint16 clip1loG_gaincode_rev6[] = {
+	u16 clip1loG_gaincode_rev6[] = {
 		0x106a, 0x106c, 0x1074, 0x107c, 0x007e, 0x107e, 0x207e, 0x307e
 	};
-	uint16 clip1loG_gaincode_rev6_224B0 = 0x1074;
-	uint16 clip1loA_gaincode = 0x00cc;
-	uint16 clip1loA_gaincode_rev4 = 0x0086;
-	uint16 clip1loA_gaincode_rev5 = 0x2086;
-	uint16 clip1loA_gaincode_rev6 = 0x2086;
-	uint16 clip1lo_gaincode;
-	uint8 crsminG_th = 0x18;
-	uint8 crsminG_th_rev5 = 0x18;
-	uint8 crsminG_th_rev6 = 0x18;
-	uint8 crsminA_th = 0x1e;
-	uint8 crsminA_th_rev4 = 0x24;
-	uint8 crsminA_th_rev5 = 0x24;
-	uint8 crsminA_th_rev6 = 0x24;
-	uint8 crsmin_th;
-	uint8 crsminlG_th = 0x18;
-	uint8 crsminlG_th_rev5 = 0x18;
-	uint8 crsminlG_th_rev6 = 0x18;
-	uint8 crsminlA_th = 0x1e;
-	uint8 crsminlA_th_rev4 = 0x24;
-	uint8 crsminlA_th_rev5 = 0x24;
-	uint8 crsminlA_th_rev6 = 0x24;
-	uint8 crsminl_th = 0;
-	uint8 crsminuG_th = 0x18;
-	uint8 crsminuG_th_rev5 = 0x18;
-	uint8 crsminuG_th_rev6 = 0x18;
-	uint8 crsminuA_th = 0x1e;
-	uint8 crsminuA_th_rev4 = 0x24;
-	uint8 crsminuA_th_rev5 = 0x24;
-	uint8 crsminuA_th_rev6 = 0x24;
-	uint8 crsminuA_th_rev6_224B0 = 0x2d;
-	uint8 crsminu_th;
-	uint16 nbclipG_th = 0x20d;
-	uint16 nbclipG_th_rev4 = 0x1a1;
-	uint16 nbclipG_th_rev5 = 0x1d0;
-	uint16 nbclipG_th_rev6 = 0x1d0;
-	uint16 nbclipA_th = 0x1a1;
-	uint16 nbclipA_th_rev4 = 0x107;
-	uint16 nbclipA_th_rev5 = 0x0a9;
-	uint16 nbclipA_th_rev6 = 0x0f0;
-	uint16 nbclip_th = 0;
-	uint8 w1clipG_th = 5;
-	uint8 w1clipG_th_rev5 = 9;
-	uint8 w1clipG_th_rev6 = 5;
-	uint8 w1clipA_th = 25, w1clip_th;
-	uint8 rssi_gain_default = 0x50;
-	uint8 rssiG_gain_rev6_224B0 = 0x50;
-	uint8 rssiA_gain_rev5 = 0x90;
-	uint8 rssiA_gain_rev6 = 0x90;
-	uint8 rssi_gain;
-	uint16 regval[21];
-	uint8 triso;
+	u16 clip1loG_gaincode_rev6_224B0 = 0x1074;
+	u16 clip1loA_gaincode = 0x00cc;
+	u16 clip1loA_gaincode_rev4 = 0x0086;
+	u16 clip1loA_gaincode_rev5 = 0x2086;
+	u16 clip1loA_gaincode_rev6 = 0x2086;
+	u16 clip1lo_gaincode;
+	u8 crsminG_th = 0x18;
+	u8 crsminG_th_rev5 = 0x18;
+	u8 crsminG_th_rev6 = 0x18;
+	u8 crsminA_th = 0x1e;
+	u8 crsminA_th_rev4 = 0x24;
+	u8 crsminA_th_rev5 = 0x24;
+	u8 crsminA_th_rev6 = 0x24;
+	u8 crsmin_th;
+	u8 crsminlG_th = 0x18;
+	u8 crsminlG_th_rev5 = 0x18;
+	u8 crsminlG_th_rev6 = 0x18;
+	u8 crsminlA_th = 0x1e;
+	u8 crsminlA_th_rev4 = 0x24;
+	u8 crsminlA_th_rev5 = 0x24;
+	u8 crsminlA_th_rev6 = 0x24;
+	u8 crsminl_th = 0;
+	u8 crsminuG_th = 0x18;
+	u8 crsminuG_th_rev5 = 0x18;
+	u8 crsminuG_th_rev6 = 0x18;
+	u8 crsminuA_th = 0x1e;
+	u8 crsminuA_th_rev4 = 0x24;
+	u8 crsminuA_th_rev5 = 0x24;
+	u8 crsminuA_th_rev6 = 0x24;
+	u8 crsminuA_th_rev6_224B0 = 0x2d;
+	u8 crsminu_th;
+	u16 nbclipG_th = 0x20d;
+	u16 nbclipG_th_rev4 = 0x1a1;
+	u16 nbclipG_th_rev5 = 0x1d0;
+	u16 nbclipG_th_rev6 = 0x1d0;
+	u16 nbclipA_th = 0x1a1;
+	u16 nbclipA_th_rev4 = 0x107;
+	u16 nbclipA_th_rev5 = 0x0a9;
+	u16 nbclipA_th_rev6 = 0x0f0;
+	u16 nbclip_th = 0;
+	u8 w1clipG_th = 5;
+	u8 w1clipG_th_rev5 = 9;
+	u8 w1clipG_th_rev6 = 5;
+	u8 w1clipA_th = 25, w1clip_th;
+	u8 rssi_gain_default = 0x50;
+	u8 rssiG_gain_rev6_224B0 = 0x50;
+	u8 rssiA_gain_rev5 = 0x90;
+	u8 rssiA_gain_rev6 = 0x90;
+	u8 rssi_gain;
+	u16 regval[21];
+	u8 triso;
 
 	triso = (CHSPEC_IS5G(pi->radio_chanspec)) ? pi->srom_fem5g.triso :
 	    pi->srom_fem2g.triso;
@@ -16936,7 +16944,7 @@ static void wlc_phy_workarounds_nphy_gainctrl(phy_info_t * pi)
 			wlc_phy_table_write_nphy(pi, 1, 21, 32, 16, regval);
 
 			for (ctr = 0; ctr < 21; ctr++) {
-				regval[ctr] = (uint16) ctr;
+				regval[ctr] = (u16) ctr;
 			}
 			wlc_phy_table_write_nphy(pi, 2, 21, 32, 16, regval);
 			wlc_phy_table_write_nphy(pi, 3, 21, 32, 16, regval);
@@ -16957,13 +16965,13 @@ static void wlc_phy_workarounds_nphy_gainctrl(phy_info_t * pi)
 	}
 }
 
-static void wlc_phy_workarounds_nphy_gainctrl_2057_rev5(phy_info_t * pi)
+static void wlc_phy_workarounds_nphy_gainctrl_2057_rev5(phy_info_t *pi)
 {
-	int8 lna1_gain_db[] = { 8, 13, 17, 22 };
-	int8 lna2_gain_db[] = { -2, 7, 11, 15 };
-	int8 tia_gain_db[] = { -4, -1, 2, 5, 5, 5, 5, 5, 5, 5 };
-	int8 tia_gainbits[] =
-	    { 0x0, 0x01, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 };
+	s8 lna1_gain_db[] = { 8, 13, 17, 22 };
+	s8 lna2_gain_db[] = { -2, 7, 11, 15 };
+	s8 tia_gain_db[] = { -4, -1, 2, 5, 5, 5, 5, 5, 5, 5 };
+	s8 tia_gainbits[] = {
+		0x0, 0x01, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 };
 
 	mod_phy_reg(pi, 0x1c, (0x1 << 13), (1 << 13));
 	mod_phy_reg(pi, 0x32, (0x1 << 13), (1 << 13));
@@ -17012,32 +17020,32 @@ static void wlc_phy_workarounds_nphy_gainctrl_2057_rev5(phy_info_t * pi)
 	}
 }
 
-static void wlc_phy_workarounds_nphy_gainctrl_2057_rev6(phy_info_t * pi)
+static void wlc_phy_workarounds_nphy_gainctrl_2057_rev6(phy_info_t *pi)
 {
-	uint16 currband;
-	int8 lna1G_gain_db_rev7[] = { 9, 14, 19, 24 };
-	int8 *lna1_gain_db = NULL;
-	int8 *lna1_gain_db_2 = NULL;
-	int8 *lna2_gain_db = NULL;
-	int8 tiaA_gain_db_rev7[] = { -9, -6, -3, 0, 3, 3, 3, 3, 3, 3 };
-	int8 *tia_gain_db;
-	int8 tiaA_gainbits_rev7[] = { 0, 1, 2, 3, 4, 4, 4, 4, 4, 4 };
-	int8 *tia_gainbits;
-	uint16 rfseqA_init_gain_rev7[] = { 0x624f, 0x624f };
-	uint16 *rfseq_init_gain;
-	uint16 init_gaincode;
-	uint16 clip1hi_gaincode;
-	uint16 clip1md_gaincode = 0;
-	uint16 clip1md_gaincode_B;
-	uint16 clip1lo_gaincode;
-	uint16 clip1lo_gaincode_B;
-	uint8 crsminl_th = 0;
-	uint8 crsminu_th;
-	uint16 nbclip_th = 0;
-	uint8 w1clip_th;
-	uint16 freq;
-	int8 nvar_baseline_offset0 = 0, nvar_baseline_offset1 = 0;
-	uint8 chg_nbclip_th = 0;
+	u16 currband;
+	s8 lna1G_gain_db_rev7[] = { 9, 14, 19, 24 };
+	s8 *lna1_gain_db = NULL;
+	s8 *lna1_gain_db_2 = NULL;
+	s8 *lna2_gain_db = NULL;
+	s8 tiaA_gain_db_rev7[] = { -9, -6, -3, 0, 3, 3, 3, 3, 3, 3 };
+	s8 *tia_gain_db;
+	s8 tiaA_gainbits_rev7[] = { 0, 1, 2, 3, 4, 4, 4, 4, 4, 4 };
+	s8 *tia_gainbits;
+	u16 rfseqA_init_gain_rev7[] = { 0x624f, 0x624f };
+	u16 *rfseq_init_gain;
+	u16 init_gaincode;
+	u16 clip1hi_gaincode;
+	u16 clip1md_gaincode = 0;
+	u16 clip1md_gaincode_B;
+	u16 clip1lo_gaincode;
+	u16 clip1lo_gaincode_B;
+	u8 crsminl_th = 0;
+	u8 crsminu_th;
+	u16 nbclip_th = 0;
+	u8 w1clip_th;
+	u16 freq;
+	s8 nvar_baseline_offset0 = 0, nvar_baseline_offset1 = 0;
+	u8 chg_nbclip_th = 0;
 
 	mod_phy_reg(pi, 0x1c, (0x1 << 13), (1 << 13));
 	mod_phy_reg(pi, 0x32, (0x1 << 13), (1 << 13));
@@ -17085,10 +17093,10 @@ static void wlc_phy_workarounds_nphy_gainctrl_2057_rev6(phy_info_t * pi)
 
 			if ((freq <= 5080) || (freq == 5825)) {
 
-				int8 lna1A_gain_db_rev7[] = { 11, 16, 20, 24 };
-				int8 lna1A_gain_db_2_rev7[] =
-				    { 11, 17, 22, 25 };
-				int8 lna2A_gain_db_rev7[] = { -1, 6, 10, 14 };
+				s8 lna1A_gain_db_rev7[] = { 11, 16, 20, 24 };
+				s8 lna1A_gain_db_2_rev7[] = {
+					11, 17, 22, 25 };
+				s8 lna2A_gain_db_rev7[] = { -1, 6, 10, 14 };
 
 				crsminu_th = 0x3e;
 				lna1_gain_db = lna1A_gain_db_rev7;
@@ -17096,10 +17104,10 @@ static void wlc_phy_workarounds_nphy_gainctrl_2057_rev6(phy_info_t * pi)
 				lna2_gain_db = lna2A_gain_db_rev7;
 			} else if ((freq >= 5500) && (freq <= 5700)) {
 
-				int8 lna1A_gain_db_rev7[] = { 11, 17, 21, 25 };
-				int8 lna1A_gain_db_2_rev7[] =
-				    { 12, 18, 22, 26 };
-				int8 lna2A_gain_db_rev7[] = { 1, 8, 12, 16 };
+				s8 lna1A_gain_db_rev7[] = { 11, 17, 21, 25 };
+				s8 lna1A_gain_db_2_rev7[] = {
+					12, 18, 22, 26 };
+				s8 lna2A_gain_db_rev7[] = { 1, 8, 12, 16 };
 
 				crsminu_th = 0x45;
 				clip1md_gaincode_B = 0x14;
@@ -17110,10 +17118,10 @@ static void wlc_phy_workarounds_nphy_gainctrl_2057_rev6(phy_info_t * pi)
 				lna2_gain_db = lna2A_gain_db_rev7;
 			} else {
 
-				int8 lna1A_gain_db_rev7[] = { 12, 18, 22, 26 };
-				int8 lna1A_gain_db_2_rev7[] =
-				    { 12, 18, 22, 26 };
-				int8 lna2A_gain_db_rev7[] = { -1, 6, 10, 14 };
+				s8 lna1A_gain_db_rev7[] = { 12, 18, 22, 26 };
+				s8 lna1A_gain_db_2_rev7[] = {
+					12, 18, 22, 26 };
+				s8 lna2A_gain_db_rev7[] = { -1, 6, 10, 14 };
 
 				crsminu_th = 0x41;
 				lna1_gain_db = lna1A_gain_db_rev7;
@@ -17218,17 +17226,17 @@ static void wlc_phy_workarounds_nphy_gainctrl_2057_rev6(phy_info_t * pi)
 
 }
 
-static void wlc_phy_adjust_lnagaintbl_nphy(phy_info_t * pi)
+static void wlc_phy_adjust_lnagaintbl_nphy(phy_info_t *pi)
 {
 	uint core;
 	int ctr;
-	int16 gain_delta[2];
-	uint8 curr_channel;
-	uint16 minmax_gain[2];
-	uint16 regval[4];
+	s16 gain_delta[2];
+	u8 curr_channel;
+	u16 minmax_gain[2];
+	u16 regval[4];
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	if (pi->nphy_gain_boost) {
 		if ((CHSPEC_IS2G(pi->radio_chanspec))) {
@@ -17239,12 +17247,12 @@ static void wlc_phy_adjust_lnagaintbl_nphy(phy_info_t * pi)
 
 			curr_channel = CHSPEC_CHANNEL(pi->radio_chanspec);
 			gain_delta[0] =
-			    (int16)
+			    (s16)
 			    PHY_HW_ROUND(((nphy_lnagain_est0[0] *
 					   curr_channel) +
 					  nphy_lnagain_est0[1]), 13);
 			gain_delta[1] =
-			    (int16)
+			    (s16)
 			    PHY_HW_ROUND(((nphy_lnagain_est1[0] *
 					   curr_channel) +
 					  nphy_lnagain_est1[1]), 13);
@@ -17271,17 +17279,17 @@ static void wlc_phy_adjust_lnagaintbl_nphy(phy_info_t * pi)
 		wlc_phy_table_write_nphy(pi, core, 4, 8, 16, regval);
 
 		minmax_gain[core] =
-		    (uint16) (nphy_def_lnagains[2] + gain_delta[core] + 4);
+		    (u16) (nphy_def_lnagains[2] + gain_delta[core] + 4);
 	}
 
 	mod_phy_reg(pi, 0x1e, (0xff << 0), (minmax_gain[0] << 0));
 	mod_phy_reg(pi, 0x34, (0xff << 0), (minmax_gain[1] << 0));
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
-void wlc_phy_switch_radio_nphy(phy_info_t * pi, bool on)
+void wlc_phy_switch_radio_nphy(phy_info_t *pi, bool on)
 {
 	if (on) {
 		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -17306,7 +17314,7 @@ void wlc_phy_switch_radio_nphy(phy_info_t * pi, bool on)
 			wlc_phy_radio_postinit_2055(pi);
 		}
 
-		pi->radio_is_on = TRUE;
+		pi->radio_is_on = true;
 
 	} else {
 
@@ -17353,18 +17361,18 @@ void wlc_phy_switch_radio_nphy(phy_info_t * pi, bool on)
 					RADIO_2056_TX_MIXG_BOOST_TUNE |
 					RADIO_2056_TX1, 0);
 
-			pi->radio_is_on = FALSE;
+			pi->radio_is_on = false;
 		}
 
 		if (NREV_GE(pi->pubpi.phy_rev, 8)) {
 			and_phy_reg(pi, 0x78, ~RFCC_CHIP0_PU);
-			pi->radio_is_on = FALSE;
+			pi->radio_is_on = false;
 		}
 
 	}
 }
 
-static void wlc_phy_radio_preinit_2055(phy_info_t * pi)
+static void wlc_phy_radio_preinit_2055(phy_info_t *pi)
 {
 
 	and_phy_reg(pi, 0x78, ~RFCC_POR_FORCE);
@@ -17373,12 +17381,12 @@ static void wlc_phy_radio_preinit_2055(phy_info_t * pi)
 	or_phy_reg(pi, 0x78, RFCC_POR_FORCE);
 }
 
-static void wlc_phy_radio_init_2055(phy_info_t * pi)
+static void wlc_phy_radio_init_2055(phy_info_t *pi)
 {
 	wlc_phy_init_radio_regs(pi, regs_2055, RADIO_DEFAULT_CORE);
 }
 
-static void wlc_phy_radio_postinit_2055(phy_info_t * pi)
+static void wlc_phy_radio_postinit_2055(phy_info_t *pi)
 {
 
 	and_radio_reg(pi, RADIO_2055_MASTER_CNTRL1,
@@ -17401,7 +17409,7 @@ static void wlc_phy_radio_postinit_2055(phy_info_t * pi)
 
 	or_radio_reg(pi, RADIO_2055_CAL_MISC, RADIO_2055_RRCAL_RST_N);
 
-	OSL_DELAY(1000);
+	udelay(1000);
 
 	or_radio_reg(pi, RADIO_2055_CAL_MISC, RADIO_2055_RRCAL_START);
 
@@ -17438,10 +17446,10 @@ static void wlc_phy_radio_postinit_2055(phy_info_t * pi)
 			     RADIO_2055_GAINBST_DISABLE);
 	}
 
-	OSL_DELAY(2);
+	udelay(2);
 }
 
-static void wlc_phy_radio_preinit_205x(phy_info_t * pi)
+static void wlc_phy_radio_preinit_205x(phy_info_t *pi)
 {
 
 	and_phy_reg(pi, 0x78, ~RFCC_CHIP0_PU);
@@ -17452,7 +17460,7 @@ static void wlc_phy_radio_preinit_205x(phy_info_t * pi)
 
 }
 
-static void wlc_phy_radio_init_2056(phy_info_t * pi)
+static void wlc_phy_radio_init_2056(phy_info_t *pi)
 {
 	radio_regs_t *regs_SYN_2056_ptr = NULL;
 	radio_regs_t *regs_TX_2056_ptr = NULL;
@@ -17505,24 +17513,24 @@ static void wlc_phy_radio_init_2056(phy_info_t * pi)
 		}
 	}
 
-	wlc_phy_init_radio_regs(pi, regs_SYN_2056_ptr, (uint16) RADIO_2056_SYN);
+	wlc_phy_init_radio_regs(pi, regs_SYN_2056_ptr, (u16) RADIO_2056_SYN);
 
-	wlc_phy_init_radio_regs(pi, regs_TX_2056_ptr, (uint16) RADIO_2056_TX0);
+	wlc_phy_init_radio_regs(pi, regs_TX_2056_ptr, (u16) RADIO_2056_TX0);
 
-	wlc_phy_init_radio_regs(pi, regs_TX_2056_ptr, (uint16) RADIO_2056_TX1);
+	wlc_phy_init_radio_regs(pi, regs_TX_2056_ptr, (u16) RADIO_2056_TX1);
 
-	wlc_phy_init_radio_regs(pi, regs_RX_2056_ptr, (uint16) RADIO_2056_RX0);
+	wlc_phy_init_radio_regs(pi, regs_RX_2056_ptr, (u16) RADIO_2056_RX0);
 
-	wlc_phy_init_radio_regs(pi, regs_RX_2056_ptr, (uint16) RADIO_2056_RX1);
+	wlc_phy_init_radio_regs(pi, regs_RX_2056_ptr, (u16) RADIO_2056_RX1);
 }
 
-static void wlc_phy_radio_postinit_2056(phy_info_t * pi)
+static void wlc_phy_radio_postinit_2056(phy_info_t *pi)
 {
 	mod_radio_reg(pi, RADIO_2056_SYN_COM_CTRL, 0xb, 0xb);
 
 	mod_radio_reg(pi, RADIO_2056_SYN_COM_PU, 0x2, 0x2);
 	mod_radio_reg(pi, RADIO_2056_SYN_COM_RESET, 0x2, 0x2);
-	OSL_DELAY(1000);
+	udelay(1000);
 	mod_radio_reg(pi, RADIO_2056_SYN_COM_RESET, 0x2, 0x0);
 
 	if ((pi->sh->boardflags2 & BFL2_LEGACY)
@@ -17541,7 +17549,7 @@ static void wlc_phy_radio_postinit_2056(phy_info_t * pi)
 	}
 }
 
-static void wlc_phy_radio_init_2057(phy_info_t * pi)
+static void wlc_phy_radio_init_2057(phy_info_t *pi)
 {
 	radio_20xx_regs_t *regs_2057_ptr = NULL;
 
@@ -17586,7 +17594,7 @@ static void wlc_phy_radio_init_2057(phy_info_t * pi)
 	wlc_phy_init_radio_regs_allbands(pi, regs_2057_ptr);
 }
 
-static void wlc_phy_radio_postinit_2057(phy_info_t * pi)
+static void wlc_phy_radio_postinit_2057(phy_info_t *pi)
 {
 
 	mod_radio_reg(pi, RADIO_2057_XTALPUOVR_PINCTRL, 0x1, 0x1);
@@ -17598,7 +17606,7 @@ static void wlc_phy_radio_postinit_2057(phy_info_t * pi)
 
 	mod_radio_reg(pi, RADIO_2057_RFPLL_MISC_CAL_RESETN, 0x78, 0x78);
 	mod_radio_reg(pi, RADIO_2057_XTAL_CONFIG2, 0x80, 0x80);
-	OSL_DELAY(2000);
+	mdelay(2);
 	mod_radio_reg(pi, RADIO_2057_RFPLL_MISC_CAL_RESETN, 0x78, 0x0);
 	mod_radio_reg(pi, RADIO_2057_XTAL_CONFIG2, 0x80, 0x0);
 
@@ -17611,17 +17619,17 @@ static void wlc_phy_radio_postinit_2057(phy_info_t * pi)
 }
 
 static bool
-wlc_phy_chan2freq_nphy(phy_info_t * pi, uint channel, int *f,
-		       chan_info_nphy_radio2057_t ** t0,
-		       chan_info_nphy_radio205x_t ** t1,
-		       chan_info_nphy_radio2057_rev5_t ** t2,
-		       chan_info_nphy_2055_t ** t3)
+wlc_phy_chan2freq_nphy(phy_info_t *pi, uint channel, int *f,
+		       chan_info_nphy_radio2057_t **t0,
+		       chan_info_nphy_radio205x_t **t1,
+		       chan_info_nphy_radio2057_rev5_t **t2,
+		       chan_info_nphy_2055_t **t3)
 {
 	uint i;
 	chan_info_nphy_radio2057_t *chan_info_tbl_p_0 = NULL;
 	chan_info_nphy_radio205x_t *chan_info_tbl_p_1 = NULL;
 	chan_info_nphy_radio2057_rev5_t *chan_info_tbl_p_2 = NULL;
-	uint32 tbl_len = 0;
+	u32 tbl_len = 0;
 
 	int freq = 0;
 
@@ -17630,7 +17638,7 @@ wlc_phy_chan2freq_nphy(phy_info_t * pi, uint channel, int *f,
 		if (NREV_IS(pi->pubpi.phy_rev, 7)) {
 
 			chan_info_tbl_p_0 = chan_info_nphyrev7_2057_rev4;
-			tbl_len = ARRAYSIZE(chan_info_nphyrev7_2057_rev4);
+			tbl_len = ARRAY_SIZE(chan_info_nphyrev7_2057_rev4);
 
 		} else if (NREV_IS(pi->pubpi.phy_rev, 8)
 			   || NREV_IS(pi->pubpi.phy_rev, 9)) {
@@ -17643,7 +17651,7 @@ wlc_phy_chan2freq_nphy(phy_info_t * pi, uint channel, int *f,
 					chan_info_tbl_p_2 =
 					    chan_info_nphyrev8_2057_rev5;
 					tbl_len =
-					    ARRAYSIZE
+					    ARRAY_SIZE
 					    (chan_info_nphyrev8_2057_rev5);
 
 				} else if (pi->pubpi.radiover == 0x1) {
@@ -17651,7 +17659,7 @@ wlc_phy_chan2freq_nphy(phy_info_t * pi, uint channel, int *f,
 					chan_info_tbl_p_2 =
 					    chan_info_nphyrev9_2057_rev5v1;
 					tbl_len =
-					    ARRAYSIZE
+					    ARRAY_SIZE
 					    (chan_info_nphyrev9_2057_rev5v1);
 
 				}
@@ -17661,14 +17669,14 @@ wlc_phy_chan2freq_nphy(phy_info_t * pi, uint channel, int *f,
 				chan_info_tbl_p_0 =
 				    chan_info_nphyrev8_2057_rev7;
 				tbl_len =
-				    ARRAYSIZE(chan_info_nphyrev8_2057_rev7);
+				    ARRAY_SIZE(chan_info_nphyrev8_2057_rev7);
 				break;
 
 			case 8:
 				chan_info_tbl_p_0 =
 				    chan_info_nphyrev8_2057_rev8;
 				tbl_len =
-				    ARRAYSIZE(chan_info_nphyrev8_2057_rev8);
+				    ARRAY_SIZE(chan_info_nphyrev8_2057_rev8);
 				break;
 
 			default:
@@ -17680,7 +17688,7 @@ wlc_phy_chan2freq_nphy(phy_info_t * pi, uint channel, int *f,
 		} else if (NREV_IS(pi->pubpi.phy_rev, 16)) {
 
 			chan_info_tbl_p_0 = chan_info_nphyrev8_2057_rev8;
-			tbl_len = ARRAYSIZE(chan_info_nphyrev8_2057_rev8);
+			tbl_len = ARRAY_SIZE(chan_info_nphyrev8_2057_rev8);
 		} else {
 			goto fail;
 		}
@@ -17712,34 +17720,34 @@ wlc_phy_chan2freq_nphy(phy_info_t * pi, uint channel, int *f,
 	} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		if (NREV_IS(pi->pubpi.phy_rev, 3)) {
 			chan_info_tbl_p_1 = chan_info_nphyrev3_2056;
-			tbl_len = ARRAYSIZE(chan_info_nphyrev3_2056);
+			tbl_len = ARRAY_SIZE(chan_info_nphyrev3_2056);
 		} else if (NREV_IS(pi->pubpi.phy_rev, 4)) {
 			chan_info_tbl_p_1 = chan_info_nphyrev4_2056_A1;
-			tbl_len = ARRAYSIZE(chan_info_nphyrev4_2056_A1);
+			tbl_len = ARRAY_SIZE(chan_info_nphyrev4_2056_A1);
 		} else if (NREV_IS(pi->pubpi.phy_rev, 5)
 			   || NREV_IS(pi->pubpi.phy_rev, 6)) {
 			switch (pi->pubpi.radiorev) {
 			case 5:
 				chan_info_tbl_p_1 = chan_info_nphyrev5_2056v5;
-				tbl_len = ARRAYSIZE(chan_info_nphyrev5_2056v5);
+				tbl_len = ARRAY_SIZE(chan_info_nphyrev5_2056v5);
 				break;
 			case 6:
 				chan_info_tbl_p_1 = chan_info_nphyrev6_2056v6;
-				tbl_len = ARRAYSIZE(chan_info_nphyrev6_2056v6);
+				tbl_len = ARRAY_SIZE(chan_info_nphyrev6_2056v6);
 				break;
 			case 7:
 			case 9:
 				chan_info_tbl_p_1 = chan_info_nphyrev5n6_2056v7;
 				tbl_len =
-				    ARRAYSIZE(chan_info_nphyrev5n6_2056v7);
+				    ARRAY_SIZE(chan_info_nphyrev5n6_2056v7);
 				break;
 			case 8:
 				chan_info_tbl_p_1 = chan_info_nphyrev6_2056v8;
-				tbl_len = ARRAYSIZE(chan_info_nphyrev6_2056v8);
+				tbl_len = ARRAY_SIZE(chan_info_nphyrev6_2056v8);
 				break;
 			case 11:
 				chan_info_tbl_p_1 = chan_info_nphyrev6_2056v11;
-				tbl_len = ARRAYSIZE(chan_info_nphyrev6_2056v11);
+				tbl_len = ARRAY_SIZE(chan_info_nphyrev6_2056v11);
 				break;
 			default:
 				if (NORADIO_ENAB(pi->pubpi)) {
@@ -17762,12 +17770,12 @@ wlc_phy_chan2freq_nphy(phy_info_t * pi, uint channel, int *f,
 		freq = chan_info_tbl_p_1[i].freq;
 
 	} else {
-		for (i = 0; i < ARRAYSIZE(chan_info_nphy_2055); i++)
+		for (i = 0; i < ARRAY_SIZE(chan_info_nphy_2055); i++)
 			if (chan_info_nphy_2055[i].chan == channel)
 				break;
 
-		if (i >= ARRAYSIZE(chan_info_nphy_2055)) {
-			ASSERT(i < ARRAYSIZE(chan_info_nphy_2055));
+		if (i >= ARRAY_SIZE(chan_info_nphy_2055)) {
+			ASSERT(i < ARRAY_SIZE(chan_info_nphy_2055));
 			goto fail;
 		}
 		*t3 = &chan_info_nphy_2055[i];
@@ -17775,14 +17783,14 @@ wlc_phy_chan2freq_nphy(phy_info_t * pi, uint channel, int *f,
 	}
 
 	*f = freq;
-	return TRUE;
+	return true;
 
  fail:
 	*f = WL_CHAN_FREQ_RANGE_2G;
-	return FALSE;
+	return false;
 }
 
-uint8 wlc_phy_get_chan_freq_range_nphy(phy_info_t * pi, uint channel)
+u8 wlc_phy_get_chan_freq_range_nphy(phy_info_t *pi, uint channel)
 {
 	int freq;
 	chan_info_nphy_radio2057_t *t0 = NULL;
@@ -17811,7 +17819,7 @@ uint8 wlc_phy_get_chan_freq_range_nphy(phy_info_t * pi, uint channel)
 }
 
 static void
-wlc_phy_chanspec_radio2055_setup(phy_info_t * pi, chan_info_nphy_2055_t * ci)
+wlc_phy_chanspec_radio2055_setup(phy_info_t *pi, chan_info_nphy_2055_t *ci)
 {
 
 	write_radio_reg(pi, RADIO_2055_PLL_REF, ci->RF_pll_ref);
@@ -17860,7 +17868,7 @@ wlc_phy_chanspec_radio2055_setup(phy_info_t * pi, chan_info_nphy_2055_t * ci)
 	write_radio_reg(pi, RADIO_2055_CORE2_TX_MX_BGTRIM,
 			ci->RF_core2_tx_mx_bgtrim);
 
-	OSL_DELAY(50);
+	udelay(50);
 
 	write_radio_reg(pi, RADIO_2055_VCO_CAL10, 0x05);
 	write_radio_reg(pi, RADIO_2055_VCO_CAL10, 0x45);
@@ -17869,12 +17877,12 @@ wlc_phy_chanspec_radio2055_setup(phy_info_t * pi, chan_info_nphy_2055_t * ci)
 
 	write_radio_reg(pi, RADIO_2055_VCO_CAL10, 0x65);
 
-	OSL_DELAY(300);
+	udelay(300);
 }
 
 static void
-wlc_phy_chanspec_radio2056_setup(phy_info_t * pi,
-				 const chan_info_nphy_radio205x_t * ci)
+wlc_phy_chanspec_radio2056_setup(phy_info_t *pi,
+				 const chan_info_nphy_radio205x_t *ci)
 {
 	radio_regs_t *regs_SYN_2056_ptr = NULL;
 
@@ -17985,11 +17993,11 @@ wlc_phy_chanspec_radio2056_setup(phy_info_t * pi,
 	if (CHSPEC_IS2G(pi->radio_chanspec)) {
 		write_radio_reg(pi, RADIO_2056_SYN_PLL_CP2 |
 				RADIO_2056_SYN,
-				(uint16) regs_SYN_2056_ptr[0x49 - 2].init_g);
+				(u16) regs_SYN_2056_ptr[0x49 - 2].init_g);
 	} else {
 		write_radio_reg(pi, RADIO_2056_SYN_PLL_CP2 |
 				RADIO_2056_SYN,
-				(uint16) regs_SYN_2056_ptr[0x49 - 2].init_a);
+				(u16) regs_SYN_2056_ptr[0x49 - 2].init_a);
 	}
 
 	if (pi->sh->boardflags2 & BFL2_GPLL_WAR) {
@@ -18048,11 +18056,11 @@ wlc_phy_chanspec_radio2056_setup(phy_info_t * pi,
 	}
 
 	if (PHY_IPA(pi) && CHSPEC_IS2G(pi->radio_chanspec)) {
-		uint16 pag_boost_tune;
-		uint16 padg_boost_tune;
-		uint16 pgag_boost_tune;
-		uint16 mixg_boost_tune;
-		uint16 bias, cascbias;
+		u16 pag_boost_tune;
+		u16 padg_boost_tune;
+		u16 pgag_boost_tune;
+		u16 mixg_boost_tune;
+		u16 bias, cascbias;
 		uint core;
 
 		for (core = 0; core < pi->pubpi.phy_corenum; core++) {
@@ -18131,11 +18139,11 @@ wlc_phy_chanspec_radio2056_setup(phy_info_t * pi,
 
 	if (PHY_IPA(pi) && NREV_IS(pi->pubpi.phy_rev, 6)
 	    && CHSPEC_IS5G(pi->radio_chanspec)) {
-		uint16 paa_boost_tune;
-		uint16 pada_boost_tune;
-		uint16 pgaa_boost_tune;
-		uint16 mixa_boost_tune;
-		uint16 freq, pabias, cascbias;
+		u16 paa_boost_tune;
+		u16 pada_boost_tune;
+		u16 pgaa_boost_tune;
+		u16 mixa_boost_tune;
+		u16 freq, pabias, cascbias;
 		uint core;
 
 		freq = CHAN5G_FREQ(CHSPEC_CHANNEL(pi->radio_chanspec));
@@ -18209,12 +18217,12 @@ wlc_phy_chanspec_radio2056_setup(phy_info_t * pi,
 		}
 	}
 
-	OSL_DELAY(50);
+	udelay(50);
 
 	wlc_phy_radio205x_vcocal_nphy(pi);
 }
 
-void wlc_phy_radio205x_vcocal_nphy(phy_info_t * pi)
+void wlc_phy_radio205x_vcocal_nphy(phy_info_t *pi)
 {
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 		mod_radio_reg(pi, RADIO_2057_RFPLL_MISC_EN, 0x01, 0x0);
@@ -18230,14 +18238,14 @@ void wlc_phy_radio205x_vcocal_nphy(phy_info_t * pi)
 		write_radio_reg(pi, RADIO_2056_SYN_PLL_MAST3, 0x39);
 	}
 
-	OSL_DELAY(300);
+	udelay(300);
 }
 
 #define MAX_205x_RCAL_WAITLOOPS 10000
 
-static uint16 wlc_phy_radio205x_rcal(phy_info_t * pi)
+static u16 wlc_phy_radio205x_rcal(phy_info_t *pi)
 {
-	uint16 rcal_reg = 0;
+	u16 rcal_reg = 0;
 	int i;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -18246,7 +18254,7 @@ static uint16 wlc_phy_radio205x_rcal(phy_info_t * pi)
 
 			and_phy_reg(pi, 0x342, ~(0x1 << 1));
 
-			OSL_DELAY(10);
+			udelay(10);
 
 			mod_radio_reg(pi, RADIO_2057_IQTEST_SEL_PU, 0x1, 0x1);
 			mod_radio_reg(pi, RADIO_2057v7_IQTEST_SEL_PU2, 0x2,
@@ -18254,7 +18262,7 @@ static uint16 wlc_phy_radio205x_rcal(phy_info_t * pi)
 		}
 		mod_radio_reg(pi, RADIO_2057_RCAL_CONFIG, 0x1, 0x1);
 
-		OSL_DELAY(10);
+		udelay(10);
 
 		mod_radio_reg(pi, RADIO_2057_RCAL_CONFIG, 0x3, 0x3);
 
@@ -18263,7 +18271,7 @@ static uint16 wlc_phy_radio205x_rcal(phy_info_t * pi)
 			if (rcal_reg & 0x1) {
 				break;
 			}
-			OSL_DELAY(100);
+			udelay(100);
 		}
 
 		ASSERT(i < MAX_205x_RCAL_WAITLOOPS);
@@ -18289,18 +18297,18 @@ static uint16 wlc_phy_radio205x_rcal(phy_info_t * pi)
 		}
 
 	} else if (NREV_IS(pi->pubpi.phy_rev, 3)) {
-		uint16 savereg;
+		u16 savereg;
 
 		savereg =
 		    read_radio_reg(pi,
 				   RADIO_2056_SYN_PLL_MAST2 | RADIO_2056_SYN);
 		write_radio_reg(pi, RADIO_2056_SYN_PLL_MAST2 | RADIO_2056_SYN,
 				savereg | 0x7);
-		OSL_DELAY(10);
+		udelay(10);
 
 		write_radio_reg(pi, RADIO_2056_SYN_RCAL_MASTER | RADIO_2056_SYN,
 				0x1);
-		OSL_DELAY(10);
+		udelay(10);
 
 		write_radio_reg(pi, RADIO_2056_SYN_RCAL_MASTER | RADIO_2056_SYN,
 				0x9);
@@ -18312,7 +18320,7 @@ static uint16 wlc_phy_radio205x_rcal(phy_info_t * pi)
 			if (rcal_reg & 0x80) {
 				break;
 			}
-			OSL_DELAY(100);
+			udelay(100);
 		}
 
 		ASSERT(i < MAX_205x_RCAL_WAITLOOPS);
@@ -18331,19 +18339,19 @@ static uint16 wlc_phy_radio205x_rcal(phy_info_t * pi)
 		write_radio_reg(pi, RADIO_2056_SYN_PLL_MAST2 | RADIO_2056_SYN,
 				savereg);
 
-		return (rcal_reg & 0x1f);
+		return rcal_reg & 0x1f;
 	}
-	return (rcal_reg & 0x3e);
+	return rcal_reg & 0x3e;
 }
 
 static void
-wlc_phy_chanspec_radio2057_setup(phy_info_t * pi,
-				 const chan_info_nphy_radio2057_t * ci,
-				 const chan_info_nphy_radio2057_rev5_t * ci2)
+wlc_phy_chanspec_radio2057_setup(phy_info_t *pi,
+				 const chan_info_nphy_radio2057_t *ci,
+				 const chan_info_nphy_radio2057_rev5_t *ci2)
 {
 	int coreNum;
-	uint16 txmix2g_tune_boost_pu = 0;
-	uint16 pad2g_tune_pus = 0;
+	u16 txmix2g_tune_boost_pu = 0;
+	u16 pad2g_tune_pus = 0;
 
 	if (pi->pubpi.radiorev == 5) {
 
@@ -18527,14 +18535,14 @@ wlc_phy_chanspec_radio2057_setup(phy_info_t * pi,
 		}
 	}
 
-	OSL_DELAY(50);
+	udelay(50);
 
 	wlc_phy_radio205x_vcocal_nphy(pi);
 }
 
-static uint16 wlc_phy_radio2057_rccal(phy_info_t * pi)
+static u16 wlc_phy_radio2057_rccal(phy_info_t *pi)
 {
-	uint16 rccal_valid;
+	u16 rccal_valid;
 	int i;
 	bool chip43226_6362A0;
 
@@ -18559,7 +18567,7 @@ static uint16 wlc_phy_radio2057_rccal(phy_info_t * pi)
 		if (rccal_valid & 0x2) {
 			break;
 		}
-		OSL_DELAY(500);
+		udelay(500);
 	}
 
 	ASSERT(rccal_valid & 0x2);
@@ -18583,7 +18591,7 @@ static uint16 wlc_phy_radio2057_rccal(phy_info_t * pi)
 		if (rccal_valid & 0x2) {
 			break;
 		}
-		OSL_DELAY(500);
+		udelay(500);
 	}
 
 	ASSERT(rccal_valid & 0x2);
@@ -18608,18 +18616,18 @@ static uint16 wlc_phy_radio2057_rccal(phy_info_t * pi)
 		if (rccal_valid & 0x2) {
 			break;
 		}
-		OSL_DELAY(500);
+		udelay(500);
 	}
 
 	ASSERT(rccal_valid & 0x2);
 
 	write_radio_reg(pi, RADIO_2057_RCCAL_START_R1_Q1_P1, 0x15);
 
-	return (rccal_valid);
+	return rccal_valid;
 }
 
 static void
-wlc_phy_adjust_rx_analpfbw_nphy(phy_info_t * pi, uint16 reduction_factr)
+wlc_phy_adjust_rx_analpfbw_nphy(phy_info_t *pi, u16 reduction_factr)
 {
 	if (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LT(pi->pubpi.phy_rev, 7)) {
 		if ((CHSPEC_CHANNEL(pi->radio_chanspec) == 11) &&
@@ -18631,7 +18639,7 @@ wlc_phy_adjust_rx_analpfbw_nphy(phy_info_t * pi, uint16 reduction_factr)
 						((pi->nphy_rccal_value +
 						  reduction_factr) | 0x80));
 
-				pi->nphy_anarxlpf_adjusted = TRUE;
+				pi->nphy_anarxlpf_adjusted = true;
 			}
 		} else {
 			if (pi->nphy_anarxlpf_adjusted) {
@@ -18640,18 +18648,18 @@ wlc_phy_adjust_rx_analpfbw_nphy(phy_info_t * pi, uint16 reduction_factr)
 						 RADIO_2056_RX0),
 						(pi->nphy_rccal_value | 0x80));
 
-				pi->nphy_anarxlpf_adjusted = FALSE;
+				pi->nphy_anarxlpf_adjusted = false;
 			}
 		}
 	}
 }
 
 static void
-wlc_phy_adjust_min_noisevar_nphy(phy_info_t * pi, int ntones, int *tone_id_buf,
-				 uint32 * noise_var_buf)
+wlc_phy_adjust_min_noisevar_nphy(phy_info_t *pi, int ntones, int *tone_id_buf,
+				 u32 *noise_var_buf)
 {
 	int i;
-	uint32 offset;
+	u32 offset;
 	int tone_id;
 	int tbllen =
 	    CHSPEC_IS40(pi->
@@ -18671,7 +18679,7 @@ wlc_phy_adjust_min_noisevar_nphy(phy_info_t * pi, int ntones, int *tone_id_buf,
 		}
 
 		pi->nphy_saved_noisevars.bufcount = 0;
-		pi->nphy_noisevars_adjusted = FALSE;
+		pi->nphy_noisevars_adjusted = false;
 	}
 
 	if ((noise_var_buf != NULL) && (tone_id_buf != NULL)) {
@@ -18692,13 +18700,13 @@ wlc_phy_adjust_min_noisevar_nphy(phy_info_t * pi, int ntones, int *tone_id_buf,
 			pi->nphy_saved_noisevars.bufcount++;
 		}
 
-		pi->nphy_noisevars_adjusted = TRUE;
+		pi->nphy_noisevars_adjusted = true;
 	}
 }
 
-static void wlc_phy_adjust_crsminpwr_nphy(phy_info_t * pi, uint8 minpwr)
+static void wlc_phy_adjust_crsminpwr_nphy(phy_info_t *pi, u8 minpwr)
 {
-	uint16 regval;
+	u16 regval;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		if ((CHSPEC_CHANNEL(pi->radio_chanspec) == 11) &&
@@ -18707,22 +18715,22 @@ static void wlc_phy_adjust_crsminpwr_nphy(phy_info_t * pi, uint8 minpwr)
 				regval = read_phy_reg(pi, 0x27d);
 				pi->nphy_crsminpwr[0] = regval & 0xff;
 				regval &= 0xff00;
-				regval |= (uint16) minpwr;
+				regval |= (u16) minpwr;
 				write_phy_reg(pi, 0x27d, regval);
 
 				regval = read_phy_reg(pi, 0x280);
 				pi->nphy_crsminpwr[1] = regval & 0xff;
 				regval &= 0xff00;
-				regval |= (uint16) minpwr;
+				regval |= (u16) minpwr;
 				write_phy_reg(pi, 0x280, regval);
 
 				regval = read_phy_reg(pi, 0x283);
 				pi->nphy_crsminpwr[2] = regval & 0xff;
 				regval &= 0xff00;
-				regval |= (uint16) minpwr;
+				regval |= (u16) minpwr;
 				write_phy_reg(pi, 0x283, regval);
 
-				pi->nphy_crsminpwr_adjusted = TRUE;
+				pi->nphy_crsminpwr_adjusted = true;
 			}
 		} else {
 			if (pi->nphy_crsminpwr_adjusted) {
@@ -18741,15 +18749,15 @@ static void wlc_phy_adjust_crsminpwr_nphy(phy_info_t * pi, uint8 minpwr)
 				regval |= pi->nphy_crsminpwr[2];
 				write_phy_reg(pi, 0x283, regval);
 
-				pi->nphy_crsminpwr_adjusted = FALSE;
+				pi->nphy_crsminpwr_adjusted = false;
 			}
 		}
 	}
 }
 
-static void wlc_phy_txlpfbw_nphy(phy_info_t * pi)
+static void wlc_phy_txlpfbw_nphy(phy_info_t *pi)
 {
-	uint8 tx_lpf_bw = 0;
+	u8 tx_lpf_bw = 0;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LT(pi->pubpi.phy_rev, 7)) {
 		if (CHSPEC_IS40(pi->radio_chanspec)) {
@@ -18786,18 +18794,18 @@ static void wlc_phy_txlpfbw_nphy(phy_info_t * pi)
 	}
 }
 
-static void wlc_phy_spurwar_nphy(phy_info_t * pi)
+static void wlc_phy_spurwar_nphy(phy_info_t *pi)
 {
-	uint16 cur_channel = 0;
+	u16 cur_channel = 0;
 	int nphy_adj_tone_id_buf[] = { 57, 58 };
-	uint32 nphy_adj_noise_var_buf[] = { 0x3ff, 0x3ff };
-	bool isAdjustNoiseVar = FALSE;
+	u32 nphy_adj_noise_var_buf[] = { 0x3ff, 0x3ff };
+	bool isAdjustNoiseVar = false;
 	uint numTonesAdjust = 0;
-	uint32 tempval = 0;
+	u32 tempval = 0;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		if (pi->phyhang_avoid)
-			wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+			wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 		cur_channel = CHSPEC_CHANNEL(pi->radio_chanspec);
 
@@ -18834,59 +18842,59 @@ static void wlc_phy_spurwar_nphy(phy_info_t * pi)
 					nphy_adj_tone_id_buf[1] = 58;
 					nphy_adj_noise_var_buf[0] = 0x22f;
 					nphy_adj_noise_var_buf[1] = 0x25f;
-					isAdjustNoiseVar = TRUE;
+					isAdjustNoiseVar = true;
 					break;
 				case 4:
 					nphy_adj_tone_id_buf[0] = 41;
 					nphy_adj_tone_id_buf[1] = 42;
 					nphy_adj_noise_var_buf[0] = 0x22f;
 					nphy_adj_noise_var_buf[1] = 0x25f;
-					isAdjustNoiseVar = TRUE;
+					isAdjustNoiseVar = true;
 					break;
 				case 5:
 					nphy_adj_tone_id_buf[0] = 25;
 					nphy_adj_tone_id_buf[1] = 26;
 					nphy_adj_noise_var_buf[0] = 0x24f;
 					nphy_adj_noise_var_buf[1] = 0x25f;
-					isAdjustNoiseVar = TRUE;
+					isAdjustNoiseVar = true;
 					break;
 				case 6:
 					nphy_adj_tone_id_buf[0] = 9;
 					nphy_adj_tone_id_buf[1] = 10;
 					nphy_adj_noise_var_buf[0] = 0x22f;
 					nphy_adj_noise_var_buf[1] = 0x24f;
-					isAdjustNoiseVar = TRUE;
+					isAdjustNoiseVar = true;
 					break;
 				case 7:
 					nphy_adj_tone_id_buf[0] = 121;
 					nphy_adj_tone_id_buf[1] = 122;
 					nphy_adj_noise_var_buf[0] = 0x18f;
 					nphy_adj_noise_var_buf[1] = 0x24f;
-					isAdjustNoiseVar = TRUE;
+					isAdjustNoiseVar = true;
 					break;
 				case 8:
 					nphy_adj_tone_id_buf[0] = 105;
 					nphy_adj_tone_id_buf[1] = 106;
 					nphy_adj_noise_var_buf[0] = 0x22f;
 					nphy_adj_noise_var_buf[1] = 0x25f;
-					isAdjustNoiseVar = TRUE;
+					isAdjustNoiseVar = true;
 					break;
 				case 9:
 					nphy_adj_tone_id_buf[0] = 89;
 					nphy_adj_tone_id_buf[1] = 90;
 					nphy_adj_noise_var_buf[0] = 0x22f;
 					nphy_adj_noise_var_buf[1] = 0x24f;
-					isAdjustNoiseVar = TRUE;
+					isAdjustNoiseVar = true;
 					break;
 				case 10:
 					nphy_adj_tone_id_buf[0] = 73;
 					nphy_adj_tone_id_buf[1] = 74;
 					nphy_adj_noise_var_buf[0] = 0x22f;
 					nphy_adj_noise_var_buf[1] = 0x24f;
-					isAdjustNoiseVar = TRUE;
+					isAdjustNoiseVar = true;
 					break;
 				default:
-					isAdjustNoiseVar = FALSE;
+					isAdjustNoiseVar = false;
 					break;
 				}
 			}
@@ -18959,15 +18967,15 @@ static void wlc_phy_spurwar_nphy(phy_info_t * pi)
 		}
 
 		if (pi->phyhang_avoid)
-			wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+			wlc_phy_stay_in_carriersearch_nphy(pi, false);
 	}
 }
 
 static void
-wlc_phy_chanspec_nphy_setup(phy_info_t * pi, chanspec_t chanspec,
-			    const nphy_sfo_cfg_t * ci)
+wlc_phy_chanspec_nphy_setup(phy_info_t *pi, chanspec_t chanspec,
+			    const nphy_sfo_cfg_t *ci)
 {
-	uint16 val;
+	u16 val;
 
 	val = read_phy_reg(pi, 0x09) & NPHY_BandControl_currentBand;
 	if (CHSPEC_IS5G(chanspec) && !val) {
@@ -18991,7 +18999,7 @@ wlc_phy_chanspec_nphy_setup(phy_info_t * pi, chanspec_t chanspec,
 		      (val | MAC_PHY_FORCE_CLK));
 
 		and_phy_reg(pi, (NPHY_TO_BPHY_OFF + BPHY_BB_CONFIG),
-			    (uint16) (~(BBCFG_RESETCCA | BBCFG_RESETRX)));
+			    (u16) (~(BBCFG_RESETCCA | BBCFG_RESETRX)));
 
 		W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, val);
 	}
@@ -19029,7 +19037,7 @@ wlc_phy_chanspec_nphy_setup(phy_info_t * pi, chanspec_t chanspec,
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)
 	    && (pi->phy_spuravoid != SPURAVOID_DISABLE)) {
-		uint8 spuravoid = 0;
+		u8 spuravoid = 0;
 
 		val = CHSPEC_CHANNEL(chanspec);
 		if (!CHSPEC_IS40(pi->radio_chanspec)) {
@@ -19073,9 +19081,9 @@ wlc_phy_chanspec_nphy_setup(phy_info_t * pi, chanspec_t chanspec,
 		    (CHIPID(pi->sh->chip) == BCM47162_CHIP_ID)) {
 			si_pmu_spuravoid(pi->sh->sih, pi->sh->osh, spuravoid);
 		} else {
-			wlapi_bmac_core_phypll_ctl(pi->sh->physhim, FALSE);
+			wlapi_bmac_core_phypll_ctl(pi->sh->physhim, false);
 			si_pmu_spuravoid(pi->sh->sih, pi->sh->osh, spuravoid);
-			wlapi_bmac_core_phypll_ctl(pi->sh->physhim, TRUE);
+			wlapi_bmac_core_phypll_ctl(pi->sh->physhim, true);
 		}
 
 		if ((CHIPID(pi->sh->chip) == BCM43224_CHIP_ID) ||
@@ -19116,7 +19124,7 @@ wlc_phy_chanspec_nphy_setup(phy_info_t * pi, chanspec_t chanspec,
 	wlc_phy_spurwar_nphy(pi);
 }
 
-void wlc_phy_chanspec_set_nphy(phy_info_t * pi, chanspec_t chanspec)
+void wlc_phy_chanspec_set_nphy(phy_info_t *pi, chanspec_t chanspec)
 {
 	int freq;
 	chan_info_nphy_radio2057_t *t0 = NULL;
@@ -19203,14 +19211,14 @@ void wlc_phy_chanspec_set_nphy(phy_info_t * pi, chanspec_t chanspec)
 
 }
 
-static void wlc_phy_savecal_nphy(phy_info_t * pi)
+static void wlc_phy_savecal_nphy(phy_info_t *pi)
 {
 	void *tbl_ptr;
 	int coreNum;
-	uint16 *txcal_radio_regs = NULL;
+	u16 *txcal_radio_regs = NULL;
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	if (CHSPEC_IS2G(pi->radio_chanspec)) {
 
@@ -19349,16 +19357,16 @@ static void wlc_phy_savecal_nphy(phy_info_t * pi)
 	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_IQLOCAL, 8, 80, 16, tbl_ptr);
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
-static void wlc_phy_restorecal_nphy(phy_info_t * pi)
+static void wlc_phy_restorecal_nphy(phy_info_t *pi)
 {
-	uint16 *loft_comp;
-	uint16 txcal_coeffs_bphy[4];
-	uint16 *tbl_ptr;
+	u16 *loft_comp;
+	u16 txcal_coeffs_bphy[4];
+	u16 *tbl_ptr;
 	int coreNum;
-	uint16 *txcal_radio_regs = NULL;
+	u16 *txcal_radio_regs = NULL;
 
 	if (CHSPEC_IS2G(pi->radio_chanspec)) {
 		if (pi->nphy_iqcal_chanspec_2G == 0)
@@ -19551,19 +19559,19 @@ static void wlc_phy_restorecal_nphy(phy_info_t * pi)
 	}
 }
 
-void wlc_phy_antsel_init(wlc_phy_t * ppi, bool lut_init)
+void wlc_phy_antsel_init(wlc_phy_t *ppi, bool lut_init)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
-	uint16 mask = 0xfc00;
-	uint32 mc = 0;
+	u16 mask = 0xfc00;
+	u32 mc = 0;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7))
 		return;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
-		uint16 v0 = 0x211, v1 = 0x222, v2 = 0x144, v3 = 0x188;
+		u16 v0 = 0x211, v1 = 0x222, v2 = 0x144, v3 = 0x188;
 
-		if (lut_init == FALSE)
+		if (lut_init == false)
 			return;
 
 		if (pi->srom_fem2g.antswctrllut == 0) {
@@ -19615,15 +19623,15 @@ void wlc_phy_antsel_init(wlc_phy_t * ppi, bool lut_init)
 	}
 }
 
-uint16 wlc_phy_classifier_nphy(phy_info_t * pi, uint16 mask, uint16 val)
+u16 wlc_phy_classifier_nphy(phy_info_t *pi, u16 mask, u16 val)
 {
-	uint16 curr_ctl, new_ctl;
-	bool suspended = FALSE;
+	u16 curr_ctl, new_ctl;
+	bool suspended = false;
 
 	if (D11REV_IS(pi->sh->corerev, 16)) {
 		suspended =
 		    (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC) ?
-		    FALSE : TRUE;
+		    false : true;
 		if (!suspended)
 			wlapi_suspend_mac_and_wait(pi->sh->physhim);
 	}
@@ -19640,7 +19648,7 @@ uint16 wlc_phy_classifier_nphy(phy_info_t * pi, uint16 mask, uint16 val)
 	return new_ctl;
 }
 
-static void wlc_phy_clip_det_nphy(phy_info_t * pi, uint8 write, uint16 * vals)
+static void wlc_phy_clip_det_nphy(phy_info_t *pi, u8 write, u16 *vals)
 {
 
 	if (write == 0) {
@@ -19652,10 +19660,10 @@ static void wlc_phy_clip_det_nphy(phy_info_t * pi, uint8 write, uint16 * vals)
 	}
 }
 
-void wlc_phy_force_rfseq_nphy(phy_info_t * pi, uint8 cmd)
+void wlc_phy_force_rfseq_nphy(phy_info_t *pi, u8 cmd)
 {
-	uint16 trigger_mask, status_mask;
-	uint16 orig_RfseqCoreActv;
+	u16 trigger_mask, status_mask;
+	u16 orig_RfseqCoreActv;
 
 	switch (cmd) {
 	case NPHY_RFSEQ_RX2TX:
@@ -19698,20 +19706,20 @@ void wlc_phy_force_rfseq_nphy(phy_info_t * pi, uint8 cmd)
 }
 
 static void
-wlc_phy_set_rfseq_nphy(phy_info_t * pi, uint8 cmd, uint8 * events, uint8 * dlys,
-		       uint8 len)
+wlc_phy_set_rfseq_nphy(phy_info_t *pi, u8 cmd, u8 *events, u8 *dlys,
+		       u8 len)
 {
-	uint32 t1_offset, t2_offset;
-	uint8 ctr;
-	uint8 end_event =
+	u32 t1_offset, t2_offset;
+	u8 ctr;
+	u8 end_event =
 	    NREV_GE(pi->pubpi.phy_rev,
 		    3) ? NPHY_REV3_RFSEQ_CMD_END : NPHY_RFSEQ_CMD_END;
-	uint8 end_dly = 1;
+	u8 end_dly = 1;
 
 	ASSERT(len <= 16);
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	t1_offset = cmd << 4;
 	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, len, t1_offset, 8,
@@ -19728,13 +19736,13 @@ wlc_phy_set_rfseq_nphy(phy_info_t * pi, uint8 cmd, uint8 * events, uint8 * dlys,
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
-static uint16 wlc_phy_read_lpf_bw_ctl_nphy(phy_info_t * pi, uint16 offset)
+static u16 wlc_phy_read_lpf_bw_ctl_nphy(phy_info_t *pi, u16 offset)
 {
-	uint16 lpf_bw_ctl_val = 0;
-	uint16 rx2tx_lpf_rc_lut_offset = 0;
+	u16 lpf_bw_ctl_val = 0;
+	u16 rx2tx_lpf_rc_lut_offset = 0;
 
 	if (offset == 0) {
 		if (CHSPEC_IS40(pi->radio_chanspec)) {
@@ -19746,7 +19754,7 @@ static uint16 wlc_phy_read_lpf_bw_ctl_nphy(phy_info_t * pi, uint16 offset)
 		rx2tx_lpf_rc_lut_offset = offset;
 	}
 	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 1,
-				(uint32) rx2tx_lpf_rc_lut_offset, 16,
+				(u32) rx2tx_lpf_rc_lut_offset, 16,
 				&lpf_bw_ctl_val);
 
 	lpf_bw_ctl_val = lpf_bw_ctl_val & 0x7;
@@ -19755,12 +19763,12 @@ static uint16 wlc_phy_read_lpf_bw_ctl_nphy(phy_info_t * pi, uint16 offset)
 }
 
 static void
-wlc_phy_rfctrl_override_nphy_rev7(phy_info_t * pi, uint16 field, uint16 value,
-				  uint8 core_mask, uint8 off, uint8 override_id)
+wlc_phy_rfctrl_override_nphy_rev7(phy_info_t *pi, u16 field, u16 value,
+				  u8 core_mask, u8 off, u8 override_id)
 {
-	uint8 core_num;
-	uint16 addr = 0, en_addr = 0, val_addr = 0, en_mask = 0, val_mask = 0;
-	uint8 val_shift = 0;
+	u8 core_num;
+	u16 addr = 0, en_addr = 0, val_addr = 0, en_mask = 0, val_mask = 0;
+	u8 val_shift = 0;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 		en_mask = field;
@@ -20025,13 +20033,13 @@ wlc_phy_rfctrl_override_nphy_rev7(phy_info_t * pi, uint16 field, uint16 value,
 }
 
 static void
-wlc_phy_rfctrl_override_nphy(phy_info_t * pi, uint16 field, uint16 value,
-			     uint8 core_mask, uint8 off)
+wlc_phy_rfctrl_override_nphy(phy_info_t *pi, u16 field, u16 value,
+			     u8 core_mask, u8 off)
 {
-	uint8 core_num;
-	uint16 addr = 0, mask = 0, en_addr = 0, val_addr = 0, en_mask =
+	u8 core_num;
+	u16 addr = 0, mask = 0, en_addr = 0, val_addr = 0, en_mask =
 	    0, val_mask = 0;
-	uint8 shift = 0, val_shift = 0;
+	u8 shift = 0, val_shift = 0;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LT(pi->pubpi.phy_rev, 7)) {
 
@@ -20265,17 +20273,17 @@ wlc_phy_rfctrl_override_nphy(phy_info_t * pi, uint16 field, uint16 value,
 
 		or_phy_reg(pi, 0xec, (0x1 << 0));
 		or_phy_reg(pi, 0x78, (0x1 << 0));
-		OSL_DELAY(1);
+		udelay(1);
 		and_phy_reg(pi, 0xec, ~(0x1 << 0));
 	}
 }
 
 static void
-wlc_phy_rfctrl_override_1tomany_nphy(phy_info_t * pi, uint16 cmd, uint16 value,
-				     uint8 core_mask, uint8 off)
+wlc_phy_rfctrl_override_1tomany_nphy(phy_info_t *pi, u16 cmd, u16 value,
+				     u8 core_mask, u8 off)
 {
-	uint16 rfmxgain = 0, lpfgain = 0;
-	uint16 tgain = 0;
+	u16 rfmxgain = 0, lpfgain = 0;
+	u16 tgain = 0;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 
@@ -20357,10 +20365,10 @@ wlc_phy_rfctrl_override_1tomany_nphy(phy_info_t * pi, uint16 cmd, uint16 value,
 }
 
 static void
-wlc_phy_scale_offset_rssi_nphy(phy_info_t * pi, uint16 scale, int8 offset,
-			       uint8 coresel, uint8 rail, uint8 rssi_type)
+wlc_phy_scale_offset_rssi_nphy(phy_info_t *pi, u16 scale, s8 offset,
+			       u8 coresel, u8 rail, u8 rssi_type)
 {
-	uint16 valuetostuff;
+	u16 valuetostuff;
 
 	offset = (offset > NPHY_RSSICAL_MAXREAD) ?
 	    NPHY_RSSICAL_MAXREAD : offset;
@@ -20497,16 +20505,16 @@ wlc_phy_scale_offset_rssi_nphy(phy_info_t * pi, uint16 scale, int8 offset,
 	}
 }
 
-void wlc_phy_rssisel_nphy(phy_info_t * pi, uint8 core_code, uint8 rssi_type)
+void wlc_phy_rssisel_nphy(phy_info_t *pi, u8 core_code, u8 rssi_type)
 {
-	uint16 mask, val;
-	uint16 afectrlovr_rssi_val, rfctrlcmd_rxen_val, rfctrlcmd_coresel_val,
+	u16 mask, val;
+	u16 afectrlovr_rssi_val, rfctrlcmd_rxen_val, rfctrlcmd_coresel_val,
 	    startseq;
-	uint16 rfctrlovr_rssi_val, rfctrlovr_rxen_val, rfctrlovr_coresel_val,
+	u16 rfctrlovr_rssi_val, rfctrlovr_rxen_val, rfctrlovr_coresel_val,
 	    rfctrlovr_trigger_val;
-	uint16 afectrlovr_rssi_mask, rfctrlcmd_mask, rfctrlovr_mask;
-	uint16 rfctrlcmd_val, rfctrlovr_val;
-	uint8 core;
+	u16 afectrlovr_rssi_mask, rfctrlcmd_mask, rfctrlovr_mask;
+	u16 rfctrlcmd_val, rfctrlovr_val;
+	u8 core;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		if (core_code == RADIO_MIMO_CORESEL_OFF) {
@@ -20793,7 +20801,7 @@ void wlc_phy_rssisel_nphy(phy_info_t * pi, uint8 core_code, uint8 rssi_type)
 			mod_phy_reg(pi, 0xec, rfctrlovr_mask, rfctrlovr_val);
 
 			mod_phy_reg(pi, 0x78, (0x1 << 0), (startseq << 0));
-			OSL_DELAY(20);
+			udelay(20);
 
 			mod_phy_reg(pi, 0xec, (0x1 << 0), 0);
 		}
@@ -20801,26 +20809,26 @@ void wlc_phy_rssisel_nphy(phy_info_t * pi, uint8 core_code, uint8 rssi_type)
 }
 
 int
-wlc_phy_poll_rssi_nphy(phy_info_t * pi, uint8 rssi_type, int32 * rssi_buf,
-		       uint8 nsamps)
+wlc_phy_poll_rssi_nphy(phy_info_t *pi, u8 rssi_type, s32 *rssi_buf,
+		       u8 nsamps)
 {
-	int16 rssi0, rssi1;
-	uint16 afectrlCore1_save = 0;
-	uint16 afectrlCore2_save = 0;
-	uint16 afectrlOverride1_save = 0;
-	uint16 afectrlOverride2_save = 0;
-	uint16 rfctrlOverrideAux0_save = 0;
-	uint16 rfctrlOverrideAux1_save = 0;
-	uint16 rfctrlMiscReg1_save = 0;
-	uint16 rfctrlMiscReg2_save = 0;
-	uint16 rfctrlcmd_save = 0;
-	uint16 rfctrloverride_save = 0;
-	uint16 rfctrlrssiothers1_save = 0;
-	uint16 rfctrlrssiothers2_save = 0;
-	int8 tmp_buf[4];
-	uint8 ctr = 0, samp = 0;
-	int32 rssi_out_val;
-	uint16 gpiosel_orig;
+	s16 rssi0, rssi1;
+	u16 afectrlCore1_save = 0;
+	u16 afectrlCore2_save = 0;
+	u16 afectrlOverride1_save = 0;
+	u16 afectrlOverride2_save = 0;
+	u16 rfctrlOverrideAux0_save = 0;
+	u16 rfctrlOverrideAux1_save = 0;
+	u16 rfctrlMiscReg1_save = 0;
+	u16 rfctrlMiscReg2_save = 0;
+	u16 rfctrlcmd_save = 0;
+	u16 rfctrloverride_save = 0;
+	u16 rfctrlrssiothers1_save = 0;
+	u16 rfctrlrssiothers2_save = 0;
+	s8 tmp_buf[4];
+	u8 ctr = 0, samp = 0;
+	s32 rssi_out_val;
+	u16 gpiosel_orig;
 
 	afectrlCore1_save = read_phy_reg(pi, 0xa6);
 	afectrlCore2_save = read_phy_reg(pi, 0xa7);
@@ -20860,10 +20868,10 @@ wlc_phy_poll_rssi_nphy(phy_info_t * pi, uint8 rssi_type, int32 * rssi_buf,
 		}
 
 		ctr = 0;
-		tmp_buf[ctr++] = ((int8) ((rssi0 & 0x3f) << 2)) >> 2;
-		tmp_buf[ctr++] = ((int8) (((rssi0 >> 8) & 0x3f) << 2)) >> 2;
-		tmp_buf[ctr++] = ((int8) ((rssi1 & 0x3f) << 2)) >> 2;
-		tmp_buf[ctr++] = ((int8) (((rssi1 >> 8) & 0x3f) << 2)) >> 2;
+		tmp_buf[ctr++] = ((s8) ((rssi0 & 0x3f) << 2)) >> 2;
+		tmp_buf[ctr++] = ((s8) (((rssi0 >> 8) & 0x3f) << 2)) >> 2;
+		tmp_buf[ctr++] = ((s8) ((rssi1 & 0x3f) << 2)) >> 2;
+		tmp_buf[ctr++] = ((s8) (((rssi1 >> 8) & 0x3f) << 2)) >> 2;
 
 		for (ctr = 0; ctr < 4; ctr++) {
 			rssi_buf[ctr] += tmp_buf[ctr];
@@ -20897,35 +20905,35 @@ wlc_phy_poll_rssi_nphy(phy_info_t * pi, uint8 rssi_type, int32 * rssi_buf,
 		write_phy_reg(pi, 0x7d, rfctrlrssiothers2_save);
 	}
 
-	return (rssi_out_val);
+	return rssi_out_val;
 }
 
-int16 wlc_phy_tempsense_nphy(phy_info_t * pi)
+s16 wlc_phy_tempsense_nphy(phy_info_t *pi)
 {
-	uint16 core1_txrf_iqcal1_save, core1_txrf_iqcal2_save;
-	uint16 core2_txrf_iqcal1_save, core2_txrf_iqcal2_save;
-	uint16 pwrdet_rxtx_core1_save;
-	uint16 pwrdet_rxtx_core2_save;
-	uint16 afectrlCore1_save;
-	uint16 afectrlCore2_save;
-	uint16 afectrlOverride_save;
-	uint16 afectrlOverride2_save;
-	uint16 pd_pll_ts_save;
-	uint16 gpioSel_save;
-	int32 radio_temp[4];
-	int32 radio_temp2[4];
-	uint16 syn_tempprocsense_save;
-	int16 offset = 0;
+	u16 core1_txrf_iqcal1_save, core1_txrf_iqcal2_save;
+	u16 core2_txrf_iqcal1_save, core2_txrf_iqcal2_save;
+	u16 pwrdet_rxtx_core1_save;
+	u16 pwrdet_rxtx_core2_save;
+	u16 afectrlCore1_save;
+	u16 afectrlCore2_save;
+	u16 afectrlOverride_save;
+	u16 afectrlOverride2_save;
+	u16 pd_pll_ts_save;
+	u16 gpioSel_save;
+	s32 radio_temp[4];
+	s32 radio_temp2[4];
+	u16 syn_tempprocsense_save;
+	s16 offset = 0;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
-		uint16 auxADC_Vmid, auxADC_Av, auxADC_Vmid_save, auxADC_Av_save;
-		uint16 auxADC_rssi_ctrlL_save, auxADC_rssi_ctrlH_save;
-		uint16 auxADC_rssi_ctrlL, auxADC_rssi_ctrlH;
-		int32 auxADC_Vl;
-		uint16 RfctrlOverride5_save, RfctrlOverride6_save;
-		uint16 RfctrlMiscReg5_save, RfctrlMiscReg6_save;
-		uint16 RSSIMultCoef0QPowerDet_save;
-		uint16 tempsense_Rcal;
+		u16 auxADC_Vmid, auxADC_Av, auxADC_Vmid_save, auxADC_Av_save;
+		u16 auxADC_rssi_ctrlL_save, auxADC_rssi_ctrlH_save;
+		u16 auxADC_rssi_ctrlL, auxADC_rssi_ctrlH;
+		s32 auxADC_Vl;
+		u16 RfctrlOverride5_save, RfctrlOverride6_save;
+		u16 RfctrlMiscReg5_save, RfctrlMiscReg6_save;
+		u16 RSSIMultCoef0QPowerDet_save;
+		u16 tempsense_Rcal;
 
 		syn_tempprocsense_save =
 		    read_radio_reg(pi, RADIO_2057_TEMPSENSE_CONFIG);
@@ -20975,7 +20983,7 @@ int16 wlc_phy_tempsense_nphy(phy_info_t * pi)
 		mod_phy_reg(pi, 0xa7, (0x1 << 2), (0x1 << 2));
 		mod_phy_reg(pi, 0x8f, (0x1 << 2), (0x1 << 2));
 		mod_phy_reg(pi, 0xa5, (0x1 << 2), (0x1 << 2));
-		OSL_DELAY(5);
+		udelay(5);
 		mod_phy_reg(pi, 0xa6, (0x1 << 2), 0);
 		mod_phy_reg(pi, 0xa7, (0x1 << 2), 0);
 		mod_phy_reg(pi, 0xa6, (0x1 << 3), 0);
@@ -20994,13 +21002,13 @@ int16 wlc_phy_tempsense_nphy(phy_info_t * pi)
 		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x0E, 16,
 					 &auxADC_Av);
 
-		OSL_DELAY(3);
+		udelay(3);
 
 		wlc_phy_poll_rssi_nphy(pi, NPHY_RSSI_SEL_IQ, radio_temp, 1);
 		write_radio_reg(pi, RADIO_2057_TEMPSENSE_CONFIG,
 				tempsense_Rcal | 0x03);
 
-		OSL_DELAY(5);
+		udelay(5);
 		wlc_phy_poll_rssi_nphy(pi, NPHY_RSSI_SEL_IQ, radio_temp2, 1);
 
 		auxADC_Av = 0x7;
@@ -21023,13 +21031,13 @@ int16 wlc_phy_tempsense_nphy(phy_info_t * pi)
 		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x0E, 16,
 					 &auxADC_Av);
 
-		OSL_DELAY(3);
+		udelay(3);
 
 		wlc_phy_poll_rssi_nphy(pi, NPHY_RSSI_SEL_IQ, radio_temp2, 1);
 		write_radio_reg(pi, RADIO_2057_TEMPSENSE_CONFIG,
 				tempsense_Rcal | 0x01);
 
-		OSL_DELAY(5);
+		udelay(5);
 		wlc_phy_poll_rssi_nphy(pi, NPHY_RSSI_SEL_IQ, radio_temp, 1);
 
 		write_radio_reg(pi, RADIO_2057_TEMPSENSE_CONFIG,
@@ -21068,7 +21076,7 @@ int16 wlc_phy_tempsense_nphy(phy_info_t * pi)
 					 128) / 256;
 		}
 
-		offset = (int16) pi->phy_tempsense_offset;
+		offset = (s16) pi->phy_tempsense_offset;
 
 	} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		syn_tempprocsense_save =
@@ -21107,7 +21115,7 @@ int16 wlc_phy_tempsense_nphy(phy_info_t * pi)
 		write_phy_reg(pi, 0x8f, afectrlOverride_save);
 		write_phy_reg(pi, 0xa5, afectrlOverride2_save);
 
-		offset = (int16) pi->phy_tempsense_offset;
+		offset = (s16) pi->phy_tempsense_offset;
 	} else {
 
 		pwrdet_rxtx_core1_save =
@@ -21180,13 +21188,13 @@ int16 wlc_phy_tempsense_nphy(phy_info_t * pi)
 		write_phy_reg(pi, 0xa5, afectrlOverride_save);
 	}
 
-	return ((int16) radio_temp[0] + offset);
+	return (s16) radio_temp[0] + offset;
 }
 
 static void
-wlc_phy_set_rssi_2055_vcm(phy_info_t * pi, uint8 rssi_type, uint8 * vcm_buf)
+wlc_phy_set_rssi_2055_vcm(phy_info_t *pi, u8 rssi_type, u8 *vcm_buf)
 {
-	uint8 core;
+	u8 core;
 
 	for (core = 0; core < pi->pubpi.phy_corenum; core++) {
 		if (rssi_type == NPHY_RSSI_SEL_NB) {
@@ -21238,7 +21246,7 @@ wlc_phy_set_rssi_2055_vcm(phy_info_t * pi, uint8 rssi_type, uint8 * vcm_buf)
 	}
 }
 
-void wlc_phy_rssi_cal_nphy(phy_info_t * pi)
+void wlc_phy_rssi_cal_nphy(phy_info_t *pi)
 {
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 
@@ -21250,35 +21258,35 @@ void wlc_phy_rssi_cal_nphy(phy_info_t * pi)
 	}
 }
 
-static void wlc_phy_rssi_cal_nphy_rev2(phy_info_t * pi, uint8 rssi_type)
+static void wlc_phy_rssi_cal_nphy_rev2(phy_info_t *pi, u8 rssi_type)
 {
-	int32 target_code;
-	uint16 classif_state;
-	uint16 clip_state[2];
-	uint16 rssi_ctrl_state[2], pd_state[2];
-	uint16 rfctrlintc_state[2], rfpdcorerxtx_state[2];
-	uint16 rfctrlintc_override_val;
-	uint16 clip_off[] = { 0xffff, 0xffff };
-	uint16 rf_pd_val, pd_mask, rssi_ctrl_mask;
-	uint8 vcm, min_vcm, vcm_tmp[4];
-	uint8 vcm_final[4] = { 0, 0, 0, 0 };
-	uint8 result_idx, ctr;
-	int32 poll_results[4][4] = {
+	s32 target_code;
+	u16 classif_state;
+	u16 clip_state[2];
+	u16 rssi_ctrl_state[2], pd_state[2];
+	u16 rfctrlintc_state[2], rfpdcorerxtx_state[2];
+	u16 rfctrlintc_override_val;
+	u16 clip_off[] = { 0xffff, 0xffff };
+	u16 rf_pd_val, pd_mask, rssi_ctrl_mask;
+	u8 vcm, min_vcm, vcm_tmp[4];
+	u8 vcm_final[4] = { 0, 0, 0, 0 };
+	u8 result_idx, ctr;
+	s32 poll_results[4][4] = {
 		{0, 0, 0, 0},
 		{0, 0, 0, 0},
 		{0, 0, 0, 0},
 		{0, 0, 0, 0}
 	};
-	int32 poll_miniq[4][2] = {
+	s32 poll_miniq[4][2] = {
 		{0, 0},
 		{0, 0},
 		{0, 0},
 		{0, 0}
 	};
-	int32 min_d, curr_d;
-	int32 fine_digital_offset[4];
-	int32 poll_results_min[4] = { 0, 0, 0, 0 };
-	int32 min_poll;
+	s32 min_d, curr_d;
+	s32 fine_digital_offset[4];
+	s32 poll_results_min[4] = { 0, 0, 0, 0 };
+	s32 min_poll;
 
 	switch (rssi_type) {
 	case NPHY_RSSI_SEL_NB:
@@ -21349,7 +21357,7 @@ static void wlc_phy_rssi_cal_nphy_rev2(phy_info_t * pi, uint8 rssi_type)
 		    || (rssi_type == NPHY_RSSI_SEL_W2)) {
 			for (ctr = 0; ctr < 2; ctr++) {
 				poll_miniq[vcm][ctr] =
-				    MIN(poll_results[vcm][ctr * 2 + 0],
+				    min(poll_results[vcm][ctr * 2 + 0],
 					poll_results[vcm][ctr * 2 + 1]);
 			}
 		}
@@ -21405,7 +21413,7 @@ static void wlc_phy_rssi_cal_nphy_rev2(phy_info_t * pi, uint8 rssi_type)
 		}
 
 		wlc_phy_scale_offset_rssi_nphy(pi, 0x0,
-					       (int8)
+					       (s8)
 					       fine_digital_offset[result_idx],
 					       (result_idx / 2 ==
 						0) ? RADIO_MIMO_CORESEL_CORE1 :
@@ -21458,11 +21466,11 @@ static void wlc_phy_rssi_cal_nphy_rev2(phy_info_t * pi, uint8 rssi_type)
 }
 
 int BCMFASTPATH
-wlc_phy_rssi_compute_nphy(phy_info_t * pi, wlc_d11rxhdr_t * wlc_rxh)
+wlc_phy_rssi_compute_nphy(phy_info_t *pi, wlc_d11rxhdr_t *wlc_rxh)
 {
 	d11rxhdr_t *rxh = &wlc_rxh->rxhdr;
-	int16 rxpwr, rxpwr0, rxpwr1;
-	int16 phyRx0_l, phyRx2_l;
+	s16 rxpwr, rxpwr0, rxpwr1;
+	s16 phyRx0_l, phyRx2_l;
 
 	rxpwr = 0;
 	rxpwr0 = ltoh16(rxh->PhyRxStatus_1) & PRXS1_nphy_PWR0_MASK;
@@ -21483,8 +21491,8 @@ wlc_phy_rssi_compute_nphy(phy_info_t * pi, wlc_d11rxhdr_t * wlc_rxh)
 		rxpwr1 = phyRx2_l;
 	}
 
-	wlc_rxh->rxpwr[0] = (int8) rxpwr0;
-	wlc_rxh->rxpwr[1] = (int8) rxpwr1;
+	wlc_rxh->rxpwr[0] = (s8) rxpwr0;
+	wlc_rxh->rxpwr[1] = (s8) rxpwr1;
 	wlc_rxh->do_rssi_ma = 0;
 
 	if (pi->sh->rssi_mode == RSSI_ANT_MERGE_MAX)
@@ -21500,12 +21508,12 @@ wlc_phy_rssi_compute_nphy(phy_info_t * pi, wlc_d11rxhdr_t * wlc_rxh)
 }
 
 static void
-wlc_phy_rfctrlintc_override_nphy(phy_info_t * pi, uint8 field, uint16 value,
-				 uint8 core_code)
+wlc_phy_rfctrlintc_override_nphy(phy_info_t *pi, u8 field, u16 value,
+				 u8 core_code)
 {
-	uint16 mask;
-	uint16 val;
-	uint8 core;
+	u16 mask;
+	u16 val;
+	u8 core;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		for (core = 0; core < pi->pubpi.phy_corenum; core++) {
@@ -21548,8 +21556,8 @@ wlc_phy_rfctrlintc_override_nphy(phy_info_t * pi, uint8 field, uint16 value,
 						    PHY_CORE_0) ? 0x91 : 0x92,
 						   (0x1 << 10));
 
-					and_phy_reg(pi, 0x2ff, (uint16)
-						    ~ (0x3 << 14));
+					and_phy_reg(pi, 0x2ff, (u16)
+						    ~(0x3 << 14));
 					or_phy_reg(pi, 0x2ff, (0x1 << 13));
 					or_phy_reg(pi, 0x2ff, (0x1 << 0));
 				} else {
@@ -21734,16 +21742,16 @@ wlc_phy_rfctrlintc_override_nphy(phy_info_t * pi, uint8 field, uint16 value,
 	}
 }
 
-static void wlc_phy_rssi_cal_nphy_rev3(phy_info_t * pi)
+static void wlc_phy_rssi_cal_nphy_rev3(phy_info_t *pi)
 {
-	uint16 classif_state;
-	uint16 clip_state[2];
-	uint16 clip_off[] = { 0xffff, 0xffff };
-	int32 target_code;
-	uint8 vcm, min_vcm;
-	uint8 vcm_final = 0;
-	uint8 result_idx;
-	int32 poll_results[8][4] = {
+	u16 classif_state;
+	u16 clip_state[2];
+	u16 clip_off[] = { 0xffff, 0xffff };
+	s32 target_code;
+	u8 vcm, min_vcm;
+	u8 vcm_final = 0;
+	u8 result_idx;
+	s32 poll_results[8][4] = {
 		{0, 0, 0, 0},
 		{0, 0, 0, 0},
 		{0, 0, 0, 0},
@@ -21753,28 +21761,28 @@ static void wlc_phy_rssi_cal_nphy_rev3(phy_info_t * pi)
 		{0, 0, 0, 0},
 		{0, 0, 0, 0}
 	};
-	int32 poll_result_core[4] = { 0, 0, 0, 0 };
-	int32 min_d = NPHY_RSSICAL_MAXD, curr_d;
-	int32 fine_digital_offset[4];
-	int32 poll_results_min[4] = { 0, 0, 0, 0 };
-	int32 min_poll;
-	uint8 vcm_level_max;
-	uint8 core;
-	uint8 wb_cnt;
-	uint8 rssi_type;
-	uint16 NPHY_Rfctrlintc1_save, NPHY_Rfctrlintc2_save;
-	uint16 NPHY_AfectrlOverride1_save, NPHY_AfectrlOverride2_save;
-	uint16 NPHY_AfectrlCore1_save, NPHY_AfectrlCore2_save;
-	uint16 NPHY_RfctrlOverride0_save, NPHY_RfctrlOverride1_save;
-	uint16 NPHY_RfctrlOverrideAux0_save, NPHY_RfctrlOverrideAux1_save;
-	uint16 NPHY_RfctrlCmd_save;
-	uint16 NPHY_RfctrlMiscReg1_save, NPHY_RfctrlMiscReg2_save;
-	uint16 NPHY_RfctrlRSSIOTHERS1_save, NPHY_RfctrlRSSIOTHERS2_save;
-	uint8 rxcore_state;
-	uint16 NPHY_REV7_RfctrlOverride3_save, NPHY_REV7_RfctrlOverride4_save;
-	uint16 NPHY_REV7_RfctrlOverride5_save, NPHY_REV7_RfctrlOverride6_save;
-	uint16 NPHY_REV7_RfctrlMiscReg3_save, NPHY_REV7_RfctrlMiscReg4_save;
-	uint16 NPHY_REV7_RfctrlMiscReg5_save, NPHY_REV7_RfctrlMiscReg6_save;
+	s32 poll_result_core[4] = { 0, 0, 0, 0 };
+	s32 min_d = NPHY_RSSICAL_MAXD, curr_d;
+	s32 fine_digital_offset[4];
+	s32 poll_results_min[4] = { 0, 0, 0, 0 };
+	s32 min_poll;
+	u8 vcm_level_max;
+	u8 core;
+	u8 wb_cnt;
+	u8 rssi_type;
+	u16 NPHY_Rfctrlintc1_save, NPHY_Rfctrlintc2_save;
+	u16 NPHY_AfectrlOverride1_save, NPHY_AfectrlOverride2_save;
+	u16 NPHY_AfectrlCore1_save, NPHY_AfectrlCore2_save;
+	u16 NPHY_RfctrlOverride0_save, NPHY_RfctrlOverride1_save;
+	u16 NPHY_RfctrlOverrideAux0_save, NPHY_RfctrlOverrideAux1_save;
+	u16 NPHY_RfctrlCmd_save;
+	u16 NPHY_RfctrlMiscReg1_save, NPHY_RfctrlMiscReg2_save;
+	u16 NPHY_RfctrlRSSIOTHERS1_save, NPHY_RfctrlRSSIOTHERS2_save;
+	u8 rxcore_state;
+	u16 NPHY_REV7_RfctrlOverride3_save, NPHY_REV7_RfctrlOverride4_save;
+	u16 NPHY_REV7_RfctrlOverride5_save, NPHY_REV7_RfctrlOverride6_save;
+	u16 NPHY_REV7_RfctrlMiscReg3_save, NPHY_REV7_RfctrlMiscReg4_save;
+	u16 NPHY_REV7_RfctrlMiscReg5_save, NPHY_REV7_RfctrlMiscReg6_save;
 
 	NPHY_REV7_RfctrlOverride3_save = NPHY_REV7_RfctrlOverride4_save =
 	    NPHY_REV7_RfctrlOverride5_save = NPHY_REV7_RfctrlOverride6_save =
@@ -21990,7 +21998,7 @@ static void wlc_phy_rssi_cal_nphy_rev3(phy_info_t * pi)
 				}
 
 				wlc_phy_scale_offset_rssi_nphy(pi, 0x0,
-							       (int8)
+							       (s8)
 							       fine_digital_offset
 							       [result_idx],
 							       (result_idx /
@@ -22067,7 +22075,7 @@ static void wlc_phy_rssi_cal_nphy_rev3(phy_info_t * pi)
 					}
 
 					wlc_phy_scale_offset_rssi_nphy(pi, 0x0,
-								       (int8)
+								       (s8)
 								       fine_digital_offset
 								       [core *
 									2],
@@ -22221,7 +22229,7 @@ static void wlc_phy_rssi_cal_nphy_rev3(phy_info_t * pi)
 	wlc_phy_clip_det_nphy(pi, 1, clip_state);
 }
 
-static void wlc_phy_restore_rssical_nphy(phy_info_t * pi)
+static void wlc_phy_restore_rssical_nphy(phy_info_t *pi)
 {
 	ASSERT(NREV_GE(pi->pubpi.phy_rev, 3));
 
@@ -22329,15 +22337,15 @@ static void wlc_phy_restore_rssical_nphy(phy_info_t * pi)
 	}
 }
 
-static uint16
-wlc_phy_gen_load_samples_nphy(phy_info_t * pi, uint32 f_kHz, uint16 max_val,
-			      uint8 dac_test_mode)
+static u16
+wlc_phy_gen_load_samples_nphy(phy_info_t *pi, u32 f_kHz, u16 max_val,
+			      u8 dac_test_mode)
 {
-	uint8 phy_bw, is_phybw40;
-	uint16 num_samps, t, spur;
+	u8 phy_bw, is_phybw40;
+	u16 num_samps, t, spur;
 	fixed theta = 0, rot = 0;
-	uint32 tbl_len;
-	cint32 *tone_buf = NULL;
+	u32 tbl_len;
+	cs32 *tone_buf = NULL;
 
 	is_phybw40 = CHSPEC_IS40(pi->radio_chanspec);
 	phy_bw = (is_phybw40 == 1) ? 40 : 20;
@@ -22352,13 +22360,12 @@ wlc_phy_gen_load_samples_nphy(phy_info_t * pi, uint32 f_kHz, uint16 max_val,
 		tbl_len = (phy_bw << 1);
 	}
 
-	if ((tone_buf =
-	     (cint32 *) MALLOC(pi->sh->osh,
-			       sizeof(cint32) * tbl_len)) == NULL) {
+	tone_buf = kmalloc(sizeof(cs32) * tbl_len, GFP_ATOMIC);
+	if (tone_buf == NULL) {
 		return 0;
 	}
 
-	num_samps = (uint16) tbl_len;
+	num_samps = (u16) tbl_len;
 	rot = FIXED((f_kHz * 36) / phy_bw) / 100;
 	theta = 0;
 
@@ -22368,29 +22375,29 @@ wlc_phy_gen_load_samples_nphy(phy_info_t * pi, uint32 f_kHz, uint16 max_val,
 
 		theta += rot;
 
-		tone_buf[t].q = (int32) FLOAT(tone_buf[t].q * max_val);
-		tone_buf[t].i = (int32) FLOAT(tone_buf[t].i * max_val);
+		tone_buf[t].q = (s32) FLOAT(tone_buf[t].q * max_val);
+		tone_buf[t].i = (s32) FLOAT(tone_buf[t].i * max_val);
 	}
 
 	wlc_phy_loadsampletable_nphy(pi, tone_buf, num_samps);
 
 	if (tone_buf != NULL)
-		MFREE(pi->sh->osh, tone_buf, sizeof(cint32) * tbl_len);
+		kfree(tone_buf);
 
 	return num_samps;
 }
 
 int
-wlc_phy_tx_tone_nphy(phy_info_t * pi, uint32 f_kHz, uint16 max_val,
-		     uint8 iqmode, uint8 dac_test_mode, bool modify_bbmult)
+wlc_phy_tx_tone_nphy(phy_info_t *pi, u32 f_kHz, u16 max_val,
+		     u8 iqmode, u8 dac_test_mode, bool modify_bbmult)
 {
-	uint16 num_samps;
-	uint16 loops = 0xffff;
-	uint16 wait = 0;
+	u16 num_samps;
+	u16 loops = 0xffff;
+	u16 wait = 0;
 
-	if ((num_samps =
-	     wlc_phy_gen_load_samples_nphy(pi, f_kHz, max_val,
-					   dac_test_mode)) == 0) {
+	num_samps =
+		wlc_phy_gen_load_samples_nphy(pi, f_kHz, max_val, dac_test_mode);
+	if (num_samps == 0) {
 		return BCME_ERROR;
 	}
 
@@ -22401,20 +22408,19 @@ wlc_phy_tx_tone_nphy(phy_info_t * pi, uint32 f_kHz, uint16 max_val,
 }
 
 static void
-wlc_phy_loadsampletable_nphy(phy_info_t * pi, cint32 * tone_buf,
-			     uint16 num_samps)
+wlc_phy_loadsampletable_nphy(phy_info_t *pi, cs32 *tone_buf,
+			     u16 num_samps)
 {
-	uint16 t;
-	uint32 *data_buf = NULL;
+	u16 t;
+	u32 *data_buf = NULL;
 
-	if ((data_buf =
-	     (uint32 *) MALLOC(pi->sh->osh,
-			       sizeof(uint32) * num_samps)) == NULL) {
+	data_buf = kmalloc(sizeof(u32) * num_samps, GFP_ATOMIC);
+	if (data_buf == NULL) {
 		return;
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	for (t = 0; t < num_samps; t++) {
 		data_buf[t] = ((((unsigned int)tone_buf[t].i) & 0x3ff) << 10) |
@@ -22424,25 +22430,25 @@ wlc_phy_loadsampletable_nphy(phy_info_t * pi, cint32 * tone_buf,
 				 data_buf);
 
 	if (data_buf != NULL)
-		MFREE(pi->sh->osh, data_buf, sizeof(uint32) * num_samps);
+		kfree(data_buf);
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
 static void
-wlc_phy_runsamples_nphy(phy_info_t * pi, uint16 num_samps, uint16 loops,
-			uint16 wait, uint8 iqmode, uint8 dac_test_mode,
+wlc_phy_runsamples_nphy(phy_info_t *pi, u16 num_samps, u16 loops,
+			u16 wait, u8 iqmode, u8 dac_test_mode,
 			bool modify_bbmult)
 {
-	uint16 bb_mult;
-	uint8 phy_bw, sample_cmd;
-	uint16 orig_RfseqCoreActv;
-	uint16 lpf_bw_ctl_override3, lpf_bw_ctl_override4, lpf_bw_ctl_miscreg3,
+	u16 bb_mult;
+	u8 phy_bw, sample_cmd;
+	u16 orig_RfseqCoreActv;
+	u16 lpf_bw_ctl_override3, lpf_bw_ctl_override4, lpf_bw_ctl_miscreg3,
 	    lpf_bw_ctl_miscreg4;
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	phy_bw = 20;
 	if (CHSPEC_IS40(pi->radio_chanspec))
@@ -22464,7 +22470,7 @@ wlc_phy_runsamples_nphy(phy_info_t * pi, uint16 num_samps, uint16 loops,
 							  (pi, 0), 0, 0,
 							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
 
-			pi->nphy_sample_play_lpf_bw_ctl_ovr = TRUE;
+			pi->nphy_sample_play_lpf_bw_ctl_ovr = true;
 
 			lpf_bw_ctl_miscreg3 = read_phy_reg(pi, 0x340) &
 			    (0x7 << 8);
@@ -22489,7 +22495,7 @@ wlc_phy_runsamples_nphy(phy_info_t * pi, uint16 num_samps, uint16 loops,
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 
 	write_phy_reg(pi, 0xc6, num_samps - 1);
 
@@ -22518,13 +22524,13 @@ wlc_phy_runsamples_nphy(phy_info_t * pi, uint16 num_samps, uint16 loops,
 	write_phy_reg(pi, 0xa1, orig_RfseqCoreActv);
 }
 
-void wlc_phy_stopplayback_nphy(phy_info_t * pi)
+void wlc_phy_stopplayback_nphy(phy_info_t *pi)
 {
-	uint16 playback_status;
-	uint16 bb_mult;
+	u16 playback_status;
+	u16 bb_mult;
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	playback_status = read_phy_reg(pi, 0xc7);
 	if (playback_status & 0x1) {
@@ -22532,10 +22538,10 @@ void wlc_phy_stopplayback_nphy(phy_info_t * pi)
 	} else if (playback_status & 0x2) {
 
 		and_phy_reg(pi, 0xc2,
-			    (uint16) ~ NPHY_iqloCalCmdGctl_IQLO_CAL_EN);
+			    (u16) ~NPHY_iqloCalCmdGctl_IQLO_CAL_EN);
 	}
 
-	and_phy_reg(pi, 0xc3, (uint16) ~ (0x1 << 2));
+	and_phy_reg(pi, 0xc3, (u16) ~(0x1 << 2));
 
 	if ((pi->nphy_bb_mult_save & BB_MULT_VALID_MASK) != 0) {
 
@@ -22552,30 +22558,30 @@ void wlc_phy_stopplayback_nphy(phy_info_t * pi)
 							  (0x1 << 7),
 							  0, 0, 1,
 							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
-			pi->nphy_sample_play_lpf_bw_ctl_ovr = FALSE;
+			pi->nphy_sample_play_lpf_bw_ctl_ovr = false;
 		}
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
-nphy_txgains_t wlc_phy_get_tx_gain_nphy(phy_info_t * pi)
+nphy_txgains_t wlc_phy_get_tx_gain_nphy(phy_info_t *pi)
 {
-	uint16 base_idx[2], curr_gain[2];
-	uint8 core_no;
+	u16 base_idx[2], curr_gain[2];
+	u8 core_no;
 	nphy_txgains_t target_gain;
-	uint32 *tx_pwrctrl_tbl = NULL;
+	u32 *tx_pwrctrl_tbl = NULL;
 
 	if (pi->nphy_txpwrctrl == PHY_TPC_HW_OFF) {
 		if (pi->phyhang_avoid)
-			wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+			wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 		wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16,
 					curr_gain);
 
 		if (pi->phyhang_avoid)
-			wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+			wlc_phy_stay_in_carriersearch_nphy(pi, false);
 
 		for (core_no = 0; core_no < 2; core_no++) {
 			if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -22714,18 +22720,18 @@ nphy_txgains_t wlc_phy_get_tx_gain_nphy(phy_info_t * pi)
 		}
 	}
 
-	return (target_gain);
+	return target_gain;
 }
 
 static void
-wlc_phy_iqcal_gainparams_nphy(phy_info_t * pi, uint16 core_no,
+wlc_phy_iqcal_gainparams_nphy(phy_info_t *pi, u16 core_no,
 			      nphy_txgains_t target_gain,
-			      nphy_iqcal_params_t * params)
+			      nphy_iqcal_params_t *params)
 {
-	uint8 k;
+	u8 k;
 	int idx;
-	uint16 gain_index;
-	uint8 band_idx = (CHSPEC_IS5G(pi->radio_chanspec) ? 1 : 0);
+	u16 gain_index;
+	u8 band_idx = (CHSPEC_IS5G(pi->radio_chanspec) ? 1 : 0);
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -22783,9 +22789,9 @@ wlc_phy_iqcal_gainparams_nphy(phy_info_t * pi, uint16 core_no,
 	}
 }
 
-static void wlc_phy_txcal_radio_setup_nphy(phy_info_t * pi)
+static void wlc_phy_txcal_radio_setup_nphy(phy_info_t *pi)
 {
-	uint16 jtag_core, core;
+	u16 jtag_core, core;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 
@@ -22840,8 +22846,7 @@ static void wlc_phy_txcal_radio_setup_nphy(phy_info_t * pi)
 							 core, TX_SSI_MUX, 0x4);
 					if (!
 					    (pi->
-					     internal_tx_iqlo_cal_tapoff_intpa_nphy))
-					{
+					     internal_tx_iqlo_cal_tapoff_intpa_nphy)) {
 
 						WRITE_RADIO_REG3(pi, RADIO_2057,
 								 TX, core,
@@ -22874,8 +22879,7 @@ static void wlc_phy_txcal_radio_setup_nphy(phy_info_t * pi)
 							 0x06);
 					if (!
 					    (pi->
-					     internal_tx_iqlo_cal_tapoff_intpa_nphy))
-					{
+					     internal_tx_iqlo_cal_tapoff_intpa_nphy)) {
 
 						WRITE_RADIO_REG3(pi, RADIO_2057,
 								 TX, core,
@@ -23095,9 +23099,9 @@ static void wlc_phy_txcal_radio_setup_nphy(phy_info_t * pi)
 	}
 }
 
-static void wlc_phy_txcal_radio_cleanup_nphy(phy_info_t * pi)
+static void wlc_phy_txcal_radio_cleanup_nphy(phy_info_t *pi)
 {
-	uint16 jtag_core, core;
+	u16 jtag_core, core;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 		for (core = 0; core <= 1; core++) {
@@ -23233,9 +23237,9 @@ static void wlc_phy_txcal_radio_cleanup_nphy(phy_info_t * pi)
 	}
 }
 
-static void wlc_phy_txcal_physetup_nphy(phy_info_t * pi)
+static void wlc_phy_txcal_physetup_nphy(phy_info_t *pi)
 {
-	uint16 val, mask;
+	u16 val, mask;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		pi->tx_rx_cal_phy_saveregs[0] = read_phy_reg(pi, 0xa6);
@@ -23385,9 +23389,9 @@ static void wlc_phy_txcal_physetup_nphy(phy_info_t * pi)
 	}
 }
 
-static void wlc_phy_txcal_phycleanup_nphy(phy_info_t * pi)
+static void wlc_phy_txcal_phycleanup_nphy(phy_info_t *pi)
 {
-	uint16 mask;
+	u16 mask;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		write_phy_reg(pi, 0xa6, pi->tx_rx_cal_phy_saveregs[0]);
@@ -23467,31 +23471,31 @@ static void wlc_phy_txcal_phycleanup_nphy(phy_info_t * pi)
 #define NPHY_TEST_TONE_FREQ_20MHz 2500
 
 void
-wlc_phy_est_tonepwr_nphy(phy_info_t * pi, int32 * qdBm_pwrbuf, uint8 num_samps)
+wlc_phy_est_tonepwr_nphy(phy_info_t *pi, s32 *qdBm_pwrbuf, u8 num_samps)
 {
-	uint16 tssi_reg;
-	int32 temp, pwrindex[2];
-	int32 idle_tssi[2];
-	int32 rssi_buf[4];
-	int32 tssival[2];
-	uint8 tssi_type;
+	u16 tssi_reg;
+	s32 temp, pwrindex[2];
+	s32 idle_tssi[2];
+	s32 rssi_buf[4];
+	s32 tssival[2];
+	u8 tssi_type;
 
 	tssi_reg = read_phy_reg(pi, 0x1e9);
 
-	temp = (int32) (tssi_reg & 0x3f);
+	temp = (s32) (tssi_reg & 0x3f);
 	idle_tssi[0] = (temp <= 31) ? temp : (temp - 64);
 
-	temp = (int32) ((tssi_reg >> 8) & 0x3f);
+	temp = (s32) ((tssi_reg >> 8) & 0x3f);
 	idle_tssi[1] = (temp <= 31) ? temp : (temp - 64);
 
 	tssi_type =
 	    CHSPEC_IS5G(pi->radio_chanspec) ?
-	    (uint8) NPHY_RSSI_SEL_TSSI_5G : (uint8) NPHY_RSSI_SEL_TSSI_2G;
+	    (u8)NPHY_RSSI_SEL_TSSI_5G:(u8)NPHY_RSSI_SEL_TSSI_2G;
 
 	wlc_phy_poll_rssi_nphy(pi, tssi_type, rssi_buf, num_samps);
 
-	tssival[0] = rssi_buf[0] / ((int32) num_samps);
-	tssival[1] = rssi_buf[2] / ((int32) num_samps);
+	tssival[0] = rssi_buf[0] / ((s32) num_samps);
+	tssival[1] = rssi_buf[2] / ((s32) num_samps);
 
 	pwrindex[0] = idle_tssi[0] - tssival[0] + 64;
 	pwrindex[1] = idle_tssi[1] - tssival[1] + 64;
@@ -23509,19 +23513,19 @@ wlc_phy_est_tonepwr_nphy(phy_info_t * pi, int32 * qdBm_pwrbuf, uint8 num_samps)
 	}
 
 	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_CORE1TXPWRCTL, 1,
-				(uint32) pwrindex[0], 32, &qdBm_pwrbuf[0]);
+				(u32) pwrindex[0], 32, &qdBm_pwrbuf[0]);
 	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_CORE2TXPWRCTL, 1,
-				(uint32) pwrindex[1], 32, &qdBm_pwrbuf[1]);
+				(u32) pwrindex[1], 32, &qdBm_pwrbuf[1]);
 }
 
-static void wlc_phy_internal_cal_txgain_nphy(phy_info_t * pi)
+static void wlc_phy_internal_cal_txgain_nphy(phy_info_t *pi)
 {
-	uint16 txcal_gain[2];
+	u16 txcal_gain[2];
 
 	pi->nphy_txcal_pwr_idx[0] = pi->nphy_cal_orig_pwr_idx[0];
 	pi->nphy_txcal_pwr_idx[1] = pi->nphy_cal_orig_pwr_idx[0];
-	wlc_phy_txpwr_index_nphy(pi, 1, pi->nphy_cal_orig_pwr_idx[0], TRUE);
-	wlc_phy_txpwr_index_nphy(pi, 2, pi->nphy_cal_orig_pwr_idx[1], TRUE);
+	wlc_phy_txpwr_index_nphy(pi, 1, pi->nphy_cal_orig_pwr_idx[0], true);
+	wlc_phy_txpwr_index_nphy(pi, 2, pi->nphy_cal_orig_pwr_idx[1], true);
 
 	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16,
 				txcal_gain);
@@ -23538,11 +23542,11 @@ static void wlc_phy_internal_cal_txgain_nphy(phy_info_t * pi)
 				 txcal_gain);
 }
 
-static void wlc_phy_precal_txgain_nphy(phy_info_t * pi)
+static void wlc_phy_precal_txgain_nphy(phy_info_t *pi)
 {
-	bool save_bbmult = FALSE;
-	uint8 txcal_index_2057_rev5n7 = 0;
-	uint8 txcal_index_2057_rev3n4n6 = 10;
+	bool save_bbmult = false;
+	u8 txcal_index_2057_rev5n7 = 0;
+	u8 txcal_index_2057_rev3n4n6 = 10;
 
 	if (pi->use_int_tx_iqlo_cal_nphy) {
 		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -23556,7 +23560,7 @@ static void wlc_phy_precal_txgain_nphy(phy_info_t * pi)
 				    txcal_index_2057_rev3n4n6;
 				wlc_phy_txpwr_index_nphy(pi, 3,
 							 txcal_index_2057_rev3n4n6,
-							 FALSE);
+							 false);
 			} else {
 
 				pi->nphy_txcal_pwr_idx[0] =
@@ -23565,58 +23569,58 @@ static void wlc_phy_precal_txgain_nphy(phy_info_t * pi)
 				    txcal_index_2057_rev5n7;
 				wlc_phy_txpwr_index_nphy(pi, 3,
 							 txcal_index_2057_rev5n7,
-							 FALSE);
+							 false);
 			}
-			save_bbmult = TRUE;
+			save_bbmult = true;
 
 		} else if (NREV_LT(pi->pubpi.phy_rev, 5)) {
-			wlc_phy_cal_txgainctrl_nphy(pi, 11, FALSE);
+			wlc_phy_cal_txgainctrl_nphy(pi, 11, false);
 			if (pi->sh->hw_phytxchain != 3) {
 				pi->nphy_txcal_pwr_idx[1] =
 				    pi->nphy_txcal_pwr_idx[0];
 				wlc_phy_txpwr_index_nphy(pi, 3,
 							 pi->
 							 nphy_txcal_pwr_idx[0],
-							 TRUE);
-				save_bbmult = TRUE;
+							 true);
+				save_bbmult = true;
 			}
 
 		} else if (NREV_IS(pi->pubpi.phy_rev, 5)) {
 			if (PHY_IPA(pi)) {
 				if (CHSPEC_IS2G(pi->radio_chanspec)) {
 					wlc_phy_cal_txgainctrl_nphy(pi, 12,
-								    FALSE);
+								    false);
 				} else {
 					pi->nphy_txcal_pwr_idx[0] = 80;
 					pi->nphy_txcal_pwr_idx[1] = 80;
 					wlc_phy_txpwr_index_nphy(pi, 3, 80,
-								 FALSE);
-					save_bbmult = TRUE;
+								 false);
+					save_bbmult = true;
 				}
 			} else {
 
 				wlc_phy_internal_cal_txgain_nphy(pi);
-				save_bbmult = TRUE;
+				save_bbmult = true;
 			}
 
 		} else if (NREV_IS(pi->pubpi.phy_rev, 6)) {
 			if (PHY_IPA(pi)) {
 				if (CHSPEC_IS2G(pi->radio_chanspec)) {
 					wlc_phy_cal_txgainctrl_nphy(pi, 12,
-								    FALSE);
+								    false);
 				} else {
 					wlc_phy_cal_txgainctrl_nphy(pi, 14,
-								    FALSE);
+								    false);
 				}
 			} else {
 
 				wlc_phy_internal_cal_txgain_nphy(pi);
-				save_bbmult = TRUE;
+				save_bbmult = true;
 			}
 		}
 
 	} else {
-		wlc_phy_cal_txgainctrl_nphy(pi, 10, FALSE);
+		wlc_phy_cal_txgainctrl_nphy(pi, 10, false);
 	}
 
 	if (save_bbmult) {
@@ -23626,20 +23630,20 @@ static void wlc_phy_precal_txgain_nphy(phy_info_t * pi)
 }
 
 void
-wlc_phy_cal_txgainctrl_nphy(phy_info_t * pi, int32 dBm_targetpower, bool debug)
+wlc_phy_cal_txgainctrl_nphy(phy_info_t *pi, s32 dBm_targetpower, bool debug)
 {
 	int gainctrl_loopidx;
 	uint core;
-	uint16 m0m1, curr_m0m1;
-	int32 delta_power;
-	int32 txpwrindex;
-	int32 qdBm_power[2];
-	uint16 orig_BBConfig;
-	uint16 phy_saveregs[4];
-	uint32 freq_test;
-	uint16 ampl_test = 250;
+	u16 m0m1, curr_m0m1;
+	s32 delta_power;
+	s32 txpwrindex;
+	s32 qdBm_power[2];
+	u16 orig_BBConfig;
+	u16 phy_saveregs[4];
+	u32 freq_test;
+	u16 ampl_test = 250;
 	uint stepsize;
-	bool phyhang_avoid_state = FALSE;
+	bool phyhang_avoid_state = false;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 
@@ -23655,14 +23659,14 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t * pi, int32 dBm_targetpower, bool debug)
 		freq_test = 2500;
 	}
 
-	wlc_phy_txpwr_index_nphy(pi, 1, pi->nphy_cal_orig_pwr_idx[0], TRUE);
-	wlc_phy_txpwr_index_nphy(pi, 2, pi->nphy_cal_orig_pwr_idx[1], TRUE);
+	wlc_phy_txpwr_index_nphy(pi, 1, pi->nphy_cal_orig_pwr_idx[0], true);
+	wlc_phy_txpwr_index_nphy(pi, 2, pi->nphy_cal_orig_pwr_idx[1], true);
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	phyhang_avoid_state = pi->phyhang_avoid;
-	pi->phyhang_avoid = FALSE;
+	pi->phyhang_avoid = false;
 
 	phy_saveregs[0] = read_phy_reg(pi, 0x91);
 	phy_saveregs[1] = read_phy_reg(pi, 0x92);
@@ -23694,12 +23698,12 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t * pi, int32 dBm_targetpower, bool debug)
 	wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &m0m1);
 
 	for (core = 0; core < pi->pubpi.phy_corenum; core++) {
-		txpwrindex = (int32) pi->nphy_cal_orig_pwr_idx[core];
+		txpwrindex = (s32) pi->nphy_cal_orig_pwr_idx[core];
 
 		for (gainctrl_loopidx = 0; gainctrl_loopidx < 2;
 		     gainctrl_loopidx++) {
 			wlc_phy_tx_tone_nphy(pi, freq_test, ampl_test, 0, 0,
-					     FALSE);
+					     false);
 
 			if (core == PHY_CORE_0) {
 				curr_m0m1 = m0m1 & 0xff00;
@@ -23710,7 +23714,7 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t * pi, int32 dBm_targetpower, bool debug)
 			wlc_phy_table_write_nphy(pi, 15, 1, 87, 16, &curr_m0m1);
 			wlc_phy_table_write_nphy(pi, 15, 1, 95, 16, &curr_m0m1);
 
-			OSL_DELAY(50);
+			udelay(50);
 
 			wlc_phy_est_tonepwr_nphy(pi, qdBm_power,
 						 NPHY_CAL_TSSISAMPS);
@@ -23744,24 +23748,24 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t * pi, int32 dBm_targetpower, bool debug)
 			}
 
 			wlc_phy_txpwr_index_nphy(pi, (1 << core),
-						 (uint8) txpwrindex, TRUE);
+						 (u8) txpwrindex, true);
 		}
 
-		pi->nphy_txcal_pwr_idx[core] = (uint8) txpwrindex;
+		pi->nphy_txcal_pwr_idx[core] = (u8) txpwrindex;
 
 		if (debug) {
-			uint16 radio_gain;
-			uint16 dbg_m0m1;
+			u16 radio_gain;
+			u16 dbg_m0m1;
 
 			wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &dbg_m0m1);
 
 			wlc_phy_tx_tone_nphy(pi, freq_test, ampl_test, 0, 0,
-					     FALSE);
+					     false);
 
 			wlc_phy_table_write_nphy(pi, 15, 1, 87, 16, &dbg_m0m1);
 			wlc_phy_table_write_nphy(pi, 15, 1, 95, 16, &dbg_m0m1);
 
-			OSL_DELAY(100);
+			udelay(100);
 
 			wlc_phy_est_tonepwr_nphy(pi, qdBm_power,
 						 NPHY_CAL_TSSISAMPS);
@@ -23769,14 +23773,14 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t * pi, int32 dBm_targetpower, bool debug)
 			wlc_phy_table_read_nphy(pi, 7, 1, (0x110 + core), 16,
 						&radio_gain);
 
-			OSL_DELAY(4000000);
+			mdelay(4000);
 			pi->nphy_bb_mult_save = 0;
 			wlc_phy_stopplayback_nphy(pi);
 		}
 	}
 
-	wlc_phy_txpwr_index_nphy(pi, 1, pi->nphy_txcal_pwr_idx[0], TRUE);
-	wlc_phy_txpwr_index_nphy(pi, 2, pi->nphy_txcal_pwr_idx[1], TRUE);
+	wlc_phy_txpwr_index_nphy(pi, 1, pi->nphy_txcal_pwr_idx[0], true);
+	wlc_phy_txpwr_index_nphy(pi, 2, pi->nphy_txcal_pwr_idx[1], true);
 
 	wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &pi->nphy_txcal_bbmult);
 
@@ -23790,15 +23794,15 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t * pi, int32 dBm_targetpower, bool debug)
 	pi->phyhang_avoid = phyhang_avoid_state;
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
-static void wlc_phy_update_txcal_ladder_nphy(phy_info_t * pi, uint16 core)
+static void wlc_phy_update_txcal_ladder_nphy(phy_info_t *pi, u16 core)
 {
 	int index;
-	uint32 bbmult_scale;
-	uint16 bbmult;
-	uint16 tblentry;
+	u32 bbmult_scale;
+	u16 bbmult;
+	u16 tblentry;
 
 	nphy_txiqcal_ladder_t ladder_lo[] = {
 		{3, 0}, {4, 0}, {6, 0}, {9, 0}, {13, 0}, {18, 0},
@@ -23835,12 +23839,12 @@ static void wlc_phy_update_txcal_ladder_nphy(phy_info_t * pi, uint16 core)
 	}
 }
 
-void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype)
+void wlc_phy_cal_perical_nphy_run(phy_info_t *pi, u8 caltype)
 {
 	nphy_txgains_t target_gain;
-	uint8 tx_pwr_ctrl_state;
-	bool fullcal = TRUE;
-	bool restore_tx_gain = FALSE;
+	u8 tx_pwr_ctrl_state;
+	bool fullcal = true;
+	bool restore_tx_gain = false;
 	bool mphase;
 
 	if (NORADIO_ENAB(pi->pubpi)) {
@@ -23856,11 +23860,11 @@ void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype)
 	if (caltype == PHY_PERICAL_AUTO)
 		fullcal = (pi->radio_chanspec != pi->nphy_txiqlocal_chanspec);
 	else if (caltype == PHY_PERICAL_PARTIAL)
-		fullcal = FALSE;
+		fullcal = false;
 
 	if (pi->cal_type_override != PHY_PERICAL_AUTO) {
 		fullcal =
-		    (pi->cal_type_override == PHY_PERICAL_FULL) ? TRUE : FALSE;
+		    (pi->cal_type_override == PHY_PERICAL_FULL) ? true : false;
 	}
 
 	if ((pi->mphase_cal_phase_id > MPHASE_CAL_STATE_INIT)) {
@@ -23879,9 +23883,9 @@ void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype)
 	if ((pi->mphase_cal_phase_id == MPHASE_CAL_STATE_IDLE) ||
 	    (pi->mphase_cal_phase_id == MPHASE_CAL_STATE_INIT)) {
 		pi->nphy_cal_orig_pwr_idx[0] =
-		    (uint8) ((read_phy_reg(pi, 0x1ed) >> 8) & 0x7f);
+		    (u8) ((read_phy_reg(pi, 0x1ed) >> 8) & 0x7f);
 		pi->nphy_cal_orig_pwr_idx[1] =
-		    (uint8) ((read_phy_reg(pi, 0x1ee) >> 8) & 0x7f);
+		    (u8) ((read_phy_reg(pi, 0x1ee) >> 8) & 0x7f);
 
 		if (pi->nphy_txpwrctrl != PHY_TPC_HW_OFF) {
 			wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 2,
@@ -23897,7 +23901,7 @@ void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype)
 	wlc_phy_txpwrctrl_enable_nphy(pi, PHY_TPC_HW_OFF);
 
 	if (pi->antsel_type == ANTSEL_2x3)
-		wlc_phy_antsel_init((wlc_phy_t *) pi, TRUE);
+		wlc_phy_antsel_init((wlc_phy_t *) pi, true);
 
 	mphase = (pi->mphase_cal_phase_id != MPHASE_CAL_STATE_IDLE);
 	if (!mphase) {
@@ -23905,14 +23909,14 @@ void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype)
 		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 			wlc_phy_precal_txgain_nphy(pi);
 			pi->nphy_cal_target_gain = wlc_phy_get_tx_gain_nphy(pi);
-			restore_tx_gain = TRUE;
+			restore_tx_gain = true;
 
 			target_gain = pi->nphy_cal_target_gain;
 		}
 		if (BCME_OK ==
 		    wlc_phy_cal_txiqlo_nphy(pi, target_gain, fullcal, mphase)) {
 			if (PHY_IPA(pi))
-				wlc_phy_a4(pi, TRUE);
+				wlc_phy_a4(pi, true);
 
 			wlc_phyreg_exit((wlc_phy_t *) pi);
 			wlapi_enable_mac(pi->sh->physhim);
@@ -23928,7 +23932,7 @@ void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype)
 								  cal_type_override
 								  ==
 								  PHY_PERICAL_FULL))
-							     ? 2 : 0, FALSE)) {
+							     ? 2 : 0, false)) {
 				wlc_phy_savecal_nphy(pi);
 
 				wlc_phy_txpwrctrl_coeff_setup_nphy(pi);
@@ -23942,7 +23946,7 @@ void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype)
 
 		if (pi->first_cal_after_assoc
 		    || (pi->cal_type_override == PHY_PERICAL_FULL)) {
-			pi->first_cal_after_assoc = FALSE;
+			pi->first_cal_after_assoc = false;
 			wlc_phy_txpwrctrl_idle_tssi_nphy(pi);
 			wlc_phy_txpwrctrl_pwr_setup_nphy(pi);
 		}
@@ -23972,11 +23976,11 @@ void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype)
 		case MPHASE_CAL_STATE_TXPHASE4:
 		case MPHASE_CAL_STATE_TXPHASE5:
 			if ((pi->radar_percal_mask & 0x10) != 0)
-				pi->nphy_rxcal_active = TRUE;
+				pi->nphy_rxcal_active = true;
 
 			if (wlc_phy_cal_txiqlo_nphy
 			    (pi, pi->nphy_cal_target_gain, fullcal,
-			     TRUE) != BCME_OK) {
+			     true) != BCME_OK) {
 
 				wlc_phy_cal_perical_mphase_reset(pi);
 				break;
@@ -23993,22 +23997,22 @@ void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype)
 
 		case MPHASE_CAL_STATE_PAPDCAL:
 			if ((pi->radar_percal_mask & 0x2) != 0)
-				pi->nphy_rxcal_active = TRUE;
+				pi->nphy_rxcal_active = true;
 
 			if (PHY_IPA(pi)) {
-				wlc_phy_a4(pi, TRUE);
+				wlc_phy_a4(pi, true);
 			}
 			pi->mphase_cal_phase_id++;
 			break;
 
 		case MPHASE_CAL_STATE_RXCAL:
 			if ((pi->radar_percal_mask & 0x1) != 0)
-				pi->nphy_rxcal_active = TRUE;
+				pi->nphy_rxcal_active = true;
 			if (wlc_phy_cal_rxiq_nphy(pi, target_gain,
 						  (pi->first_cal_after_assoc ||
 						   (pi->cal_type_override ==
 						    PHY_PERICAL_FULL)) ? 2 : 0,
-						  FALSE) == BCME_OK) {
+						  false) == BCME_OK) {
 				wlc_phy_savecal_nphy(pi);
 			}
 
@@ -24017,14 +24021,14 @@ void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype)
 
 		case MPHASE_CAL_STATE_RSSICAL:
 			if ((pi->radar_percal_mask & 0x4) != 0)
-				pi->nphy_rxcal_active = TRUE;
+				pi->nphy_rxcal_active = true;
 			wlc_phy_txpwrctrl_coeff_setup_nphy(pi);
 			wlc_phy_rssi_cal_nphy(pi);
 
 			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 				wlc_phy_radio205x_vcocal_nphy(pi);
 			}
-			restore_tx_gain = TRUE;
+			restore_tx_gain = true;
 
 			if (pi->first_cal_after_assoc) {
 				pi->mphase_cal_phase_id++;
@@ -24036,10 +24040,10 @@ void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype)
 
 		case MPHASE_CAL_STATE_IDLETSSI:
 			if ((pi->radar_percal_mask & 0x8) != 0)
-				pi->nphy_rxcal_active = TRUE;
+				pi->nphy_rxcal_active = true;
 
 			if (pi->first_cal_after_assoc) {
-				pi->first_cal_after_assoc = FALSE;
+				pi->first_cal_after_assoc = false;
 				wlc_phy_txpwrctrl_idle_tssi_nphy(pi);
 				wlc_phy_txpwrctrl_pwr_setup_nphy(pi);
 			}
@@ -24061,27 +24065,27 @@ void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype)
 				wlc_phy_txpwr_index_nphy(pi, 1,
 							 pi->
 							 nphy_cal_orig_pwr_idx
-							 [0], FALSE);
+							 [0], false);
 				wlc_phy_txpwr_index_nphy(pi, 2,
 							 pi->
 							 nphy_cal_orig_pwr_idx
-							 [1], FALSE);
+							 [1], false);
 
 				pi->nphy_txpwrindex[0].index = -1;
 				pi->nphy_txpwrindex[1].index = -1;
 			} else {
 				wlc_phy_txpwr_index_nphy(pi, (1 << 0),
-							 (int8) (pi->
+							 (s8) (pi->
 								 nphy_txpwrindex
 								 [0].
 								 index_internal),
-							 FALSE);
+							 false);
 				wlc_phy_txpwr_index_nphy(pi, (1 << 1),
-							 (int8) (pi->
+							 (s8) (pi->
 								 nphy_txpwrindex
 								 [1].
 								 index_internal),
-							 FALSE);
+							 false);
 			}
 		}
 	}
@@ -24092,93 +24096,93 @@ void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype)
 }
 
 int
-wlc_phy_cal_txiqlo_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
+wlc_phy_cal_txiqlo_nphy(phy_info_t *pi, nphy_txgains_t target_gain,
 			bool fullcal, bool mphase)
 {
-	uint16 val;
-	uint16 tbl_buf[11];
-	uint8 cal_cnt;
-	uint16 cal_cmd;
-	uint8 num_cals, max_cal_cmds;
-	uint16 core_no, cal_type;
-	uint16 diq_start = 0;
-	uint8 phy_bw;
-	uint16 max_val;
-	uint16 tone_freq;
-	uint16 gain_save[2];
-	uint16 cal_gain[2];
+	u16 val;
+	u16 tbl_buf[11];
+	u8 cal_cnt;
+	u16 cal_cmd;
+	u8 num_cals, max_cal_cmds;
+	u16 core_no, cal_type;
+	u16 diq_start = 0;
+	u8 phy_bw;
+	u16 max_val;
+	u16 tone_freq;
+	u16 gain_save[2];
+	u16 cal_gain[2];
 	nphy_iqcal_params_t cal_params[2];
-	uint32 tbl_len;
+	u32 tbl_len;
 	void *tbl_ptr;
 	bool ladder_updated[2];
-	uint8 mphase_cal_lastphase = 0;
+	u8 mphase_cal_lastphase = 0;
 	int bcmerror = BCME_OK;
-	bool phyhang_avoid_state = FALSE;
+	bool phyhang_avoid_state = false;
 
-	uint16 tbl_tx_iqlo_cal_loft_ladder_20[] = {
+	u16 tbl_tx_iqlo_cal_loft_ladder_20[] = {
 		0x0300, 0x0500, 0x0700, 0x0900, 0x0d00, 0x1100, 0x1900, 0x1901,
 		    0x1902,
 		0x1903, 0x1904, 0x1905, 0x1906, 0x1907, 0x2407, 0x3207, 0x4607,
 		    0x6407
 	};
 
-	uint16 tbl_tx_iqlo_cal_iqimb_ladder_20[] = {
+	u16 tbl_tx_iqlo_cal_iqimb_ladder_20[] = {
 		0x0200, 0x0300, 0x0600, 0x0900, 0x0d00, 0x1100, 0x1900, 0x2400,
 		    0x3200,
 		0x4600, 0x6400, 0x6401, 0x6402, 0x6403, 0x6404, 0x6405, 0x6406,
 		    0x6407
 	};
 
-	uint16 tbl_tx_iqlo_cal_loft_ladder_40[] = {
+	u16 tbl_tx_iqlo_cal_loft_ladder_40[] = {
 		0x0200, 0x0300, 0x0400, 0x0700, 0x0900, 0x0c00, 0x1200, 0x1201,
 		    0x1202,
 		0x1203, 0x1204, 0x1205, 0x1206, 0x1207, 0x1907, 0x2307, 0x3207,
 		    0x4707
 	};
 
-	uint16 tbl_tx_iqlo_cal_iqimb_ladder_40[] = {
+	u16 tbl_tx_iqlo_cal_iqimb_ladder_40[] = {
 		0x0100, 0x0200, 0x0400, 0x0700, 0x0900, 0x0c00, 0x1200, 0x1900,
 		    0x2300,
 		0x3200, 0x4700, 0x4701, 0x4702, 0x4703, 0x4704, 0x4705, 0x4706,
 		    0x4707
 	};
 
-	uint16 tbl_tx_iqlo_cal_startcoefs[] = {
+	u16 tbl_tx_iqlo_cal_startcoefs[] = {
 		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 		    0x0000
 	};
 
-	uint16 tbl_tx_iqlo_cal_cmds_fullcal[] = {
+	u16 tbl_tx_iqlo_cal_cmds_fullcal[] = {
 		0x8123, 0x8264, 0x8086, 0x8245, 0x8056,
 		0x9123, 0x9264, 0x9086, 0x9245, 0x9056
 	};
 
-	uint16 tbl_tx_iqlo_cal_cmds_recal[] = {
+	u16 tbl_tx_iqlo_cal_cmds_recal[] = {
 		0x8101, 0x8253, 0x8053, 0x8234, 0x8034,
 		0x9101, 0x9253, 0x9053, 0x9234, 0x9034
 	};
 
-	uint16 tbl_tx_iqlo_cal_startcoefs_nphyrev3[] = {
+	u16 tbl_tx_iqlo_cal_startcoefs_nphyrev3[] = {
 		0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 		0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 		0x0000
 	};
 
-	uint16 tbl_tx_iqlo_cal_cmds_fullcal_nphyrev3[] = {
+	u16 tbl_tx_iqlo_cal_cmds_fullcal_nphyrev3[] = {
 		0x8434, 0x8334, 0x8084, 0x8267, 0x8056, 0x8234,
 		0x9434, 0x9334, 0x9084, 0x9267, 0x9056, 0x9234
 	};
 
-	uint16 tbl_tx_iqlo_cal_cmds_recal_nphyrev3[] = {
+	u16 tbl_tx_iqlo_cal_cmds_recal_nphyrev3[] = {
 		0x8423, 0x8323, 0x8073, 0x8256, 0x8045, 0x8223,
 		0x9423, 0x9323, 0x9073, 0x9256, 0x9045, 0x9223
 	};
 
-	wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+	wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	if (NREV_GE(pi->pubpi.phy_rev, 4)) {
 		phyhang_avoid_state = pi->phyhang_avoid;
-		pi->phyhang_avoid = FALSE;
+		pi->phyhang_avoid = false;
 	}
 
 	if (CHSPEC_IS40(pi->radio_chanspec)) {
@@ -24201,27 +24205,27 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
 
 	wlc_phy_txcal_physetup_nphy(pi);
 
-	ladder_updated[0] = ladder_updated[1] = FALSE;
+	ladder_updated[0] = ladder_updated[1] = false;
 	if (!(NREV_GE(pi->pubpi.phy_rev, 6) ||
 	      (NREV_IS(pi->pubpi.phy_rev, 5) && PHY_IPA(pi)
 	       && (CHSPEC_IS2G(pi->radio_chanspec))))) {
 
 		if (phy_bw == 40) {
 			tbl_ptr = tbl_tx_iqlo_cal_loft_ladder_40;
-			tbl_len = ARRAYSIZE(tbl_tx_iqlo_cal_loft_ladder_40);
+			tbl_len = ARRAY_SIZE(tbl_tx_iqlo_cal_loft_ladder_40);
 		} else {
 			tbl_ptr = tbl_tx_iqlo_cal_loft_ladder_20;
-			tbl_len = ARRAYSIZE(tbl_tx_iqlo_cal_loft_ladder_20);
+			tbl_len = ARRAY_SIZE(tbl_tx_iqlo_cal_loft_ladder_20);
 		}
 		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, tbl_len, 0,
 					 16, tbl_ptr);
 
 		if (phy_bw == 40) {
 			tbl_ptr = tbl_tx_iqlo_cal_iqimb_ladder_40;
-			tbl_len = ARRAYSIZE(tbl_tx_iqlo_cal_iqimb_ladder_40);
+			tbl_len = ARRAY_SIZE(tbl_tx_iqlo_cal_iqimb_ladder_40);
 		} else {
 			tbl_ptr = tbl_tx_iqlo_cal_iqimb_ladder_20;
-			tbl_len = ARRAYSIZE(tbl_tx_iqlo_cal_iqimb_ladder_20);
+			tbl_len = ARRAY_SIZE(tbl_tx_iqlo_cal_iqimb_ladder_20);
 		}
 		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, tbl_len, 32,
 					 16, tbl_ptr);
@@ -24237,18 +24241,18 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
 	tone_freq = (phy_bw == 20) ? 2500 : 5000;
 
 	if (pi->mphase_cal_phase_id > MPHASE_CAL_STATE_TXPHASE0) {
-		wlc_phy_runsamples_nphy(pi, phy_bw * 8, 0xffff, 0, 1, 0, FALSE);
+		wlc_phy_runsamples_nphy(pi, phy_bw * 8, 0xffff, 0, 1, 0, false);
 		bcmerror = BCME_OK;
 	} else {
 		bcmerror =
-		    wlc_phy_tx_tone_nphy(pi, tone_freq, max_val, 1, 0, FALSE);
+		    wlc_phy_tx_tone_nphy(pi, tone_freq, max_val, 1, 0, false);
 	}
 
 	if (bcmerror == BCME_OK) {
 
 		if (pi->mphase_cal_phase_id > MPHASE_CAL_STATE_TXPHASE0) {
 			tbl_ptr = pi->mphase_txcal_bestcoeffs;
-			tbl_len = ARRAYSIZE(pi->mphase_txcal_bestcoeffs);
+			tbl_len = ARRAY_SIZE(pi->mphase_txcal_bestcoeffs);
 			if (NREV_LT(pi->pubpi.phy_rev, 3)) {
 
 				tbl_len -= 2;
@@ -24257,25 +24261,25 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
 			if ((!fullcal) && (pi->nphy_txiqlocal_coeffsvalid)) {
 
 				tbl_ptr = pi->nphy_txiqlocal_bestc;
-				tbl_len = ARRAYSIZE(pi->nphy_txiqlocal_bestc);
+				tbl_len = ARRAY_SIZE(pi->nphy_txiqlocal_bestc);
 				if (NREV_LT(pi->pubpi.phy_rev, 3)) {
 
 					tbl_len -= 2;
 				}
 			} else {
 
-				fullcal = TRUE;
+				fullcal = true;
 
 				if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 					tbl_ptr =
 					    tbl_tx_iqlo_cal_startcoefs_nphyrev3;
 					tbl_len =
-					    ARRAYSIZE
+					    ARRAY_SIZE
 					    (tbl_tx_iqlo_cal_startcoefs_nphyrev3);
 				} else {
 					tbl_ptr = tbl_tx_iqlo_cal_startcoefs;
 					tbl_len =
-					    ARRAYSIZE
+					    ARRAY_SIZE
 					    (tbl_tx_iqlo_cal_startcoefs);
 				}
 			}
@@ -24285,12 +24289,12 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
 
 		if (fullcal) {
 			max_cal_cmds = (NREV_GE(pi->pubpi.phy_rev, 3)) ?
-			    ARRAYSIZE(tbl_tx_iqlo_cal_cmds_fullcal_nphyrev3) :
-			    ARRAYSIZE(tbl_tx_iqlo_cal_cmds_fullcal);
+			    ARRAY_SIZE(tbl_tx_iqlo_cal_cmds_fullcal_nphyrev3) :
+			    ARRAY_SIZE(tbl_tx_iqlo_cal_cmds_fullcal);
 		} else {
 			max_cal_cmds = (NREV_GE(pi->pubpi.phy_rev, 3)) ?
-			    ARRAYSIZE(tbl_tx_iqlo_cal_cmds_recal_nphyrev3) :
-			    ARRAYSIZE(tbl_tx_iqlo_cal_cmds_recal);
+			    ARRAY_SIZE(tbl_tx_iqlo_cal_cmds_recal_nphyrev3) :
+			    ARRAY_SIZE(tbl_tx_iqlo_cal_cmds_recal);
 		}
 
 		if (mphase) {
@@ -24328,7 +24332,7 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
 				if (!ladder_updated[core_no]) {
 					wlc_phy_update_txcal_ladder_nphy(pi,
 									 core_no);
-					ladder_updated[core_no] = TRUE;
+					ladder_updated[core_no] = true;
 				}
 			}
 
@@ -24410,7 +24414,7 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
 			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, 2, 93,
 						 16, tbl_buf);
 
-			tbl_len = ARRAYSIZE(pi->nphy_txiqlocal_bestc);
+			tbl_len = ARRAY_SIZE(pi->nphy_txiqlocal_bestc);
 			if (NREV_LT(pi->pubpi.phy_rev, 3)) {
 
 				tbl_len -= 2;
@@ -24419,10 +24423,10 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
 						tbl_len, 96, 16,
 						pi->nphy_txiqlocal_bestc);
 
-			pi->nphy_txiqlocal_coeffsvalid = TRUE;
+			pi->nphy_txiqlocal_coeffsvalid = true;
 			pi->nphy_txiqlocal_chanspec = pi->radio_chanspec;
 		} else {
-			tbl_len = ARRAYSIZE(pi->mphase_txcal_bestcoeffs);
+			tbl_len = ARRAY_SIZE(pi->mphase_txcal_bestcoeffs);
 			if (NREV_LT(pi->pubpi.phy_rev, 3)) {
 
 				tbl_len -= 2;
@@ -24455,21 +24459,21 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
 		pi->phyhang_avoid = phyhang_avoid_state;
 	}
 
-	wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+	wlc_phy_stay_in_carriersearch_nphy(pi, false);
 
 	return bcmerror;
 }
 
-static void wlc_phy_reapply_txcal_coeffs_nphy(phy_info_t * pi)
+static void wlc_phy_reapply_txcal_coeffs_nphy(phy_info_t *pi)
 {
-	uint16 tbl_buf[7];
+	u16 tbl_buf[7];
 
 	ASSERT(NREV_LT(pi->pubpi.phy_rev, 2));
 
 	if ((pi->nphy_txiqlocal_chanspec == pi->radio_chanspec) &&
 	    (pi->nphy_txiqlocal_coeffsvalid)) {
 		wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_IQLOCAL,
-					ARRAYSIZE(tbl_buf), 80, 16, tbl_buf);
+					ARRAY_SIZE(tbl_buf), 80, 16, tbl_buf);
 
 		if ((pi->nphy_txiqlocal_bestc[0] != tbl_buf[0]) ||
 		    (pi->nphy_txiqlocal_bestc[1] != tbl_buf[1]) ||
@@ -24497,7 +24501,7 @@ static void wlc_phy_reapply_txcal_coeffs_nphy(phy_info_t * pi)
 	}
 }
 
-static void wlc_phy_tx_iq_war_nphy(phy_info_t * pi)
+static void wlc_phy_tx_iq_war_nphy(phy_info_t *pi)
 {
 	nphy_iq_comp_t tx_comp;
 
@@ -24510,7 +24514,7 @@ static void wlc_phy_tx_iq_war_nphy(phy_info_t * pi)
 }
 
 void
-wlc_phy_rx_iq_coeffs_nphy(phy_info_t * pi, uint8 write, nphy_iq_comp_t * pcomp)
+wlc_phy_rx_iq_coeffs_nphy(phy_info_t *pi, u8 write, nphy_iq_comp_t *pcomp)
 {
 	if (write) {
 		write_phy_reg(pi, 0x9a, pcomp->a0);
@@ -24526,10 +24530,10 @@ wlc_phy_rx_iq_coeffs_nphy(phy_info_t * pi, uint8 write, nphy_iq_comp_t * pcomp)
 }
 
 void
-wlc_phy_rx_iq_est_nphy(phy_info_t * pi, phy_iq_est_t * est, uint16 num_samps,
-		       uint8 wait_time, uint8 wait_for_crs)
+wlc_phy_rx_iq_est_nphy(phy_info_t *pi, phy_iq_est_t *est, u16 num_samps,
+		       u8 wait_time, u8 wait_for_crs)
 {
-	uint8 core;
+	u8 core;
 
 	write_phy_reg(pi, 0x12b, num_samps);
 	mod_phy_reg(pi, 0x12a, (0xff << 0), (wait_time << 0));
@@ -24559,15 +24563,15 @@ wlc_phy_rx_iq_est_nphy(phy_info_t * pi, phy_iq_est_t * est, uint16 num_samps,
 }
 
 #define CAL_RETRY_CNT 2
-static void wlc_phy_calc_rx_iq_comp_nphy(phy_info_t * pi, uint8 core_mask)
+static void wlc_phy_calc_rx_iq_comp_nphy(phy_info_t *pi, u8 core_mask)
 {
-	uint8 curr_core;
+	u8 curr_core;
 	phy_iq_est_t est[PHY_CORE_MAX];
 	nphy_iq_comp_t old_comp, new_comp;
-	int32 iq = 0;
-	uint32 ii = 0, qq = 0;
-	int16 iq_nbits, qq_nbits, brsh, arsh;
-	int32 a, b, temp;
+	s32 iq = 0;
+	u32 ii = 0, qq = 0;
+	s16 iq_nbits, qq_nbits, brsh, arsh;
+	s32 a, b, temp;
 	int bcmerror = BCME_OK;
 	uint cal_retry = 0;
 
@@ -24608,14 +24612,14 @@ static void wlc_phy_calc_rx_iq_comp_nphy(phy_info_t * pi, uint8 core_mask)
 		arsh = 10 - (30 - iq_nbits);
 		if (arsh >= 0) {
 			a = (-(iq << (30 - iq_nbits)) + (ii >> (1 + arsh)));
-			temp = (int32) (ii >> arsh);
+			temp = (s32) (ii >> arsh);
 			if (temp == 0) {
 				bcmerror = BCME_ERROR;
 				break;
 			}
 		} else {
 			a = (-(iq << (30 - iq_nbits)) + (ii << (-1 - arsh)));
-			temp = (int32) (ii << -arsh);
+			temp = (s32) (ii << -arsh);
 			if (temp == 0) {
 				bcmerror = BCME_ERROR;
 				break;
@@ -24627,14 +24631,14 @@ static void wlc_phy_calc_rx_iq_comp_nphy(phy_info_t * pi, uint8 core_mask)
 		brsh = qq_nbits - 31 + 20;
 		if (brsh >= 0) {
 			b = (qq << (31 - qq_nbits));
-			temp = (int32) (ii >> brsh);
+			temp = (s32) (ii >> brsh);
 			if (temp == 0) {
 				bcmerror = BCME_ERROR;
 				break;
 			}
 		} else {
 			b = (qq << (31 - qq_nbits));
-			temp = (int32) (ii << -brsh);
+			temp = (s32) (ii << -brsh);
 			if (temp == 0) {
 				bcmerror = BCME_ERROR;
 				break;
@@ -24642,27 +24646,27 @@ static void wlc_phy_calc_rx_iq_comp_nphy(phy_info_t * pi, uint8 core_mask)
 		}
 		b /= temp;
 		b -= a * a;
-		b = (int32) wlc_phy_sqrt_int((uint32) b);
+		b = (s32) wlc_phy_sqrt_int((u32) b);
 		b -= (1 << 10);
 
 		if ((curr_core == PHY_CORE_0) && (core_mask & 0x1)) {
 			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
-				new_comp.a0 = (int16) a & 0x3ff;
-				new_comp.b0 = (int16) b & 0x3ff;
+				new_comp.a0 = (s16) a & 0x3ff;
+				new_comp.b0 = (s16) b & 0x3ff;
 			} else {
 
-				new_comp.a0 = (int16) b & 0x3ff;
-				new_comp.b0 = (int16) a & 0x3ff;
+				new_comp.a0 = (s16) b & 0x3ff;
+				new_comp.b0 = (s16) a & 0x3ff;
 			}
 		}
 		if ((curr_core == PHY_CORE_1) && (core_mask & 0x2)) {
 			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
-				new_comp.a1 = (int16) a & 0x3ff;
-				new_comp.b1 = (int16) b & 0x3ff;
+				new_comp.a1 = (s16) a & 0x3ff;
+				new_comp.b1 = (s16) b & 0x3ff;
 			} else {
 
-				new_comp.a1 = (int16) b & 0x3ff;
-				new_comp.b1 = (int16) a & 0x3ff;
+				new_comp.a1 = (s16) b & 0x3ff;
+				new_comp.b1 = (s16) a & 0x3ff;
 			}
 		}
 	}
@@ -24682,11 +24686,11 @@ static void wlc_phy_calc_rx_iq_comp_nphy(phy_info_t * pi, uint8 core_mask)
 	wlc_phy_rx_iq_coeffs_nphy(pi, 1, &new_comp);
 }
 
-static void wlc_phy_rxcal_radio_setup_nphy(phy_info_t * pi, uint8 rx_core)
+static void wlc_phy_rxcal_radio_setup_nphy(phy_info_t *pi, u8 rx_core)
 {
-	uint16 offtune_val;
-	uint16 bias_g = 0;
-	uint16 bias_a = 0;
+	u16 offtune_val;
+	u16 bias_g = 0;
+	u16 bias_a = 0;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 		if (rx_core == PHY_CORE_0) {
@@ -24979,7 +24983,7 @@ static void wlc_phy_rxcal_radio_setup_nphy(phy_info_t * pi, uint8 rx_core)
 	}
 }
 
-static void wlc_phy_rxcal_radio_cleanup_nphy(phy_info_t * pi, uint8 rx_core)
+static void wlc_phy_rxcal_radio_cleanup_nphy(phy_info_t *pi, u8 rx_core)
 {
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 		if (rx_core == PHY_CORE_0) {
@@ -25149,10 +25153,10 @@ static void wlc_phy_rxcal_radio_cleanup_nphy(phy_info_t * pi, uint8 rx_core)
 	}
 }
 
-static void wlc_phy_rxcal_physetup_nphy(phy_info_t * pi, uint8 rx_core)
+static void wlc_phy_rxcal_physetup_nphy(phy_info_t *pi, u8 rx_core)
 {
-	uint8 tx_core;
-	uint16 rx_antval, tx_antval;
+	u8 tx_core;
+	u16 rx_antval, tx_antval;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 
@@ -25276,7 +25280,7 @@ static void wlc_phy_rxcal_physetup_nphy(phy_info_t * pi, uint8 rx_core)
 	}
 }
 
-static void wlc_phy_rxcal_phycleanup_nphy(phy_info_t * pi, uint8 rx_core)
+static void wlc_phy_rxcal_phycleanup_nphy(phy_info_t *pi, u8 rx_core)
 {
 
 	write_phy_reg(pi, 0xa2, pi->tx_rx_cal_phy_saveregs[0]);
@@ -25303,27 +25307,27 @@ static void wlc_phy_rxcal_phycleanup_nphy(phy_info_t * pi, uint8 rx_core)
 }
 
 static void
-wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t * pi, uint8 rx_core,
-				 uint16 * rxgain, uint8 cal_type)
+wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t *pi, u8 rx_core,
+				 u16 *rxgain, u8 cal_type)
 {
 
-	uint16 num_samps;
+	u16 num_samps;
 	phy_iq_est_t est[PHY_CORE_MAX];
-	uint8 tx_core;
+	u8 tx_core;
 	nphy_iq_comp_t save_comp, zero_comp;
-	uint32 i_pwr, q_pwr, curr_pwr, optim_pwr = 0, prev_pwr = 0, thresh_pwr =
+	u32 i_pwr, q_pwr, curr_pwr, optim_pwr = 0, prev_pwr = 0, thresh_pwr =
 	    10000;
-	int16 desired_log2_pwr, actual_log2_pwr, delta_pwr;
-	bool gainctrl_done = FALSE;
-	uint8 mix_tia_gain = 3;
-	int8 optim_gaintbl_index = 0, prev_gaintbl_index = 0;
-	int8 curr_gaintbl_index = 3;
-	uint8 gainctrl_dirn = NPHY_RXCAL_GAIN_INIT;
+	s16 desired_log2_pwr, actual_log2_pwr, delta_pwr;
+	bool gainctrl_done = false;
+	u8 mix_tia_gain = 3;
+	s8 optim_gaintbl_index = 0, prev_gaintbl_index = 0;
+	s8 curr_gaintbl_index = 3;
+	u8 gainctrl_dirn = NPHY_RXCAL_GAIN_INIT;
 	nphy_ipa_txrxgain_t *nphy_rxcal_gaintbl;
-	uint16 hpvga, lpf_biq1, lpf_biq0, lna2, lna1;
-	int16 fine_gain_idx;
-	int8 txpwrindex;
-	uint16 nphy_rxcal_txgain[2];
+	u16 hpvga, lpf_biq1, lpf_biq0, lna2, lna1;
+	int fine_gain_idx;
+	s8 txpwrindex;
+	u16 nphy_rxcal_txgain[2];
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 
@@ -25398,13 +25402,13 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t * pi, uint8 rx_core,
 						 nphy_rxcal_txgain);
 		} else {
 			wlc_phy_txpwr_index_nphy(pi, tx_core + 1, txpwrindex,
-						 FALSE);
+						 false);
 		}
 
 		wlc_phy_tx_tone_nphy(pi, (CHSPEC_IS40(pi->radio_chanspec)) ?
 				     NPHY_RXCAL_TONEFREQ_40MHz :
 				     NPHY_RXCAL_TONEFREQ_20MHz,
-				     NPHY_RXCAL_TONEAMP, 0, cal_type, FALSE);
+				     NPHY_RXCAL_TONEAMP, 0, cal_type, false);
 
 		wlc_phy_rx_iq_est_nphy(pi, est, num_samps, 32, 0);
 		i_pwr = (est[rx_core].i_pwr + num_samps / 2) / num_samps;
@@ -25426,7 +25430,7 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t * pi, uint8 rx_core,
 
 		case NPHY_RXCAL_GAIN_UP:
 			if (curr_pwr > thresh_pwr) {
-				gainctrl_done = TRUE;
+				gainctrl_done = true;
 				optim_pwr = prev_pwr;
 				optim_gaintbl_index = prev_gaintbl_index;
 			} else {
@@ -25440,7 +25444,7 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t * pi, uint8 rx_core,
 				prev_gaintbl_index = curr_gaintbl_index;
 				curr_gaintbl_index--;
 			} else {
-				gainctrl_done = TRUE;
+				gainctrl_done = true;
 				optim_pwr = curr_pwr;
 				optim_gaintbl_index = curr_gaintbl_index;
 			}
@@ -25452,7 +25456,7 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t * pi, uint8 rx_core,
 
 		if ((curr_gaintbl_index < 0) ||
 		    (curr_gaintbl_index > NPHY_IPA_RXCAL_MAXGAININDEX)) {
-			gainctrl_done = TRUE;
+			gainctrl_done = true;
 			optim_pwr = curr_pwr;
 			optim_gaintbl_index = prev_gaintbl_index;
 		} else {
@@ -25478,7 +25482,7 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t * pi, uint8 rx_core,
 		if (fine_gain_idx + (int)lpf_biq0 > 10) {
 			lpf_biq1 = 10 - lpf_biq0;
 		} else {
-			lpf_biq1 = (uint16) MAX(fine_gain_idx, 0);
+			lpf_biq1 = (u16) max(fine_gain_idx, 0);
 		}
 		wlc_phy_rfctrl_override_1tomany_nphy(pi,
 						     NPHY_REV7_RfctrlOverride_cmd_rxgain,
@@ -25488,7 +25492,7 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t * pi, uint8 rx_core,
 						      (lna2 << 2) | lna1), 0x3,
 						     0);
 	} else {
-		hpvga = (uint16) MAX(MIN(((int)hpvga) + delta_pwr, 10), 0);
+		hpvga = (u16) max(min(((int)hpvga) + delta_pwr, 10), 0);
 		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 12),
 					     ((hpvga << 12) | (lpf_biq1 << 10) |
 					      (lpf_biq0 << 8) | (mix_tia_gain <<
@@ -25511,45 +25515,45 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t * pi, uint8 rx_core,
 }
 
 static void
-wlc_phy_rxcal_gainctrl_nphy(phy_info_t * pi, uint8 rx_core, uint16 * rxgain,
-			    uint8 cal_type)
+wlc_phy_rxcal_gainctrl_nphy(phy_info_t *pi, u8 rx_core, u16 *rxgain,
+			    u8 cal_type)
 {
 	wlc_phy_rxcal_gainctrl_nphy_rev5(pi, rx_core, rxgain, cal_type);
 }
 
-static uint8
-wlc_phy_rc_sweep_nphy(phy_info_t * pi, uint8 core_idx, uint8 loopback_type)
+static u8
+wlc_phy_rc_sweep_nphy(phy_info_t *pi, u8 core_idx, u8 loopback_type)
 {
-	uint32 target_bws[2] = { 9500, 21000 };
-	uint32 ref_tones[2] = { 3000, 6000 };
-	uint32 target_bw, ref_tone;
-
-	uint32 target_pwr_ratios[2] = { 28606, 18468 };
-	uint32 target_pwr_ratio, pwr_ratio, last_pwr_ratio = 0;
-
-	uint16 start_rccal_ovr_val = 128;
-	uint16 txlpf_rccal_lpc_ovr_val = 128;
-	uint16 rxlpf_rccal_hpc_ovr_val = 159;
-
-	uint16 orig_txlpf_rccal_lpc_ovr_val;
-	uint16 orig_rxlpf_rccal_hpc_ovr_val;
-	uint16 radio_addr_offset_rx;
-	uint16 radio_addr_offset_tx;
-	uint16 orig_dcBypass;
-	uint16 orig_RxStrnFilt40Num[6];
-	uint16 orig_RxStrnFilt40Den[4];
-	uint16 orig_rfctrloverride[2];
-	uint16 orig_rfctrlauxreg[2];
-	uint16 orig_rfctrlrssiothers;
-	uint16 tx_lpf_bw = 4;
-
-	uint16 rx_lpf_bw, rx_lpf_bws[2] = { 2, 4 };
-	uint16 lpf_hpc = 7, hpvga_hpc = 7;
-
-	int8 rccal_stepsize;
-	uint16 rccal_val, last_rccal_val = 0, best_rccal_val = 0;
-	uint32 ref_iq_vals = 0, target_iq_vals = 0;
-	uint16 num_samps, log_num_samps = 10;
+	u32 target_bws[2] = { 9500, 21000 };
+	u32 ref_tones[2] = { 3000, 6000 };
+	u32 target_bw, ref_tone;
+
+	u32 target_pwr_ratios[2] = { 28606, 18468 };
+	u32 target_pwr_ratio, pwr_ratio, last_pwr_ratio = 0;
+
+	u16 start_rccal_ovr_val = 128;
+	u16 txlpf_rccal_lpc_ovr_val = 128;
+	u16 rxlpf_rccal_hpc_ovr_val = 159;
+
+	u16 orig_txlpf_rccal_lpc_ovr_val;
+	u16 orig_rxlpf_rccal_hpc_ovr_val;
+	u16 radio_addr_offset_rx;
+	u16 radio_addr_offset_tx;
+	u16 orig_dcBypass;
+	u16 orig_RxStrnFilt40Num[6];
+	u16 orig_RxStrnFilt40Den[4];
+	u16 orig_rfctrloverride[2];
+	u16 orig_rfctrlauxreg[2];
+	u16 orig_rfctrlrssiothers;
+	u16 tx_lpf_bw = 4;
+
+	u16 rx_lpf_bw, rx_lpf_bws[2] = { 2, 4 };
+	u16 lpf_hpc = 7, hpvga_hpc = 7;
+
+	s8 rccal_stepsize;
+	u16 rccal_val, last_rccal_val = 0, best_rccal_val = 0;
+	u32 ref_iq_vals = 0, target_iq_vals = 0;
+	u16 num_samps, log_num_samps = 10;
 	phy_iq_est_t est[PHY_CORE_MAX];
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -25652,26 +25656,26 @@ wlc_phy_rc_sweep_nphy(phy_info_t * pi, uint8 core_idx, uint8 loopback_type)
 		if (rccal_stepsize == 16) {
 
 			wlc_phy_tx_tone_nphy(pi, ref_tone, NPHY_RXCAL_TONEAMP,
-					     0, 1, FALSE);
-			OSL_DELAY(2);
+					     0, 1, false);
+			udelay(2);
 
 			wlc_phy_rx_iq_est_nphy(pi, est, num_samps, 32, 0);
 
 			if (core_idx == 0) {
 				ref_iq_vals =
-				    MAX((est[0].i_pwr +
+				    max_t(u32, (est[0].i_pwr +
 					 est[0].q_pwr) >> (log_num_samps + 1),
 					1);
 			} else {
 				ref_iq_vals =
-				    MAX((est[1].i_pwr +
+				    max_t(u32, (est[1].i_pwr +
 					 est[1].q_pwr) >> (log_num_samps + 1),
 					1);
 			}
 
 			wlc_phy_tx_tone_nphy(pi, target_bw, NPHY_RXCAL_TONEAMP,
-					     0, 1, FALSE);
-			OSL_DELAY(2);
+					     0, 1, false);
+			udelay(2);
 		}
 
 		wlc_phy_rx_iq_est_nphy(pi, est, num_samps, 32, 0);
@@ -25752,36 +25756,36 @@ wlc_phy_rc_sweep_nphy(phy_info_t * pi, uint8 core_idx, uint8 loopback_type)
 	write_phy_reg(pi, 0xfa, orig_rfctrlauxreg[1]);
 	write_phy_reg(pi, (core_idx == 0) ? 0x7a : 0x7d, orig_rfctrlrssiothers);
 
-	pi->nphy_anarxlpf_adjusted = FALSE;
+	pi->nphy_anarxlpf_adjusted = false;
 
-	return (best_rccal_val - 0x80);
+	return best_rccal_val - 0x80;
 }
 
-#define WAIT_FOR_SCOPE	4000000
+#define WAIT_FOR_SCOPE	4000
 static int
-wlc_phy_cal_rxiq_nphy_rev3(phy_info_t * pi, nphy_txgains_t target_gain,
-			   uint8 cal_type, bool debug)
+wlc_phy_cal_rxiq_nphy_rev3(phy_info_t *pi, nphy_txgains_t target_gain,
+			   u8 cal_type, bool debug)
 {
-	uint16 orig_BBConfig;
-	uint8 core_no, rx_core;
-	uint8 best_rccal[2];
-	uint16 gain_save[2];
-	uint16 cal_gain[2];
+	u16 orig_BBConfig;
+	u8 core_no, rx_core;
+	u8 best_rccal[2];
+	u16 gain_save[2];
+	u16 cal_gain[2];
 	nphy_iqcal_params_t cal_params[2];
-	uint8 rxcore_state;
-	int8 rxlpf_rccal_hpc, txlpf_rccal_lpc;
-	int8 txlpf_idac;
-	bool phyhang_avoid_state = FALSE;
-	bool skip_rxiqcal = FALSE;
+	u8 rxcore_state;
+	s8 rxlpf_rccal_hpc, txlpf_rccal_lpc;
+	s8 txlpf_idac;
+	bool phyhang_avoid_state = false;
+	bool skip_rxiqcal = false;
 
 	orig_BBConfig = read_phy_reg(pi, 0x01);
 	mod_phy_reg(pi, 0x01, (0x1 << 15), 0);
 
-	wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+	wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	if (NREV_GE(pi->pubpi.phy_rev, 4)) {
 		phyhang_avoid_state = pi->phyhang_avoid;
-		pi->phyhang_avoid = FALSE;
+		pi->phyhang_avoid = false;
 	}
 
 	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16, gain_save);
@@ -25799,7 +25803,7 @@ wlc_phy_cal_rxiq_nphy_rev3(phy_info_t * pi, nphy_txgains_t target_gain,
 	for (rx_core = 0; rx_core < pi->pubpi.phy_corenum; rx_core++) {
 
 		skip_rxiqcal =
-		    ((rxcore_state & (1 << rx_core)) == 0) ? TRUE : FALSE;
+		    ((rxcore_state & (1 << rx_core)) == 0) ? true : false;
 
 		wlc_phy_rxcal_physetup_nphy(pi, rx_core);
 
@@ -25814,10 +25818,10 @@ wlc_phy_cal_rxiq_nphy_rev3(phy_info_t * pi, nphy_txgains_t target_gain,
 					     NPHY_RXCAL_TONEFREQ_40MHz :
 					     NPHY_RXCAL_TONEFREQ_20MHz,
 					     NPHY_RXCAL_TONEAMP, 0, cal_type,
-					     FALSE);
+					     false);
 
 			if (debug)
-				OSL_DELAY(WAIT_FOR_SCOPE);
+				mdelay(WAIT_FOR_SCOPE);
 
 			wlc_phy_calc_rx_iq_comp_nphy(pi, rx_core + 1);
 			wlc_phy_stopplayback_nphy(pi);
@@ -25873,8 +25877,8 @@ wlc_phy_cal_rxiq_nphy_rev3(phy_info_t * pi, nphy_txgains_t target_gain,
 						 TXLPF_IDAC_4, txlpf_idac);
 			}
 
-			rxlpf_rccal_hpc = MAX(MIN(rxlpf_rccal_hpc, 31), 0);
-			txlpf_rccal_lpc = MAX(MIN(txlpf_rccal_lpc, 31), 0);
+			rxlpf_rccal_hpc = max(min_t(u8, rxlpf_rccal_hpc, 31), 0);
+			txlpf_rccal_lpc = max(min_t(u8, txlpf_rccal_lpc, 31), 0);
 
 			write_radio_reg(pi, (RADIO_2056_RX_RXLPF_RCCAL_HPC |
 					     ((rx_core ==
@@ -25910,37 +25914,37 @@ wlc_phy_cal_rxiq_nphy_rev3(phy_info_t * pi, nphy_txgains_t target_gain,
 		pi->phyhang_avoid = phyhang_avoid_state;
 	}
 
-	wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+	wlc_phy_stay_in_carriersearch_nphy(pi, false);
 
 	return BCME_OK;
 }
 
 static int
-wlc_phy_cal_rxiq_nphy_rev2(phy_info_t * pi, nphy_txgains_t target_gain,
+wlc_phy_cal_rxiq_nphy_rev2(phy_info_t *pi, nphy_txgains_t target_gain,
 			   bool debug)
 {
 	phy_iq_est_t est[PHY_CORE_MAX];
-	uint8 core_num, rx_core, tx_core;
-	uint16 lna_vals[] = { 0x3, 0x3, 0x1 };
-	uint16 hpf1_vals[] = { 0x7, 0x2, 0x0 };
-	uint16 hpf2_vals[] = { 0x2, 0x0, 0x0 };
-	int16 curr_hpf1, curr_hpf2, curr_hpf, curr_lna;
-	int16 desired_log2_pwr, actual_log2_pwr, hpf_change;
-	uint16 orig_RfseqCoreActv, orig_AfectrlCore, orig_AfectrlOverride;
-	uint16 orig_RfctrlIntcRx, orig_RfctrlIntcTx;
-	uint16 num_samps;
-	uint32 i_pwr, q_pwr, tot_pwr[3];
-	uint8 gain_pass, use_hpf_num;
-	uint16 mask, val1, val2;
-	uint16 core_no;
-	uint16 gain_save[2];
-	uint16 cal_gain[2];
+	u8 core_num, rx_core, tx_core;
+	u16 lna_vals[] = { 0x3, 0x3, 0x1 };
+	u16 hpf1_vals[] = { 0x7, 0x2, 0x0 };
+	u16 hpf2_vals[] = { 0x2, 0x0, 0x0 };
+	s16 curr_hpf1, curr_hpf2, curr_hpf, curr_lna;
+	s16 desired_log2_pwr, actual_log2_pwr, hpf_change;
+	u16 orig_RfseqCoreActv, orig_AfectrlCore, orig_AfectrlOverride;
+	u16 orig_RfctrlIntcRx, orig_RfctrlIntcTx;
+	u16 num_samps;
+	u32 i_pwr, q_pwr, tot_pwr[3];
+	u8 gain_pass, use_hpf_num;
+	u16 mask, val1, val2;
+	u16 core_no;
+	u16 gain_save[2];
+	u16 cal_gain[2];
 	nphy_iqcal_params_t cal_params[2];
-	uint8 phy_bw;
+	u8 phy_bw;
 	int bcmerror = BCME_OK;
-	bool first_playtone = TRUE;
+	bool first_playtone = true;
 
-	wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+	wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	if (NREV_LT(pi->pubpi.phy_rev, 2)) {
 
@@ -26018,7 +26022,7 @@ wlc_phy_cal_rxiq_nphy_rev2(phy_info_t * pi, nphy_txgains_t target_gain,
 		for (gain_pass = 0; gain_pass < 4; gain_pass++) {
 
 			if (debug)
-				OSL_DELAY(WAIT_FOR_SCOPE);
+				mdelay(WAIT_FOR_SCOPE);
 
 			if (gain_pass < 3) {
 				curr_lna = lna_vals[gain_pass];
@@ -26056,7 +26060,7 @@ wlc_phy_cal_rxiq_nphy_rev2(phy_info_t * pi, nphy_txgains_t target_gain,
 
 				hpf_change = desired_log2_pwr - actual_log2_pwr;
 				curr_hpf += hpf_change;
-				curr_hpf = MAX(MIN(curr_hpf, 10), 0);
+				curr_hpf = max(min_t(u16, curr_hpf, 10), 0);
 				if (use_hpf_num == 1) {
 					curr_hpf1 = curr_hpf;
 				} else {
@@ -26074,17 +26078,17 @@ wlc_phy_cal_rxiq_nphy_rev2(phy_info_t * pi, nphy_txgains_t target_gain,
 
 			if (first_playtone) {
 				bcmerror = wlc_phy_tx_tone_nphy(pi, 4000,
-								(uint16) (pi->
+								(u16) (pi->
 									  nphy_rxcalparams
 									  &
 									  0xffff),
-								0, 0, TRUE);
-				first_playtone = FALSE;
+								0, 0, true);
+				first_playtone = false;
 			} else {
 				phy_bw =
 				    (CHSPEC_IS40(pi->radio_chanspec)) ? 40 : 20;
 				wlc_phy_runsamples_nphy(pi, phy_bw * 8, 0xffff,
-							0, 0, 0, TRUE);
+							0, 0, 0, true);
 			}
 
 			if (bcmerror == BCME_OK) {
@@ -26136,14 +26140,14 @@ wlc_phy_cal_rxiq_nphy_rev2(phy_info_t * pi, nphy_txgains_t target_gain,
 	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16,
 				 gain_save);
 
-	wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+	wlc_phy_stay_in_carriersearch_nphy(pi, false);
 
 	return bcmerror;
 }
 
 int
-wlc_phy_cal_rxiq_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
-		      uint8 cal_type, bool debug)
+wlc_phy_cal_rxiq_nphy(phy_info_t *pi, nphy_txgains_t target_gain,
+		      u8 cal_type, bool debug)
 {
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 
@@ -26157,10 +26161,10 @@ wlc_phy_cal_rxiq_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
 	}
 }
 
-static void wlc_phy_extpa_set_tx_digi_filts_nphy(phy_info_t * pi)
+static void wlc_phy_extpa_set_tx_digi_filts_nphy(phy_info_t *pi)
 {
 	int j, type = 2;
-	uint16 addr_offset = 0x2c5;
+	u16 addr_offset = 0x2c5;
 
 	for (j = 0; j < NPHY_NUM_DIG_FILT_COEFFS; j++) {
 		write_phy_reg(pi, addr_offset + j,
@@ -26168,10 +26172,10 @@ static void wlc_phy_extpa_set_tx_digi_filts_nphy(phy_info_t * pi)
 	}
 }
 
-static void wlc_phy_ipa_set_tx_digi_filts_nphy(phy_info_t * pi)
+static void wlc_phy_ipa_set_tx_digi_filts_nphy(phy_info_t *pi)
 {
 	int j, type;
-	uint16 addr_offset[] = { 0x186, 0x195,
+	u16 addr_offset[] = { 0x186, 0x195,
 		0x2c5
 	};
 
@@ -26206,7 +26210,7 @@ static void wlc_phy_ipa_set_tx_digi_filts_nphy(phy_info_t * pi)
 	}
 }
 
-static void wlc_phy_ipa_restore_tx_digi_filts_nphy(phy_info_t * pi)
+static void wlc_phy_ipa_restore_tx_digi_filts_nphy(phy_info_t *pi)
 {
 	int j;
 
@@ -26223,26 +26227,26 @@ static void wlc_phy_ipa_restore_tx_digi_filts_nphy(phy_info_t * pi)
 	}
 }
 
-static uint16 wlc_phy_ipa_get_bbmult_nphy(phy_info_t * pi)
+static u16 wlc_phy_ipa_get_bbmult_nphy(phy_info_t *pi)
 {
-	uint16 m0m1;
+	u16 m0m1;
 
 	wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &m0m1);
 
 	return m0m1;
 }
 
-static void wlc_phy_ipa_set_bbmult_nphy(phy_info_t * pi, uint8 m0, uint8 m1)
+static void wlc_phy_ipa_set_bbmult_nphy(phy_info_t *pi, u8 m0, u8 m1)
 {
-	uint16 m0m1 = (uint16) ((m0 << 8) | m1);
+	u16 m0m1 = (u16) ((m0 << 8) | m1);
 
 	wlc_phy_table_write_nphy(pi, 15, 1, 87, 16, &m0m1);
 	wlc_phy_table_write_nphy(pi, 15, 1, 95, 16, &m0m1);
 }
 
-static uint32 *wlc_phy_get_ipa_gaintbl_nphy(phy_info_t * pi)
+static u32 *wlc_phy_get_ipa_gaintbl_nphy(phy_info_t *pi)
 {
-	uint32 *tx_pwrctrl_tbl = NULL;
+	u32 *tx_pwrctrl_tbl = NULL;
 
 	if (CHSPEC_IS2G(pi->radio_chanspec)) {
 
@@ -26312,12 +26316,12 @@ static uint32 *wlc_phy_get_ipa_gaintbl_nphy(phy_info_t * pi)
 }
 
 static void
-wlc_phy_papd_cal_setup_nphy(phy_info_t * pi, nphy_papd_restore_state * state,
-			    uint8 core)
+wlc_phy_papd_cal_setup_nphy(phy_info_t *pi, nphy_papd_restore_state *state,
+			    u8 core)
 {
-	int32 tone_freq;
-	uint8 off_core;
-	uint16 mixgain = 0;
+	s32 tone_freq;
+	u8 off_core;
+	u16 mixgain = 0;
 
 	off_core = core ^ 0x1;
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -26505,7 +26509,7 @@ wlc_phy_papd_cal_setup_nphy(phy_info_t * pi, nphy_papd_restore_state * state,
 
 		tone_freq = 4000;
 
-		wlc_phy_tx_tone_nphy(pi, tone_freq, 181, 0, 0, FALSE);
+		wlc_phy_tx_tone_nphy(pi, tone_freq, 181, 0, 0, false);
 
 		mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
 			    0x29b, (0x1 << 0), (NPHY_PAPD_COMP_ON) << 0);
@@ -26575,7 +26579,7 @@ wlc_phy_papd_cal_setup_nphy(phy_info_t * pi, nphy_papd_restore_state * state,
 
 		tone_freq = 4000;
 
-		wlc_phy_tx_tone_nphy(pi, tone_freq, 181, 0, 0, FALSE);
+		wlc_phy_tx_tone_nphy(pi, tone_freq, 181, 0, 0, false);
 
 		mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
 			    0x29b, (0x1 << 0), (1) << 0);
@@ -26588,9 +26592,9 @@ wlc_phy_papd_cal_setup_nphy(phy_info_t * pi, nphy_papd_restore_state * state,
 }
 
 static void
-wlc_phy_papd_cal_cleanup_nphy(phy_info_t * pi, nphy_papd_restore_state * state)
+wlc_phy_papd_cal_cleanup_nphy(phy_info_t *pi, nphy_papd_restore_state *state)
 {
-	uint8 core;
+	u8 core;
 
 	wlc_phy_stopplayback_nphy(pi);
 
@@ -26714,19 +26718,17 @@ wlc_phy_papd_cal_cleanup_nphy(phy_info_t * pi, nphy_papd_restore_state * state)
 }
 
 static void
-wlc_phy_a1_nphy(phy_info_t * pi, uint8 core, uint32 winsz, uint32 start,
-		uint32 end)
+wlc_phy_a1_nphy(phy_info_t *pi, u8 core, u32 winsz, u32 start,
+		u32 end)
 {
-	uint32 *buf, *src, *dst, sz;
+	u32 *buf, *src, *dst, sz;
 
 	sz = end - start + 1;
 	ASSERT(end > start);
 	ASSERT(end < NPHY_PAPD_EPS_TBL_SIZE);
 
-	if (NULL ==
-	    (buf =
-	     MALLOC(pi->sh->osh,
-		    2 * sizeof(uint32) * NPHY_PAPD_EPS_TBL_SIZE))) {
+	buf = kmalloc(2 * sizeof(u32) * NPHY_PAPD_EPS_TBL_SIZE, GFP_ATOMIC);
+	if (NULL == buf) {
 		return;
 	}
 
@@ -26740,11 +26742,11 @@ wlc_phy_a1_nphy(phy_info_t * pi, uint8 core, uint32 winsz, uint32 start,
 				NPHY_PAPD_EPS_TBL_SIZE, 0, 32, src);
 
 	do {
-		uint32 phy_a1, phy_a2;
-		int32 phy_a3, phy_a4, phy_a5, phy_a6, phy_a7;
+		u32 phy_a1, phy_a2;
+		s32 phy_a3, phy_a4, phy_a5, phy_a6, phy_a7;
 
-		phy_a1 = end - MIN(end, (winsz >> 1));
-		phy_a2 = MIN(NPHY_PAPD_EPS_TBL_SIZE - 1, end + (winsz >> 1));
+		phy_a1 = end - min(end, (winsz >> 1));
+		phy_a2 = min_t(u32, NPHY_PAPD_EPS_TBL_SIZE - 1, end + (winsz >> 1));
 		phy_a3 = phy_a2 - phy_a1 + 1;
 		phy_a6 = 0;
 		phy_a7 = 0;
@@ -26758,7 +26760,7 @@ wlc_phy_a1_nphy(phy_info_t * pi, uint8 core, uint32 winsz, uint32 start,
 
 		phy_a6 /= phy_a3;
 		phy_a7 /= phy_a3;
-		dst[end] = ((uint32) phy_a7 << 13) | ((uint32) phy_a6 & 0x1fff);
+		dst[end] = ((u32) phy_a7 << 13) | ((u32) phy_a6 & 0x1fff);
 	} while (end-- != start);
 
 	wlc_phy_table_write_nphy(pi,
@@ -26766,18 +26768,18 @@ wlc_phy_a1_nphy(phy_info_t * pi, uint8 core, uint32 winsz, uint32 start,
 				  PHY_CORE_0) ? NPHY_TBL_ID_EPSILONTBL0 :
 				 NPHY_TBL_ID_EPSILONTBL1, sz, start, 32, dst);
 
-	MFREE(pi->sh->osh, buf, 2 * sizeof(uint32) * NPHY_PAPD_EPS_TBL_SIZE);
+	kfree(buf);
 }
 
 static void
-wlc_phy_a2_nphy(phy_info_t * pi, nphy_ipa_txcalgains_t * txgains,
-		phy_cal_mode_t cal_mode, uint8 core)
+wlc_phy_a2_nphy(phy_info_t *pi, nphy_ipa_txcalgains_t *txgains,
+		phy_cal_mode_t cal_mode, u8 core)
 {
-	uint16 phy_a1, phy_a2, phy_a3;
-	uint16 phy_a4, phy_a5;
+	u16 phy_a1, phy_a2, phy_a3;
+	u16 phy_a4, phy_a5;
 	bool phy_a6;
-	uint8 phy_a7, m[2];
-	uint32 phy_a8 = 0;
+	u8 phy_a7, m[2];
+	u32 phy_a8 = 0;
 	nphy_txgains_t phy_a9;
 
 	if (NREV_LT(pi->pubpi.phy_rev, 3))
@@ -26788,7 +26790,7 @@ wlc_phy_a2_nphy(phy_info_t * pi, nphy_ipa_txcalgains_t * txgains,
 	ASSERT((cal_mode == CAL_FULL) || (cal_mode == CAL_GCTRL)
 	       || (cal_mode == CAL_SOFT));
 	phy_a6 = ((cal_mode == CAL_GCTRL)
-		  || (cal_mode == CAL_SOFT)) ? TRUE : FALSE;
+		  || (cal_mode == CAL_SOFT)) ? true : false;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 
@@ -27070,24 +27072,24 @@ wlc_phy_a2_nphy(phy_info_t * pi, nphy_ipa_txcalgains_t * txgains,
 	}
 }
 
-static uint8 wlc_phy_a3_nphy(phy_info_t * pi, uint8 start_gain, uint8 core)
+static u8 wlc_phy_a3_nphy(phy_info_t *pi, u8 start_gain, u8 core)
 {
 	int phy_a1;
 	int phy_a2;
 	bool phy_a3;
 	nphy_ipa_txcalgains_t phy_a4;
-	bool phy_a5 = FALSE;
-	bool phy_a6 = TRUE;
-	int32 phy_a7, phy_a8;
-	uint32 phy_a9;
+	bool phy_a5 = false;
+	bool phy_a6 = true;
+	s32 phy_a7, phy_a8;
+	u32 phy_a9;
 	int phy_a10;
-	bool phy_a11 = FALSE;
+	bool phy_a11 = false;
 	int phy_a12;
-	uint8 phy_a13 = 0;
-	uint8 phy_a14;
-	uint8 *phy_a15 = NULL;
+	u8 phy_a13 = 0;
+	u8 phy_a14;
+	u8 *phy_a15 = NULL;
 
-	phy_a4.useindex = TRUE;
+	phy_a4.useindex = true;
 	phy_a12 = start_gain;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -27128,10 +27130,10 @@ static uint8 wlc_phy_a3_nphy(phy_info_t * pi, uint8 start_gain, uint8 core)
 		for (phy_a10 = 0; phy_a10 < phy_a2; phy_a10++) {
 			if (CHSPEC_IS2G(pi->radio_chanspec)) {
 				phy_a4.gains.pad[core] =
-				    (uint16) phy_a15[phy_a12];
+				    (u16) phy_a15[phy_a12];
 			} else {
 				phy_a4.gains.pga[core] =
-				    (uint16) phy_a15[phy_a12];
+				    (u16) phy_a15[phy_a12];
 			}
 
 			wlc_phy_a2_nphy(pi, &phy_a4, CAL_GCTRL, core);
@@ -27150,16 +27152,16 @@ static uint8 wlc_phy_a3_nphy(phy_info_t * pi, uint8 start_gain, uint8 core)
 
 			if (!phy_a6 && (phy_a3 != phy_a5)) {
 				if (!phy_a3) {
-					phy_a12 -= (uint8) phy_a1;
+					phy_a12 -= (u8) phy_a1;
 				}
-				phy_a11 = TRUE;
+				phy_a11 = true;
 				break;
 			}
 
 			if (phy_a3)
-				phy_a12 += (uint8) phy_a1;
+				phy_a12 += (u8) phy_a1;
 			else
-				phy_a12 -= (uint8) phy_a1;
+				phy_a12 -= (u8) phy_a1;
 
 			if ((phy_a12 < phy_a14) || (phy_a12 > phy_a13)) {
 				if (phy_a12 < phy_a14) {
@@ -27167,11 +27169,11 @@ static uint8 wlc_phy_a3_nphy(phy_info_t * pi, uint8 start_gain, uint8 core)
 				} else {
 					phy_a12 = phy_a13;
 				}
-				phy_a11 = TRUE;
+				phy_a11 = true;
 				break;
 			}
 
-			phy_a6 = FALSE;
+			phy_a6 = false;
 			phy_a5 = phy_a3;
 		}
 
@@ -27179,7 +27181,7 @@ static uint8 wlc_phy_a3_nphy(phy_info_t * pi, uint8 start_gain, uint8 core)
 		phy_a2 = 10;
 		phy_a1 = 8;
 		for (phy_a10 = 0; phy_a10 < phy_a2; phy_a10++) {
-			phy_a4.index = (uint8) phy_a12;
+			phy_a4.index = (u8) phy_a12;
 			wlc_phy_a2_nphy(pi, &phy_a4, CAL_GCTRL, core);
 
 			wlc_phy_table_read_nphy(pi,
@@ -27196,16 +27198,16 @@ static uint8 wlc_phy_a3_nphy(phy_info_t * pi, uint8 start_gain, uint8 core)
 
 			if (!phy_a6 && (phy_a3 != phy_a5)) {
 				if (!phy_a3) {
-					phy_a12 -= (uint8) phy_a1;
+					phy_a12 -= (u8) phy_a1;
 				}
-				phy_a11 = TRUE;
+				phy_a11 = true;
 				break;
 			}
 
 			if (phy_a3)
-				phy_a12 += (uint8) phy_a1;
+				phy_a12 += (u8) phy_a1;
 			else
-				phy_a12 -= (uint8) phy_a1;
+				phy_a12 -= (u8) phy_a1;
 
 			if ((phy_a12 < 0) || (phy_a12 > 127)) {
 				if (phy_a12 < 0) {
@@ -27213,34 +27215,34 @@ static uint8 wlc_phy_a3_nphy(phy_info_t * pi, uint8 start_gain, uint8 core)
 				} else {
 					phy_a12 = 127;
 				}
-				phy_a11 = TRUE;
+				phy_a11 = true;
 				break;
 			}
 
-			phy_a6 = FALSE;
+			phy_a6 = false;
 			phy_a5 = phy_a3;
 		}
 
 	}
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
-		return (uint8) phy_a15[phy_a12];
+		return (u8) phy_a15[phy_a12];
 	} else {
-		return (uint8) phy_a12;
+		return (u8) phy_a12;
 	}
 
 }
 
-static void wlc_phy_a4(phy_info_t * pi, bool full_cal)
+static void wlc_phy_a4(phy_info_t *pi, bool full_cal)
 {
 	nphy_ipa_txcalgains_t phy_b1[2];
 	nphy_papd_restore_state phy_b2;
 	bool phy_b3;
-	uint8 phy_b4;
-	uint8 phy_b5;
-	int16 phy_b6, phy_b7, phy_b8;
-	uint16 phy_b9;
-	int16 phy_b10, phy_b11, phy_b12;
+	u8 phy_b4;
+	u8 phy_b5;
+	s16 phy_b6, phy_b7, phy_b8;
+	u16 phy_b9;
+	s16 phy_b10, phy_b11, phy_b12;
 
 	phy_b11 = 0;
 	phy_b12 = 0;
@@ -27257,9 +27259,9 @@ static void wlc_phy_a4(phy_info_t * pi, bool full_cal)
 		wlapi_suspend_mac_and_wait(pi->sh->physhim);
 	}
 
-	wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+	wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
-	pi->nphy_force_papd_cal = FALSE;
+	pi->nphy_force_papd_cal = false;
 
 	for (phy_b5 = 0; phy_b5 < pi->pubpi.phy_corenum; phy_b5++)
 		pi->nphy_papd_tx_gain_at_last_cal[phy_b5] =
@@ -27283,7 +27285,7 @@ static void wlc_phy_a4(phy_info_t * pi, bool full_cal)
 	mod_phy_reg(pi, 0x01, (0x1 << 15), 0);
 
 	for (phy_b5 = 0; phy_b5 < pi->pubpi.phy_corenum; phy_b5++) {
-		int32 i, val = 0;
+		s32 i, val = 0;
 		for (i = 0; i < 64; i++) {
 			wlc_phy_table_write_nphy(pi,
 						 ((phy_b5 ==
@@ -27349,7 +27351,7 @@ static void wlc_phy_a4(phy_info_t * pi, bool full_cal)
 				    pi->nphy_papd_cal_gain_index[phy_b5];
 			}
 		} else {
-			phy_b1[phy_b5].useindex = TRUE;
+			phy_b1[phy_b5].useindex = true;
 			phy_b1[phy_b5].index = 16;
 			phy_b1[phy_b5].index =
 			    wlc_phy_a3_nphy(pi, phy_b1[phy_b5].index, phy_b5);
@@ -27512,32 +27514,32 @@ static void wlc_phy_a4(phy_info_t * pi, bool full_cal)
 	wlc_phy_txpwrctrl_enable_nphy(pi, phy_b4);
 	if (phy_b4 == PHY_TPC_HW_OFF) {
 		wlc_phy_txpwr_index_nphy(pi, (1 << 0),
-					 (int8) (pi->nphy_txpwrindex[0].
-						 index_internal), FALSE);
+					 (s8) (pi->nphy_txpwrindex[0].
+						 index_internal), false);
 		wlc_phy_txpwr_index_nphy(pi, (1 << 1),
-					 (int8) (pi->nphy_txpwrindex[1].
-						 index_internal), FALSE);
+					 (s8) (pi->nphy_txpwrindex[1].
+						 index_internal), false);
 	}
 
-	wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+	wlc_phy_stay_in_carriersearch_nphy(pi, false);
 
 	if (!phy_b3) {
 		wlapi_enable_mac(pi->sh->physhim);
 	}
 }
 
-void wlc_phy_txpwr_fixpower_nphy(phy_info_t * pi)
+void wlc_phy_txpwr_fixpower_nphy(phy_info_t *pi)
 {
 	uint core;
-	uint32 txgain;
-	uint16 rad_gain, dac_gain, bbmult, m1m2;
-	uint8 txpi[2], chan_freq_range;
-	int32 rfpwr_offset;
+	u32 txgain;
+	u16 rad_gain, dac_gain, bbmult, m1m2;
+	u8 txpi[2], chan_freq_range;
+	s32 rfpwr_offset;
 
 	ASSERT(pi->nphy_txpwrctrl == PHY_TPC_HW_OFF);
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	if (pi->sh->sromrev < 4) {
 		txpi[0] = txpi[1] = 72;
@@ -27588,7 +27590,7 @@ void wlc_phy_txpwr_fixpower_nphy(phy_info_t * pi)
 	for (core = 0; core < pi->pubpi.phy_corenum; core++) {
 		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 			if (PHY_IPA(pi)) {
-				uint32 *tx_gaintbl =
+				u32 *tx_gaintbl =
 				    wlc_phy_get_ipa_gaintbl_nphy(pi);
 				txgain = tx_gaintbl[txpi[core]];
 			} else {
@@ -27669,7 +27671,7 @@ void wlc_phy_txpwr_fixpower_nphy(phy_info_t * pi)
 
 			mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
 				    0x29b, (0x1ff << 4),
-				    ((int16) rfpwr_offset) << 4);
+				    ((s16) rfpwr_offset) << 4);
 
 			mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
 				    0x29b, (0x1 << 2), (1) << 2);
@@ -27677,20 +27679,20 @@ void wlc_phy_txpwr_fixpower_nphy(phy_info_t * pi)
 		}
 	}
 
-	and_phy_reg(pi, 0xbf, (uint16) (~(0x1f << 0)));
+	and_phy_reg(pi, 0xbf, (u16) (~(0x1f << 0)));
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
 static void
-wlc_phy_txpwr_nphy_srom_convert(uint8 * srom_max, uint16 * pwr_offset,
-				uint8 tmp_max_pwr, uint8 rate_start,
-				uint8 rate_end)
+wlc_phy_txpwr_nphy_srom_convert(u8 *srom_max, u16 *pwr_offset,
+				u8 tmp_max_pwr, u8 rate_start,
+				u8 rate_end)
 {
-	uint8 rate;
-	uint8 word_num, nibble_num;
-	uint8 tmp_nibble;
+	u8 rate;
+	u8 word_num, nibble_num;
+	u8 tmp_nibble;
 
 	for (rate = rate_start; rate <= rate_end; rate++) {
 		word_num = (rate - rate_start) >> 2;
@@ -27702,10 +27704,10 @@ wlc_phy_txpwr_nphy_srom_convert(uint8 * srom_max, uint16 * pwr_offset,
 }
 
 static void
-wlc_phy_txpwr_nphy_po_apply(uint8 * srom_max, uint8 pwr_offset,
-			    uint8 rate_start, uint8 rate_end)
+wlc_phy_txpwr_nphy_po_apply(u8 *srom_max, u8 pwr_offset,
+			    u8 rate_start, u8 rate_end)
 {
-	uint8 rate;
+	u8 rate;
 
 	for (rate = rate_start; rate <= rate_end; rate++) {
 		srom_max[rate] -= 2 * pwr_offset;
@@ -27713,10 +27715,10 @@ wlc_phy_txpwr_nphy_po_apply(uint8 * srom_max, uint8 pwr_offset,
 }
 
 void
-wlc_phy_ofdm_to_mcs_powers_nphy(uint8 * power, uint8 rate_mcs_start,
-				uint8 rate_mcs_end, uint8 rate_ofdm_start)
+wlc_phy_ofdm_to_mcs_powers_nphy(u8 *power, u8 rate_mcs_start,
+				u8 rate_mcs_end, u8 rate_ofdm_start)
 {
-	uint8 rate1, rate2;
+	u8 rate1, rate2;
 
 	rate2 = rate_ofdm_start;
 	for (rate1 = rate_mcs_start; rate1 <= rate_mcs_end - 1; rate1++) {
@@ -27727,10 +27729,10 @@ wlc_phy_ofdm_to_mcs_powers_nphy(uint8 * power, uint8 rate_mcs_start,
 }
 
 void
-wlc_phy_mcs_to_ofdm_powers_nphy(uint8 * power, uint8 rate_ofdm_start,
-				uint8 rate_ofdm_end, uint8 rate_mcs_start)
+wlc_phy_mcs_to_ofdm_powers_nphy(u8 *power, u8 rate_ofdm_start,
+				u8 rate_ofdm_end, u8 rate_mcs_start)
 {
-	uint8 rate1, rate2;
+	u8 rate1, rate2;
 
 	for (rate1 = rate_ofdm_start, rate2 = rate_mcs_start;
 	     rate1 <= rate_ofdm_end; rate1++, rate2++) {
@@ -27740,18 +27742,19 @@ wlc_phy_mcs_to_ofdm_powers_nphy(uint8 * power, uint8 rate_ofdm_start,
 	}
 }
 
-void BCMNMIATTACHFN(wlc_phy_txpwr_apply_nphy) (phy_info_t * pi) {
+void wlc_phy_txpwr_apply_nphy(phy_info_t *pi)
+{
 	uint rate1, rate2, band_num;
-	uint8 tmp_bw40po = 0, tmp_cddpo = 0, tmp_stbcpo = 0;
-	uint8 tmp_max_pwr = 0;
-	uint16 pwr_offsets1[2], *pwr_offsets2 = NULL;
-	uint8 *tx_srom_max_rate = NULL;
+	u8 tmp_bw40po = 0, tmp_cddpo = 0, tmp_stbcpo = 0;
+	u8 tmp_max_pwr = 0;
+	u16 pwr_offsets1[2], *pwr_offsets2 = NULL;
+	u8 *tx_srom_max_rate = NULL;
 
 	for (band_num = 0; band_num < (CH_2G_GROUP + CH_5G_GROUP); band_num++) {
 		switch (band_num) {
 		case 0:
 
-			tmp_max_pwr = MIN(pi->nphy_pwrctrl_info[0].max_pwr_2g,
+			tmp_max_pwr = min(pi->nphy_pwrctrl_info[0].max_pwr_2g,
 					  pi->nphy_pwrctrl_info[1].max_pwr_2g);
 
 			pwr_offsets1[0] = pi->cck2gpo;
@@ -27761,9 +27764,9 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_nphy) (phy_info_t * pi) {
 							TXP_FIRST_CCK,
 							TXP_LAST_CCK);
 
-			pwr_offsets1[0] = (uint16) (pi->ofdm2gpo & 0xffff);
+			pwr_offsets1[0] = (u16) (pi->ofdm2gpo & 0xffff);
 			pwr_offsets1[1] =
-			    (uint16) (pi->ofdm2gpo >> 16) & 0xffff;
+			    (u16) (pi->ofdm2gpo >> 16) & 0xffff;
 
 			pwr_offsets2 = pi->mcs2gpo;
 
@@ -27775,12 +27778,12 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_nphy) (phy_info_t * pi) {
 			break;
 		case 1:
 
-			tmp_max_pwr = MIN(pi->nphy_pwrctrl_info[0].max_pwr_5gm,
+			tmp_max_pwr = min(pi->nphy_pwrctrl_info[0].max_pwr_5gm,
 					  pi->nphy_pwrctrl_info[1].max_pwr_5gm);
 
-			pwr_offsets1[0] = (uint16) (pi->ofdm5gpo & 0xffff);
+			pwr_offsets1[0] = (u16) (pi->ofdm5gpo & 0xffff);
 			pwr_offsets1[1] =
-			    (uint16) (pi->ofdm5gpo >> 16) & 0xffff;
+			    (u16) (pi->ofdm5gpo >> 16) & 0xffff;
 
 			pwr_offsets2 = pi->mcs5gpo;
 
@@ -27792,12 +27795,12 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_nphy) (phy_info_t * pi) {
 			break;
 		case 2:
 
-			tmp_max_pwr = MIN(pi->nphy_pwrctrl_info[0].max_pwr_5gl,
+			tmp_max_pwr = min(pi->nphy_pwrctrl_info[0].max_pwr_5gl,
 					  pi->nphy_pwrctrl_info[1].max_pwr_5gl);
 
-			pwr_offsets1[0] = (uint16) (pi->ofdm5glpo & 0xffff);
+			pwr_offsets1[0] = (u16) (pi->ofdm5glpo & 0xffff);
 			pwr_offsets1[1] =
-			    (uint16) (pi->ofdm5glpo >> 16) & 0xffff;
+			    (u16) (pi->ofdm5glpo >> 16) & 0xffff;
 
 			pwr_offsets2 = pi->mcs5glpo;
 
@@ -27809,12 +27812,12 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_nphy) (phy_info_t * pi) {
 			break;
 		case 3:
 
-			tmp_max_pwr = MIN(pi->nphy_pwrctrl_info[0].max_pwr_5gh,
+			tmp_max_pwr = min(pi->nphy_pwrctrl_info[0].max_pwr_5gh,
 					  pi->nphy_pwrctrl_info[1].max_pwr_5gh);
 
-			pwr_offsets1[0] = (uint16) (pi->ofdm5ghpo & 0xffff);
+			pwr_offsets1[0] = (u16) (pi->ofdm5ghpo & 0xffff);
 			pwr_offsets1[1] =
-			    (uint16) (pi->ofdm5ghpo >> 16) & 0xffff;
+			    (u16) (pi->ofdm5ghpo >> 16) & 0xffff;
 
 			pwr_offsets2 = pi->mcs5ghpo;
 
@@ -27937,8 +27940,9 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_nphy) (phy_info_t * pi) {
 	return;
 }
 
-static void BCMATTACHFN(wlc_phy_txpwr_srom_read_ppr_nphy) (phy_info_t * pi) {
-	uint16 bw40po, cddpo, stbcpo, bwduppo;
+static void wlc_phy_txpwr_srom_read_ppr_nphy(phy_info_t *pi)
+{
+	u16 bw40po, cddpo, stbcpo, bwduppo;
 	uint band_num;
 
 	if (pi->sh->sromrev >= 9) {
@@ -27946,25 +27950,25 @@ static void BCMATTACHFN(wlc_phy_txpwr_srom_read_ppr_nphy) (phy_info_t * pi) {
 		return;
 	}
 
-	bw40po = (uint16) PHY_GETINTVAR(pi, "bw40po");
+	bw40po = (u16) PHY_GETINTVAR(pi, "bw40po");
 	pi->bw402gpo = bw40po & 0xf;
 	pi->bw405gpo = (bw40po & 0xf0) >> 4;
 	pi->bw405glpo = (bw40po & 0xf00) >> 8;
 	pi->bw405ghpo = (bw40po & 0xf000) >> 12;
 
-	cddpo = (uint16) PHY_GETINTVAR(pi, "cddpo");
+	cddpo = (u16) PHY_GETINTVAR(pi, "cddpo");
 	pi->cdd2gpo = cddpo & 0xf;
 	pi->cdd5gpo = (cddpo & 0xf0) >> 4;
 	pi->cdd5glpo = (cddpo & 0xf00) >> 8;
 	pi->cdd5ghpo = (cddpo & 0xf000) >> 12;
 
-	stbcpo = (uint16) PHY_GETINTVAR(pi, "stbcpo");
+	stbcpo = (u16) PHY_GETINTVAR(pi, "stbcpo");
 	pi->stbc2gpo = stbcpo & 0xf;
 	pi->stbc5gpo = (stbcpo & 0xf0) >> 4;
 	pi->stbc5glpo = (stbcpo & 0xf00) >> 8;
 	pi->stbc5ghpo = (stbcpo & 0xf000) >> 12;
 
-	bwduppo = (uint16) PHY_GETINTVAR(pi, "bwduppo");
+	bwduppo = (u16) PHY_GETINTVAR(pi, "bwduppo");
 	pi->bwdup2gpo = bwduppo & 0xf;
 	pi->bwdup5gpo = (bwduppo & 0xf0) >> 4;
 	pi->bwdup5glpo = (bwduppo & 0xf00) >> 8;
@@ -27975,168 +27979,168 @@ static void BCMATTACHFN(wlc_phy_txpwr_srom_read_ppr_nphy) (phy_info_t * pi) {
 		case 0:
 
 			pi->nphy_txpid2g[PHY_CORE_0] =
-			    (uint8) PHY_GETINTVAR(pi, "txpid2ga0");
+			    (u8) PHY_GETINTVAR(pi, "txpid2ga0");
 			pi->nphy_txpid2g[PHY_CORE_1] =
-			    (uint8) PHY_GETINTVAR(pi, "txpid2ga1");
+			    (u8) PHY_GETINTVAR(pi, "txpid2ga1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].max_pwr_2g =
-			    (int8) PHY_GETINTVAR(pi, "maxp2ga0");
+			    (s8) PHY_GETINTVAR(pi, "maxp2ga0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].max_pwr_2g =
-			    (int8) PHY_GETINTVAR(pi, "maxp2ga1");
+			    (s8) PHY_GETINTVAR(pi, "maxp2ga1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_2g_a1 =
-			    (int16) PHY_GETINTVAR(pi, "pa2gw0a0");
+			    (s16) PHY_GETINTVAR(pi, "pa2gw0a0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_2g_a1 =
-			    (int16) PHY_GETINTVAR(pi, "pa2gw0a1");
+			    (s16) PHY_GETINTVAR(pi, "pa2gw0a1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_2g_b0 =
-			    (int16) PHY_GETINTVAR(pi, "pa2gw1a0");
+			    (s16) PHY_GETINTVAR(pi, "pa2gw1a0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_2g_b0 =
-			    (int16) PHY_GETINTVAR(pi, "pa2gw1a1");
+			    (s16) PHY_GETINTVAR(pi, "pa2gw1a1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_2g_b1 =
-			    (int16) PHY_GETINTVAR(pi, "pa2gw2a0");
+			    (s16) PHY_GETINTVAR(pi, "pa2gw2a0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_2g_b1 =
-			    (int16) PHY_GETINTVAR(pi, "pa2gw2a1");
+			    (s16) PHY_GETINTVAR(pi, "pa2gw2a1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].idle_targ_2g =
-			    (int8) PHY_GETINTVAR(pi, "itt2ga0");
+			    (s8) PHY_GETINTVAR(pi, "itt2ga0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].idle_targ_2g =
-			    (int8) PHY_GETINTVAR(pi, "itt2ga1");
+			    (s8) PHY_GETINTVAR(pi, "itt2ga1");
 
-			pi->cck2gpo = (uint16) PHY_GETINTVAR(pi, "cck2gpo");
+			pi->cck2gpo = (u16) PHY_GETINTVAR(pi, "cck2gpo");
 
-			pi->ofdm2gpo = (uint32) PHY_GETINTVAR(pi, "ofdm2gpo");
+			pi->ofdm2gpo = (u32) PHY_GETINTVAR(pi, "ofdm2gpo");
 
-			pi->mcs2gpo[0] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo0");
-			pi->mcs2gpo[1] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo1");
-			pi->mcs2gpo[2] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo2");
-			pi->mcs2gpo[3] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo3");
-			pi->mcs2gpo[4] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo4");
-			pi->mcs2gpo[5] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo5");
-			pi->mcs2gpo[6] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo6");
-			pi->mcs2gpo[7] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo7");
+			pi->mcs2gpo[0] = (u16) PHY_GETINTVAR(pi, "mcs2gpo0");
+			pi->mcs2gpo[1] = (u16) PHY_GETINTVAR(pi, "mcs2gpo1");
+			pi->mcs2gpo[2] = (u16) PHY_GETINTVAR(pi, "mcs2gpo2");
+			pi->mcs2gpo[3] = (u16) PHY_GETINTVAR(pi, "mcs2gpo3");
+			pi->mcs2gpo[4] = (u16) PHY_GETINTVAR(pi, "mcs2gpo4");
+			pi->mcs2gpo[5] = (u16) PHY_GETINTVAR(pi, "mcs2gpo5");
+			pi->mcs2gpo[6] = (u16) PHY_GETINTVAR(pi, "mcs2gpo6");
+			pi->mcs2gpo[7] = (u16) PHY_GETINTVAR(pi, "mcs2gpo7");
 			break;
 		case 1:
 
 			pi->nphy_txpid5g[PHY_CORE_0] =
-			    (uint8) PHY_GETINTVAR(pi, "txpid5ga0");
+			    (u8) PHY_GETINTVAR(pi, "txpid5ga0");
 			pi->nphy_txpid5g[PHY_CORE_1] =
-			    (uint8) PHY_GETINTVAR(pi, "txpid5ga1");
+			    (u8) PHY_GETINTVAR(pi, "txpid5ga1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].max_pwr_5gm =
-			    (int8) PHY_GETINTVAR(pi, "maxp5ga0");
+			    (s8) PHY_GETINTVAR(pi, "maxp5ga0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].max_pwr_5gm =
-			    (int8) PHY_GETINTVAR(pi, "maxp5ga1");
+			    (s8) PHY_GETINTVAR(pi, "maxp5ga1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_5gm_a1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5gw0a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5gw0a0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_5gm_a1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5gw0a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5gw0a1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_5gm_b0 =
-			    (int16) PHY_GETINTVAR(pi, "pa5gw1a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5gw1a0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_5gm_b0 =
-			    (int16) PHY_GETINTVAR(pi, "pa5gw1a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5gw1a1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_5gm_b1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5gw2a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5gw2a0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_5gm_b1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5gw2a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5gw2a1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].idle_targ_5gm =
-			    (int8) PHY_GETINTVAR(pi, "itt5ga0");
+			    (s8) PHY_GETINTVAR(pi, "itt5ga0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].idle_targ_5gm =
-			    (int8) PHY_GETINTVAR(pi, "itt5ga1");
-
-			pi->ofdm5gpo = (uint32) PHY_GETINTVAR(pi, "ofdm5gpo");
-
-			pi->mcs5gpo[0] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo0");
-			pi->mcs5gpo[1] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo1");
-			pi->mcs5gpo[2] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo2");
-			pi->mcs5gpo[3] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo3");
-			pi->mcs5gpo[4] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo4");
-			pi->mcs5gpo[5] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo5");
-			pi->mcs5gpo[6] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo6");
-			pi->mcs5gpo[7] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo7");
+			    (s8) PHY_GETINTVAR(pi, "itt5ga1");
+
+			pi->ofdm5gpo = (u32) PHY_GETINTVAR(pi, "ofdm5gpo");
+
+			pi->mcs5gpo[0] = (u16) PHY_GETINTVAR(pi, "mcs5gpo0");
+			pi->mcs5gpo[1] = (u16) PHY_GETINTVAR(pi, "mcs5gpo1");
+			pi->mcs5gpo[2] = (u16) PHY_GETINTVAR(pi, "mcs5gpo2");
+			pi->mcs5gpo[3] = (u16) PHY_GETINTVAR(pi, "mcs5gpo3");
+			pi->mcs5gpo[4] = (u16) PHY_GETINTVAR(pi, "mcs5gpo4");
+			pi->mcs5gpo[5] = (u16) PHY_GETINTVAR(pi, "mcs5gpo5");
+			pi->mcs5gpo[6] = (u16) PHY_GETINTVAR(pi, "mcs5gpo6");
+			pi->mcs5gpo[7] = (u16) PHY_GETINTVAR(pi, "mcs5gpo7");
 			break;
 		case 2:
 
 			pi->nphy_txpid5gl[0] =
-			    (uint8) PHY_GETINTVAR(pi, "txpid5gla0");
+			    (u8) PHY_GETINTVAR(pi, "txpid5gla0");
 			pi->nphy_txpid5gl[1] =
-			    (uint8) PHY_GETINTVAR(pi, "txpid5gla1");
+			    (u8) PHY_GETINTVAR(pi, "txpid5gla1");
 			pi->nphy_pwrctrl_info[0].max_pwr_5gl =
-			    (int8) PHY_GETINTVAR(pi, "maxp5gla0");
+			    (s8) PHY_GETINTVAR(pi, "maxp5gla0");
 			pi->nphy_pwrctrl_info[1].max_pwr_5gl =
-			    (int8) PHY_GETINTVAR(pi, "maxp5gla1");
+			    (s8) PHY_GETINTVAR(pi, "maxp5gla1");
 			pi->nphy_pwrctrl_info[0].pwrdet_5gl_a1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5glw0a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5glw0a0");
 			pi->nphy_pwrctrl_info[1].pwrdet_5gl_a1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5glw0a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5glw0a1");
 			pi->nphy_pwrctrl_info[0].pwrdet_5gl_b0 =
-			    (int16) PHY_GETINTVAR(pi, "pa5glw1a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5glw1a0");
 			pi->nphy_pwrctrl_info[1].pwrdet_5gl_b0 =
-			    (int16) PHY_GETINTVAR(pi, "pa5glw1a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5glw1a1");
 			pi->nphy_pwrctrl_info[0].pwrdet_5gl_b1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5glw2a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5glw2a0");
 			pi->nphy_pwrctrl_info[1].pwrdet_5gl_b1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5glw2a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5glw2a1");
 			pi->nphy_pwrctrl_info[0].idle_targ_5gl = 0;
 			pi->nphy_pwrctrl_info[1].idle_targ_5gl = 0;
 
-			pi->ofdm5glpo = (uint32) PHY_GETINTVAR(pi, "ofdm5glpo");
+			pi->ofdm5glpo = (u32) PHY_GETINTVAR(pi, "ofdm5glpo");
 
 			pi->mcs5glpo[0] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo0");
+			    (u16) PHY_GETINTVAR(pi, "mcs5glpo0");
 			pi->mcs5glpo[1] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo1");
+			    (u16) PHY_GETINTVAR(pi, "mcs5glpo1");
 			pi->mcs5glpo[2] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo2");
+			    (u16) PHY_GETINTVAR(pi, "mcs5glpo2");
 			pi->mcs5glpo[3] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo3");
+			    (u16) PHY_GETINTVAR(pi, "mcs5glpo3");
 			pi->mcs5glpo[4] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo4");
+			    (u16) PHY_GETINTVAR(pi, "mcs5glpo4");
 			pi->mcs5glpo[5] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo5");
+			    (u16) PHY_GETINTVAR(pi, "mcs5glpo5");
 			pi->mcs5glpo[6] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo6");
+			    (u16) PHY_GETINTVAR(pi, "mcs5glpo6");
 			pi->mcs5glpo[7] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo7");
+			    (u16) PHY_GETINTVAR(pi, "mcs5glpo7");
 			break;
 		case 3:
 
 			pi->nphy_txpid5gh[0] =
-			    (uint8) PHY_GETINTVAR(pi, "txpid5gha0");
+			    (u8) PHY_GETINTVAR(pi, "txpid5gha0");
 			pi->nphy_txpid5gh[1] =
-			    (uint8) PHY_GETINTVAR(pi, "txpid5gha1");
+			    (u8) PHY_GETINTVAR(pi, "txpid5gha1");
 			pi->nphy_pwrctrl_info[0].max_pwr_5gh =
-			    (int8) PHY_GETINTVAR(pi, "maxp5gha0");
+			    (s8) PHY_GETINTVAR(pi, "maxp5gha0");
 			pi->nphy_pwrctrl_info[1].max_pwr_5gh =
-			    (int8) PHY_GETINTVAR(pi, "maxp5gha1");
+			    (s8) PHY_GETINTVAR(pi, "maxp5gha1");
 			pi->nphy_pwrctrl_info[0].pwrdet_5gh_a1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5ghw0a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5ghw0a0");
 			pi->nphy_pwrctrl_info[1].pwrdet_5gh_a1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5ghw0a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5ghw0a1");
 			pi->nphy_pwrctrl_info[0].pwrdet_5gh_b0 =
-			    (int16) PHY_GETINTVAR(pi, "pa5ghw1a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5ghw1a0");
 			pi->nphy_pwrctrl_info[1].pwrdet_5gh_b0 =
-			    (int16) PHY_GETINTVAR(pi, "pa5ghw1a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5ghw1a1");
 			pi->nphy_pwrctrl_info[0].pwrdet_5gh_b1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5ghw2a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5ghw2a0");
 			pi->nphy_pwrctrl_info[1].pwrdet_5gh_b1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5ghw2a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5ghw2a1");
 			pi->nphy_pwrctrl_info[0].idle_targ_5gh = 0;
 			pi->nphy_pwrctrl_info[1].idle_targ_5gh = 0;
 
-			pi->ofdm5ghpo = (uint32) PHY_GETINTVAR(pi, "ofdm5ghpo");
+			pi->ofdm5ghpo = (u32) PHY_GETINTVAR(pi, "ofdm5ghpo");
 
 			pi->mcs5ghpo[0] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo0");
+			    (u16) PHY_GETINTVAR(pi, "mcs5ghpo0");
 			pi->mcs5ghpo[1] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo1");
+			    (u16) PHY_GETINTVAR(pi, "mcs5ghpo1");
 			pi->mcs5ghpo[2] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo2");
+			    (u16) PHY_GETINTVAR(pi, "mcs5ghpo2");
 			pi->mcs5ghpo[3] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo3");
+			    (u16) PHY_GETINTVAR(pi, "mcs5ghpo3");
 			pi->mcs5ghpo[4] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo4");
+			    (u16) PHY_GETINTVAR(pi, "mcs5ghpo4");
 			pi->mcs5ghpo[5] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo5");
+			    (u16) PHY_GETINTVAR(pi, "mcs5ghpo5");
 			pi->mcs5ghpo[6] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo6");
+			    (u16) PHY_GETINTVAR(pi, "mcs5ghpo6");
 			pi->mcs5ghpo[7] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo7");
+			    (u16) PHY_GETINTVAR(pi, "mcs5ghpo7");
 			break;
 		}
 	}
@@ -28144,47 +28148,47 @@ static void BCMATTACHFN(wlc_phy_txpwr_srom_read_ppr_nphy) (phy_info_t * pi) {
 	wlc_phy_txpwr_apply_nphy(pi);
 }
 
-static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_nphy) (phy_info_t * pi) {
+static bool wlc_phy_txpwr_srom_read_nphy(phy_info_t *pi)
+{
 
-	pi->antswitch = (uint8) PHY_GETINTVAR(pi, "antswitch");
-	pi->aa2g = (uint8) PHY_GETINTVAR(pi, "aa2g");
-	pi->aa5g = (uint8) PHY_GETINTVAR(pi, "aa5g");
+	pi->antswitch = (u8) PHY_GETINTVAR(pi, "antswitch");
+	pi->aa2g = (u8) PHY_GETINTVAR(pi, "aa2g");
+	pi->aa5g = (u8) PHY_GETINTVAR(pi, "aa5g");
 
-	pi->srom_fem2g.tssipos = (uint8) PHY_GETINTVAR(pi, "tssipos2g");
-	pi->srom_fem2g.extpagain = (uint8) PHY_GETINTVAR(pi, "extpagain2g");
-	pi->srom_fem2g.pdetrange = (uint8) PHY_GETINTVAR(pi, "pdetrange2g");
-	pi->srom_fem2g.triso = (uint8) PHY_GETINTVAR(pi, "triso2g");
-	pi->srom_fem2g.antswctrllut = (uint8) PHY_GETINTVAR(pi, "antswctl2g");
+	pi->srom_fem2g.tssipos = (u8) PHY_GETINTVAR(pi, "tssipos2g");
+	pi->srom_fem2g.extpagain = (u8) PHY_GETINTVAR(pi, "extpagain2g");
+	pi->srom_fem2g.pdetrange = (u8) PHY_GETINTVAR(pi, "pdetrange2g");
+	pi->srom_fem2g.triso = (u8) PHY_GETINTVAR(pi, "triso2g");
+	pi->srom_fem2g.antswctrllut = (u8) PHY_GETINTVAR(pi, "antswctl2g");
 
-	pi->srom_fem5g.tssipos = (uint8) PHY_GETINTVAR(pi, "tssipos5g");
-	pi->srom_fem5g.extpagain = (uint8) PHY_GETINTVAR(pi, "extpagain5g");
-	pi->srom_fem5g.pdetrange = (uint8) PHY_GETINTVAR(pi, "pdetrange5g");
-	pi->srom_fem5g.triso = (uint8) PHY_GETINTVAR(pi, "triso5g");
+	pi->srom_fem5g.tssipos = (u8) PHY_GETINTVAR(pi, "tssipos5g");
+	pi->srom_fem5g.extpagain = (u8) PHY_GETINTVAR(pi, "extpagain5g");
+	pi->srom_fem5g.pdetrange = (u8) PHY_GETINTVAR(pi, "pdetrange5g");
+	pi->srom_fem5g.triso = (u8) PHY_GETINTVAR(pi, "triso5g");
 	if (PHY_GETVAR(pi, "antswctl5g")) {
 
 		pi->srom_fem5g.antswctrllut =
-		    (uint8) PHY_GETINTVAR(pi, "antswctl5g");
+		    (u8) PHY_GETINTVAR(pi, "antswctl5g");
 	} else {
 
 		pi->srom_fem5g.antswctrllut =
-		    (uint8) PHY_GETINTVAR(pi, "antswctl2g");
+		    (u8) PHY_GETINTVAR(pi, "antswctl2g");
 	}
 
 	wlc_phy_txpower_ipa_upd(pi);
 
-	pi->phy_txcore_disable_temp = (int16) PHY_GETINTVAR(pi, "tempthresh");
+	pi->phy_txcore_disable_temp = (s16) PHY_GETINTVAR(pi, "tempthresh");
 	if (pi->phy_txcore_disable_temp == 0) {
 		pi->phy_txcore_disable_temp = PHY_CHAIN_TX_DISABLE_TEMP;
 	}
 
-	pi->phy_tempsense_offset = (int8) PHY_GETINTVAR(pi, "tempoffset");
+	pi->phy_tempsense_offset = (s8) PHY_GETINTVAR(pi, "tempoffset");
 	if (pi->phy_tempsense_offset != 0) {
 		if (pi->phy_tempsense_offset >
 		    (NPHY_SROM_TEMPSHIFT + NPHY_SROM_MAXTEMPOFFSET)) {
 			pi->phy_tempsense_offset = NPHY_SROM_MAXTEMPOFFSET;
 		} else if (pi->phy_tempsense_offset < (NPHY_SROM_TEMPSHIFT +
-						       NPHY_SROM_MINTEMPOFFSET))
-		{
+						    NPHY_SROM_MINTEMPOFFSET)) {
 			pi->phy_tempsense_offset = NPHY_SROM_MINTEMPOFFSET;
 		} else {
 			pi->phy_tempsense_offset -= NPHY_SROM_TEMPSHIFT;
@@ -28194,19 +28198,19 @@ static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_nphy) (phy_info_t * pi) {
 	pi->phy_txcore_enable_temp =
 	    pi->phy_txcore_disable_temp - PHY_HYSTERESIS_DELTATEMP;
 
-	pi->phycal_tempdelta = (uint8) PHY_GETINTVAR(pi, "phycal_tempdelta");
+	pi->phycal_tempdelta = (u8) PHY_GETINTVAR(pi, "phycal_tempdelta");
 	if (pi->phycal_tempdelta > NPHY_CAL_MAXTEMPDELTA) {
 		pi->phycal_tempdelta = 0;
 	}
 
 	wlc_phy_txpwr_srom_read_ppr_nphy(pi);
 
-	return TRUE;
+	return true;
 }
 
-void wlc_phy_txpower_recalc_target_nphy(phy_info_t * pi)
+void wlc_phy_txpower_recalc_target_nphy(phy_info_t *pi)
 {
-	uint8 tx_pwr_ctrl_state;
+	u8 tx_pwr_ctrl_state;
 	wlc_phy_txpwr_limit_to_tbl_nphy(pi);
 	wlc_phy_txpwrctrl_pwr_setup_nphy(pi);
 
@@ -28215,7 +28219,7 @@ void wlc_phy_txpower_recalc_target_nphy(phy_info_t * pi)
 	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) {
 		wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK, MCTL_PHYLOCK);
 		(void)R_REG(pi->sh->osh, &pi->regs->maccontrol);
-		OSL_DELAY(1);
+		udelay(1);
 	}
 
 	wlc_phy_txpwrctrl_enable_nphy(pi, tx_pwr_ctrl_state);
@@ -28224,18 +28228,18 @@ void wlc_phy_txpower_recalc_target_nphy(phy_info_t * pi)
 		wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK, 0);
 }
 
-static void wlc_phy_txpwrctrl_coeff_setup_nphy(phy_info_t * pi)
+static void wlc_phy_txpwrctrl_coeff_setup_nphy(phy_info_t *pi)
 {
-	uint32 idx;
-	uint16 iqloCalbuf[7];
-	uint32 iqcomp, locomp, curr_locomp;
-	int8 locomp_i, locomp_q;
-	int8 curr_locomp_i, curr_locomp_q;
-	uint32 tbl_id, tbl_len, tbl_offset;
-	uint32 regval[128];
+	u32 idx;
+	u16 iqloCalbuf[7];
+	u32 iqcomp, locomp, curr_locomp;
+	s8 locomp_i, locomp_q;
+	s8 curr_locomp_i, curr_locomp_q;
+	u32 tbl_id, tbl_len, tbl_offset;
+	u32 regval[128];
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	wlc_phy_table_read_nphy(pi, 15, 7, 80, 16, iqloCalbuf);
 
@@ -28245,9 +28249,9 @@ static void wlc_phy_txpwrctrl_coeff_setup_nphy(phy_info_t * pi)
 	     tbl_id <= NPHY_TBL_ID_CORE2TXPWRCTL; tbl_id++) {
 		iqcomp =
 		    (tbl_id ==
-		     26) ? (((uint32) (iqloCalbuf[0] & 0x3ff)) << 10) |
+		     26) ? (((u32) (iqloCalbuf[0] & 0x3ff)) << 10) |
 		    (iqloCalbuf[1] & 0x3ff)
-		    : (((uint32) (iqloCalbuf[2] & 0x3ff)) << 10) |
+		    : (((u32) (iqloCalbuf[2] & 0x3ff)) << 10) |
 		    (iqloCalbuf[3] & 0x3ff);
 
 		for (idx = 0; idx < tbl_len; idx++) {
@@ -28262,23 +28266,23 @@ static void wlc_phy_txpwrctrl_coeff_setup_nphy(phy_info_t * pi)
 	     tbl_id <= NPHY_TBL_ID_CORE2TXPWRCTL; tbl_id++) {
 
 		locomp =
-		    (uint32) ((tbl_id == 26) ? iqloCalbuf[5] : iqloCalbuf[6]);
-		locomp_i = (int8) ((locomp >> 8) & 0xff);
-		locomp_q = (int8) ((locomp) & 0xff);
+		    (u32) ((tbl_id == 26) ? iqloCalbuf[5] : iqloCalbuf[6]);
+		locomp_i = (s8) ((locomp >> 8) & 0xff);
+		locomp_q = (s8) ((locomp) & 0xff);
 		for (idx = 0; idx < tbl_len; idx++) {
 			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 				curr_locomp_i = locomp_i;
 				curr_locomp_q = locomp_q;
 			} else {
-				curr_locomp_i = (int8) ((locomp_i *
+				curr_locomp_i = (s8) ((locomp_i *
 							 nphy_tpc_loscale[idx] +
 							 128) >> 8);
 				curr_locomp_q =
-				    (int8) ((locomp_q * nphy_tpc_loscale[idx] +
+				    (s8) ((locomp_q * nphy_tpc_loscale[idx] +
 					     128) >> 8);
 			}
-			curr_locomp = (uint32) ((curr_locomp_i & 0xff) << 8);
-			curr_locomp |= (uint32) (curr_locomp_q & 0xff);
+			curr_locomp = (u32) ((curr_locomp_i & 0xff) << 8);
+			curr_locomp |= (u32) (curr_locomp_q & 0xff);
 			regval[idx] = curr_locomp;
 		}
 		wlc_phy_table_write_nphy(pi, tbl_id, tbl_len, tbl_offset, 32,
@@ -28292,12 +28296,12 @@ static void wlc_phy_txpwrctrl_coeff_setup_nphy(phy_info_t * pi)
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
-static void wlc_phy_ipa_internal_tssi_setup_nphy(phy_info_t * pi)
+static void wlc_phy_ipa_internal_tssi_setup_nphy(phy_info_t *pi)
 {
-	uint8 core;
+	u8 core;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 		for (core = 0; core < pi->pubpi.phy_corenum; core++) {
@@ -28405,10 +28409,10 @@ static void wlc_phy_ipa_internal_tssi_setup_nphy(phy_info_t * pi)
 	}
 }
 
-static void wlc_phy_txpwrctrl_idle_tssi_nphy(phy_info_t * pi)
+static void wlc_phy_txpwrctrl_idle_tssi_nphy(phy_info_t *pi)
 {
-	int32 rssi_buf[4];
-	int32 int_val;
+	s32 rssi_buf[4];
+	s32 int_val;
 
 	if (SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi) || PHY_MUTED(pi))
 
@@ -28428,11 +28432,11 @@ static void wlc_phy_txpwrctrl_idle_tssi_nphy(phy_info_t * pi)
 
 	wlc_phy_stopplayback_nphy(pi);
 
-	wlc_phy_tx_tone_nphy(pi, 4000, 0, 0, 0, FALSE);
+	wlc_phy_tx_tone_nphy(pi, 4000, 0, 0, 0, false);
 
-	OSL_DELAY(20);
+	udelay(20);
 	int_val =
-	    wlc_phy_poll_rssi_nphy(pi, (uint8) NPHY_RSSI_SEL_TSSI_2G, rssi_buf,
+	    wlc_phy_poll_rssi_nphy(pi, (u8) NPHY_RSSI_SEL_TSSI_2G, rssi_buf,
 				   1);
 	wlc_phy_stopplayback_nphy(pi);
 	wlc_phy_rssisel_nphy(pi, RADIO_MIMO_CORESEL_OFF, 0);
@@ -28448,54 +28452,54 @@ static void wlc_phy_txpwrctrl_idle_tssi_nphy(phy_info_t * pi)
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 
 		pi->nphy_pwrctrl_info[PHY_CORE_0].idle_tssi_2g =
-		    (uint8) ((int_val >> 24) & 0xff);
+		    (u8) ((int_val >> 24) & 0xff);
 		pi->nphy_pwrctrl_info[PHY_CORE_0].idle_tssi_5g =
-		    (uint8) ((int_val >> 24) & 0xff);
+		    (u8) ((int_val >> 24) & 0xff);
 
 		pi->nphy_pwrctrl_info[PHY_CORE_1].idle_tssi_2g =
-		    (uint8) ((int_val >> 8) & 0xff);
+		    (u8) ((int_val >> 8) & 0xff);
 		pi->nphy_pwrctrl_info[PHY_CORE_1].idle_tssi_5g =
-		    (uint8) ((int_val >> 8) & 0xff);
+		    (u8) ((int_val >> 8) & 0xff);
 	} else {
 		pi->nphy_pwrctrl_info[PHY_CORE_0].idle_tssi_2g =
-		    (uint8) ((int_val >> 24) & 0xff);
+		    (u8) ((int_val >> 24) & 0xff);
 
 		pi->nphy_pwrctrl_info[PHY_CORE_1].idle_tssi_2g =
-		    (uint8) ((int_val >> 8) & 0xff);
+		    (u8) ((int_val >> 8) & 0xff);
 
 		pi->nphy_pwrctrl_info[PHY_CORE_0].idle_tssi_5g =
-		    (uint8) ((int_val >> 16) & 0xff);
+		    (u8) ((int_val >> 16) & 0xff);
 		pi->nphy_pwrctrl_info[PHY_CORE_1].idle_tssi_5g =
-		    (uint8) ((int_val) & 0xff);
+		    (u8) ((int_val) & 0xff);
 	}
 
 }
 
-static void wlc_phy_txpwrctrl_pwr_setup_nphy(phy_info_t * pi)
+static void wlc_phy_txpwrctrl_pwr_setup_nphy(phy_info_t *pi)
 {
-	uint32 idx;
-	int16 a1[2], b0[2], b1[2];
-	int8 target_pwr_qtrdbm[2];
-	int32 num, den, pwr_est;
-	uint8 chan_freq_range;
-	uint8 idle_tssi[2];
-	uint32 tbl_id, tbl_len, tbl_offset;
-	uint32 regval[64];
-	uint8 core;
+	u32 idx;
+	s16 a1[2], b0[2], b1[2];
+	s8 target_pwr_qtrdbm[2];
+	s32 num, den, pwr_est;
+	u8 chan_freq_range;
+	u8 idle_tssi[2];
+	u32 tbl_id, tbl_len, tbl_offset;
+	u32 regval[64];
+	u8 core;
 
 	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) {
 		wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK, MCTL_PHYLOCK);
 		(void)R_REG(pi->sh->osh, &pi->regs->maccontrol);
-		OSL_DELAY(1);
+		udelay(1);
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	or_phy_reg(pi, 0x122, (0x1 << 0));
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
-		and_phy_reg(pi, 0x1e7, (uint16) (~(0x1 << 15)));
+		and_phy_reg(pi, 0x1e7, (u16) (~(0x1 << 15)));
 	} else {
 
 		or_phy_reg(pi, 0x1e7, (0x1 << 15));
@@ -28590,8 +28594,8 @@ static void wlc_phy_txpwrctrl_pwr_setup_nphy(phy_info_t * pi)
 		}
 	}
 
-	target_pwr_qtrdbm[0] = (int8) pi->tx_power_max;
-	target_pwr_qtrdbm[1] = (int8) pi->tx_power_max;
+	target_pwr_qtrdbm[0] = (s8) pi->tx_power_max;
+	target_pwr_qtrdbm[1] = (s8) pi->tx_power_max;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		if (pi->srom_fem2g.tssipos) {
@@ -28643,7 +28647,7 @@ static void wlc_phy_txpwrctrl_pwr_setup_nphy(phy_info_t * pi)
 	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) {
 		wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK, MCTL_PHYLOCK);
 		(void)R_REG(pi->sh->osh, &pi->regs->maccontrol);
-		OSL_DELAY(1);
+		udelay(1);
 	}
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -28683,16 +28687,16 @@ static void wlc_phy_txpwrctrl_pwr_setup_nphy(phy_info_t * pi)
 			num =
 			    8 * (16 * b0[tbl_id - 26] + b1[tbl_id - 26] * idx);
 			den = 32768 + a1[tbl_id - 26] * idx;
-			pwr_est = MAX(((4 * num + den / 2) / den), -8);
+			pwr_est = max(((4 * num + den / 2) / den), -8);
 			if (NREV_LT(pi->pubpi.phy_rev, 3)) {
 				if (idx <=
 				    (uint) (31 - idle_tssi[tbl_id - 26] + 1))
 					pwr_est =
-					    MAX(pwr_est,
+					    max(pwr_est,
 						target_pwr_qtrdbm[tbl_id - 26] +
 						1);
 			}
-			regval[idx] = (uint32) pwr_est;
+			regval[idx] = (u32) pwr_est;
 		}
 		wlc_phy_table_write_nphy(pi, tbl_id, tbl_len, tbl_offset, 32,
 					 regval);
@@ -28705,26 +28709,26 @@ static void wlc_phy_txpwrctrl_pwr_setup_nphy(phy_info_t * pi)
 				 pi->adj_pwr_tbl_nphy);
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
-static bool wlc_phy_txpwr_ison_nphy(phy_info_t * pi)
+static bool wlc_phy_txpwr_ison_nphy(phy_info_t *pi)
 {
-	return (read_phy_reg((pi), 0x1e7) & ((0x1 << 15) |
-					     (0x1 << 14) | (0x1 << 13)));
+	return read_phy_reg((pi), 0x1e7) & ((0x1 << 15) |
+					     (0x1 << 14) | (0x1 << 13));
 }
 
-static uint8 wlc_phy_txpwr_idx_cur_get_nphy(phy_info_t * pi, uint8 core)
+static u8 wlc_phy_txpwr_idx_cur_get_nphy(phy_info_t *pi, u8 core)
 {
-	uint16 tmp;
+	u16 tmp;
 	tmp = read_phy_reg(pi, ((core == PHY_CORE_0) ? 0x1ed : 0x1ee));
 
 	tmp = (tmp & (0x7f << 8)) >> 8;
-	return (uint8) tmp;
+	return (u8) tmp;
 }
 
 static void
-wlc_phy_txpwr_idx_cur_set_nphy(phy_info_t * pi, uint8 idx0, uint8 idx1)
+wlc_phy_txpwr_idx_cur_set_nphy(phy_info_t *pi, u8 idx0, u8 idx1)
 {
 	mod_phy_reg(pi, 0x1e7, (0x7f << 0), idx0);
 
@@ -28732,10 +28736,10 @@ wlc_phy_txpwr_idx_cur_set_nphy(phy_info_t * pi, uint8 idx0, uint8 idx1)
 		mod_phy_reg(pi, 0x222, (0xff << 0), idx1);
 }
 
-uint16 wlc_phy_txpwr_idx_get_nphy(phy_info_t * pi)
+u16 wlc_phy_txpwr_idx_get_nphy(phy_info_t *pi)
 {
-	uint16 tmp;
-	uint16 pwr_idx[2];
+	u16 tmp;
+	u16 pwr_idx[2];
 
 	if (wlc_phy_txpwr_ison_nphy(pi)) {
 		pwr_idx[0] = wlc_phy_txpwr_idx_cur_get_nphy(pi, PHY_CORE_0);
@@ -28754,33 +28758,33 @@ uint16 wlc_phy_txpwr_idx_get_nphy(phy_info_t * pi)
 	return tmp;
 }
 
-void wlc_phy_txpwr_papd_cal_nphy(phy_info_t * pi)
+void wlc_phy_txpwr_papd_cal_nphy(phy_info_t *pi)
 {
 	if (PHY_IPA(pi)
 	    && (pi->nphy_force_papd_cal
 		|| (wlc_phy_txpwr_ison_nphy(pi)
 		    &&
-		    (((uint32)
+		    (((u32)
 		      ABS(wlc_phy_txpwr_idx_cur_get_nphy(pi, 0) -
 			  pi->nphy_papd_tx_gain_at_last_cal[0]) >= 4)
-		     || ((uint32)
+		     || ((u32)
 			 ABS(wlc_phy_txpwr_idx_cur_get_nphy(pi, 1) -
 			     pi->nphy_papd_tx_gain_at_last_cal[1]) >= 4))))) {
-		wlc_phy_a4(pi, TRUE);
+		wlc_phy_a4(pi, true);
 	}
 }
 
-void wlc_phy_txpwrctrl_enable_nphy(phy_info_t * pi, uint8 ctrl_type)
+void wlc_phy_txpwrctrl_enable_nphy(phy_info_t *pi, u8 ctrl_type)
 {
-	uint16 mask = 0, val = 0, ishw = 0;
-	uint8 ctr;
+	u16 mask = 0, val = 0, ishw = 0;
+	u8 ctr;
 	uint core;
-	uint32 tbl_offset;
-	uint32 tbl_len;
-	uint16 regval[84];
+	u32 tbl_offset;
+	u32 tbl_len;
+	u16 regval[84];
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	switch (ctrl_type) {
 	case PHY_TPC_HW_OFF:
@@ -28799,7 +28803,7 @@ void wlc_phy_txpwrctrl_enable_nphy(phy_info_t * pi, uint8 ctrl_type)
 				     core++)
 					pi->nphy_txpwr_idx[core] =
 					    wlc_phy_txpwr_idx_cur_get_nphy(pi,
-									   (uint8)
+									   (u8)
 									   core);
 			}
 
@@ -28818,11 +28822,11 @@ void wlc_phy_txpwrctrl_enable_nphy(phy_info_t * pi, uint8 ctrl_type)
 		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 
 			and_phy_reg(pi, 0x1e7,
-				    (uint16) (~((0x1 << 15) |
+				    (u16) (~((0x1 << 15) |
 						(0x1 << 14) | (0x1 << 13))));
 		} else {
 			and_phy_reg(pi, 0x1e7,
-				    (uint16) (~((0x1 << 14) | (0x1 << 13))));
+				    (u16) (~((0x1 << 14) | (0x1 << 13))));
 		}
 
 		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
@@ -28912,29 +28916,29 @@ void wlc_phy_txpwrctrl_enable_nphy(phy_info_t * pi, uint8 ctrl_type)
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
 void
-wlc_phy_txpwr_index_nphy(phy_info_t * pi, uint8 core_mask, int8 txpwrindex,
+wlc_phy_txpwr_index_nphy(phy_info_t *pi, u8 core_mask, s8 txpwrindex,
 			 bool restore_cals)
 {
-	uint8 core, txpwrctl_tbl;
-	uint16 tx_ind0, iq_ind0, lo_ind0;
-	uint16 m1m2;
-	uint32 txgain;
-	uint16 rad_gain, dac_gain;
-	uint8 bbmult;
-	uint32 iqcomp;
-	uint16 iqcomp_a, iqcomp_b;
-	uint32 locomp;
-	uint16 tmpval;
-	uint8 tx_pwr_ctrl_state;
-	int32 rfpwr_offset;
-	uint16 regval[2];
+	u8 core, txpwrctl_tbl;
+	u16 tx_ind0, iq_ind0, lo_ind0;
+	u16 m1m2;
+	u32 txgain;
+	u16 rad_gain, dac_gain;
+	u8 bbmult;
+	u32 iqcomp;
+	u16 iqcomp_a, iqcomp_b;
+	u32 locomp;
+	u16 tmpval;
+	u8 tx_pwr_ctrl_state;
+	s32 rfpwr_offset;
+	u16 regval[2];
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	tx_ind0 = 192;
 	iq_ind0 = 320;
@@ -29042,7 +29046,7 @@ wlc_phy_txpwr_index_nphy(phy_info_t * pi, uint8 core_mask, int8 txpwrindex,
 				tmpval >>= ((core == PHY_CORE_0) ? 8 : 0);
 				tmpval &= 0xff;
 				pi->nphy_txpwrindex[core].bbmult =
-				    (uint8) tmpval;
+				    (u8) tmpval;
 
 				wlc_phy_table_read_nphy(pi, 15, 2,
 							(80 + 2 * core), 16,
@@ -29107,8 +29111,8 @@ wlc_phy_txpwr_index_nphy(phy_info_t * pi, uint8 core_mask, int8 txpwrindex,
 			iqcomp_b = (iqcomp >> 0) & ((1 << (9 - 0 + 1)) - 1);
 
 			if (restore_cals) {
-				regval[0] = (uint16) iqcomp_a;
-				regval[1] = (uint16) iqcomp_b;
+				regval[0] = (u16) iqcomp_a;
+				regval[1] = (u16) iqcomp_b;
 				wlc_phy_table_write_nphy(pi, 15, 2,
 							 (80 + 2 * core), 16,
 							 regval);
@@ -29137,7 +29141,7 @@ wlc_phy_txpwr_index_nphy(phy_info_t * pi, uint8 core_mask, int8 txpwrindex,
 
 				mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
 					    0x29b, (0x1ff << 4),
-					    ((int16) rfpwr_offset) << 4);
+					    ((s16) rfpwr_offset) << 4);
 
 				mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
 					    0x29b, (0x1 << 2), (1) << 2);
@@ -29151,14 +29155,14 @@ wlc_phy_txpwr_index_nphy(phy_info_t * pi, uint8 core_mask, int8 txpwrindex,
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
 void
-wlc_phy_txpower_sromlimit_get_nphy(phy_info_t * pi, uint chan, uint8 * max_pwr,
-				   uint8 txp_rate_idx)
+wlc_phy_txpower_sromlimit_get_nphy(phy_info_t *pi, uint chan, u8 *max_pwr,
+				   u8 txp_rate_idx)
 {
-	uint8 chan_freq_range;
+	u8 chan_freq_range;
 
 	chan_freq_range = wlc_phy_get_chan_freq_range_nphy(pi, chan);
 	switch (chan_freq_range) {
@@ -29183,9 +29187,9 @@ wlc_phy_txpower_sromlimit_get_nphy(phy_info_t * pi, uint chan, uint8 * max_pwr,
 	return;
 }
 
-void wlc_phy_stay_in_carriersearch_nphy(phy_info_t * pi, bool enable)
+void wlc_phy_stay_in_carriersearch_nphy(phy_info_t *pi, bool enable)
 {
-	uint16 clip_off[] = { 0xffff, 0xffff };
+	u16 clip_off[] = { 0xffff, 0xffff };
 
 	ASSERT(0 == (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
 
@@ -29215,16 +29219,16 @@ void wlc_phy_stay_in_carriersearch_nphy(phy_info_t * pi, bool enable)
 	}
 }
 
-void wlc_nphy_deaf_mode(phy_info_t * pi, bool mode)
+void wlc_nphy_deaf_mode(phy_info_t *pi, bool mode)
 {
 	wlapi_suspend_mac_and_wait(pi->sh->physhim);
 
 	if (mode) {
 		if (pi->nphy_deaf_count == 0)
-			wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+			wlc_phy_stay_in_carriersearch_nphy(pi, true);
 	} else {
 		if (pi->nphy_deaf_count > 0)
-			wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+			wlc_phy_stay_in_carriersearch_nphy(pi, false);
 	}
 	wlapi_enable_mac(pi->sh->physhim);
 }
diff --git a/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.c b/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.c
index adfb97b..6ce9e5d 100644
--- a/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.c
@@ -14,12 +14,11 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <typedefs.h>
-
+#include <linux/types.h>
 #include <wlc_phy_int.h>
 #include <wlc_phytbl_lcn.h>
 
-CONST uint32 dot11lcn_gain_tbl_rev0[] = {
+const u32 dot11lcn_gain_tbl_rev0[] = {
 	0x00000000,
 	0x00000000,
 	0x00000000,
@@ -118,7 +117,7 @@ CONST uint32 dot11lcn_gain_tbl_rev0[] = {
 	0x00000000,
 };
 
-CONST uint32 dot11lcn_gain_tbl_rev1[] = {
+const u32 dot11lcn_gain_tbl_rev1[] = {
 	0x00000000,
 	0x00000000,
 	0x00000000,
@@ -217,7 +216,7 @@ CONST uint32 dot11lcn_gain_tbl_rev1[] = {
 	0x00000000,
 };
 
-CONST uint16 dot11lcn_aux_gain_idx_tbl_rev0[] = {
+const u16 dot11lcn_aux_gain_idx_tbl_rev0[] = {
 	0x0401,
 	0x0402,
 	0x0403,
@@ -258,7 +257,7 @@ CONST uint16 dot11lcn_aux_gain_idx_tbl_rev0[] = {
 	0x0000,
 };
 
-CONST uint32 dot11lcn_gain_idx_tbl_rev0[] = {
+const u32 dot11lcn_gain_idx_tbl_rev0[] = {
 	0x00000000,
 	0x00000000,
 	0x10000000,
@@ -409,7 +408,7 @@ CONST uint32 dot11lcn_gain_idx_tbl_rev0[] = {
 	0x0000001c,
 };
 
-CONST uint16 dot11lcn_aux_gain_idx_tbl_2G[] = {
+const u16 dot11lcn_aux_gain_idx_tbl_2G[] = {
 	0x0000,
 	0x0000,
 	0x0000,
@@ -450,7 +449,7 @@ CONST uint16 dot11lcn_aux_gain_idx_tbl_2G[] = {
 	0x0000
 };
 
-CONST uint8 dot11lcn_gain_val_tbl_2G[] = {
+const u8 dot11lcn_gain_val_tbl_2G[] = {
 	0xfc,
 	0x02,
 	0x08,
@@ -521,7 +520,7 @@ CONST uint8 dot11lcn_gain_val_tbl_2G[] = {
 	0x00
 };
 
-CONST uint32 dot11lcn_gain_idx_tbl_2G[] = {
+const u32 dot11lcn_gain_idx_tbl_2G[] = {
 	0x00000000,
 	0x00000000,
 	0x00000000,
@@ -676,7 +675,7 @@ CONST uint32 dot11lcn_gain_idx_tbl_2G[] = {
 	0x00000000
 };
 
-CONST uint32 dot11lcn_gain_tbl_2G[] = {
+const u32 dot11lcn_gain_tbl_2G[] = {
 	0x00000000,
 	0x00000004,
 	0x00000008,
@@ -775,7 +774,7 @@ CONST uint32 dot11lcn_gain_tbl_2G[] = {
 	0x00000000
 };
 
-CONST uint32 dot11lcn_gain_tbl_extlna_2G[] = {
+const u32 dot11lcn_gain_tbl_extlna_2G[] = {
 	0x00000000,
 	0x00000004,
 	0x00000008,
@@ -874,7 +873,7 @@ CONST uint32 dot11lcn_gain_tbl_extlna_2G[] = {
 	0x00000000
 };
 
-CONST uint16 dot11lcn_aux_gain_idx_tbl_extlna_2G[] = {
+const u16 dot11lcn_aux_gain_idx_tbl_extlna_2G[] = {
 	0x0400,
 	0x0400,
 	0x0400,
@@ -915,7 +914,7 @@ CONST uint16 dot11lcn_aux_gain_idx_tbl_extlna_2G[] = {
 	0x0000
 };
 
-CONST uint8 dot11lcn_gain_val_tbl_extlna_2G[] = {
+const u8 dot11lcn_gain_val_tbl_extlna_2G[] = {
 	0xfc,
 	0x02,
 	0x08,
@@ -986,7 +985,7 @@ CONST uint8 dot11lcn_gain_val_tbl_extlna_2G[] = {
 	0x00
 };
 
-CONST uint32 dot11lcn_gain_idx_tbl_extlna_2G[] = {
+const u32 dot11lcn_gain_idx_tbl_extlna_2G[] = {
 	0x00000000,
 	0x00000040,
 	0x00000000,
@@ -1141,7 +1140,7 @@ CONST uint32 dot11lcn_gain_idx_tbl_extlna_2G[] = {
 	0x00000000
 };
 
-CONST uint32 dot11lcn_aux_gain_idx_tbl_5G[] = {
+const u32 dot11lcn_aux_gain_idx_tbl_5G[] = {
 	0x0000,
 	0x0000,
 	0x0000,
@@ -1182,7 +1181,7 @@ CONST uint32 dot11lcn_aux_gain_idx_tbl_5G[] = {
 	0x0000
 };
 
-CONST uint32 dot11lcn_gain_val_tbl_5G[] = {
+const u32 dot11lcn_gain_val_tbl_5G[] = {
 	0xf7,
 	0xfd,
 	0x00,
@@ -1253,7 +1252,7 @@ CONST uint32 dot11lcn_gain_val_tbl_5G[] = {
 	0x00
 };
 
-CONST uint32 dot11lcn_gain_idx_tbl_5G[] = {
+const u32 dot11lcn_gain_idx_tbl_5G[] = {
 	0x00000000,
 	0x00000000,
 	0x00000000,
@@ -1408,7 +1407,7 @@ CONST uint32 dot11lcn_gain_idx_tbl_5G[] = {
 	0x00000000
 };
 
-CONST uint32 dot11lcn_gain_tbl_5G[] = {
+const u32 dot11lcn_gain_tbl_5G[] = {
 	0x00000000,
 	0x00000040,
 	0x00000080,
@@ -1507,7 +1506,7 @@ CONST uint32 dot11lcn_gain_tbl_5G[] = {
 	0x00000000
 };
 
-CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_rev0[] = {
+const dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_rev0[] = {
 	{&dot11lcn_gain_tbl_rev0,
 	 sizeof(dot11lcn_gain_tbl_rev0) / sizeof(dot11lcn_gain_tbl_rev0[0]), 18,
 	 0, 32}
@@ -1522,7 +1521,7 @@ CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_rev0[] = {
 	,
 };
 
-CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_rev1[] = {
+const dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_rev1[] = {
 	{&dot11lcn_gain_tbl_rev1,
 	 sizeof(dot11lcn_gain_tbl_rev1) / sizeof(dot11lcn_gain_tbl_rev1[0]), 18,
 	 0, 32}
@@ -1537,7 +1536,7 @@ CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_rev1[] = {
 	,
 };
 
-CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_2G_rev2[] = {
+const dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_2G_rev2[] = {
 	{&dot11lcn_gain_tbl_2G,
 	 sizeof(dot11lcn_gain_tbl_2G) / sizeof(dot11lcn_gain_tbl_2G[0]), 18, 0,
 	 32}
@@ -1555,7 +1554,7 @@ CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_2G_rev2[] = {
 	 17, 0, 8}
 };
 
-CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_5G_rev2[] = {
+const dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_5G_rev2[] = {
 	{&dot11lcn_gain_tbl_5G,
 	 sizeof(dot11lcn_gain_tbl_5G) / sizeof(dot11lcn_gain_tbl_5G[0]), 18, 0,
 	 32}
@@ -1573,7 +1572,7 @@ CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_5G_rev2[] = {
 	 17, 0, 8}
 };
 
-CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_extlna_2G_rev2[] = {
+const dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_extlna_2G_rev2[] = {
 	{&dot11lcn_gain_tbl_extlna_2G,
 	 sizeof(dot11lcn_gain_tbl_extlna_2G) /
 	 sizeof(dot11lcn_gain_tbl_extlna_2G[0]), 18, 0, 32}
@@ -1591,7 +1590,7 @@ CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_extlna_2G_rev2[] = {
 	 sizeof(dot11lcn_gain_val_tbl_extlna_2G[0]), 17, 0, 8}
 };
 
-CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_extlna_5G_rev2[] = {
+const dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_extlna_5G_rev2[] = {
 	{&dot11lcn_gain_tbl_5G,
 	 sizeof(dot11lcn_gain_tbl_5G) / sizeof(dot11lcn_gain_tbl_5G[0]), 18, 0,
 	 32}
@@ -1609,23 +1608,23 @@ CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_extlna_5G_rev2[] = {
 	 17, 0, 8}
 };
 
-CONST uint32 dot11lcnphytbl_rx_gain_info_sz_rev0 =
+const u32 dot11lcnphytbl_rx_gain_info_sz_rev0 =
     sizeof(dot11lcnphytbl_rx_gain_info_rev0) /
     sizeof(dot11lcnphytbl_rx_gain_info_rev0[0]);
 
-CONST uint32 dot11lcnphytbl_rx_gain_info_sz_rev1 =
+const u32 dot11lcnphytbl_rx_gain_info_sz_rev1 =
     sizeof(dot11lcnphytbl_rx_gain_info_rev1) /
     sizeof(dot11lcnphytbl_rx_gain_info_rev1[0]);
 
-CONST uint32 dot11lcnphytbl_rx_gain_info_2G_rev2_sz =
+const u32 dot11lcnphytbl_rx_gain_info_2G_rev2_sz =
     sizeof(dot11lcnphytbl_rx_gain_info_2G_rev2) /
     sizeof(dot11lcnphytbl_rx_gain_info_2G_rev2[0]);
 
-CONST uint32 dot11lcnphytbl_rx_gain_info_5G_rev2_sz =
+const u32 dot11lcnphytbl_rx_gain_info_5G_rev2_sz =
     sizeof(dot11lcnphytbl_rx_gain_info_5G_rev2) /
     sizeof(dot11lcnphytbl_rx_gain_info_5G_rev2[0]);
 
-CONST uint16 dot11lcn_min_sig_sq_tbl_rev0[] = {
+const u16 dot11lcn_min_sig_sq_tbl_rev0[] = {
 	0x014d,
 	0x014d,
 	0x014d,
@@ -1692,7 +1691,7 @@ CONST uint16 dot11lcn_min_sig_sq_tbl_rev0[] = {
 	0x014d,
 };
 
-CONST uint16 dot11lcn_noise_scale_tbl_rev0[] = {
+const u16 dot11lcn_noise_scale_tbl_rev0[] = {
 	0x0000,
 	0x0000,
 	0x0000,
@@ -1759,7 +1758,7 @@ CONST uint16 dot11lcn_noise_scale_tbl_rev0[] = {
 	0x0000,
 };
 
-CONST uint32 dot11lcn_fltr_ctrl_tbl_rev0[] = {
+const u32 dot11lcn_fltr_ctrl_tbl_rev0[] = {
 	0x000141f8,
 	0x000021f8,
 	0x000021fb,
@@ -1772,7 +1771,7 @@ CONST uint32 dot11lcn_fltr_ctrl_tbl_rev0[] = {
 	0x0000024b,
 };
 
-CONST uint32 dot11lcn_ps_ctrl_tbl_rev0[] = {
+const u32 dot11lcn_ps_ctrl_tbl_rev0[] = {
 	0x00100001,
 	0x00200010,
 	0x00300001,
@@ -1795,7 +1794,7 @@ CONST uint32 dot11lcn_ps_ctrl_tbl_rev0[] = {
 	0x00600f22,
 };
 
-CONST uint16 dot11lcn_sw_ctrl_tbl_4313_epa_rev0_combo[] = {
+const u16 dot11lcn_sw_ctrl_tbl_4313_epa_rev0_combo[] = {
 	0x0007,
 	0x0005,
 	0x0006,
@@ -1863,7 +1862,7 @@ CONST uint16 dot11lcn_sw_ctrl_tbl_4313_epa_rev0_combo[] = {
 
 };
 
-CONST uint16 dot11lcn_sw_ctrl_tbl_4313_bt_epa_p250_rev0[] = {
+const u16 dot11lcn_sw_ctrl_tbl_4313_bt_epa_p250_rev0[] = {
 	0x0007,
 	0x0005,
 	0x0002,
@@ -1930,7 +1929,7 @@ CONST uint16 dot11lcn_sw_ctrl_tbl_4313_bt_epa_p250_rev0[] = {
 	0x0002,
 };
 
-CONST uint16 dot11lcn_sw_ctrl_tbl_4313_epa_rev0[] = {
+const u16 dot11lcn_sw_ctrl_tbl_4313_epa_rev0[] = {
 	0x0002,
 	0x0008,
 	0x0004,
@@ -1997,7 +1996,7 @@ CONST uint16 dot11lcn_sw_ctrl_tbl_4313_epa_rev0[] = {
 	0x0001,
 };
 
-CONST uint16 dot11lcn_sw_ctrl_tbl_4313_rev0[] = {
+const u16 dot11lcn_sw_ctrl_tbl_4313_rev0[] = {
 	0x000a,
 	0x0009,
 	0x0006,
@@ -2064,7 +2063,7 @@ CONST uint16 dot11lcn_sw_ctrl_tbl_4313_rev0[] = {
 	0x0005,
 };
 
-CONST uint16 dot11lcn_sw_ctrl_tbl_rev0[] = {
+const u16 dot11lcn_sw_ctrl_tbl_rev0[] = {
 	0x0004,
 	0x0004,
 	0x0002,
@@ -2131,7 +2130,7 @@ CONST uint16 dot11lcn_sw_ctrl_tbl_rev0[] = {
 	0x0002,
 };
 
-CONST uint8 dot11lcn_nf_table_rev0[] = {
+const u8 dot11lcn_nf_table_rev0[] = {
 	0x5f,
 	0x36,
 	0x29,
@@ -2150,7 +2149,7 @@ CONST uint8 dot11lcn_nf_table_rev0[] = {
 	0x1f,
 };
 
-CONST uint8 dot11lcn_gain_val_tbl_rev0[] = {
+const u8 dot11lcn_gain_val_tbl_rev0[] = {
 	0x09,
 	0x0f,
 	0x14,
@@ -2213,7 +2212,7 @@ CONST uint8 dot11lcn_gain_val_tbl_rev0[] = {
 	0x00,
 };
 
-CONST uint8 dot11lcn_spur_tbl_rev0[] = {
+const u8 dot11lcn_spur_tbl_rev0[] = {
 	0x01,
 	0x01,
 	0x01,
@@ -2344,7 +2343,7 @@ CONST uint8 dot11lcn_spur_tbl_rev0[] = {
 	0x01,
 };
 
-CONST uint16 dot11lcn_unsup_mcs_tbl_rev0[] = {
+const u16 dot11lcn_unsup_mcs_tbl_rev0[] = {
 	0x001a,
 	0x0034,
 	0x004e,
@@ -2501,7 +2500,7 @@ CONST uint16 dot11lcn_unsup_mcs_tbl_rev0[] = {
 	0x06f6,
 };
 
-CONST uint16 dot11lcn_iq_local_tbl_rev0[] = {
+const u16 dot11lcn_iq_local_tbl_rev0[] = {
 	0x0200,
 	0x0300,
 	0x0400,
@@ -2612,7 +2611,7 @@ CONST uint16 dot11lcn_iq_local_tbl_rev0[] = {
 	0x0000,
 };
 
-CONST uint32 dot11lcn_papd_compdelta_tbl_rev0[] = {
+const u32 dot11lcn_papd_compdelta_tbl_rev0[] = {
 	0x00080000,
 	0x00080000,
 	0x00080000,
@@ -2775,7 +2774,7 @@ CONST uint32 dot11lcn_papd_compdelta_tbl_rev0[] = {
 	0x00080000,
 };
 
-CONST dot11lcnphytbl_info_t dot11lcnphytbl_info_rev0[] = {
+const dot11lcnphytbl_info_t dot11lcnphytbl_info_rev0[] = {
 	{&dot11lcn_min_sig_sq_tbl_rev0,
 	 sizeof(dot11lcn_min_sig_sq_tbl_rev0) /
 	 sizeof(dot11lcn_min_sig_sq_tbl_rev0[0]), 2, 0, 16}
@@ -2834,34 +2833,34 @@ CONST dot11lcnphytbl_info_t dot11lcnphytbl_info_rev0[] = {
 	,
 };
 
-CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313 = {
+const dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313 = {
 	&dot11lcn_sw_ctrl_tbl_4313_rev0,
 	    sizeof(dot11lcn_sw_ctrl_tbl_4313_rev0) /
 	    sizeof(dot11lcn_sw_ctrl_tbl_4313_rev0[0]), 15, 0, 16
 };
 
-CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_epa = {
+const dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_epa = {
 	&dot11lcn_sw_ctrl_tbl_4313_epa_rev0,
 	    sizeof(dot11lcn_sw_ctrl_tbl_4313_epa_rev0) /
 	    sizeof(dot11lcn_sw_ctrl_tbl_4313_epa_rev0[0]), 15, 0, 16
 };
 
-CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_bt_epa = {
+const dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_bt_epa = {
 	&dot11lcn_sw_ctrl_tbl_4313_epa_rev0_combo,
 	    sizeof(dot11lcn_sw_ctrl_tbl_4313_epa_rev0_combo) /
 	    sizeof(dot11lcn_sw_ctrl_tbl_4313_epa_rev0_combo[0]), 15, 0, 16
 };
 
-CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_bt_epa_p250 = {
+const dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_bt_epa_p250 = {
 	&dot11lcn_sw_ctrl_tbl_4313_bt_epa_p250_rev0,
 	    sizeof(dot11lcn_sw_ctrl_tbl_4313_bt_epa_p250_rev0) /
 	    sizeof(dot11lcn_sw_ctrl_tbl_4313_bt_epa_p250_rev0[0]), 15, 0, 16
 };
 
-CONST uint32 dot11lcnphytbl_info_sz_rev0 =
+const u32 dot11lcnphytbl_info_sz_rev0 =
     sizeof(dot11lcnphytbl_info_rev0) / sizeof(dot11lcnphytbl_info_rev0[0]);
 
-CONST lcnphy_tx_gain_tbl_entry dot11lcnphy_2GHz_extPA_gaintable_rev0[128] = {
+const lcnphy_tx_gain_tbl_entry dot11lcnphy_2GHz_extPA_gaintable_rev0[128] = {
 	{3, 0, 31, 0, 72,}
 	,
 	{3, 0, 31, 0, 70,}
@@ -3120,7 +3119,7 @@ CONST lcnphy_tx_gain_tbl_entry dot11lcnphy_2GHz_extPA_gaintable_rev0[128] = {
 	,
 };
 
-CONST lcnphy_tx_gain_tbl_entry dot11lcnphy_2GHz_gaintable_rev0[128] = {
+const lcnphy_tx_gain_tbl_entry dot11lcnphy_2GHz_gaintable_rev0[128] = {
 	{7, 0, 31, 0, 72,}
 	,
 	{7, 0, 31, 0, 70,}
@@ -3379,7 +3378,7 @@ CONST lcnphy_tx_gain_tbl_entry dot11lcnphy_2GHz_gaintable_rev0[128] = {
 	,
 };
 
-CONST lcnphy_tx_gain_tbl_entry dot11lcnphy_5GHz_gaintable_rev0[128] = {
+const lcnphy_tx_gain_tbl_entry dot11lcnphy_5GHz_gaintable_rev0[128] = {
 	{255, 255, 0xf0, 0, 152,}
 	,
 	{255, 255, 0xf0, 0, 147,}
diff --git a/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.h b/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.h
index 8a8ef7b..5a64a98 100644
--- a/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.h
+++ b/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.h
@@ -16,34 +16,34 @@
 
 typedef phytbl_info_t dot11lcnphytbl_info_t;
 
-extern CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_rev0[];
-extern CONST uint32 dot11lcnphytbl_rx_gain_info_sz_rev0;
-extern CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313;
-extern CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_epa;
-extern CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_epa_combo;
+extern const dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_rev0[];
+extern const u32 dot11lcnphytbl_rx_gain_info_sz_rev0;
+extern const dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313;
+extern const dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_epa;
+extern const dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_epa_combo;
 
-extern CONST dot11lcnphytbl_info_t dot11lcnphytbl_info_rev0[];
-extern CONST uint32 dot11lcnphytbl_info_sz_rev0;
+extern const dot11lcnphytbl_info_t dot11lcnphytbl_info_rev0[];
+extern const u32 dot11lcnphytbl_info_sz_rev0;
 
-extern CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_2G_rev2[];
-extern CONST uint32 dot11lcnphytbl_rx_gain_info_2G_rev2_sz;
+extern const dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_2G_rev2[];
+extern const u32 dot11lcnphytbl_rx_gain_info_2G_rev2_sz;
 
-extern CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_5G_rev2[];
-extern CONST uint32 dot11lcnphytbl_rx_gain_info_5G_rev2_sz;
+extern const dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_5G_rev2[];
+extern const u32 dot11lcnphytbl_rx_gain_info_5G_rev2_sz;
 
-extern CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_extlna_2G_rev2[];
+extern const dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_extlna_2G_rev2[];
 
-extern CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_extlna_5G_rev2[];
+extern const dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_extlna_5G_rev2[];
 
 typedef struct {
-	uchar gm;
-	uchar pga;
-	uchar pad;
-	uchar dac;
-	uchar bb_mult;
+	unsigned char gm;
+	unsigned char pga;
+	unsigned char pad;
+	unsigned char dac;
+	unsigned char bb_mult;
 } lcnphy_tx_gain_tbl_entry;
 
-extern CONST lcnphy_tx_gain_tbl_entry dot11lcnphy_2GHz_gaintable_rev0[];
-extern CONST lcnphy_tx_gain_tbl_entry dot11lcnphy_2GHz_extPA_gaintable_rev0[];
+extern const lcnphy_tx_gain_tbl_entry dot11lcnphy_2GHz_gaintable_rev0[];
+extern const lcnphy_tx_gain_tbl_entry dot11lcnphy_2GHz_extPA_gaintable_rev0[];
 
-extern CONST lcnphy_tx_gain_tbl_entry dot11lcnphy_5GHz_gaintable_rev0[];
+extern const lcnphy_tx_gain_tbl_entry dot11lcnphy_5GHz_gaintable_rev0[];
diff --git a/drivers/staging/brcm80211/phy/wlc_phytbl_n.c b/drivers/staging/brcm80211/phy/wlc_phytbl_n.c
index e5f2e02..7cc2c56 100644
--- a/drivers/staging/brcm80211/phy/wlc_phytbl_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phytbl_n.c
@@ -14,12 +14,12 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <typedefs.h>
+#include <linux/kernel.h>
 
 #include <wlc_phy_int.h>
 #include <wlc_phytbl_n.h>
 
-CONST uint32 frame_struct_rev0[] = {
+const u32 frame_struct_rev0[] = {
 	0x08004a04,
 	0x00100000,
 	0x01000a05,
@@ -854,7 +854,7 @@ CONST uint32 frame_struct_rev0[] = {
 	0x00000000,
 };
 
-CONST uint8 frame_lut_rev0[] = {
+const u8 frame_lut_rev0[] = {
 	0x02,
 	0x04,
 	0x14,
@@ -889,7 +889,7 @@ CONST uint8 frame_lut_rev0[] = {
 	0x2a,
 };
 
-CONST uint32 tmap_tbl_rev0[] = {
+const u32 tmap_tbl_rev0[] = {
 	0x8a88aa80,
 	0x8aaaaa8a,
 	0x8a8a8aa8,
@@ -1340,7 +1340,7 @@ CONST uint32 tmap_tbl_rev0[] = {
 	0x00000000,
 };
 
-CONST uint32 tdtrn_tbl_rev0[] = {
+const u32 tdtrn_tbl_rev0[] = {
 	0x061c061c,
 	0x0050ee68,
 	0xf592fe36,
@@ -2047,7 +2047,7 @@ CONST uint32 tdtrn_tbl_rev0[] = {
 	0x00f006be,
 };
 
-CONST uint32 intlv_tbl_rev0[] = {
+const u32 intlv_tbl_rev0[] = {
 	0x00802070,
 	0x0671188d,
 	0x0a60192c,
@@ -2057,7 +2057,7 @@ CONST uint32 intlv_tbl_rev0[] = {
 	0x00000070,
 };
 
-CONST uint16 pilot_tbl_rev0[] = {
+const u16 pilot_tbl_rev0[] = {
 	0xff08,
 	0xff08,
 	0xff08,
@@ -2148,7 +2148,7 @@ CONST uint16 pilot_tbl_rev0[] = {
 	0xffff,
 };
 
-CONST uint32 pltlut_tbl_rev0[] = {
+const u32 pltlut_tbl_rev0[] = {
 	0x76540123,
 	0x62407351,
 	0x76543201,
@@ -2157,7 +2157,7 @@ CONST uint32 pltlut_tbl_rev0[] = {
 	0x76430521,
 };
 
-CONST uint32 tdi_tbl20_ant0_rev0[] = {
+const u32 tdi_tbl20_ant0_rev0[] = {
 	0x00091226,
 	0x000a1429,
 	0x000b56ad,
@@ -2215,7 +2215,7 @@ CONST uint32 tdi_tbl20_ant0_rev0[] = {
 	0x00000000,
 };
 
-CONST uint32 tdi_tbl20_ant1_rev0[] = {
+const u32 tdi_tbl20_ant1_rev0[] = {
 	0x00014b26,
 	0x00028d29,
 	0x000393ad,
@@ -2273,7 +2273,7 @@ CONST uint32 tdi_tbl20_ant1_rev0[] = {
 	0x00000000,
 };
 
-CONST uint32 tdi_tbl40_ant0_rev0[] = {
+const u32 tdi_tbl40_ant0_rev0[] = {
 	0x0011a346,
 	0x00136ccf,
 	0x0014f5d9,
@@ -2386,7 +2386,7 @@ CONST uint32 tdi_tbl40_ant0_rev0[] = {
 	0x00000000,
 };
 
-CONST uint32 tdi_tbl40_ant1_rev0[] = {
+const u32 tdi_tbl40_ant1_rev0[] = {
 	0x001edb36,
 	0x000129ca,
 	0x0002b353,
@@ -2499,7 +2499,7 @@ CONST uint32 tdi_tbl40_ant1_rev0[] = {
 	0x00000000,
 };
 
-CONST uint16 bdi_tbl_rev0[] = {
+const u16 bdi_tbl_rev0[] = {
 	0x0070,
 	0x0126,
 	0x012c,
@@ -2508,7 +2508,7 @@ CONST uint16 bdi_tbl_rev0[] = {
 	0x04d2,
 };
 
-CONST uint32 chanest_tbl_rev0[] = {
+const u32 chanest_tbl_rev0[] = {
 	0x44444444,
 	0x44444444,
 	0x44444444,
@@ -2607,7 +2607,7 @@ CONST uint32 chanest_tbl_rev0[] = {
 	0x10101010,
 };
 
-CONST uint8 mcs_tbl_rev0[] = {
+const u8 mcs_tbl_rev0[] = {
 	0x00,
 	0x08,
 	0x0a,
@@ -2738,7 +2738,7 @@ CONST uint8 mcs_tbl_rev0[] = {
 	0x00,
 };
 
-CONST uint32 noise_var_tbl0_rev0[] = {
+const u32 noise_var_tbl0_rev0[] = {
 	0x020c020c,
 	0x0000014d,
 	0x020c020c,
@@ -2997,7 +2997,7 @@ CONST uint32 noise_var_tbl0_rev0[] = {
 	0x0000014d,
 };
 
-CONST uint32 noise_var_tbl1_rev0[] = {
+const u32 noise_var_tbl1_rev0[] = {
 	0x020c020c,
 	0x0000014d,
 	0x020c020c,
@@ -3256,7 +3256,7 @@ CONST uint32 noise_var_tbl1_rev0[] = {
 	0x0000014d,
 };
 
-CONST uint8 est_pwr_lut_core0_rev0[] = {
+const u8 est_pwr_lut_core0_rev0[] = {
 	0x50,
 	0x4f,
 	0x4e,
@@ -3323,7 +3323,7 @@ CONST uint8 est_pwr_lut_core0_rev0[] = {
 	0x11,
 };
 
-CONST uint8 est_pwr_lut_core1_rev0[] = {
+const u8 est_pwr_lut_core1_rev0[] = {
 	0x50,
 	0x4f,
 	0x4e,
@@ -3390,7 +3390,7 @@ CONST uint8 est_pwr_lut_core1_rev0[] = {
 	0x11,
 };
 
-CONST uint8 adj_pwr_lut_core0_rev0[] = {
+const u8 adj_pwr_lut_core0_rev0[] = {
 	0x00,
 	0x00,
 	0x00,
@@ -3521,7 +3521,7 @@ CONST uint8 adj_pwr_lut_core0_rev0[] = {
 	0x00,
 };
 
-CONST uint8 adj_pwr_lut_core1_rev0[] = {
+const u8 adj_pwr_lut_core1_rev0[] = {
 	0x00,
 	0x00,
 	0x00,
@@ -3652,7 +3652,7 @@ CONST uint8 adj_pwr_lut_core1_rev0[] = {
 	0x00,
 };
 
-CONST uint32 gainctrl_lut_core0_rev0[] = {
+const u32 gainctrl_lut_core0_rev0[] = {
 	0x03cc2b44,
 	0x03cc2b42,
 	0x03cc2b40,
@@ -3783,7 +3783,7 @@ CONST uint32 gainctrl_lut_core0_rev0[] = {
 	0x00002b00,
 };
 
-CONST uint32 gainctrl_lut_core1_rev0[] = {
+const u32 gainctrl_lut_core1_rev0[] = {
 	0x03cc2b44,
 	0x03cc2b42,
 	0x03cc2b40,
@@ -3914,7 +3914,7 @@ CONST uint32 gainctrl_lut_core1_rev0[] = {
 	0x00002b00,
 };
 
-CONST uint32 iq_lut_core0_rev0[] = {
+const u32 iq_lut_core0_rev0[] = {
 	0x0000007f,
 	0x0000007f,
 	0x0000007f,
@@ -4045,7 +4045,7 @@ CONST uint32 iq_lut_core0_rev0[] = {
 	0x0000007f,
 };
 
-CONST uint32 iq_lut_core1_rev0[] = {
+const u32 iq_lut_core1_rev0[] = {
 	0x0000007f,
 	0x0000007f,
 	0x0000007f,
@@ -4176,7 +4176,7 @@ CONST uint32 iq_lut_core1_rev0[] = {
 	0x0000007f,
 };
 
-CONST uint16 loft_lut_core0_rev0[] = {
+const u16 loft_lut_core0_rev0[] = {
 	0x0000,
 	0x0101,
 	0x0002,
@@ -4307,7 +4307,7 @@ CONST uint16 loft_lut_core0_rev0[] = {
 	0x0103,
 };
 
-CONST uint16 loft_lut_core1_rev0[] = {
+const u16 loft_lut_core1_rev0[] = {
 	0x0000,
 	0x0101,
 	0x0002,
@@ -4438,7 +4438,7 @@ CONST uint16 loft_lut_core1_rev0[] = {
 	0x0103,
 };
 
-CONST mimophytbl_info_t mimophytbl_info_rev0_volatile[] = {
+const mimophytbl_info_t mimophytbl_info_rev0_volatile[] = {
 	{&bdi_tbl_rev0, sizeof(bdi_tbl_rev0) / sizeof(bdi_tbl_rev0[0]), 21, 0,
 	 16}
 	,
@@ -4486,7 +4486,7 @@ CONST mimophytbl_info_t mimophytbl_info_rev0_volatile[] = {
 	,
 };
 
-CONST mimophytbl_info_t mimophytbl_info_rev0[] = {
+const mimophytbl_info_t mimophytbl_info_rev0[] = {
 	{&frame_struct_rev0,
 	 sizeof(frame_struct_rev0) / sizeof(frame_struct_rev0[0]), 10, 0, 32}
 	,
@@ -4536,13 +4536,13 @@ CONST mimophytbl_info_t mimophytbl_info_rev0[] = {
 	,
 };
 
-CONST uint32 mimophytbl_info_sz_rev0 =
+const u32 mimophytbl_info_sz_rev0 =
     sizeof(mimophytbl_info_rev0) / sizeof(mimophytbl_info_rev0[0]);
-CONST uint32 mimophytbl_info_sz_rev0_volatile =
+const u32 mimophytbl_info_sz_rev0_volatile =
     sizeof(mimophytbl_info_rev0_volatile) /
     sizeof(mimophytbl_info_rev0_volatile[0]);
 
-CONST uint16 ant_swctrl_tbl_rev3[] = {
+const u16 ant_swctrl_tbl_rev3[] = {
 	0x0082,
 	0x0082,
 	0x0211,
@@ -4577,7 +4577,7 @@ CONST uint16 ant_swctrl_tbl_rev3[] = {
 	0x0000,
 };
 
-CONST uint16 ant_swctrl_tbl_rev3_1[] = {
+const u16 ant_swctrl_tbl_rev3_1[] = {
 	0x0022,
 	0x0022,
 	0x0011,
@@ -4612,7 +4612,7 @@ CONST uint16 ant_swctrl_tbl_rev3_1[] = {
 	0x0000,
 };
 
-CONST uint16 ant_swctrl_tbl_rev3_2[] = {
+const u16 ant_swctrl_tbl_rev3_2[] = {
 	0x0088,
 	0x0088,
 	0x0044,
@@ -4647,7 +4647,7 @@ CONST uint16 ant_swctrl_tbl_rev3_2[] = {
 	0x0000,
 };
 
-CONST uint16 ant_swctrl_tbl_rev3_3[] = {
+const u16 ant_swctrl_tbl_rev3_3[] = {
 	0x022,
 	0x022,
 	0x011,
@@ -4682,7 +4682,7 @@ CONST uint16 ant_swctrl_tbl_rev3_3[] = {
 	0x3cc
 };
 
-CONST uint32 frame_struct_rev3[] = {
+const u32 frame_struct_rev3[] = {
 	0x08004a04,
 	0x00100000,
 	0x01000a05,
@@ -5517,7 +5517,7 @@ CONST uint32 frame_struct_rev3[] = {
 	0x00000000,
 };
 
-CONST uint16 pilot_tbl_rev3[] = {
+const u16 pilot_tbl_rev3[] = {
 	0xff08,
 	0xff08,
 	0xff08,
@@ -5608,7 +5608,7 @@ CONST uint16 pilot_tbl_rev3[] = {
 	0xffff,
 };
 
-CONST uint32 tmap_tbl_rev3[] = {
+const u32 tmap_tbl_rev3[] = {
 	0x8a88aa80,
 	0x8aaaaa8a,
 	0x8a8a8aa8,
@@ -6059,7 +6059,7 @@ CONST uint32 tmap_tbl_rev3[] = {
 	0x00000000,
 };
 
-CONST uint32 intlv_tbl_rev3[] = {
+const u32 intlv_tbl_rev3[] = {
 	0x00802070,
 	0x0671188d,
 	0x0a60192c,
@@ -6069,7 +6069,7 @@ CONST uint32 intlv_tbl_rev3[] = {
 	0x00000070,
 };
 
-CONST uint32 tdtrn_tbl_rev3[] = {
+const u32 tdtrn_tbl_rev3[] = {
 	0x061c061c,
 	0x0050ee68,
 	0xf592fe36,
@@ -6776,7 +6776,7 @@ CONST uint32 tdtrn_tbl_rev3[] = {
 	0x00f006be,
 };
 
-CONST uint32 noise_var_tbl_rev3[] = {
+const u32 noise_var_tbl_rev3[] = {
 	0x02110211,
 	0x0000014d,
 	0x02110211,
@@ -7035,7 +7035,7 @@ CONST uint32 noise_var_tbl_rev3[] = {
 	0x0000014d,
 };
 
-CONST uint16 mcs_tbl_rev3[] = {
+const u16 mcs_tbl_rev3[] = {
 	0x0000,
 	0x0008,
 	0x000a,
@@ -7166,7 +7166,7 @@ CONST uint16 mcs_tbl_rev3[] = {
 	0x0007,
 };
 
-CONST uint32 tdi_tbl20_ant0_rev3[] = {
+const u32 tdi_tbl20_ant0_rev3[] = {
 	0x00091226,
 	0x000a1429,
 	0x000b56ad,
@@ -7224,7 +7224,7 @@ CONST uint32 tdi_tbl20_ant0_rev3[] = {
 	0x00000000,
 };
 
-CONST uint32 tdi_tbl20_ant1_rev3[] = {
+const u32 tdi_tbl20_ant1_rev3[] = {
 	0x00014b26,
 	0x00028d29,
 	0x000393ad,
@@ -7282,7 +7282,7 @@ CONST uint32 tdi_tbl20_ant1_rev3[] = {
 	0x00000000,
 };
 
-CONST uint32 tdi_tbl40_ant0_rev3[] = {
+const u32 tdi_tbl40_ant0_rev3[] = {
 	0x0011a346,
 	0x00136ccf,
 	0x0014f5d9,
@@ -7395,7 +7395,7 @@ CONST uint32 tdi_tbl40_ant0_rev3[] = {
 	0x00000000,
 };
 
-CONST uint32 tdi_tbl40_ant1_rev3[] = {
+const u32 tdi_tbl40_ant1_rev3[] = {
 	0x001edb36,
 	0x000129ca,
 	0x0002b353,
@@ -7508,7 +7508,7 @@ CONST uint32 tdi_tbl40_ant1_rev3[] = {
 	0x00000000,
 };
 
-CONST uint32 pltlut_tbl_rev3[] = {
+const u32 pltlut_tbl_rev3[] = {
 	0x76540213,
 	0x62407351,
 	0x76543210,
@@ -7517,7 +7517,7 @@ CONST uint32 pltlut_tbl_rev3[] = {
 	0x76430521,
 };
 
-CONST uint32 chanest_tbl_rev3[] = {
+const u32 chanest_tbl_rev3[] = {
 	0x44444444,
 	0x44444444,
 	0x44444444,
@@ -7616,7 +7616,7 @@ CONST uint32 chanest_tbl_rev3[] = {
 	0x10101010,
 };
 
-CONST uint8 frame_lut_rev3[] = {
+const u8 frame_lut_rev3[] = {
 	0x02,
 	0x04,
 	0x14,
@@ -7651,7 +7651,7 @@ CONST uint8 frame_lut_rev3[] = {
 	0x2a,
 };
 
-CONST uint8 est_pwr_lut_core0_rev3[] = {
+const u8 est_pwr_lut_core0_rev3[] = {
 	0x55,
 	0x54,
 	0x54,
@@ -7718,7 +7718,7 @@ CONST uint8 est_pwr_lut_core0_rev3[] = {
 	0xfd,
 };
 
-CONST uint8 est_pwr_lut_core1_rev3[] = {
+const u8 est_pwr_lut_core1_rev3[] = {
 	0x55,
 	0x54,
 	0x54,
@@ -7785,7 +7785,7 @@ CONST uint8 est_pwr_lut_core1_rev3[] = {
 	0xfd,
 };
 
-CONST uint8 adj_pwr_lut_core0_rev3[] = {
+const u8 adj_pwr_lut_core0_rev3[] = {
 	0x00,
 	0x00,
 	0x00,
@@ -7916,7 +7916,7 @@ CONST uint8 adj_pwr_lut_core0_rev3[] = {
 	0x00,
 };
 
-CONST uint8 adj_pwr_lut_core1_rev3[] = {
+const u8 adj_pwr_lut_core1_rev3[] = {
 	0x00,
 	0x00,
 	0x00,
@@ -8047,7 +8047,7 @@ CONST uint8 adj_pwr_lut_core1_rev3[] = {
 	0x00,
 };
 
-CONST uint32 gainctrl_lut_core0_rev3[] = {
+const u32 gainctrl_lut_core0_rev3[] = {
 	0x5bf70044,
 	0x5bf70042,
 	0x5bf70040,
@@ -8178,7 +8178,7 @@ CONST uint32 gainctrl_lut_core0_rev3[] = {
 	0x5b07001c,
 };
 
-CONST uint32 gainctrl_lut_core1_rev3[] = {
+const u32 gainctrl_lut_core1_rev3[] = {
 	0x5bf70044,
 	0x5bf70042,
 	0x5bf70040,
@@ -8309,7 +8309,7 @@ CONST uint32 gainctrl_lut_core1_rev3[] = {
 	0x5b07001c,
 };
 
-CONST uint32 iq_lut_core0_rev3[] = {
+const u32 iq_lut_core0_rev3[] = {
 	0x00000000,
 	0x00000000,
 	0x00000000,
@@ -8440,7 +8440,7 @@ CONST uint32 iq_lut_core0_rev3[] = {
 	0x00000000,
 };
 
-CONST uint32 iq_lut_core1_rev3[] = {
+const u32 iq_lut_core1_rev3[] = {
 	0x00000000,
 	0x00000000,
 	0x00000000,
@@ -8571,7 +8571,7 @@ CONST uint32 iq_lut_core1_rev3[] = {
 	0x00000000,
 };
 
-CONST uint16 loft_lut_core0_rev3[] = {
+const u16 loft_lut_core0_rev3[] = {
 	0x0000,
 	0x0000,
 	0x0000,
@@ -8702,7 +8702,7 @@ CONST uint16 loft_lut_core0_rev3[] = {
 	0x0000,
 };
 
-CONST uint16 loft_lut_core1_rev3[] = {
+const u16 loft_lut_core1_rev3[] = {
 	0x0000,
 	0x0000,
 	0x0000,
@@ -8833,7 +8833,7 @@ CONST uint16 loft_lut_core1_rev3[] = {
 	0x0000,
 };
 
-CONST uint16 papd_comp_rfpwr_tbl_core0_rev3[] = {
+const u16 papd_comp_rfpwr_tbl_core0_rev3[] = {
 	0x0036,
 	0x0036,
 	0x0036,
@@ -8964,7 +8964,7 @@ CONST uint16 papd_comp_rfpwr_tbl_core0_rev3[] = {
 	0x01d6,
 };
 
-CONST uint16 papd_comp_rfpwr_tbl_core1_rev3[] = {
+const u16 papd_comp_rfpwr_tbl_core1_rev3[] = {
 	0x0036,
 	0x0036,
 	0x0036,
@@ -9095,7 +9095,7 @@ CONST uint16 papd_comp_rfpwr_tbl_core1_rev3[] = {
 	0x01d6,
 };
 
-CONST uint32 papd_comp_epsilon_tbl_core0_rev3[] = {
+const u32 papd_comp_epsilon_tbl_core0_rev3[] = {
 	0x00000000,
 	0x00001fa0,
 	0x00019f78,
@@ -9162,7 +9162,7 @@ CONST uint32 papd_comp_epsilon_tbl_core0_rev3[] = {
 	0x03e38ffe,
 };
 
-CONST uint32 papd_cal_scalars_tbl_core0_rev3[] = {
+const u32 papd_cal_scalars_tbl_core0_rev3[] = {
 	0x05af005a,
 	0x0571005e,
 	0x05040066,
@@ -9229,7 +9229,7 @@ CONST uint32 papd_cal_scalars_tbl_core0_rev3[] = {
 	0x002606a4,
 };
 
-CONST uint32 papd_comp_epsilon_tbl_core1_rev3[] = {
+const u32 papd_comp_epsilon_tbl_core1_rev3[] = {
 	0x00000000,
 	0x00001fa0,
 	0x00019f78,
@@ -9296,7 +9296,7 @@ CONST uint32 papd_comp_epsilon_tbl_core1_rev3[] = {
 	0x03e38ffe,
 };
 
-CONST uint32 papd_cal_scalars_tbl_core1_rev3[] = {
+const u32 papd_cal_scalars_tbl_core1_rev3[] = {
 	0x05af005a,
 	0x0571005e,
 	0x05040066,
@@ -9363,34 +9363,34 @@ CONST uint32 papd_cal_scalars_tbl_core1_rev3[] = {
 	0x002606a4,
 };
 
-CONST mimophytbl_info_t mimophytbl_info_rev3_volatile[] = {
+const mimophytbl_info_t mimophytbl_info_rev3_volatile[] = {
 	{&ant_swctrl_tbl_rev3,
 	 sizeof(ant_swctrl_tbl_rev3) / sizeof(ant_swctrl_tbl_rev3[0]), 9, 0, 16}
 	,
 };
 
-CONST mimophytbl_info_t mimophytbl_info_rev3_volatile1[] = {
+const mimophytbl_info_t mimophytbl_info_rev3_volatile1[] = {
 	{&ant_swctrl_tbl_rev3_1,
 	 sizeof(ant_swctrl_tbl_rev3_1) / sizeof(ant_swctrl_tbl_rev3_1[0]), 9, 0,
 	 16}
 	,
 };
 
-CONST mimophytbl_info_t mimophytbl_info_rev3_volatile2[] = {
+const mimophytbl_info_t mimophytbl_info_rev3_volatile2[] = {
 	{&ant_swctrl_tbl_rev3_2,
 	 sizeof(ant_swctrl_tbl_rev3_2) / sizeof(ant_swctrl_tbl_rev3_2[0]), 9, 0,
 	 16}
 	,
 };
 
-CONST mimophytbl_info_t mimophytbl_info_rev3_volatile3[] = {
+const mimophytbl_info_t mimophytbl_info_rev3_volatile3[] = {
 	{&ant_swctrl_tbl_rev3_3,
 	 sizeof(ant_swctrl_tbl_rev3_3) / sizeof(ant_swctrl_tbl_rev3_3[0]), 9, 0,
 	 16}
 	,
 };
 
-CONST mimophytbl_info_t mimophytbl_info_rev3[] = {
+const mimophytbl_info_t mimophytbl_info_rev3[] = {
 	{&frame_struct_rev3,
 	 sizeof(frame_struct_rev3) / sizeof(frame_struct_rev3[0]), 10, 0, 32}
 	,
@@ -9476,22 +9476,22 @@ CONST mimophytbl_info_t mimophytbl_info_rev3[] = {
 	 16}
 };
 
-CONST uint32 mimophytbl_info_sz_rev3 =
+const u32 mimophytbl_info_sz_rev3 =
     sizeof(mimophytbl_info_rev3) / sizeof(mimophytbl_info_rev3[0]);
-CONST uint32 mimophytbl_info_sz_rev3_volatile =
+const u32 mimophytbl_info_sz_rev3_volatile =
     sizeof(mimophytbl_info_rev3_volatile) /
     sizeof(mimophytbl_info_rev3_volatile[0]);
-CONST uint32 mimophytbl_info_sz_rev3_volatile1 =
+const u32 mimophytbl_info_sz_rev3_volatile1 =
     sizeof(mimophytbl_info_rev3_volatile1) /
     sizeof(mimophytbl_info_rev3_volatile1[0]);
-CONST uint32 mimophytbl_info_sz_rev3_volatile2 =
+const u32 mimophytbl_info_sz_rev3_volatile2 =
     sizeof(mimophytbl_info_rev3_volatile2) /
     sizeof(mimophytbl_info_rev3_volatile2[0]);
-CONST uint32 mimophytbl_info_sz_rev3_volatile3 =
+const u32 mimophytbl_info_sz_rev3_volatile3 =
     sizeof(mimophytbl_info_rev3_volatile3) /
     sizeof(mimophytbl_info_rev3_volatile3[0]);
 
-CONST uint32 tmap_tbl_rev7[] = {
+const u32 tmap_tbl_rev7[] = {
 	0x8a88aa80,
 	0x8aaaaa8a,
 	0x8a8a8aa8,
@@ -9942,7 +9942,7 @@ CONST uint32 tmap_tbl_rev7[] = {
 	0x00000000,
 };
 
-CONST uint32 noise_var_tbl_rev7[] = {
+const u32 noise_var_tbl_rev7[] = {
 	0x020c020c,
 	0x0000014d,
 	0x020c020c,
@@ -10201,7 +10201,7 @@ CONST uint32 noise_var_tbl_rev7[] = {
 	0x0000014d,
 };
 
-CONST uint32 papd_comp_epsilon_tbl_core0_rev7[] = {
+const u32 papd_comp_epsilon_tbl_core0_rev7[] = {
 	0x00000000,
 	0x00000000,
 	0x00016023,
@@ -10268,7 +10268,7 @@ CONST uint32 papd_comp_epsilon_tbl_core0_rev7[] = {
 	0x0156cfff,
 };
 
-CONST uint32 papd_cal_scalars_tbl_core0_rev7[] = {
+const u32 papd_cal_scalars_tbl_core0_rev7[] = {
 	0x0b5e002d,
 	0x0ae2002f,
 	0x0a3b0032,
@@ -10335,7 +10335,7 @@ CONST uint32 papd_cal_scalars_tbl_core0_rev7[] = {
 	0x004e068c,
 };
 
-CONST uint32 papd_comp_epsilon_tbl_core1_rev7[] = {
+const u32 papd_comp_epsilon_tbl_core1_rev7[] = {
 	0x00000000,
 	0x00000000,
 	0x00016023,
@@ -10402,7 +10402,7 @@ CONST uint32 papd_comp_epsilon_tbl_core1_rev7[] = {
 	0x0156cfff,
 };
 
-CONST uint32 papd_cal_scalars_tbl_core1_rev7[] = {
+const u32 papd_cal_scalars_tbl_core1_rev7[] = {
 	0x0b5e002d,
 	0x0ae2002f,
 	0x0a3b0032,
@@ -10469,7 +10469,7 @@ CONST uint32 papd_cal_scalars_tbl_core1_rev7[] = {
 	0x004e068c,
 };
 
-CONST mimophytbl_info_t mimophytbl_info_rev7[] = {
+const mimophytbl_info_t mimophytbl_info_rev7[] = {
 	{&frame_struct_rev3,
 	 sizeof(frame_struct_rev3) / sizeof(frame_struct_rev3[0]), 10, 0, 32}
 	,
@@ -10580,10 +10580,10 @@ CONST mimophytbl_info_t mimophytbl_info_rev7[] = {
 	,
 };
 
-CONST uint32 mimophytbl_info_sz_rev7 =
+const u32 mimophytbl_info_sz_rev7 =
     sizeof(mimophytbl_info_rev7) / sizeof(mimophytbl_info_rev7[0]);
 
-CONST mimophytbl_info_t mimophytbl_info_rev16[] = {
+const mimophytbl_info_t mimophytbl_info_rev16[] = {
 	{&noise_var_tbl_rev7,
 	 sizeof(noise_var_tbl_rev7) / sizeof(noise_var_tbl_rev7[0]), 16, 0, 32}
 	,
@@ -10627,5 +10627,5 @@ CONST mimophytbl_info_t mimophytbl_info_rev16[] = {
 	,
 };
 
-CONST uint32 mimophytbl_info_sz_rev16 =
+const u32 mimophytbl_info_sz_rev16 =
     sizeof(mimophytbl_info_rev16) / sizeof(mimophytbl_info_rev16[0]);
diff --git a/drivers/staging/brcm80211/phy/wlc_phytbl_n.h b/drivers/staging/brcm80211/phy/wlc_phytbl_n.h
index 108197c..396122f 100644
--- a/drivers/staging/brcm80211/phy/wlc_phytbl_n.h
+++ b/drivers/staging/brcm80211/phy/wlc_phytbl_n.h
@@ -18,22 +18,22 @@
 
 typedef phytbl_info_t mimophytbl_info_t;
 
-extern CONST mimophytbl_info_t mimophytbl_info_rev0[],
+extern const mimophytbl_info_t mimophytbl_info_rev0[],
     mimophytbl_info_rev0_volatile[];
-extern CONST uint32 mimophytbl_info_sz_rev0, mimophytbl_info_sz_rev0_volatile;
+extern const u32 mimophytbl_info_sz_rev0, mimophytbl_info_sz_rev0_volatile;
 
-extern CONST mimophytbl_info_t mimophytbl_info_rev3[],
+extern const mimophytbl_info_t mimophytbl_info_rev3[],
     mimophytbl_info_rev3_volatile[], mimophytbl_info_rev3_volatile1[],
     mimophytbl_info_rev3_volatile2[], mimophytbl_info_rev3_volatile3[];
-extern CONST uint32 mimophytbl_info_sz_rev3, mimophytbl_info_sz_rev3_volatile,
+extern const u32 mimophytbl_info_sz_rev3, mimophytbl_info_sz_rev3_volatile,
     mimophytbl_info_sz_rev3_volatile1, mimophytbl_info_sz_rev3_volatile2,
     mimophytbl_info_sz_rev3_volatile3;
 
-extern CONST uint32 noise_var_tbl_rev3[];
+extern const u32 noise_var_tbl_rev3[];
 
-extern CONST mimophytbl_info_t mimophytbl_info_rev7[];
-extern CONST uint32 mimophytbl_info_sz_rev7;
-extern CONST uint32 noise_var_tbl_rev7[];
+extern const mimophytbl_info_t mimophytbl_info_rev7[];
+extern const u32 mimophytbl_info_sz_rev7;
+extern const u32 noise_var_tbl_rev7[];
 
-extern CONST mimophytbl_info_t mimophytbl_info_rev16[];
-extern CONST uint32 mimophytbl_info_sz_rev16;
+extern const mimophytbl_info_t mimophytbl_info_rev16[];
+extern const u32 mimophytbl_info_sz_rev16;
diff --git a/drivers/staging/brcm80211/sys/wl_dbg.h b/drivers/staging/brcm80211/sys/wl_dbg.h
index a2dd359..e63b27e 100644
--- a/drivers/staging/brcm80211/sys/wl_dbg.h
+++ b/drivers/staging/brcm80211/sys/wl_dbg.h
@@ -18,17 +18,17 @@
 #define _wl_dbg_h_
 
 /* wl_msg_level is a bit vector with defs in wlioctl.h */
-extern uint32 wl_msg_level;
+extern u32 wl_msg_level;
 
 #define WL_PRINT(args)		printf args
 #define WL_NONE(args)
 
 #ifdef BCMDBG
 
-#define	WL_ERROR(args)		do {if ((wl_msg_level & WL_ERROR_VAL)) WL_PRINT(args);} while (0)
-#define	WL_TRACE(args)		do {if (wl_msg_level & WL_TRACE_VAL) WL_PRINT(args);} while (0)
-#define WL_AMPDU(args)		do {if (wl_msg_level & WL_AMPDU_VAL) WL_PRINT(args);} while (0)
-#define WL_FFPLD(args)		do {if (wl_msg_level & WL_FFPLD_VAL) WL_PRINT(args);} while (0)
+#define	WL_ERROR(args)		do {if ((wl_msg_level & WL_ERROR_VAL)) WL_PRINT(args); } while (0)
+#define	WL_TRACE(args)		do {if (wl_msg_level & WL_TRACE_VAL) WL_PRINT(args); } while (0)
+#define WL_AMPDU(args)		do {if (wl_msg_level & WL_AMPDU_VAL) WL_PRINT(args); } while (0)
+#define WL_FFPLD(args)		do {if (wl_msg_level & WL_FFPLD_VAL) WL_PRINT(args); } while (0)
 
 #define WL_ERROR_ON()		(wl_msg_level & WL_ERROR_VAL)
 
@@ -42,16 +42,16 @@ extern uint32 wl_msg_level;
 #define   WL_AMPDU_HWTXS_VAL    0x00000040	/* AMPDU_HWTXS */
 #define   WL_AMPDU_HWDBG_VAL    0x00000080	/* AMPDU_DBG */
 
-extern uint32 wl_ampdu_dbg;
+extern u32 wl_ampdu_dbg;
 
-#define WL_AMPDU_UPDN(args) do {if (wl_ampdu_dbg & WL_AMPDU_UPDN_VAL) {WL_AMPDU(args);}} while (0)
-#define WL_AMPDU_RX(args) do {if (wl_ampdu_dbg & WL_AMPDU_RX_VAL) {WL_AMPDU(args);}} while (0)
-#define WL_AMPDU_ERR(args) do {if (wl_ampdu_dbg & WL_AMPDU_ERR_VAL) {WL_AMPDU(args);}} while (0)
-#define WL_AMPDU_TX(args) do {if (wl_ampdu_dbg & WL_AMPDU_TX_VAL) {WL_AMPDU(args);}} while (0)
-#define WL_AMPDU_CTL(args) do {if (wl_ampdu_dbg & WL_AMPDU_CTL_VAL) {WL_AMPDU(args);}} while (0)
-#define WL_AMPDU_HW(args) do {if (wl_ampdu_dbg & WL_AMPDU_HW_VAL) {WL_AMPDU(args);}} while (0)
-#define WL_AMPDU_HWTXS(args) do {if (wl_ampdu_dbg & WL_AMPDU_HWTXS_VAL) {WL_AMPDU(args);}} while (0)
-#define WL_AMPDU_HWDBG(args) do {if (wl_ampdu_dbg & WL_AMPDU_HWDBG_VAL) {WL_AMPDU(args);}} while (0)
+#define WL_AMPDU_UPDN(args) do {if (wl_ampdu_dbg & WL_AMPDU_UPDN_VAL) {WL_AMPDU(args); } } while (0)
+#define WL_AMPDU_RX(args) do {if (wl_ampdu_dbg & WL_AMPDU_RX_VAL) {WL_AMPDU(args); } } while (0)
+#define WL_AMPDU_ERR(args) do {if (wl_ampdu_dbg & WL_AMPDU_ERR_VAL) {WL_AMPDU(args); } } while (0)
+#define WL_AMPDU_TX(args) do {if (wl_ampdu_dbg & WL_AMPDU_TX_VAL) {WL_AMPDU(args); } } while (0)
+#define WL_AMPDU_CTL(args) do {if (wl_ampdu_dbg & WL_AMPDU_CTL_VAL) {WL_AMPDU(args); } } while (0)
+#define WL_AMPDU_HW(args) do {if (wl_ampdu_dbg & WL_AMPDU_HW_VAL) {WL_AMPDU(args); } } while (0)
+#define WL_AMPDU_HWTXS(args) do {if (wl_ampdu_dbg & WL_AMPDU_HWTXS_VAL) {WL_AMPDU(args); } } while (0)
+#define WL_AMPDU_HWDBG(args) do {if (wl_ampdu_dbg & WL_AMPDU_HWDBG_VAL) {WL_AMPDU(args); } } while (0)
 #define WL_AMPDU_ERR_ON() (wl_ampdu_dbg & WL_AMPDU_ERR_VAL)
 #define WL_AMPDU_HW_ON() (wl_ampdu_dbg & WL_AMPDU_HW_VAL)
 #define WL_AMPDU_HWTXS_ON() (wl_ampdu_dbg & WL_AMPDU_HWTXS_VAL)
diff --git a/drivers/staging/brcm80211/sys/wl_export.h b/drivers/staging/brcm80211/sys/wl_export.h
index 3bf493a..08442f8 100644
--- a/drivers/staging/brcm80211/sys/wl_export.h
+++ b/drivers/staging/brcm80211/sys/wl_export.h
@@ -24,11 +24,11 @@ struct wlc_if;
 extern void wl_init(struct wl_info *wl);
 extern uint wl_reset(struct wl_info *wl);
 extern void wl_intrson(struct wl_info *wl);
-extern uint32 wl_intrsoff(struct wl_info *wl);
-extern void wl_intrsrestore(struct wl_info *wl, uint32 macintmask);
-extern void wl_event(struct wl_info *wl, char *ifname, wlc_event_t * e);
-extern void wl_event_sendup(struct wl_info *wl, const wlc_event_t * e,
-			    uint8 * data, uint32 len);
+extern u32 wl_intrsoff(struct wl_info *wl);
+extern void wl_intrsrestore(struct wl_info *wl, u32 macintmask);
+extern void wl_event(struct wl_info *wl, char *ifname, wlc_event_t *e);
+extern void wl_event_sendup(struct wl_info *wl, const wlc_event_t *e,
+			    u8 *data, u32 len);
 extern int wl_up(struct wl_info *wl);
 extern void wl_down(struct wl_info *wl);
 extern void wl_txflowcontrol(struct wl_info *wl, struct wl_if *wlif, bool state,
@@ -45,12 +45,12 @@ extern void wl_add_timer(struct wl_info *wl, struct wl_timer *timer, uint ms,
 			 int periodic);
 extern bool wl_del_timer(struct wl_info *wl, struct wl_timer *timer);
 
-extern uint wl_buf_to_pktcopy(osl_t * osh, void *p, uchar * buf, int len,
+extern uint wl_buf_to_pktcopy(osl_t *osh, void *p, unsigned char *buf, int len,
 			      uint offset);
-extern void *wl_get_pktbuffer(osl_t * osh, int len);
-extern int wl_set_pktlen(osl_t * osh, void *p, int len);
+extern void *wl_get_pktbuffer(osl_t *osh, int len);
+extern int wl_set_pktlen(osl_t *osh, void *p, int len);
 
-#define wl_sort_bsslist(a, b) FALSE
+#define wl_sort_bsslist(a, b) false
 
 extern int wl_tkip_miccheck(struct wl_info *wl, void *p, int hdr_len,
 			    bool group_key, int id);
@@ -59,5 +59,5 @@ extern int wl_tkip_encrypt(struct wl_info *wl, void *p, int hdr_len);
 extern int wl_tkip_decrypt(struct wl_info *wl, void *p, int hdr_len,
 			   bool group_key);
 extern void wl_tkip_printstats(struct wl_info *wl, bool group_key);
-extern int wl_tkip_keyset(struct wl_info *wl, wsec_key_t * key);
+extern int wl_tkip_keyset(struct wl_info *wl, wsec_key_t *key);
 #endif				/* _wl_export_h_ */
--- a/drivers/staging/brcm80211/sys/wl_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wl_mac80211.c
@@ -16,45 +16,25 @@
 
 #define __UNDEF_NO_VERSION__
 
-#include <typedefs.h>
-#include <linuxver.h>
-#include <osl.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/pci.h>
-#include <linux/init.h>
 #include <linux/kernel.h>
-#include <linux/netdevice.h>
 #include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/delay.h>
 #include <linux/string.h>
-#include <linux/ethtool.h>
-#include <linux/completion.h>
 #include <linux/pci_ids.h>
+#include <bcmdefs.h>
+#include <linuxver.h>
+#include <osl.h>
 #define WLC_MAXBSSCFG		1	/* single BSS configs */
 
-#include <asm/system.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/pgtable.h>
-#include <asm/uaccess.h>
-#include <asm/unaligned.h>
 #include <wlc_cfg.h>
 #include <net/mac80211.h>
 #include <epivers.h>
 #ifndef WLC_HIGH_ONLY
 #include <phy_version.h>
 #endif
-#include <bcmendian.h>
 #include <bcmutils.h>
 #include <pcicfg.h>
 #include <wlioctl.h>
 #include <wlc_key.h>
-#include <proto/802.1d.h>	/* NUMPRIO & BE */
-#include <linux/proc_fs.h>
-#include <linux/vmalloc.h>
 #include <wlc_channel.h>
 #include <wlc_pub.h>
 #include <wlc_scb.h>
@@ -82,21 +62,15 @@
 extern struct device *sdiommc_dev;
 #endif
 
-extern void wlc_wme_setparams(wlc_info_t * wlc, u16 aci, void *arg,
+extern void wlc_wme_setparams(wlc_info_t *wlc, u16 aci, void *arg,
 			      bool suspend);
-bool wlc_sendpkt_mac80211(wlc_info_t * wlc, void *sdu, struct ieee80211_hw *hw);
-void wlc_mac_bcn_promisc_change(wlc_info_t * wlc, bool promisc);
-void wlc_set_addrmatch(wlc_info_t * wlc, int match_reg_offset,
+bool wlc_sendpkt_mac80211(wlc_info_t *wlc, void *sdu, struct ieee80211_hw *hw);
+void wlc_mac_bcn_promisc_change(wlc_info_t *wlc, bool promisc);
+void wlc_set_addrmatch(wlc_info_t *wlc, int match_reg_offset,
 		       const struct ether_addr *addr);
 
-static void wl_timer(ulong data);
-static void _wl_timer(wl_timer_t * t);
-
-/* proc fs */
-static int wl_proc_read(char *buffer, char **start, off_t offset, int length,
-			int *eof, void *data);
-static int wl_proc_write(struct file *filp, const char __user * buff,
-			 unsigned long len, void *data);
+static void wl_timer(unsigned long data);
+static void _wl_timer(wl_timer_t *t);
 
 #ifdef WLC_HIGH_ONLY
 #define RPCQ_LOCK(_wl, _flags) spin_lock_irqsave(&(_wl)->rpcq_lock, (_flags))
@@ -104,13 +78,13 @@ static int wl_proc_write(struct file *filp, const char __user * buff,
 #define TXQ_LOCK(_wl, _flags) spin_lock_irqsave(&(_wl)->txq_lock, (_flags))
 #define TXQ_UNLOCK(_wl, _flags)  spin_unlock_irqrestore(&(_wl)->txq_lock, (_flags))
 static void wl_rpc_down(void *wlh);
-static void wl_rpcq_free(wl_info_t * wl);
+static void wl_rpcq_free(wl_info_t *wl);
 static void wl_rpcq_dispatch(struct wl_task *task);
 static void wl_rpc_dispatch_schedule(void *ctx, struct rpc_buf *buf);
 static void wl_start_txqwork(struct wl_task *task);
-static void wl_txq_free(wl_info_t * wl);
-static void wl_timer_task(wl_task_t * task);
-static int wl_schedule_task(wl_info_t * wl, void (*fn) (struct wl_task *),
+static void wl_txq_free(wl_info_t *wl);
+static void wl_timer_task(wl_task_t *task);
+static int wl_schedule_task(wl_info_t *wl, void (*fn) (struct wl_task *),
 			    void *context);
 #endif				/* WLC_HIGH_ONLY */
 
@@ -128,7 +102,7 @@ static int wl_linux_watchdog(void *ctx);
 	FIF_OTHER_BSS | \
 	FIF_BCN_PRBRESP_PROMISC)
 
-static int wl_found = 0;
+static int wl_found;
 
 struct ieee80211_tkip_data {
 #define TKIP_KEY_LEN 32
@@ -161,16 +135,17 @@ struct ieee80211_tkip_data {
 };
 
 #ifndef WLC_HIGH_ONLY
-#define	WL_INFO(dev)		((wl_info_t*)(WL_DEV_IF(dev)->wl))	/* points to wl */
-static int wl_request_fw(wl_info_t * wl, struct pci_dev *pdev);
-static void wl_release_fw(wl_info_t * wl);
+#define WL_DEV_IF(dev)		((wl_if_t *)netdev_priv(dev))
+#define	WL_INFO(dev)		((wl_info_t *)(WL_DEV_IF(dev)->wl))	/* points to wl */
+static int wl_request_fw(wl_info_t *wl, struct pci_dev *pdev);
+static void wl_release_fw(wl_info_t *wl);
 #endif
 
 /* local prototypes */
-static int wl_start(struct sk_buff *skb, wl_info_t * wl);
-static int wl_start_int(wl_info_t * wl, struct ieee80211_hw *hw,
+static int wl_start(struct sk_buff *skb, wl_info_t *wl);
+static int wl_start_int(wl_info_t *wl, struct ieee80211_hw *hw,
 			struct sk_buff *skb);
-static void wl_dpc(ulong data);
+static void wl_dpc(unsigned long data);
 
 MODULE_AUTHOR("Broadcom Corporation");
 MODULE_DESCRIPTION("Broadcom 802.11n wireless LAN driver.");
@@ -187,6 +162,7 @@ static struct pci_device_id wl_id_table[] = {
 };
 
 MODULE_DEVICE_TABLE(pci, wl_id_table);
+static void wl_remove(struct pci_dev *pdev);
 #endif				/* !BCMSDIO */
 
 #ifdef BCMSDIO
@@ -203,17 +179,17 @@ module_param(phymsglevel, int, 0);
 #endif				/* WLC_HIGH_ONLY */
 #endif				/* BCMDBG */
 
-static int oneonly = 0;
+static int oneonly;
 module_param(oneonly, int, 0);
 
-static int piomode = 0;
+static int piomode;
 module_param(piomode, int, 0);
 
-static int instance_base = 0;	/* Starting instance number */
+static int instance_base;	/* Starting instance number */
 module_param(instance_base, int, 0);
 
 #if defined(BCMDBG)
-static char *macaddr = NULL;
+static char *macaddr;
 module_param(macaddr, charp, S_IRUGO);
 #endif
 
@@ -229,8 +205,8 @@ module_param_string(name, name, IFNAMSIZ, 0);
 
 #define WL_MAGIC 	0xdeadbeef
 
-#define HW_TO_WL(hw)	 hw->priv
-#define WL_TO_HW(wl)	  wl->pub->ieee_hw
+#define HW_TO_WL(hw)	 (hw->priv)
+#define WL_TO_HW(wl)	  (wl->pub->ieee_hw)
 #ifdef WLC_HIGH_ONLY
 static int wl_ops_tx_nl(struct ieee80211_hw *hw, struct sk_buff *skb);
 #else
@@ -271,7 +247,7 @@ static int wl_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			 struct ieee80211_sta *sta);
 static int wl_ampdu_action(struct ieee80211_hw *hw,
 			   enum ieee80211_ampdu_mlme_action action,
-			   struct ieee80211_sta *sta, u16 tid, u16 * ssn);
+			   struct ieee80211_sta *sta, u16 tid, u16 *ssn);
 
 #ifdef WLC_HIGH_ONLY
 static int wl_ops_tx_nl(struct ieee80211_hw *hw, struct sk_buff *skb)
@@ -499,7 +475,7 @@ wl_ops_bss_info_changed(struct ieee80211_hw *hw,
 	}
 	if (changed & BSS_CHANGED_BASIC_RATES) {
 		WL_NONE(("Need to change Basic Rates:\t0x%x! Implement me\n",
-			 (uint32) info->basic_rates));
+			 (u32) info->basic_rates));
 		/* Basic rateset changed */
 	}
 	if (changed & BSS_CHANGED_BEACON_INT) {
@@ -508,11 +484,8 @@ wl_ops_bss_info_changed(struct ieee80211_hw *hw,
 		/* Beacon interval changed */
 	}
 	if (changed & BSS_CHANGED_BSSID) {
-		/* char eabuf[ETHER_ADDR_STR_LEN]; */
-		WL_NONE(("new BSSID:\taid %d  bss:%s\n",
-			 info->aid,
-			 bcm_ether_ntoa((struct ether_addr *)info->bssid,
-					eabuf)));
+		WL_NONE(("new BSSID:\taid %d  bss:%pM\n", info->aid,
+			info->bssid));
 		/* BSSID changed, for whatever reason (IBSS and managed mode) */
 		/* FIXME: need to store bssid in bsscfg */
 		wlc_set_addrmatch(wl->wlc, RCM_BSSID_OFFSET,
@@ -636,7 +609,7 @@ wl_ops_conf_tx(struct ieee80211_hw *hw, u16 queue,
 		 params->txop, params->cw_min, params->cw_max, params->aifs));
 
 	WL_LOCK(wl);
-	wlc_wme_setparams(wl->wlc, queue, (void *)params, TRUE);
+	wlc_wme_setparams(wl->wlc, queue, (void *)params, true);
 	WL_UNLOCK(wl);
 
 	return 0;
@@ -676,7 +649,7 @@ wl_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	pktq_init(&scb->scb_ampdu.txq, AMPDU_MAX_SCB_TID,
 		  AMPDU_MAX_SCB_TID * PKTQ_LEN_DEFAULT);
 
-	sta->ht_cap.ht_supported = TRUE;
+	sta->ht_cap.ht_supported = true;
 #ifdef WLC_HIGH_ONLY
 	sta->ht_cap.ampdu_factor = AMPDU_RX_FACTOR_16K;
 #else
@@ -703,7 +676,7 @@ static int
 static int
 wl_ampdu_action(struct ieee80211_hw *hw,
 		enum ieee80211_ampdu_mlme_action action,
-		struct ieee80211_sta *sta, u16 tid, u16 * ssn)
+		struct ieee80211_sta *sta, u16 tid, u16 *ssn)
 {
 #if defined(BCMDBG)
 	struct scb *scb = (struct scb *)sta->drv_priv;
@@ -771,11 +744,11 @@ static const struct ieee80211_ops wl_ops = {
 	.ampdu_action = wl_ampdu_action,
 };
 
-static int wl_set_hint(wl_info_t * wl, char *abbrev)
+static int wl_set_hint(wl_info_t *wl, char *abbrev)
 {
 	WL_ERROR(("%s: Sending country code %c%c to MAC80211\n", __func__,
 		  abbrev[0], abbrev[1]));
-	return (regulatory_hint(wl->pub->ieee_hw->wiphy, abbrev));
+	return regulatory_hint(wl->pub->ieee_hw->wiphy, abbrev);
 }
 
 /**
@@ -789,16 +762,16 @@ static int wl_set_hint(wl_info_t * wl, char *abbrev)
  * a warning that this function is defined but not used if we declare
  * it as static.
  */
-static wl_info_t *wl_attach(uint16 vendor, uint16 device, ulong regs,
+static wl_info_t *wl_attach(u16 vendor, u16 device, unsigned long regs,
 			    uint bustype, void *btparam, uint irq)
 {
 	wl_info_t *wl;
 	osl_t *osh;
 	int unit, err;
 
-	ulong base_addr;
+	unsigned long base_addr;
 	struct ieee80211_hw *hw;
-	uint8 perm[ETH_ALEN];
+	u8 perm[ETH_ALEN];
 
 	unit = wl_found + instance_base;
 	err = 0;
@@ -814,7 +787,7 @@ static wl_info_t *wl_attach(uint16 vendor, uint16 device, ulong regs,
 	}
 
 	/* Requires pkttag feature */
-	osh = osl_attach(btparam, bustype, TRUE);
+	osh = osl_attach(btparam, bustype, true);
 	ASSERT(osh);
 
 #ifdef WLC_HIGH_ONLY
@@ -838,7 +811,7 @@ static wl_info_t *wl_attach(uint16 vendor, uint16 device, ulong regs,
 	atomic_set(&wl->callbacks, 0);
 
 	/* setup the bottom half handler */
-	tasklet_init(&wl->tasklet, wl_dpc, (ulong) wl);
+	tasklet_init(&wl->tasklet, wl_dpc, (unsigned long) wl);
 
 #ifdef WLC_HIGH_ONLY
 	wl->rpc_th = bcm_rpc_tp_attach(osh, NULL);
@@ -856,7 +829,7 @@ static wl_info_t *wl_attach(uint16 vendor, uint16 device, ulong regs,
 	}
 
 	/* init tx work queue for wl_start/send pkt; no need to destroy workitem  */
-	MY_INIT_WORK(&wl->txq_task.work, (work_func_t) wl_start_txqwork);
+	INIT_WORK(&wl->txq_task.work, (work_func_t) wl_start_txqwork);
 	wl->txq_task.context = wl;
 #endif				/* WLC_HIGH_ONLY */
 
@@ -884,7 +857,8 @@ static wl_info_t *wl_attach(uint16 vendor, uint16 device, ulong regs,
 		btparam = wl->rpc;
 	} else
 #endif
-	if ((wl->regsva = ioremap_nocache(base_addr, PCI_BAR0_WINSZ)) == NULL) {
+	wl->regsva = ioremap_nocache(base_addr, PCI_BAR0_WINSZ);
+	if (wl->regsva == NULL) {
 		WL_ERROR(("wl%d: ioremap() failed\n", unit));
 		goto fail;
 	}
@@ -892,7 +866,7 @@ static wl_info_t *wl_attach(uint16 vendor, uint16 device, ulong regs,
 	spin_lock_init(&wl->rpcq_lock);
 	spin_lock_init(&wl->txq_lock);
 
-	init_MUTEX(&wl->sem);
+	sema_init(&wl->sem, 1);
 #else
 	spin_lock_init(&wl->lock);
 	spin_lock_init(&wl->isr_lock);
@@ -901,9 +875,11 @@ static wl_info_t *wl_attach(uint16 vendor, uint16 device, ulong regs,
 #ifndef WLC_HIGH_ONLY
 	/* prepare ucode */
 	if (wl_request_fw(wl, (struct pci_dev *)btparam)) {
-		printf("%s: %s driver failed\n", KBUILD_MODNAME,
-		       EPI_VERSION_STR);
-		goto fail;
+		printf("%s: Failed to find firmware usually in %s\n",
+			KBUILD_MODNAME, "/lib/firmware/brcm");
+		wl_release_fw(wl);
+		wl_remove((struct pci_dev *)btparam);
+		goto fail1;
 	}
 #endif
 
@@ -914,8 +890,8 @@ static wl_info_t *wl_attach(uint16 vendor, uint16 device, ulong regs,
 	wl_release_fw(wl);
 #endif
 	if (!wl->wlc) {
-		printf("%s: %s driver failed with code %d\n", KBUILD_MODNAME,
-		       EPI_VERSION_STR, err);
+		printf("%s: %s wlc_attach() failed with code %d\n",
+			KBUILD_MODNAME, EPI_VERSION_STR, err);
 		goto fail;
 	}
 	wl->pub = wlc_pub(wl->wlc);
@@ -993,162 +969,25 @@ static wl_info_t *wl_attach(uint16 vendor, uint16 device, ulong regs,
 #endif				/* BCMDBG */
 	printf("\n");
 
-	if ((wl->proc_entry =
-	     create_proc_entry(PROC_ENTRY_NAME, 0644, NULL)) == NULL) {
-		WL_ERROR(("create_proc_entry failed *******\n"));
-		ASSERT(0);
-	} else {
-		wl->proc_entry->read_proc = wl_proc_read;
-		wl->proc_entry->write_proc = wl_proc_write;
-		wl->proc_entry->data = wl;
-		/* wl->proc_entry->owner = THIS_MODULE; */
-
-		if ((wl->ioctlbuf = (char *)vmalloc(PAGE_SIZE)) == NULL) {
-			WL_ERROR(("%s: Vmalloc failed\n", __func__));
-		}
-		wl->ioctlbuf_sz = PAGE_SIZE;
-		memset(wl->ioctlbuf, 0, PAGE_SIZE);
-		wl->ioctlbuf[0] = '!';
-	}
-
 	wl_found++;
 	return wl;
 
  fail:
 	wl_free(wl);
+fail1:
 	return NULL;
 }
 
-#define PROC_MESSAGE  "Broadcom driver debugger access only.  Requires matching 'wl' app\n"
-
-/* OS Entry point when app attempts to read */
-static int
-wl_proc_read(char *buffer, char **start, off_t offset, int length, int *eof,
-	     void *data)
-{
-	wl_info_t *wl = (wl_info_t *) data;
-
-	switch (wl->proc_state) {
-
-	case WL_PROC_IDLE:
-		return 0;
-
-	case WL_PROC_HAVE_IOC:
-		/* Give the processed buffer back to userland */
-		if (!wl->ioctl_in_progress) {
-			WL_ERROR(("%s: No ioctl in progress nothing to read, 2\n", __func__));
-			return 0;
-		}
-
-		if (wl->ioc.len > wl->ioctlbuf_sz) {
-		}
-		bcopy(wl->ioctlbuf, buffer + offset, wl->ioc.len);
-		wl->proc_state--;
-		wl->ioctl_in_progress = 0;
-		return wl->ioc.len + offset;
-
-	case WL_PROC_HAVE_BUF:
-		/* Give the processed IOC back to userland */
-		if (!wl->ioctl_in_progress) {
-			WL_ERROR(("%s: No ioctl in progress nothing to read, 1\n", __func__));
-			return 0;
-		}
-		if (length != sizeof(wl_ioctl_t)) {
-			WL_ERROR(("%s: Reading ioc but len != sizeof(wl_ioctl_t)\n", __func__));
-			return 0;
-		}
-		bcopy(&wl->ioc, buffer + offset, length);
-		wl->proc_state--;
-		return length + offset;
-
-	default:
-		WL_ERROR(("%s: Proc read out of sync. proc_state %d, ioctl_in_progress %d\n", __func__, wl->proc_state, wl->ioctl_in_progress));
-	}
-
-	WL_ERROR(("%s: Invalid ioctl!!!\n", __func__));
-	return 0;
-}
-
-/* OS Entry point when app attempts to write */
-static int
-wl_proc_write(struct file *filp, const char __user * buff, unsigned long length,
-	      void *data)
-{
-	wl_info_t *wl = (wl_info_t *) data;
-	int bcmerror;
-
-	switch (wl->proc_state) {
-
-	case WL_PROC_IDLE:
-		if (wl->ioctl_in_progress) {
-			WL_ERROR(("%s: ioctl still in progress\n", __func__));
-			return -EIO;
-		}
-		if (length != sizeof(wl_ioctl_t)) {
-			WL_ERROR(("%s: Expecting ioctl sized buf\n", __func__));
-			return -EIO;
-		}
-		if (copy_from_user(&wl->ioc, buff, sizeof(wl_ioctl_t))) {
-			WL_ERROR(("%s: copy from user failed\n", __func__));
-			return -EIO;
-		}
-		wl->proc_state++;
-		wl->ioctl_in_progress++;
-		return sizeof(wl_ioctl_t);
-
-	case WL_PROC_HAVE_IOC:
-		if (!wl->ioctl_in_progress) {
-			WL_ERROR(("%s: Ioctl not ready yet 1\n", __func__));
-			return -EIO;
-		}
-		if (wl->ioctlbuf_sz < length) {
-			WL_ERROR(("%s: Buf write, ioctl buf %d not big enough too hold buffer %d\n", __func__, (int)sizeof(wl->ioctlbuf), (int)length));
-			WL_ERROR(("Shortening input\n"));
-			length = wl->ioctlbuf_sz;
-		}
-		if (length != wl->ioc.len) {
-			WL_ERROR(("%s: ioc.len %d != length param %d\n",
-				  __func__, wl->ioc.len, (int)length));
-			return -EIO;
-		}
-		if (copy_from_user(wl->ioctlbuf, buff, length)) {
-			WL_ERROR(("%s: copy from user of %d bytes failed\n",
-				  __func__, (int)length));
-			return -EIO;
-		}
-		wl->proc_state++;
-
-		WL_LOCK(wl);
-		bcmerror =
-		    wlc_ioctl(wl->wlc, wl->ioc.cmd, wl->ioctlbuf, wl->ioc.len,
-			      NULL);
-		WL_UNLOCK(wl);
-
-		if (bcmerror < 0)
-			return bcmerror;
-
-		return length;
-
-	case WL_PROC_HAVE_BUF:
-		WL_ERROR(("%s: Illegal write.  Rejecting.\n", __func__));
-		return 0;
-	default:
-		WL_ERROR(("%s: Proc write out of sync. proc_state %d, ioctl_in_progress %d\n", __func__, wl->proc_state, wl->ioctl_in_progress));
-	}
-	return 0;
-}
-
 #ifdef WLC_HIGH_ONLY
-static void *wl_dbus_probe_cb(void *arg, const char *desc, uint32 bustype,
-			      uint32 hdrlen)
+static void *wl_dbus_probe_cb(void *arg, const char *desc, u32 bustype,
+			      u32 hdrlen)
 {
 	wl_info_t *wl;
 	WL_ERROR(("%s:\n", __func__));
 
-	if (!
-	    (wl =
-	     wl_attach(BCM_DNGL_VID, BCM_DNGL_BDC_PID, (ulong) NULL, RPC_BUS,
-		       NULL, 0))) {
+	wl = wl_attach(BCM_DNGL_VID, BCM_DNGL_BDC_PID, (unsigned long) NULL, RPC_BUS,
+		NULL, 0);
+	if (!wl) {
 		WL_ERROR(("%s: wl_attach failed\n", __func__));
 	}
 
@@ -1188,9 +1027,6 @@ static void wl_dbus_disconnect_cb(void *arg)
 }
 #endif				/* WLC_HIGH_ONLY */
 
-#ifndef BCMSDIO
-static void __devexit wl_remove(struct pci_dev *pdev);
-#endif
 
 #define CHAN2GHZ(channel, freqency, chflags)  { \
 	.band = IEEE80211_BAND_2GHZ, \
@@ -1403,7 +1239,7 @@ static int ieee_hw_rate_init(struct ieee80211_hw *hw)
 		hw->wiphy->bands[IEEE80211_BAND_2GHZ] = &wl_band_2GHz_nphy;
 	} else {
 		BUG();
-		return (-1);
+		return -1;
 	}
 
 	/* Assume all bands use the same phy.  True for 11n devices. */
@@ -1417,13 +1253,13 @@ static int ieee_hw_rate_init(struct ieee80211_hw *hw)
 			hw->wiphy->bands[IEEE80211_BAND_5GHZ] =
 			    &wl_band_5GHz_nphy;
 		} else {
-			return (-1);
+			return -1;
 		}
 	}
 
 	WL_NONE(("%s: 2ghz = %d, 5ghz = %d\n", __func__, 1, has_5g));
 
-	return (0);
+	return 0;
 }
 
 static int ieee_hw_init(struct ieee80211_hw *hw)
@@ -1449,7 +1285,7 @@ static int ieee_hw_init(struct ieee80211_hw *hw)
 	hw->rate_control_algorithm = "minstrel_ht";
 
 	hw->sta_data_size = sizeof(struct scb);
-	return (ieee_hw_rate_init(hw));
+	return ieee_hw_rate_init(hw);
 }
 
 #ifndef BCMSDIO
@@ -1466,7 +1302,7 @@ wl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	int rc;
 	wl_info_t *wl;
 	struct ieee80211_hw *hw;
-	uint32 val;
+	u32 val;
 
 	ASSERT(pdev);
 
@@ -1478,14 +1314,14 @@ wl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	    (((pdev->device & 0xff00) != 0x4300) &&
 	     ((pdev->device & 0xff00) != 0x4700) &&
 	     ((pdev->device < 43000) || (pdev->device > 43999))))
-		return (-ENODEV);
+		return -ENODEV;
 
 	rc = pci_enable_device(pdev);
 	if (rc) {
 		WL_ERROR(("%s: Cannot enable device %d-%d_%d\n", __func__,
 			  pdev->bus->number, PCI_SLOT(pdev->devfn),
 			  PCI_FUNC(pdev->devfn)));
-		return (-ENODEV);
+		return -ENODEV;
 	}
 	pci_set_master(pdev);
 
@@ -1509,6 +1345,11 @@ wl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	wl = wl_attach(pdev->vendor, pdev->device, pci_resource_start(pdev, 0),
 		       PCI_BUS, pdev, pdev->irq);
 
+	if (!wl) {
+		WL_ERROR(("%s: %s: wl_attach failed!\n",
+			KBUILD_MODNAME, __func__));
+		return -ENODEV;
+	}
 	return 0;
  err_1:
 	WL_ERROR(("%s: err_1: Major hoarkage\n", __func__));
@@ -1516,7 +1357,7 @@ wl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 }
 
 #ifdef LINUXSTA_PS
-static int wl_suspend(struct pci_dev *pdev, DRV_SUSPEND_STATE_TYPE state)
+static int wl_suspend(struct pci_dev *pdev, pm_message_t state)
 {
 	wl_info_t *wl;
 	struct ieee80211_hw *hw;
@@ -1532,9 +1373,9 @@ static int wl_suspend(struct pci_dev *pdev, DRV_SUSPEND_STATE_TYPE state)
 
 	WL_LOCK(wl);
 	wl_down(wl);
-	wl->pub->hw_up = FALSE;
+	wl->pub->hw_up = false;
 	WL_UNLOCK(wl);
-	PCI_SAVE_STATE(pdev, wl->pci_psstate);
+	pci_save_state(pdev, wl->pci_psstate);
 	pci_disable_device(pdev);
 	return pci_set_power_state(pdev, PCI_D3hot);
 }
@@ -1544,7 +1385,7 @@ static int wl_resume(struct pci_dev *pdev)
 	wl_info_t *wl;
 	struct ieee80211_hw *hw;
 	int err = 0;
-	uint32 val;
+	u32 val;
 
 	WL_TRACE(("wl: wl_resume\n"));
 	hw = pci_get_drvdata(pdev);
@@ -1558,7 +1399,7 @@ static int wl_resume(struct pci_dev *pdev)
 	if (err)
 		return err;
 
-	PCI_RESTORE_STATE(pdev, wl->pci_psstate);
+	pci_restore_state(pdev, wl->pci_psstate);
 
 	err = pci_enable_device(pdev);
 	if (err)
@@ -1574,11 +1415,11 @@ static int wl_resume(struct pci_dev *pdev)
 	err = wl_up(wl);
 	WL_UNLOCK(wl);
 
-	return (err);
+	return err;
 }
 #endif				/* LINUXSTA_PS */
 
-static void __devexit wl_remove(struct pci_dev *pdev)
+static void wl_remove(struct pci_dev *pdev)
 {
 	wl_info_t *wl;
 	struct ieee80211_hw *hw;
@@ -1593,14 +1434,13 @@ static void __devexit wl_remove(struct pci_dev *pdev)
 		WL_ERROR(("wl: wl_remove: wlc_chipmatch failed\n"));
 		return;
 	}
-
-	ieee80211_unregister_hw(hw);
-
-	WL_LOCK(wl);
-	wl_down(wl);
-	WL_UNLOCK(wl);
-	WL_NONE(("%s: Down\n", __func__));
-
+	if (wl->wlc) {
+		ieee80211_unregister_hw(hw);
+		WL_LOCK(wl);
+		wl_down(wl);
+		WL_UNLOCK(wl);
+		WL_NONE(("%s: Down\n", __func__));
+	}
 	pci_disable_device(pdev);
 
 	wl_free(wl);
@@ -1610,14 +1450,14 @@ static void __devexit wl_remove(struct pci_dev *pdev)
 }
 
 static struct pci_driver wl_pci_driver = {
- name:	"brcm80211",
- probe:wl_pci_probe,
+ .name  = "brcm80211",
+ .probe = wl_pci_probe,
 #ifdef LINUXSTA_PS
- suspend:wl_suspend,
- resume:wl_resume,
+ .suspend = wl_suspend,
+ .resume  = wl_resume,
 #endif				/* LINUXSTA_PS */
- remove:__devexit_p(wl_remove),
- id_table:wl_id_table,
+ .remove   = __devexit_p(wl_remove),
+ .id_table = wl_id_table,
 };
 #endif				/* !BCMSDIO */
 
@@ -1638,26 +1478,27 @@ static int __init wl_module_init(void)
 	else {
 		char *var = getvar(NULL, "wl_msglevel");
 		if (var)
-			wl_msg_level = bcm_strtoul(var, NULL, 0);
+			wl_msg_level = simple_strtoul(var, NULL, 0);
 	}
 #ifndef WLC_HIGH_ONLY
 	{
-		extern uint32 phyhal_msg_level;
+		extern u32 phyhal_msg_level;
 
 		if (phymsglevel != 0xdeadbeef)
 			phyhal_msg_level = phymsglevel;
 		else {
 			char *var = getvar(NULL, "phy_msglevel");
 			if (var)
-				phyhal_msg_level = bcm_strtoul(var, NULL, 0);
+				phyhal_msg_level = simple_strtoul(var, NULL, 0);
 		}
 	}
 #endif				/* WLC_HIGH_ONLY */
 #endif				/* BCMDBG */
 
 #ifndef BCMSDIO
-	if (!(error = pci_module_init(&wl_pci_driver)))
-		return (0);
+	error = pci_register_driver(&wl_pci_driver);
+	if (!error)
+		return 0;
 
 #endif				/* !BCMSDIO */
 
@@ -1671,7 +1512,7 @@ static int __init wl_module_init(void)
 	}
 #endif				/* WLC_HIGH_ONLY */
 
-	return (error);
+	return error;
 }
 
 /**
@@ -1702,7 +1543,7 @@ module_exit(wl_module_exit);
  * by the wl parameter.
  *
  */
-void wl_free(wl_info_t * wl)
+void wl_free(wl_info_t *wl)
 {
 	wl_timer_t *t, *next;
 	osl_t *osh;
@@ -1741,15 +1582,9 @@ void wl_free(wl_info_t * wl)
 		next = t->next;
 #ifdef BCMDBG
 		if (t->name)
-			MFREE(wl->osh, t->name, strlen(t->name) + 1);
+			kfree(t->name);
 #endif
-		MFREE(wl->osh, t, sizeof(wl_timer_t));
-	}
-
-	if (wl->ioctlbuf_sz) {
-		remove_proc_entry(PROC_ENTRY_NAME, NULL);
-		vfree(wl->ioctlbuf);
-		wl->ioctlbuf_sz = 0;
+		kfree(t);
 	}
 
 	osh = wl->osh;
@@ -1780,17 +1615,12 @@ void wl_free(wl_info_t * wl)
 	}
 #endif				/* WLC_HIGH_ONLY */
 
-	if (osl_malloced(osh)) {
-		printf("****   Memory leak of bytes %d\n", osl_malloced(osh));
-		ASSERT(0 && "Memory Leak");
-	}
-
 	osl_detach(osh);
 }
 
 #ifdef WLC_LOW
 /* transmit a packet */
-static int BCMFASTPATH wl_start(struct sk_buff *skb, wl_info_t * wl)
+static int BCMFASTPATH wl_start(struct sk_buff *skb, wl_info_t *wl)
 {
 	if (!wl)
 		return -ENETDOWN;
@@ -1800,7 +1630,7 @@ static int BCMFASTPATH wl_start(struct sk_buff *skb, wl_info_t * wl)
 #endif				/* WLC_LOW */
 
 static int BCMFASTPATH
-wl_start_int(wl_info_t * wl, struct ieee80211_hw *hw, struct sk_buff *skb)
+wl_start_int(wl_info_t *wl, struct ieee80211_hw *hw, struct sk_buff *skb)
 {
 #ifdef WLC_HIGH_ONLY
 	WL_LOCK(wl);
@@ -1809,10 +1639,10 @@ wl_start_int(wl_info_t * wl, struct ieee80211_hw *hw, struct sk_buff *skb)
 #ifdef WLC_HIGH_ONLY
 	WL_UNLOCK(wl);
 #endif
-	return (NETDEV_TX_OK);
+	return NETDEV_TX_OK;
 }
 
-void wl_txflowcontrol(wl_info_t * wl, struct wl_if *wlif, bool state, int prio)
+void wl_txflowcontrol(wl_info_t *wl, struct wl_if *wlif, bool state, int prio)
 {
 	WL_ERROR(("Shouldn't be here %s\n", __func__));
 }
@@ -1820,24 +1650,25 @@ void wl_txflowcontrol(wl_info_t * wl, struct wl_if *wlif, bool state, int prio)
 #if defined(WLC_HIGH_ONLY)
 /* Schedule a completion handler to run at safe time */
 static int
-wl_schedule_task(wl_info_t * wl, void (*fn) (struct wl_task * task),
+wl_schedule_task(wl_info_t *wl, void (*fn) (struct wl_task *task),
 		 void *context)
 {
 	wl_task_t *task;
 
 	WL_TRACE(("wl%d: wl_schedule_task\n", wl->pub->unit));
 
-	if (!(task = osl_malloc(wl->osh, sizeof(wl_task_t)))) {
-		WL_ERROR(("wl%d: wl_schedule_task: out of memory, malloced %d bytes\n", wl->pub->unit, osl_malloced(wl->osh)));
+	task = kmalloc(sizeof(wl_task_t), GFP_ATOMIC);
+	if (!task) {
+		WL_ERROR(("wl%d: wl_schedule_task: out of memory\n", wl->pub->unit));
 		return -ENOMEM;
 	}
 
-	MY_INIT_WORK(&task->work, (work_func_t) fn);
+	INIT_WORK(&task->work, (work_func_t) fn);
 	task->context = context;
 
 	if (!schedule_work(&task->work)) {
 		WL_ERROR(("wl%d: schedule_work() failed\n", wl->pub->unit));
-		MFREE(wl->osh, task, sizeof(wl_task_t));
+		kfree(task);
 		return -ENOMEM;
 	}
 
@@ -1847,7 +1678,7 @@ wl_schedule_task(wl_info_t * wl, void (*fn) (struct wl_task * task),
 }
 #endif				/* defined(WLC_HIGH_ONLY) */
 
-void wl_init(wl_info_t * wl)
+void wl_init(wl_info_t *wl)
 {
 	WL_TRACE(("wl%d: wl_init\n", wl->pub->unit));
 
@@ -1856,7 +1687,7 @@ void wl_init(wl_info_t * wl)
 	wlc_init(wl->wlc);
 }
 
-uint wl_reset(wl_info_t * wl)
+uint wl_reset(wl_info_t *wl)
 {
 	WL_TRACE(("wl%d: wl_reset\n", wl->pub->unit));
 
@@ -1865,14 +1696,14 @@ uint wl_reset(wl_info_t * wl)
 	/* dpc will not be rescheduled */
 	wl->resched = 0;
 
-	return (0);
+	return 0;
 }
 
 /*
  * These are interrupt on/off entry points. Disable interrupts
  * during interrupt state transition.
  */
-void BCMFASTPATH wl_intrson(wl_info_t * wl)
+void BCMFASTPATH wl_intrson(wl_info_t *wl)
 {
 #if defined(WLC_LOW)
 	unsigned long flags;
@@ -1883,16 +1714,16 @@ void BCMFASTPATH wl_intrson(wl_info_t * wl)
 #endif				/* WLC_LOW */
 }
 
-bool wl_alloc_dma_resources(wl_info_t * wl, uint addrwidth)
+bool wl_alloc_dma_resources(wl_info_t *wl, uint addrwidth)
 {
-	return TRUE;
+	return true;
 }
 
-uint32 BCMFASTPATH wl_intrsoff(wl_info_t * wl)
+u32 BCMFASTPATH wl_intrsoff(wl_info_t *wl)
 {
 #if defined(WLC_LOW)
 	unsigned long flags;
-	uint32 status;
+	u32 status;
 
 	INT_LOCK(wl, flags);
 	status = wlc_intrsoff(wl->wlc);
@@ -1903,7 +1734,7 @@ uint32 BCMFASTPATH wl_intrsoff(wl_info_t * wl)
 #endif				/* WLC_LOW */
 }
 
-void wl_intrsrestore(wl_info_t * wl, uint32 macintmask)
+void wl_intrsrestore(wl_info_t *wl, u32 macintmask)
 {
 #if defined(WLC_LOW)
 	unsigned long flags;
@@ -1914,19 +1745,19 @@ void wl_intrsrestore(wl_info_t * wl, uint32 macintmask)
 #endif				/* WLC_LOW */
 }
 
-int wl_up(wl_info_t * wl)
+int wl_up(wl_info_t *wl)
 {
 	int error = 0;
 
 	if (wl->pub->up)
-		return (0);
+		return 0;
 
 	error = wlc_up(wl->wlc);
 
-	return (error);
+	return error;
 }
 
-void wl_down(wl_info_t * wl)
+void wl_down(wl_info_t *wl)
 {
 	uint callbacks, ret_val = 0;
 
@@ -1959,13 +1790,14 @@ irqreturn_t BCMFASTPATH wl_isr(int irq, void *dev_id)
 	WL_ISRLOCK(wl, flags);
 
 	/* call common first level interrupt handler */
-	if ((ours = wlc_isr(wl->wlc, &wantdpc))) {
+	ours = wlc_isr(wl->wlc, &wantdpc);
+	if (ours) {
 		/* if more to do... */
 		if (wantdpc) {
 
 			/* ...and call the second level interrupt handler */
 			/* schedule dpc */
-			ASSERT(wl->resched == FALSE);
+			ASSERT(wl->resched == false);
 			tasklet_schedule(&wl->tasklet);
 		}
 	}
@@ -1978,7 +1810,7 @@ irqreturn_t BCMFASTPATH wl_isr(int irq, void *dev_id)
 #endif				/* WLC_LOW */
 }
 
-static void BCMFASTPATH wl_dpc(ulong data)
+static void BCMFASTPATH wl_dpc(unsigned long data)
 {
 #ifdef WLC_LOW
 	wl_info_t *wl;
@@ -1997,7 +1829,7 @@ static void BCMFASTPATH wl_dpc(ulong data)
 			INT_UNLOCK(wl, flags);
 		}
 
-		wl->resched = wlc_dpc(wl->wlc, TRUE);
+		wl->resched = wlc_dpc(wl->wlc, true);
 	}
 
 	/* wlc_dpc() may bring the driver down */
@@ -2017,17 +1849,17 @@ static void BCMFASTPATH wl_dpc(ulong data)
 #endif				/* WLC_LOW */
 }
 
-static void wl_link_up(wl_info_t * wl, char *ifname)
+static void wl_link_up(wl_info_t *wl, char *ifname)
 {
 	WL_ERROR(("wl%d: link up (%s)\n", wl->pub->unit, ifname));
 }
 
-static void wl_link_down(wl_info_t * wl, char *ifname)
+static void wl_link_down(wl_info_t *wl, char *ifname)
 {
 	WL_ERROR(("wl%d: link down (%s)\n", wl->pub->unit, ifname));
 }
 
-void wl_event(wl_info_t * wl, char *ifname, wlc_event_t * e)
+void wl_event(wl_info_t *wl, char *ifname, wlc_event_t *e)
 {
 
 	switch (e->event.event_type) {
@@ -2043,7 +1875,7 @@ void wl_event(wl_info_t * wl, char *ifname, wlc_event_t * e)
 	}
 }
 
-static void wl_timer(ulong data)
+static void wl_timer(unsigned long data)
 {
 #ifndef WLC_HIGH_ONLY
 	_wl_timer((wl_timer_t *) data);
@@ -2053,7 +1885,7 @@ static void wl_timer(ulong data)
 #endif				/* WLC_HIGH_ONLY */
 }
 
-static void _wl_timer(wl_timer_t * t)
+static void _wl_timer(wl_timer_t *t)
 {
 	WL_LOCK(t->wl);
 
@@ -2062,9 +1894,9 @@ static void _wl_timer(wl_timer_t * t)
 			t->timer.expires = jiffies + t->ms * HZ / 1000;
 			atomic_inc(&t->wl->callbacks);
 			add_timer(&t->timer);
-			t->set = TRUE;
+			t->set = true;
 		} else
-			t->set = FALSE;
+			t->set = false;
 
 		t->fn(t->arg);
 	}
@@ -2074,20 +1906,21 @@ static void _wl_timer(wl_timer_t * t)
 	WL_UNLOCK(t->wl);
 }
 
-wl_timer_t *wl_init_timer(wl_info_t * wl, void (*fn) (void *arg), void *arg,
+wl_timer_t *wl_init_timer(wl_info_t *wl, void (*fn) (void *arg), void *arg,
 			  const char *name)
 {
 	wl_timer_t *t;
 
-	if (!(t = osl_malloc(wl->osh, sizeof(wl_timer_t)))) {
-		WL_ERROR(("wl%d: wl_init_timer: out of memory, malloced %d bytes\n", wl->pub->unit, osl_malloced(wl->osh)));
+	t = kmalloc(sizeof(wl_timer_t), GFP_ATOMIC);
+	if (!t) {
+		WL_ERROR(("wl%d: wl_init_timer: out of memory\n", wl->pub->unit));
 		return 0;
 	}
 
 	bzero(t, sizeof(wl_timer_t));
 
 	init_timer(&t->timer);
-	t->timer.data = (ulong) t;
+	t->timer.data = (unsigned long) t;
 	t->timer.function = wl_timer;
 	t->wl = wl;
 	t->fn = fn;
@@ -2096,7 +1929,8 @@ wl_timer_t *wl_init_timer(wl_info_t * wl, void (*fn) (void *arg), void *arg,
 	wl->timers = t;
 
 #ifdef BCMDBG
-	if ((t->name = osl_malloc(wl->osh, strlen(name) + 1)))
+	t->name = kmalloc(strlen(name) + 1, GFP_ATOMIC);
+	if (t->name)
 		strcpy(t->name, name);
 #endif
 
@@ -2106,7 +1940,7 @@ wl_timer_t *wl_init_timer(wl_info_t * wl, void (*fn) (void *arg), void *arg,
 /* BMAC_NOTE: Add timer adds only the kernel timer since it's going to be more accurate
  * as well as it's easier to make it periodic
  */
-void wl_add_timer(wl_info_t * wl, wl_timer_t * t, uint ms, int periodic)
+void wl_add_timer(wl_info_t *wl, wl_timer_t *t, uint ms, int periodic)
 {
 #ifdef BCMDBG
 	if (t->set) {
@@ -2118,28 +1952,28 @@ void wl_add_timer(wl_info_t * wl, wl_timer_t * t, uint ms, int periodic)
 
 	t->ms = ms;
 	t->periodic = (bool) periodic;
-	t->set = TRUE;
+	t->set = true;
 	t->timer.expires = jiffies + ms * HZ / 1000;
 
 	atomic_inc(&wl->callbacks);
 	add_timer(&t->timer);
 }
 
-/* return TRUE if timer successfully deleted, FALSE if still pending */
-bool wl_del_timer(wl_info_t * wl, wl_timer_t * t)
+/* return true if timer successfully deleted, false if still pending */
+bool wl_del_timer(wl_info_t *wl, wl_timer_t *t)
 {
 	if (t->set) {
-		t->set = FALSE;
+		t->set = false;
 		if (!del_timer(&t->timer)) {
-			return FALSE;
+			return false;
 		}
 		atomic_dec(&wl->callbacks);
 	}
 
-	return TRUE;
+	return true;
 }
 
-void wl_free_timer(wl_info_t * wl, wl_timer_t * t)
+void wl_free_timer(wl_info_t *wl, wl_timer_t *t)
 {
 	wl_timer_t *tmp;
 
@@ -2150,9 +1984,9 @@ void wl_free_timer(wl_info_t * wl, wl_timer_t * t)
 		wl->timers = wl->timers->next;
 #ifdef BCMDBG
 		if (t->name)
-			MFREE(wl->osh, t->name, strlen(t->name) + 1);
+			kfree(t->name);
 #endif
-		MFREE(wl->osh, t, sizeof(wl_timer_t));
+		kfree(t);
 		return;
 
 	}
@@ -2163,9 +1997,9 @@ void wl_free_timer(wl_info_t * wl, wl_timer_t * t)
 			tmp->next = t->next;
 #ifdef BCMDBG
 			if (t->name)
-				MFREE(wl->osh, t->name, strlen(t->name) + 1);
+				kfree(t->name);
 #endif
-			MFREE(wl->osh, t, sizeof(wl_timer_t));
+			kfree(t);
 			return;
 		}
 		tmp = tmp->next;
@@ -2210,9 +2044,9 @@ static int wl_linux_watchdog(void *ctx)
 }
 
 struct wl_fw_hdr {
-	uint32 offset;
-	uint32 len;
-	uint32 idx;
+	u32 offset;
+	u32 len;
+	u32 idx;
 };
 
 #ifdef WLC_HIGH_ONLY
@@ -2225,10 +2059,10 @@ static void wl_rpc_down(void *wlh)
 	wl_rpcq_free(wl);
 }
 
-static int BCMFASTPATH wl_start(struct sk_buff *skb, wl_info_t * wl)
+static int BCMFASTPATH wl_start(struct sk_buff *skb, wl_info_t *wl)
 {
 
-	ulong flags;
+	unsigned long flags;
 
 	skb->prev = NULL;
 
@@ -2241,8 +2075,8 @@ static int BCMFASTPATH wl_start(struct sk_buff *skb, wl_info_t * wl)
 	}
 	wl->txq_tail = skb;
 
-	if (wl->txq_dispatched == FALSE) {
-		wl->txq_dispatched = TRUE;
+	if (wl->txq_dispatched == false) {
+		wl->txq_dispatched = true;
 
 		if (schedule_work(&wl->txq_task.work)) {
 			atomic_inc(&wl->callbacks);
@@ -2254,7 +2088,7 @@ static int BCMFASTPATH wl_start(struct sk_buff *skb, wl_info_t * wl)
 
 	TXQ_UNLOCK(wl, flags);
 
-	return (0);
+	return 0;
 
 }
 
@@ -2262,7 +2096,7 @@ static void wl_start_txqwork(struct wl_task *task)
 {
 	wl_info_t *wl = (wl_info_t *) task->context;
 	struct sk_buff *skb;
-	ulong flags;
+	unsigned long flags;
 	uint count = 0;
 
 	WL_TRACE(("wl%d: wl_start_txqwork\n", wl->pub->unit));
@@ -2294,7 +2128,7 @@ static void wl_start_txqwork(struct wl_task *task)
 			atomic_dec(&wl->callbacks);
 		}
 	} else {
-		wl->txq_dispatched = FALSE;
+		wl->txq_dispatched = false;
 		TXQ_UNLOCK(wl, flags);
 		atomic_dec(&wl->callbacks);
 	}
@@ -2302,7 +2136,7 @@ static void wl_start_txqwork(struct wl_task *task)
 	return;
 }
 
-static void wl_txq_free(wl_info_t * wl)
+static void wl_txq_free(wl_info_t *wl)
 {
 	struct sk_buff *skb;
 
@@ -2314,13 +2148,13 @@ static void wl_txq_free(wl_info_t * wl)
 	while (wl->txq_head) {
 		skb = wl->txq_head;
 		wl->txq_head = skb->prev;
-		PKTFREE(wl->osh, skb, TRUE);
+		PKTFREE(wl->osh, skb, true);
 	}
 
 	wl->txq_tail = NULL;
 }
 
-static void wl_rpcq_free(wl_info_t * wl)
+static void wl_rpcq_free(wl_info_t *wl)
 {
 	rpc_buf_t *buf;
 
@@ -2342,7 +2176,7 @@ static void wl_rpcq_dispatch(struct wl_task *task)
 {
 	wl_info_t *wl = (wl_info_t *) task->context;
 	rpc_buf_t *buf;
-	ulong flags;
+	unsigned long flags;
 
 	/* First remove an entry then go for execution */
 	RPCQ_LOCK(wl, flags);
@@ -2361,17 +2195,17 @@ static void wl_rpcq_dispatch(struct wl_task *task)
 		RPCQ_LOCK(wl, flags);
 	}
 
-	wl->rpcq_dispatched = FALSE;
+	wl->rpcq_dispatched = false;
 
 	RPCQ_UNLOCK(wl, flags);
 
-	MFREE(wl->osh, task, sizeof(wl_task_t));
+	kfree(task);
 	atomic_dec(&wl->callbacks);
 }
 
-static void wl_rpcq_add(wl_info_t * wl, rpc_buf_t * buf)
+static void wl_rpcq_add(wl_info_t *wl, rpc_buf_t *buf)
 {
-	ulong flags;
+	unsigned long flags;
 
 	bcm_rpc_buf_next_set(wl->rpc_th, buf, NULL);
 
@@ -2384,8 +2218,8 @@ static void wl_rpcq_add(wl_info_t * wl, rpc_buf_t * buf)
 
 	wl->rpcq_tail = buf;
 
-	if (wl->rpcq_dispatched == FALSE) {
-		wl->rpcq_dispatched = TRUE;
+	if (wl->rpcq_dispatched == false) {
+		wl->rpcq_dispatched = true;
 		wl_schedule_task(wl, wl_rpcq_dispatch, wl);
 	}
 
@@ -2407,7 +2241,7 @@ static void wl_rpc_dispatch_schedule(void *ctx, struct rpc_buf *buf)
 	bcm_xdr_buf_init(&b, bcm_rpc_buf_data(wl->rpc_th, buf),
 			 bcm_rpc_buf_len_get(wl->rpc_th, buf));
 
-	err = bcm_xdr_unpack_uint32(&b, &rpc_id);
+	err = bcm_xdr_unpack_u32(&b, &rpc_id);
 	ASSERT(!err);
 	WL_TRACE(("%s: Dispatch id %s\n", __func__,
 		  WLC_RPC_ID_LOOKUP(rpc_name_tbl, rpc_id)));
@@ -2420,12 +2254,12 @@ static void wl_rpc_dispatch_schedule(void *ctx, struct rpc_buf *buf)
 	}
 }
 
-static void wl_timer_task(wl_task_t * task)
+static void wl_timer_task(wl_task_t *task)
 {
 	wl_timer_t *t = (wl_timer_t *) task->context;
 
 	_wl_timer(t);
-	MFREE(t->wl->osh, task, sizeof(wl_task_t));
+	kfree(task);
 
 	/* This dec is for the task_schedule. The timer related
 	 * callback is decremented in _wl_timer
@@ -2441,10 +2275,10 @@ char *wl_firmwares[WL_MAX_FW] = {
 };
 
 #ifdef WLC_LOW
-int wl_ucode_init_buf(wl_info_t * wl, void **pbuf, uint32 idx)
+int wl_ucode_init_buf(wl_info_t *wl, void **pbuf, u32 idx)
 {
 	int i, entry;
-	const uint8 *pdata;
+	const u8 *pdata;
 	struct wl_fw_hdr *hdr;
 	for (i = 0; i < wl->fw.fw_cnt; i++) {
 		hdr = (struct wl_fw_hdr *)wl->fw.fw_hdr[i]->data;
@@ -2467,10 +2301,10 @@ int wl_ucode_init_buf(wl_info_t * wl, void **pbuf, uint32 idx)
 	return -1;
 }
 
-int wl_ucode_init_uint(wl_info_t * wl, uint32 * data, uint32 idx)
+int wl_ucode_init_uint(wl_info_t *wl, u32 *data, u32 idx)
 {
 	int i, entry;
-	const uint8 *pdata;
+	const u8 *pdata;
 	struct wl_fw_hdr *hdr;
 	for (i = 0; i < wl->fw.fw_cnt; i++) {
 		hdr = (struct wl_fw_hdr *)wl->fw.fw_hdr[i]->data;
@@ -2479,7 +2313,7 @@ int wl_ucode_init_uint(wl_info_t * wl, uint32 * data, uint32 idx)
 			if (hdr->idx == idx) {
 				pdata = wl->fw.fw_bin[i]->data + hdr->offset;
 				ASSERT(hdr->len == 4);
-				*data = *((uint32 *) pdata);
+				*data = *((u32 *) pdata);
 				return 0;
 			}
 		}
@@ -2489,7 +2323,7 @@ int wl_ucode_init_uint(wl_info_t * wl, uint32 * data, uint32 idx)
 }
 #endif				/* WLC_LOW */
 
-static int wl_request_fw(wl_info_t * wl, struct pci_dev *pdev)
+static int wl_request_fw(wl_info_t *wl, struct pci_dev *pdev)
 {
 	int status;
 	struct device *device = &pdev->dev;
@@ -2505,7 +2339,8 @@ static int wl_request_fw(wl_info_t * wl, struct pci_dev *pdev)
 		WL_NONE(("request fw %s\n", fw_name));
 		status = request_firmware(&wl->fw.fw_bin[i], fw_name, device);
 		if (status) {
-			printf("fail to request firmware %s\n", fw_name);
+			printf("%s: fail to load firmware %s\n",
+				KBUILD_MODNAME, fw_name);
 			wl_release_fw(wl);
 			return status;
 		}
@@ -2514,7 +2349,8 @@ static int wl_request_fw(wl_info_t * wl, struct pci_dev *pdev)
 			UCODE_LOADER_API_VER);
 		status = request_firmware(&wl->fw.fw_hdr[i], fw_name, device);
 		if (status) {
-			printf("fail to request firmware %s\n", fw_name);
+			printf("%s: fail to load firmware %s\n",
+				KBUILD_MODNAME, fw_name);
 			wl_release_fw(wl);
 			return status;
 		}
@@ -2535,7 +2371,7 @@ void wl_ucode_free_buf(void *p)
 }
 #endif				/* WLC_LOW */
 
-static void wl_release_fw(wl_info_t * wl)
+static void wl_release_fw(wl_info_t *wl)
 {
 	int i;
 	for (i = 0; i < WL_MAX_FW; i++) {
diff --git a/drivers/staging/brcm80211/sys/wl_mac80211.h b/drivers/staging/brcm80211/sys/wl_mac80211.h
index a7c89a9..78cee44 100644
--- a/drivers/staging/brcm80211/sys/wl_mac80211.h
+++ b/drivers/staging/brcm80211/sys/wl_mac80211.h
@@ -53,17 +53,17 @@ struct wl_if {
 
 #define WL_MAX_FW		4
 struct wl_firmware {
-	uint32 fw_cnt;
+	u32 fw_cnt;
 	const struct firmware *fw_bin[WL_MAX_FW];
 	const struct firmware *fw_hdr[WL_MAX_FW];
-	uint32 hdr_num_entries[WL_MAX_FW];
+	u32 hdr_num_entries[WL_MAX_FW];
 };
 
 struct wl_info {
 	wlc_pub_t *pub;		/* pointer to public wlc state */
 	void *wlc;		/* pointer to private common os-independent data */
 	osl_t *osh;		/* pointer to os handler */
-	uint32 magic;
+	u32 magic;
 
 	int irq;
 
@@ -81,11 +81,11 @@ struct wl_info {
 	struct tasklet_struct tasklet;	/* dpc tasklet */
 #ifdef BCMSDIO
 	bcmsdh_info_t *sdh;	/* pointer to sdio bus handler */
-	ulong flags;		/* current irq flags */
+	unsigned long flags;		/* current irq flags */
 #endif				/* BCMSDIO */
 	bool resched;		/* dpc needs to be and is rescheduled */
 #ifdef LINUXSTA_PS
-	uint32 pci_psstate[16];	/* pci ps-state save/restore */
+	u32 pci_psstate[16];	/* pci ps-state save/restore */
 #endif
 	/* RPC, handle, lock, txq, workitem */
 #ifdef WLC_HIGH_ONLY
@@ -108,26 +108,16 @@ struct wl_info {
 	uint stats_id;		/* the current set of stats */
 	/* ping-pong stats counters updated by Linux watchdog */
 	struct net_device_stats stats_watchdog[2];
-
-	struct proc_dir_entry *proc_entry;
-	char *ioctlbuf;
-	unsigned int ioctlbuf_sz;
-	wl_ioctl_t ioc;
-	int proc_state;
-	bool ioctl_in_progress;
 	struct wl_firmware fw;
 };
-#define WL_PROC_IDLE		(0)
-#define WL_PROC_HAVE_IOC	(1)
-#define WL_PROC_HAVE_BUF 	(2)
 
 #ifndef WLC_HIGH_ONLY
 #define WL_LOCK(wl)	spin_lock_bh(&(wl)->lock)
 #define WL_UNLOCK(wl)	spin_unlock_bh(&(wl)->lock)
 
 /* locking from inside wl_isr */
-#define WL_ISRLOCK(wl, flags) do {spin_lock(&(wl)->isr_lock); (void)(flags);} while (0)
-#define WL_ISRUNLOCK(wl, flags) do {spin_unlock(&(wl)->isr_lock); (void)(flags);} while (0)
+#define WL_ISRLOCK(wl, flags) do {spin_lock(&(wl)->isr_lock); (void)(flags); } while (0)
+#define WL_ISRUNLOCK(wl, flags) do {spin_unlock(&(wl)->isr_lock); (void)(flags); } while (0)
 
 /* locking under WL_LOCK() to synchronize with wl_isr */
 #define INT_LOCK(wl, flags)	spin_lock_irqsave(&(wl)->isr_lock, flags)
@@ -158,14 +148,14 @@ extern irqreturn_t wl_isr(int irq, void *dev_id);
 
 extern int __devinit wl_pci_probe(struct pci_dev *pdev,
 				  const struct pci_device_id *ent);
-extern void wl_free(wl_info_t * wl);
+extern void wl_free(wl_info_t *wl);
 extern int wl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
-extern int wl_ucode_data_init(wl_info_t * wl);
+extern int wl_ucode_data_init(wl_info_t *wl);
 extern void wl_ucode_data_free(void);
 #ifdef WLC_LOW
 extern void wl_ucode_free_buf(void *);
-extern int wl_ucode_init_buf(wl_info_t * wl, void **pbuf, uint32 idx);
-extern int wl_ucode_init_uint(wl_info_t * wl, uint32 * data, uint32 idx);
+extern int wl_ucode_init_buf(wl_info_t *wl, void **pbuf, u32 idx);
+extern int wl_ucode_init_uint(wl_info_t *wl, u32 *data, u32 idx);
 #endif				/* WLC_LOW */
 
 #endif				/* _wl_mac80211_h_ */
diff --git a/drivers/staging/brcm80211/sys/wl_ucode.h b/drivers/staging/brcm80211/sys/wl_ucode.h
index 2763b7c..a1ba372 100644
--- a/drivers/staging/brcm80211/sys/wl_ucode.h
+++ b/drivers/staging/brcm80211/sys/wl_ucode.h
@@ -14,11 +14,10 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <typedefs.h>
 typedef struct d11init {
-	uint16 addr;
-	uint16 size;
-	uint32 value;
+	u16 addr;
+	u16 size;
+	u32 value;
 } d11init_t;
 
 extern d11init_t *d11lcn0bsinitvals24;
@@ -30,9 +29,9 @@ extern d11init_t *d11lcn2initvals24;
 extern d11init_t *d11n0absinitvals16;
 extern d11init_t *d11n0bsinitvals16;
 extern d11init_t *d11n0initvals16;
-extern uint32 *bcm43xx_16_mimo;
-extern uint32 bcm43xx_16_mimosz;
-extern uint32 *bcm43xx_24_lcn;
-extern uint32 bcm43xx_24_lcnsz;
-extern uint32 *bcm43xx_bommajor;
-extern uint32 *bcm43xx_bomminor;
+extern u32 *bcm43xx_16_mimo;
+extern u32 bcm43xx_16_mimosz;
+extern u32 *bcm43xx_24_lcn;
+extern u32 bcm43xx_24_lcnsz;
+extern u32 *bcm43xx_bommajor;
+extern u32 *bcm43xx_bomminor;
diff --git a/drivers/staging/brcm80211/sys/wl_ucode_loader.c b/drivers/staging/brcm80211/sys/wl_ucode_loader.c
index 7eef308..0b41a9c 100644
--- a/drivers/staging/brcm80211/sys/wl_ucode_loader.c
+++ b/drivers/staging/brcm80211/sys/wl_ucode_loader.c
@@ -15,13 +15,14 @@
  */
 
 typedef struct wl_info wl_info_t;
-#include <typedefs.h>
+#include <linux/types.h>
+#include <bcmdefs.h>
 #include <d11ucode_ext.h>
 #include <wl_ucode.h>
 
-extern int wl_ucode_init_buf(wl_info_t * wl, void **pbuf, unsigned int idx);
-extern int wl_ucode_init_uint(wl_info_t * wl, unsigned *data, unsigned int idx);
-extern int wl_ucode_data_init(wl_info_t * wl);
+extern int wl_ucode_init_buf(wl_info_t *wl, void **pbuf, unsigned int idx);
+extern int wl_ucode_init_uint(wl_info_t *wl, unsigned *data, unsigned int idx);
+extern int wl_ucode_data_init(wl_info_t *wl);
 extern void wl_ucode_data_free(void);
 extern void wl_ucode_free_buf(void *);
 
@@ -34,14 +35,14 @@ d11init_t *d11lcn2initvals24;
 d11init_t *d11n0absinitvals16;
 d11init_t *d11n0bsinitvals16;
 d11init_t *d11n0initvals16;
-uint32 *bcm43xx_16_mimo;
-uint32 bcm43xx_16_mimosz;
-uint32 *bcm43xx_24_lcn;
-uint32 bcm43xx_24_lcnsz;
-uint32 *bcm43xx_bommajor;
-uint32 *bcm43xx_bomminor;
+u32 *bcm43xx_16_mimo;
+u32 bcm43xx_16_mimosz;
+u32 *bcm43xx_24_lcn;
+u32 bcm43xx_24_lcnsz;
+u32 *bcm43xx_bommajor;
+u32 *bcm43xx_bomminor;
 
-int wl_ucode_data_init(wl_info_t * wl)
+int wl_ucode_data_init(wl_info_t *wl)
 {
 	wl_ucode_init_buf(wl, (void **)&d11lcn0bsinitvals24,
 			  D11LCN0BSINITVALS24);
diff --git a/drivers/staging/brcm80211/sys/wlc_alloc.c b/drivers/staging/brcm80211/sys/wlc_alloc.c
index 4f3f831..2dc89f9 100644
--- a/drivers/staging/brcm80211/sys/wlc_alloc.c
+++ b/drivers/staging/brcm80211/sys/wlc_alloc.c
@@ -13,44 +13,37 @@
  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
-
-#include <wlc_cfg.h>
-#include <typedefs.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
 #include <bcmdefs.h>
+#include <wlc_cfg.h>
+#include <linuxver.h>
 #include <osl.h>
 #include <bcmutils.h>
 #include <siutils.h>
-#include <proto/802.11.h>
-#include <proto/802.11e.h>
-#include <proto/wpa.h>
 #include <wlioctl.h>
-#include <bcmwpa.h>
-#include <d11.h>
-#include <wlc_rate.h>
 #include <wlc_pub.h>
 #include <wlc_key.h>
-#include <wlc_bsscfg.h>
 #include <wlc_mac80211.h>
 #include <wlc_alloc.h>
 
-static wlc_pub_t *wlc_pub_malloc(osl_t * osh, uint unit, uint * err,
+static wlc_pub_t *wlc_pub_malloc(osl_t *osh, uint unit, uint *err,
 				 uint devid);
-static void wlc_pub_mfree(osl_t * osh, wlc_pub_t * pub);
-static void wlc_tunables_init(wlc_tunables_t * tunables, uint devid);
+static void wlc_pub_mfree(osl_t *osh, wlc_pub_t *pub);
+static void wlc_tunables_init(wlc_tunables_t *tunables, uint devid);
 
-void *wlc_calloc(osl_t * osh, uint unit, uint size)
+void *wlc_calloc(osl_t *osh, uint unit, uint size)
 {
 	void *item;
 
-	if ((item = MALLOC(osh, size)) == NULL)
-		WL_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
-			  unit, __func__, MALLOCED(osh)));
-	else
-		bzero((char *)item, size);
+	item = kzalloc(size, GFP_ATOMIC);
+	if (item == NULL)
+		WL_ERROR(("wl%d: %s: out of memory\n", unit, __func__));
 	return item;
 }
 
-void BCMATTACHFN(wlc_tunables_init) (wlc_tunables_t * tunables, uint devid) {
+void wlc_tunables_init(wlc_tunables_t *tunables, uint devid)
+{
 	tunables->ntxd = NTXD;
 	tunables->nrxd = NRXD;
 	tunables->rxbufsz = RXBUFSZ;
@@ -72,18 +65,19 @@ void BCMATTACHFN(wlc_tunables_init) (wlc_tunables_t * tunables, uint devid) {
 #endif				/* WLC_HIGH_ONLY */
 }
 
-static wlc_pub_t *BCMATTACHFN(wlc_pub_malloc) (osl_t * osh, uint unit,
-					       uint * err, uint devid) {
+static wlc_pub_t *wlc_pub_malloc(osl_t *osh, uint unit, uint *err, uint devid)
+{
 	wlc_pub_t *pub;
 
-	if ((pub =
-	     (wlc_pub_t *) wlc_calloc(osh, unit, sizeof(wlc_pub_t))) == NULL) {
+	pub = (wlc_pub_t *) wlc_calloc(osh, unit, sizeof(wlc_pub_t));
+	if (pub == NULL) {
 		*err = 1001;
 		goto fail;
 	}
 
-	if ((pub->tunables = (wlc_tunables_t *)
-	     wlc_calloc(osh, unit, sizeof(wlc_tunables_t))) == NULL) {
+	pub->tunables = (wlc_tunables_t *)wlc_calloc(osh, unit,
+		sizeof(wlc_tunables_t));
+	if (pub->tunables == NULL) {
 		*err = 1028;
 		goto fail;
 	}
@@ -91,9 +85,9 @@ static wlc_pub_t *BCMATTACHFN(wlc_pub_malloc) (osl_t * osh, uint unit,
 	/* need to init the tunables now */
 	wlc_tunables_init(pub->tunables, devid);
 
-	if ((pub->multicast = (struct ether_addr *)
-	     wlc_calloc(osh, unit,
-			(sizeof(struct ether_addr) * MAXMULTILIST))) == NULL) {
+	pub->multicast = (struct ether_addr *)wlc_calloc(osh, unit,
+		(sizeof(struct ether_addr) * MAXMULTILIST));
+	if (pub->multicast == NULL) {
 		*err = 1003;
 		goto fail;
 	}
@@ -105,33 +99,32 @@ static wlc_pub_t *BCMATTACHFN(wlc_pub_malloc) (osl_t * osh, uint unit,
 	return NULL;
 }
 
-static void BCMATTACHFN(wlc_pub_mfree) (osl_t * osh, wlc_pub_t * pub) {
+static void wlc_pub_mfree(osl_t *osh, wlc_pub_t *pub)
+{
 	if (pub == NULL)
 		return;
 
 	if (pub->multicast)
-		MFREE(osh, pub->multicast,
-		      (sizeof(struct ether_addr) * MAXMULTILIST));
-
+		kfree(pub->multicast);
 	if (pub->tunables) {
-		MFREE(osh, pub->tunables, sizeof(wlc_tunables_t));
+		kfree(pub->tunables);
 		pub->tunables = NULL;
 	}
 
-	MFREE(osh, pub, sizeof(wlc_pub_t));
+	kfree(pub);
 }
 
-wlc_bsscfg_t *wlc_bsscfg_malloc(osl_t * osh, uint unit)
+wlc_bsscfg_t *wlc_bsscfg_malloc(osl_t *osh, uint unit)
 {
 	wlc_bsscfg_t *cfg;
 
-	if ((cfg =
-	     (wlc_bsscfg_t *) wlc_calloc(osh, unit,
-					 sizeof(wlc_bsscfg_t))) == NULL)
+	cfg = (wlc_bsscfg_t *) wlc_calloc(osh, unit, sizeof(wlc_bsscfg_t));
+	if (cfg == NULL)
 		goto fail;
 
-	if ((cfg->current_bss = (wlc_bss_info_t *)
-	     wlc_calloc(osh, unit, sizeof(wlc_bss_info_t))) == NULL)
+	cfg->current_bss = (wlc_bss_info_t *)wlc_calloc(osh, unit,
+		sizeof(wlc_bss_info_t));
+	if (cfg->current_bss == NULL)
 		goto fail;
 
 	return cfg;
@@ -141,31 +134,28 @@ wlc_bsscfg_t *wlc_bsscfg_malloc(osl_t * osh, uint unit)
 	return NULL;
 }
 
-void wlc_bsscfg_mfree(osl_t * osh, wlc_bsscfg_t * cfg)
+void wlc_bsscfg_mfree(osl_t *osh, wlc_bsscfg_t *cfg)
 {
 	if (cfg == NULL)
 		return;
 
 	if (cfg->maclist) {
-		MFREE(osh, cfg->maclist,
-		      (int)(OFFSETOF(struct maclist, ea) +
-			    cfg->nmac * ETHER_ADDR_LEN));
+		kfree(cfg->maclist);
 		cfg->maclist = NULL;
 	}
 
 	if (cfg->current_bss != NULL) {
 		wlc_bss_info_t *current_bss = cfg->current_bss;
 		if (current_bss->bcn_prb != NULL)
-			MFREE(osh, current_bss->bcn_prb,
-			      current_bss->bcn_prb_len);
-		MFREE(osh, current_bss, sizeof(wlc_bss_info_t));
+			kfree(current_bss->bcn_prb);
+		kfree(current_bss);
 		cfg->current_bss = NULL;
 	}
 
-	MFREE(osh, cfg, sizeof(wlc_bsscfg_t));
+	kfree(cfg);
 }
 
-void wlc_bsscfg_ID_assign(wlc_info_t * wlc, wlc_bsscfg_t * bsscfg)
+void wlc_bsscfg_ID_assign(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg)
 {
 	bsscfg->ID = wlc->next_bsscfg_ID;
 	wlc->next_bsscfg_ID++;
@@ -174,13 +164,12 @@ void wlc_bsscfg_ID_assign(wlc_info_t * wlc, wlc_bsscfg_t * bsscfg)
 /*
  * The common driver entry routine. Error codes should be unique
  */
-wlc_info_t *BCMATTACHFN(wlc_attach_malloc) (osl_t * osh, uint unit, uint * err,
-					    uint devid) {
+wlc_info_t *wlc_attach_malloc(osl_t *osh, uint unit, uint *err, uint devid)
+{
 	wlc_info_t *wlc;
 
-	if ((wlc =
-	     (wlc_info_t *) wlc_calloc(osh, unit,
-				       sizeof(wlc_info_t))) == NULL) {
+	wlc = (wlc_info_t *) wlc_calloc(osh, unit, sizeof(wlc_info_t));
+	if (wlc == NULL) {
 		*err = 1002;
 		goto fail;
 	}
@@ -188,7 +177,8 @@ wlc_info_t *BCMATTACHFN(wlc_attach_malloc) (osl_t * osh, uint unit, uint * err,
 	wlc->hwrxoff = WL_HWRXOFF;
 
 	/* allocate wlc_pub_t state structure */
-	if ((wlc->pub = wlc_pub_malloc(osh, unit, err, devid)) == NULL) {
+	wlc->pub = wlc_pub_malloc(osh, unit, err, devid);
+	if (wlc->pub == NULL) {
 		*err = 1003;
 		goto fail;
 	}
@@ -196,16 +186,18 @@ wlc_info_t *BCMATTACHFN(wlc_attach_malloc) (osl_t * osh, uint unit, uint * err,
 
 	/* allocate wlc_hw_info_t state structure */
 
-	if ((wlc->hw = (wlc_hw_info_t *)
-	     wlc_calloc(osh, unit, sizeof(wlc_hw_info_t))) == NULL) {
+	wlc->hw = (wlc_hw_info_t *)wlc_calloc(osh, unit,
+		sizeof(wlc_hw_info_t));
+	if (wlc->hw == NULL) {
 		*err = 1005;
 		goto fail;
 	}
 	wlc->hw->wlc = wlc;
 
 #ifdef WLC_LOW
-	if ((wlc->hw->bandstate[0] = (wlc_hwband_t *)
-	     wlc_calloc(osh, unit, (sizeof(wlc_hwband_t) * MAXBANDS))) == NULL) {
+	wlc->hw->bandstate[0] = (wlc_hwband_t *)wlc_calloc(osh, unit,
+		(sizeof(wlc_hwband_t) * MAXBANDS));
+	if (wlc->hw->bandstate[0] == NULL) {
 		*err = 1006;
 		goto fail;
 	} else {
@@ -213,67 +205,70 @@ wlc_info_t *BCMATTACHFN(wlc_attach_malloc) (osl_t * osh, uint unit, uint * err,
 
 		for (i = 1; i < MAXBANDS; i++) {
 			wlc->hw->bandstate[i] = (wlc_hwband_t *)
-			    ((uintptr) wlc->hw->bandstate[0] +
+			    ((unsigned long)wlc->hw->bandstate[0] +
 			     (sizeof(wlc_hwband_t) * i));
 		}
 	}
 #endif				/* WLC_LOW */
 
-	if ((wlc->modulecb = (modulecb_t *)
-	     wlc_calloc(osh, unit,
-			sizeof(modulecb_t) * WLC_MAXMODULES)) == NULL) {
+	wlc->modulecb = (modulecb_t *)wlc_calloc(osh, unit,
+		sizeof(modulecb_t) * WLC_MAXMODULES);
+	if (wlc->modulecb == NULL) {
 		*err = 1009;
 		goto fail;
 	}
 
-	if ((wlc->default_bss = (wlc_bss_info_t *)
-	     wlc_calloc(osh, unit, sizeof(wlc_bss_info_t))) == NULL) {
+	wlc->default_bss = (wlc_bss_info_t *)wlc_calloc(osh, unit,
+		sizeof(wlc_bss_info_t));
+	if (wlc->default_bss == NULL) {
 		*err = 1010;
 		goto fail;
 	}
 
-	if ((wlc->cfg = wlc_bsscfg_malloc(osh, unit)) == NULL) {
+	wlc->cfg = wlc_bsscfg_malloc(osh, unit);
+	if (wlc->cfg == NULL) {
 		*err = 1011;
 		goto fail;
 	}
 	wlc_bsscfg_ID_assign(wlc, wlc->cfg);
 
-	if ((wlc->pkt_callback = (pkt_cb_t *)
-	     wlc_calloc(osh, unit,
-			(sizeof(pkt_cb_t) *
-			 (wlc->pub->tunables->maxpktcb + 1)))) == NULL) {
+	wlc->pkt_callback = (pkt_cb_t *)wlc_calloc(osh, unit,
+		(sizeof(pkt_cb_t) * (wlc->pub->tunables->maxpktcb + 1)));
+	if (wlc->pkt_callback == NULL) {
 		*err = 1013;
 		goto fail;
 	}
 
-	if ((wlc->wsec_def_keys[0] = (wsec_key_t *)
-	     wlc_calloc(osh, unit,
-			(sizeof(wsec_key_t) * WLC_DEFAULT_KEYS))) == NULL) {
+	wlc->wsec_def_keys[0] = (wsec_key_t *)wlc_calloc(osh, unit,
+		(sizeof(wsec_key_t) * WLC_DEFAULT_KEYS));
+	if (wlc->wsec_def_keys[0] == NULL) {
 		*err = 1015;
 		goto fail;
 	} else {
 		int i;
 		for (i = 1; i < WLC_DEFAULT_KEYS; i++) {
 			wlc->wsec_def_keys[i] = (wsec_key_t *)
-			    ((uintptr) wlc->wsec_def_keys[0] +
+			    ((unsigned long)wlc->wsec_def_keys[0] +
 			     (sizeof(wsec_key_t) * i));
 		}
 	}
 
-	if ((wlc->protection = (wlc_protection_t *)
-	     wlc_calloc(osh, unit, sizeof(wlc_protection_t))) == NULL) {
+	wlc->protection = (wlc_protection_t *)wlc_calloc(osh, unit,
+		sizeof(wlc_protection_t));
+	if (wlc->protection == NULL) {
 		*err = 1016;
 		goto fail;
 	}
 
-	if ((wlc->stf = (wlc_stf_t *)
-	     wlc_calloc(osh, unit, sizeof(wlc_stf_t))) == NULL) {
+	wlc->stf = (wlc_stf_t *)wlc_calloc(osh, unit, sizeof(wlc_stf_t));
+	if (wlc->stf == NULL) {
 		*err = 1017;
 		goto fail;
 	}
 
-	if ((wlc->bandstate[0] = (wlcband_t *)
-	     wlc_calloc(osh, unit, (sizeof(wlcband_t) * MAXBANDS))) == NULL) {
+	wlc->bandstate[0] = (wlcband_t *)wlc_calloc(osh, unit,
+				(sizeof(wlcband_t) * MAXBANDS));
+	if (wlc->bandstate[0] == NULL) {
 		*err = 1025;
 		goto fail;
 	} else {
@@ -281,19 +276,20 @@ wlc_info_t *BCMATTACHFN(wlc_attach_malloc) (osl_t * osh, uint unit, uint * err,
 
 		for (i = 1; i < MAXBANDS; i++) {
 			wlc->bandstate[i] =
-			    (wlcband_t *) ((uintptr) wlc->bandstate[0] +
+			    (wlcband_t *) ((unsigned long)wlc->bandstate[0] +
 					   (sizeof(wlcband_t) * i));
 		}
 	}
 
-	if ((wlc->corestate = (wlccore_t *)
-	     wlc_calloc(osh, unit, sizeof(wlccore_t))) == NULL) {
+	wlc->corestate = (wlccore_t *)wlc_calloc(osh, unit, sizeof(wlccore_t));
+	if (wlc->corestate == NULL) {
 		*err = 1026;
 		goto fail;
 	}
 
-	if ((wlc->corestate->macstat_snapshot = (macstat_t *)
-	     wlc_calloc(osh, unit, sizeof(macstat_t))) == NULL) {
+	wlc->corestate->macstat_snapshot =
+		(macstat_t *)wlc_calloc(osh, unit, sizeof(macstat_t));
+	if (wlc->corestate->macstat_snapshot == NULL) {
 		*err = 1027;
 		goto fail;
 	}
@@ -305,17 +301,18 @@ wlc_info_t *BCMATTACHFN(wlc_attach_malloc) (osl_t * osh, uint unit, uint * err,
 	return NULL;
 }
 
-void BCMATTACHFN(wlc_detach_mfree) (wlc_info_t * wlc, osl_t * osh) {
+void wlc_detach_mfree(wlc_info_t *wlc, osl_t *osh)
+{
 	if (wlc == NULL)
 		return;
 
 	if (wlc->modulecb) {
-		MFREE(osh, wlc->modulecb, sizeof(modulecb_t) * WLC_MAXMODULES);
+		kfree(wlc->modulecb);
 		wlc->modulecb = NULL;
 	}
 
 	if (wlc->default_bss) {
-		MFREE(osh, wlc->default_bss, sizeof(wlc_bss_info_t));
+		kfree(wlc->default_bss);
 		wlc->default_bss = NULL;
 	}
 	if (wlc->cfg) {
@@ -324,36 +321,30 @@ void BCMATTACHFN(wlc_detach_mfree) (wlc_info_t * wlc, osl_t * osh) {
 	}
 
 	if (wlc->pkt_callback && wlc->pub && wlc->pub->tunables) {
-		MFREE(osh,
-		      wlc->pkt_callback,
-		      sizeof(pkt_cb_t) * (wlc->pub->tunables->maxpktcb + 1));
+		kfree(wlc->pkt_callback);
 		wlc->pkt_callback = NULL;
 	}
 
 	if (wlc->wsec_def_keys[0])
-		MFREE(osh, wlc->wsec_def_keys[0],
-		      (sizeof(wsec_key_t) * WLC_DEFAULT_KEYS));
-
+		kfree(wlc->wsec_def_keys[0]);
 	if (wlc->protection) {
-		MFREE(osh, wlc->protection, sizeof(wlc_protection_t));
+		kfree(wlc->protection);
 		wlc->protection = NULL;
 	}
 
 	if (wlc->stf) {
-		MFREE(osh, wlc->stf, sizeof(wlc_stf_t));
+		kfree(wlc->stf);
 		wlc->stf = NULL;
 	}
 
 	if (wlc->bandstate[0])
-		MFREE(osh, wlc->bandstate[0], (sizeof(wlcband_t) * MAXBANDS));
+		kfree(wlc->bandstate[0]);
 
 	if (wlc->corestate) {
 		if (wlc->corestate->macstat_snapshot) {
-			MFREE(osh, wlc->corestate->macstat_snapshot,
-			      sizeof(macstat_t));
-			wlc->corestate->macstat_snapshot = NULL;
+	kfree(wlc->corestate->macstat_snapshot);			wlc->corestate->macstat_snapshot = NULL;
 		}
-		MFREE(osh, wlc->corestate, sizeof(wlccore_t));
+		kfree(wlc->corestate);
 		wlc->corestate = NULL;
 	}
 
@@ -366,18 +357,17 @@ void BCMATTACHFN(wlc_detach_mfree) (wlc_info_t * wlc, osl_t * osh) {
 	if (wlc->hw) {
 #ifdef WLC_LOW
 		if (wlc->hw->bandstate[0]) {
-			MFREE(osh, wlc->hw->bandstate[0],
-			      (sizeof(wlc_hwband_t) * MAXBANDS));
+			kfree(wlc->hw->bandstate[0]);
 			wlc->hw->bandstate[0] = NULL;
 		}
 #endif
 
 		/* free hw struct */
-		MFREE(osh, wlc->hw, sizeof(wlc_hw_info_t));
+		kfree(wlc->hw);
 		wlc->hw = NULL;
 	}
 
 	/* free the wlc */
-	MFREE(osh, wlc, sizeof(wlc_info_t));
+	kfree(wlc);
 	wlc = NULL;
 }
diff --git a/drivers/staging/brcm80211/sys/wlc_alloc.h b/drivers/staging/brcm80211/sys/wlc_alloc.h
index fc923de..678a2b9 100644
--- a/drivers/staging/brcm80211/sys/wlc_alloc.h
+++ b/drivers/staging/brcm80211/sys/wlc_alloc.h
@@ -14,12 +14,12 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-extern void *wlc_calloc(osl_t * osh, uint unit, uint size);
+extern void *wlc_calloc(osl_t *osh, uint unit, uint size);
 
-extern wlc_info_t *wlc_attach_malloc(osl_t * osh, uint unit, uint * err,
+extern wlc_info_t *wlc_attach_malloc(osl_t *osh, uint unit, uint *err,
 				     uint devid);
-extern void wlc_detach_mfree(wlc_info_t * wlc, osl_t * osh);
+extern void wlc_detach_mfree(wlc_info_t *wlc, osl_t *osh);
 
 struct wlc_bsscfg;
-extern struct wlc_bsscfg *wlc_bsscfg_malloc(osl_t * osh, uint unit);
-extern void wlc_bsscfg_mfree(osl_t * osh, struct wlc_bsscfg *cfg);
+extern struct wlc_bsscfg *wlc_bsscfg_malloc(osl_t *osh, uint unit);
+extern void wlc_bsscfg_mfree(osl_t *osh, struct wlc_bsscfg *cfg);
diff --git a/drivers/staging/brcm80211/sys/wlc_ampdu.c b/drivers/staging/brcm80211/sys/wlc_ampdu.c
index d7071e5..a4e49f3 100644
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.c
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.c
@@ -13,24 +13,22 @@
  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
-
+#include <linux/kernel.h>
 #include <wlc_cfg.h>
-#include <typedefs.h>
+#include <bcmdefs.h>
+#include <linuxver.h>
 #include <bcmdefs.h>
 #include <osl.h>
 #include <bcmutils.h>
 #include <siutils.h>
 #include <bcmendian.h>
-#include <proto/802.11.h>
 #include <wlioctl.h>
-#include <sbhndpio.h>
 #include <sbhnddma.h>
 #include <hnddma.h>
 #include <d11.h>
 #include <wlc_rate.h>
 #include <wlc_pub.h>
 #include <wlc_key.h>
-#include <wlc_bsscfg.h>
 #include <wlc_mac80211.h>
 #include <wlc_phy_hal.h>
 #include <wlc_antsel.h>
@@ -69,14 +67,14 @@
 					 * accumulate between resets.
 					 */
 
-#define TX_SEQ_TO_INDEX(seq) (seq) % AMPDU_TX_BA_MAX_WSIZE
+#define TX_SEQ_TO_INDEX(seq) ((seq) % AMPDU_TX_BA_MAX_WSIZE)
 
 /* max possible overhead per mpdu in the ampdu; 3 is for roundup if needed */
 #define AMPDU_MAX_MPDU_OVERHEAD (DOT11_FCS_LEN + DOT11_ICV_AES_LEN + AMPDU_DELIMITER_LEN + 3 \
 	+ DOT11_A4_HDR_LEN + DOT11_QOS_LEN + DOT11_IV_MAX_LEN)
 
 #ifdef BCMDBG
-uint32 wl_ampdu_dbg =
+u32 wl_ampdu_dbg =
     WL_AMPDU_UPDN_VAL |
     WL_AMPDU_ERR_VAL |
     WL_AMPDU_TX_VAL |
@@ -92,37 +90,37 @@ uint32 wl_ampdu_dbg =
  * how often and/or when the wlc counters are updated.
  */
 typedef struct wlc_fifo_info {
-	uint16 ampdu_pld_size;	/* number of bytes to be pre-loaded */
-	uint8 mcs2ampdu_table[FFPLD_MAX_MCS + 1];	/* per-mcs max # of mpdus in an ampdu */
-	uint16 prev_txfunfl;	/* num of underflows last read from the HW macstats counter */
-	uint32 accum_txfunfl;	/* num of underflows since we modified pld params */
-	uint32 accum_txampdu;	/* num of tx ampdu since we modified pld params  */
-	uint32 prev_txampdu;	/* previous reading of tx ampdu */
-	uint32 dmaxferrate;	/* estimated dma avg xfer rate in kbits/sec */
+	u16 ampdu_pld_size;	/* number of bytes to be pre-loaded */
+	u8 mcs2ampdu_table[FFPLD_MAX_MCS + 1];	/* per-mcs max # of mpdus in an ampdu */
+	u16 prev_txfunfl;	/* num of underflows last read from the HW macstats counter */
+	u32 accum_txfunfl;	/* num of underflows since we modified pld params */
+	u32 accum_txampdu;	/* num of tx ampdu since we modified pld params  */
+	u32 prev_txampdu;	/* previous reading of tx ampdu */
+	u32 dmaxferrate;	/* estimated dma avg xfer rate in kbits/sec */
 } wlc_fifo_info_t;
 
 /* AMPDU module specific state */
 struct ampdu_info {
 	wlc_info_t *wlc;	/* pointer to main wlc structure */
 	int scb_handle;		/* scb cubby handle to retrieve data from scb */
-	uint8 ini_enable[AMPDU_MAX_SCB_TID];	/* per-tid initiator enable/disable of ampdu */
-	uint8 ba_tx_wsize;	/* Tx ba window size (in pdu) */
-	uint8 ba_rx_wsize;	/* Rx ba window size (in pdu) */
-	uint8 retry_limit;	/* mpdu transmit retry limit */
-	uint8 rr_retry_limit;	/* mpdu transmit retry limit at regular rate */
-	uint8 retry_limit_tid[AMPDU_MAX_SCB_TID];	/* per-tid mpdu transmit retry limit */
+	u8 ini_enable[AMPDU_MAX_SCB_TID];	/* per-tid initiator enable/disable of ampdu */
+	u8 ba_tx_wsize;	/* Tx ba window size (in pdu) */
+	u8 ba_rx_wsize;	/* Rx ba window size (in pdu) */
+	u8 retry_limit;	/* mpdu transmit retry limit */
+	u8 rr_retry_limit;	/* mpdu transmit retry limit at regular rate */
+	u8 retry_limit_tid[AMPDU_MAX_SCB_TID];	/* per-tid mpdu transmit retry limit */
 	/* per-tid mpdu transmit retry limit at regular rate */
-	uint8 rr_retry_limit_tid[AMPDU_MAX_SCB_TID];
-	uint8 mpdu_density;	/* min mpdu spacing (0-7) ==> 2^(x-1)/8 usec */
-	int8 max_pdu;		/* max pdus allowed in ampdu */
-	uint8 dur;		/* max duration of an ampdu (in msec) */
-	uint8 txpkt_weight;	/* weight of ampdu in txfifo; reduces rate lag */
-	uint8 rx_factor;	/* maximum rx ampdu factor (0-3) ==> 2^(13+x) bytes */
-	uint32 ffpld_rsvd;	/* number of bytes to reserve for preload */
-	uint32 max_txlen[MCS_TABLE_SIZE][2][2];	/* max size of ampdu per mcs, bw and sgi */
+	u8 rr_retry_limit_tid[AMPDU_MAX_SCB_TID];
+	u8 mpdu_density;	/* min mpdu spacing (0-7) ==> 2^(x-1)/8 usec */
+	s8 max_pdu;		/* max pdus allowed in ampdu */
+	u8 dur;		/* max duration of an ampdu (in msec) */
+	u8 txpkt_weight;	/* weight of ampdu in txfifo; reduces rate lag */
+	u8 rx_factor;	/* maximum rx ampdu factor (0-3) ==> 2^(13+x) bytes */
+	u32 ffpld_rsvd;	/* number of bytes to reserve for preload */
+	u32 max_txlen[MCS_TABLE_SIZE][2][2];	/* max size of ampdu per mcs, bw and sgi */
 	void *ini_free[AMPDU_INI_FREE];	/* array of ini's to be freed on detach */
 	bool mfbr;		/* enable multiple fallback rate */
-	uint32 tx_max_funl;	/* underflows should be kept such that
+	u32 tx_max_funl;	/* underflows should be kept such that
 				 * (tx_max_funfl*underflows) < tx frames
 				 */
 	wlc_fifo_info_t fifo_tb[NUM_FFPLD_FIFO];	/* table of fifo infos  */
@@ -140,68 +138,63 @@ struct ampdu_info {
 #define SCB_AMPDU_CUBBY(ampdu, scb) (&(scb->scb_ampdu))
 #define SCB_AMPDU_INI(scb_ampdu, tid) (&(scb_ampdu->ini[tid]))
 
-static void wlc_ffpld_init(ampdu_info_t * ampdu);
-static int wlc_ffpld_check_txfunfl(wlc_info_t * wlc, int f);
-static void wlc_ffpld_calc_mcs2ampdu_table(ampdu_info_t * ampdu, int f);
+static void wlc_ffpld_init(ampdu_info_t *ampdu);
+static int wlc_ffpld_check_txfunfl(wlc_info_t *wlc, int f);
+static void wlc_ffpld_calc_mcs2ampdu_table(ampdu_info_t *ampdu, int f);
 
-static scb_ampdu_tid_ini_t *wlc_ampdu_init_tid_ini(ampdu_info_t * ampdu,
-						   scb_ampdu_t * scb_ampdu,
-						   uint8 tid, bool override);
-static void ampdu_cleanup_tid_ini(ampdu_info_t * ampdu, scb_ampdu_t * scb_ampdu,
-				  uint8 tid, bool force);
-static void ampdu_update_max_txlen(ampdu_info_t * ampdu, uint8 dur);
-static void scb_ampdu_update_config(ampdu_info_t * ampdu, struct scb *scb);
-static void scb_ampdu_update_config_all(ampdu_info_t * ampdu);
+static scb_ampdu_tid_ini_t *wlc_ampdu_init_tid_ini(ampdu_info_t *ampdu,
+						   scb_ampdu_t *scb_ampdu,
+						   u8 tid, bool override);
+static void ampdu_cleanup_tid_ini(ampdu_info_t *ampdu, scb_ampdu_t *scb_ampdu,
+				  u8 tid, bool force);
+static void ampdu_update_max_txlen(ampdu_info_t *ampdu, u8 dur);
+static void scb_ampdu_update_config(ampdu_info_t *ampdu, struct scb *scb);
+static void scb_ampdu_update_config_all(ampdu_info_t *ampdu);
 
 #define wlc_ampdu_txflowcontrol(a, b, c)	do {} while (0)
 
-static void wlc_ampdu_dotxstatus_complete(ampdu_info_t * ampdu, struct scb *scb,
-					  void *p, tx_status_t * txs,
-					  uint32 frmtxstatus,
-					  uint32 frmtxstatus2);
+static void wlc_ampdu_dotxstatus_complete(ampdu_info_t *ampdu, struct scb *scb,
+					  void *p, tx_status_t *txs,
+					  u32 frmtxstatus,
+					  u32 frmtxstatus2);
 
-static INLINE uint16 pkt_txh_seqnum(wlc_info_t * wlc, void *p)
+static inline u16 pkt_txh_seqnum(wlc_info_t *wlc, void *p)
 {
 	d11txh_t *txh;
 	struct dot11_header *h;
 	txh = (d11txh_t *) PKTDATA(p);
-	h = (struct dot11_header *)((uint8 *) (txh + 1) + D11_PHY_HDR_LEN);
-	return (ltoh16(h->seq) >> SEQNUM_SHIFT);
+	h = (struct dot11_header *)((u8 *) (txh + 1) + D11_PHY_HDR_LEN);
+	return ltoh16(h->seq) >> SEQNUM_SHIFT;
 }
 
-ampdu_info_t *BCMATTACHFN(wlc_ampdu_attach) (wlc_info_t * wlc) {
+ampdu_info_t *wlc_ampdu_attach(wlc_info_t *wlc)
+{
 	ampdu_info_t *ampdu;
 	int i;
 
 	/* some code depends on packed structures */
-	ASSERT(sizeof(struct dot11_bar) == DOT11_BAR_LEN);
-	ASSERT(sizeof(struct dot11_ba) == DOT11_BA_LEN + DOT11_BA_BITMAP_LEN);
-	ASSERT(sizeof(struct dot11_ctl_header) == DOT11_CTL_HDR_LEN);
-	ASSERT(sizeof(struct dot11_addba_req) == DOT11_ADDBA_REQ_LEN);
-	ASSERT(sizeof(struct dot11_addba_resp) == DOT11_ADDBA_RESP_LEN);
-	ASSERT(sizeof(struct dot11_delba) == DOT11_DELBA_LEN);
-	ASSERT(DOT11_MAXNUMFRAGS == NBITS(uint16));
+	ASSERT(DOT11_MAXNUMFRAGS == NBITS(u16));
 	ASSERT(ISPOWEROF2(AMPDU_TX_BA_MAX_WSIZE));
 	ASSERT(ISPOWEROF2(AMPDU_RX_BA_MAX_WSIZE));
 	ASSERT(wlc->pub->tunables->ampdunummpdu <= AMPDU_MAX_MPDU);
 	ASSERT(wlc->pub->tunables->ampdunummpdu > 0);
 
-	if (!(ampdu = (ampdu_info_t *) MALLOC(wlc->osh, sizeof(ampdu_info_t)))) {
-		WL_ERROR(("wl%d: wlc_ampdu_attach: out of mem, malloced %d bytes\n", wlc->pub->unit, MALLOCED(wlc->osh)));
+	ampdu = kzalloc(sizeof(ampdu_info_t), GFP_ATOMIC);
+	if (!ampdu) {
+		WL_ERROR(("wl%d: wlc_ampdu_attach: out of mem\n", wlc->pub->unit));
 		return NULL;
 	}
-	bzero((char *)ampdu, sizeof(ampdu_info_t));
 	ampdu->wlc = wlc;
 
 	for (i = 0; i < AMPDU_MAX_SCB_TID; i++)
-		ampdu->ini_enable[i] = TRUE;
+		ampdu->ini_enable[i] = true;
 	/* Disable ampdu for VO by default */
-	ampdu->ini_enable[PRIO_8021D_VO] = FALSE;
-	ampdu->ini_enable[PRIO_8021D_NC] = FALSE;
+	ampdu->ini_enable[PRIO_8021D_VO] = false;
+	ampdu->ini_enable[PRIO_8021D_NC] = false;
 
 	/* Disable ampdu for BK by default since not enough fifo space */
-	ampdu->ini_enable[PRIO_8021D_NONE] = FALSE;
-	ampdu->ini_enable[PRIO_8021D_BK] = FALSE;
+	ampdu->ini_enable[PRIO_8021D_NONE] = false;
+	ampdu->ini_enable[PRIO_8021D_BK] = false;
 
 	ampdu->ba_tx_wsize = AMPDU_TX_BA_DEF_WSIZE;
 	ampdu->ba_rx_wsize = AMPDU_RX_BA_DEF_WSIZE;
@@ -229,7 +222,7 @@ ampdu_info_t *BCMATTACHFN(wlc_ampdu_attach) (wlc_info_t * wlc) {
 	}
 
 	ampdu_update_max_txlen(ampdu, ampdu->dur);
-	ampdu->mfbr = FALSE;
+	ampdu->mfbr = false;
 	/* try to set ampdu to the default value */
 	wlc_ampdu_set(ampdu, wlc->pub->_ampdu);
 
@@ -239,7 +232,8 @@ ampdu_info_t *BCMATTACHFN(wlc_ampdu_attach) (wlc_info_t * wlc) {
 	return ampdu;
 }
 
-void BCMATTACHFN(wlc_ampdu_detach) (ampdu_info_t * ampdu) {
+void wlc_ampdu_detach(ampdu_info_t *ampdu)
+{
 	int i;
 
 	if (!ampdu)
@@ -248,42 +242,41 @@ void BCMATTACHFN(wlc_ampdu_detach) (ampdu_info_t * ampdu) {
 	/* free all ini's which were to be freed on callbacks which were never called */
 	for (i = 0; i < AMPDU_INI_FREE; i++) {
 		if (ampdu->ini_free[i]) {
-			MFREE(ampdu->wlc->osh, ampdu->ini_free[i],
-			      sizeof(scb_ampdu_tid_ini_t));
+			kfree(ampdu->ini_free[i]);
 		}
 	}
 
 	wlc_module_unregister(ampdu->wlc->pub, "ampdu", ampdu);
-	MFREE(ampdu->wlc->osh, ampdu, sizeof(ampdu_info_t));
+	kfree(ampdu);
 }
 
-void scb_ampdu_cleanup(ampdu_info_t * ampdu, struct scb *scb)
+void scb_ampdu_cleanup(ampdu_info_t *ampdu, struct scb *scb)
 {
 	scb_ampdu_t *scb_ampdu = SCB_AMPDU_CUBBY(ampdu, scb);
-	uint8 tid;
+	u8 tid;
 
 	WL_AMPDU_UPDN(("scb_ampdu_cleanup: enter\n"));
 	ASSERT(scb_ampdu);
 
 	for (tid = 0; tid < AMPDU_MAX_SCB_TID; tid++) {
-		ampdu_cleanup_tid_ini(ampdu, scb_ampdu, tid, FALSE);
+		ampdu_cleanup_tid_ini(ampdu, scb_ampdu, tid, false);
 	}
 }
 
 /* reset the ampdu state machine so that it can gracefully handle packets that were
  * freed from the dma and tx queues during reinit
  */
-void wlc_ampdu_reset(ampdu_info_t * ampdu)
+void wlc_ampdu_reset(ampdu_info_t *ampdu)
 {
 	WL_NONE(("%s: Entering\n", __func__));
 }
 
-static void scb_ampdu_update_config(ampdu_info_t * ampdu, struct scb *scb)
+static void scb_ampdu_update_config(ampdu_info_t *ampdu, struct scb *scb)
 {
 	scb_ampdu_t *scb_ampdu = SCB_AMPDU_CUBBY(ampdu, scb);
 	int i;
 
-	scb_ampdu->max_pdu = (uint8) ampdu->wlc->pub->tunables->ampdunummpdu;
+	scb_ampdu->max_pdu = (u8) ampdu->wlc->pub->tunables->ampdunummpdu;
 
 	/* go back to legacy size if some preloading is occuring */
 	for (i = 0; i < NUM_FFPLD_FIFO; i++) {
@@ -293,27 +286,27 @@ static void scb_ampdu_update_config(ampdu_info_t * ampdu, struct scb *scb)
 
 	/* apply user override */
 	if (ampdu->max_pdu != AUTO)
-		scb_ampdu->max_pdu = (uint8) ampdu->max_pdu;
+		scb_ampdu->max_pdu = (u8) ampdu->max_pdu;
 
-	scb_ampdu->release = MIN(scb_ampdu->max_pdu, AMPDU_SCB_MAX_RELEASE);
+	scb_ampdu->release = min_t(u8, scb_ampdu->max_pdu, AMPDU_SCB_MAX_RELEASE);
 
 	if (scb_ampdu->max_rxlen)
 		scb_ampdu->release =
-		    MIN(scb_ampdu->release, scb_ampdu->max_rxlen / 1600);
+		    min_t(u8, scb_ampdu->release, scb_ampdu->max_rxlen / 1600);
 
-	scb_ampdu->release = MIN(scb_ampdu->release,
+	scb_ampdu->release = min(scb_ampdu->release,
 				 ampdu->fifo_tb[TX_AC_BE_FIFO].
 				 mcs2ampdu_table[FFPLD_MAX_MCS]);
 
 	ASSERT(scb_ampdu->release);
 }
 
-void scb_ampdu_update_config_all(ampdu_info_t * ampdu)
+void scb_ampdu_update_config_all(ampdu_info_t *ampdu)
 {
 	scb_ampdu_update_config(ampdu, ampdu->wlc->pub->global_scb);
 }
 
-static void wlc_ffpld_init(ampdu_info_t * ampdu)
+static void wlc_ffpld_init(ampdu_info_t *ampdu)
 {
 	int i, j;
 	wlc_fifo_info_t *fifo;
@@ -337,24 +330,24 @@ static void wlc_ffpld_init(ampdu_info_t * ampdu)
  * Return 1 if pre-loading not active, -1 if not an underflow event,
  * 0 if pre-loading module took care of the event.
  */
-static int wlc_ffpld_check_txfunfl(wlc_info_t * wlc, int fid)
+static int wlc_ffpld_check_txfunfl(wlc_info_t *wlc, int fid)
 {
 	ampdu_info_t *ampdu = wlc->ampdu;
-	uint32 phy_rate = MCS_RATE(FFPLD_MAX_MCS, TRUE, FALSE);
-	uint32 txunfl_ratio;
-	uint8 max_mpdu;
-	uint32 current_ampdu_cnt = 0;
-	uint16 max_pld_size;
-	uint32 new_txunfl;
+	u32 phy_rate = MCS_RATE(FFPLD_MAX_MCS, true, false);
+	u32 txunfl_ratio;
+	u8 max_mpdu;
+	u32 current_ampdu_cnt = 0;
+	u16 max_pld_size;
+	u32 new_txunfl;
 	wlc_fifo_info_t *fifo = (ampdu->fifo_tb + fid);
 	uint xmtfifo_sz;
-	uint16 cur_txunfl;
+	u16 cur_txunfl;
 
 	/* return if we got here for a different reason than underflows */
 	cur_txunfl =
 	    wlc_read_shm(wlc,
-			 M_UCODE_MACSTAT + OFFSETOF(macstat_t, txfunfl[fid]));
-	new_txunfl = (uint16) (cur_txunfl - fifo->prev_txfunfl);
+			 M_UCODE_MACSTAT + offsetof(macstat_t, txfunfl[fid]));
+	new_txunfl = (u16) (cur_txunfl - fifo->prev_txfunfl);
 	if (new_txunfl == 0) {
 		WL_FFPLD(("check_txunfl : TX status FRAG set but no tx underflows\n"));
 		return -1;
@@ -370,7 +363,7 @@ static int wlc_ffpld_check_txfunfl(wlc_info_t * wlc, int fid)
 		return -1;
 	}
 
-	if ((TXFIFO_SIZE_UNIT * (uint32) xmtfifo_sz) <= ampdu->ffpld_rsvd)
+	if ((TXFIFO_SIZE_UNIT * (u32) xmtfifo_sz) <= ampdu->ffpld_rsvd)
 		return 1;
 
 	max_pld_size = TXFIFO_SIZE_UNIT * xmtfifo_sz - ampdu->ffpld_rsvd;
@@ -401,7 +394,7 @@ static int wlc_ffpld_check_txfunfl(wlc_info_t * wlc, int fid)
 		return 0;
 	}
 	max_mpdu =
-	    MIN(fifo->mcs2ampdu_table[FFPLD_MAX_MCS], AMPDU_NUM_MPDU_LEGACY);
+	    min_t(u8, fifo->mcs2ampdu_table[FFPLD_MAX_MCS], AMPDU_NUM_MPDU_LEGACY);
 
 	/* In case max value max_pdu is already lower than
 	   the fifo depth, there is nothing more we can do.
@@ -457,18 +450,18 @@ static int wlc_ffpld_check_txfunfl(wlc_info_t * wlc, int fid)
 	return 0;
 }
 
-static void wlc_ffpld_calc_mcs2ampdu_table(ampdu_info_t * ampdu, int f)
+static void wlc_ffpld_calc_mcs2ampdu_table(ampdu_info_t *ampdu, int f)
 {
 	int i;
-	uint32 phy_rate, dma_rate, tmp;
-	uint8 max_mpdu;
+	u32 phy_rate, dma_rate, tmp;
+	u8 max_mpdu;
 	wlc_fifo_info_t *fifo = (ampdu->fifo_tb + f);
 
 	/* recompute the dma rate */
 	/* note : we divide/multiply by 100 to avoid integer overflows */
 	max_mpdu =
-	    MIN(fifo->mcs2ampdu_table[FFPLD_MAX_MCS], AMPDU_NUM_MPDU_LEGACY);
-	phy_rate = MCS_RATE(FFPLD_MAX_MCS, TRUE, FALSE);
+	    min_t(u8, fifo->mcs2ampdu_table[FFPLD_MAX_MCS], AMPDU_NUM_MPDU_LEGACY);
+	phy_rate = MCS_RATE(FFPLD_MAX_MCS, true, false);
 	dma_rate =
 	    (((phy_rate / 100) *
 	      (max_mpdu * FFPLD_MPDU_SIZE - fifo->ampdu_pld_size))
@@ -479,67 +472,67 @@ static void wlc_ffpld_calc_mcs2ampdu_table(ampdu_info_t * ampdu, int f)
 	dma_rate = dma_rate >> 7;
 	for (i = 0; i < FFPLD_MAX_MCS; i++) {
 		/* shifting to keep it within integer range */
-		phy_rate = MCS_RATE(i, TRUE, FALSE) >> 7;
+		phy_rate = MCS_RATE(i, true, false) >> 7;
 		if (phy_rate > dma_rate) {
 			tmp = ((fifo->ampdu_pld_size * phy_rate) /
 			       ((phy_rate - dma_rate) * FFPLD_MPDU_SIZE)) + 1;
-			tmp = MIN(tmp, 255);
-			fifo->mcs2ampdu_table[i] = (uint8) tmp;
+			tmp = min_t(u32, tmp, 255);
+			fifo->mcs2ampdu_table[i] = (u8) tmp;
 		}
 	}
 }
 
 static void BCMFASTPATH
-wlc_ampdu_agg(ampdu_info_t * ampdu, struct scb *scb, void *p, uint prec)
+wlc_ampdu_agg(ampdu_info_t *ampdu, struct scb *scb, void *p, uint prec)
 {
 	scb_ampdu_t *scb_ampdu;
 	scb_ampdu_tid_ini_t *ini;
-	uint8 tid = (uint8) PKTPRIO(p);
+	u8 tid = (u8) PKTPRIO(p);
 
 	scb_ampdu = SCB_AMPDU_CUBBY(ampdu, scb);
 
 	/* initialize initiator on first packet; sends addba req */
 	ini = SCB_AMPDU_INI(scb_ampdu, tid);
 	if (ini->magic != INI_MAGIC) {
-		ini = wlc_ampdu_init_tid_ini(ampdu, scb_ampdu, tid, FALSE);
+		ini = wlc_ampdu_init_tid_ini(ampdu, scb_ampdu, tid, false);
 	}
 	return;
 }
 
 int BCMFASTPATH
-wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
+wlc_sendampdu(ampdu_info_t *ampdu, wlc_txq_info_t *qi, void **pdu, int prec)
 {
 	wlc_info_t *wlc;
 	osl_t *osh;
 	void *p, *pkt[AMPDU_MAX_MPDU];
-	uint8 tid, ndelim;
+	u8 tid, ndelim;
 	int err = 0;
-	uint8 preamble_type = WLC_GF_PREAMBLE;
-	uint8 fbr_preamble_type = WLC_GF_PREAMBLE;
-	uint8 rts_preamble_type = WLC_LONG_PREAMBLE;
-	uint8 rts_fbr_preamble_type = WLC_LONG_PREAMBLE;
+	u8 preamble_type = WLC_GF_PREAMBLE;
+	u8 fbr_preamble_type = WLC_GF_PREAMBLE;
+	u8 rts_preamble_type = WLC_LONG_PREAMBLE;
+	u8 rts_fbr_preamble_type = WLC_LONG_PREAMBLE;
 
-	bool rr = TRUE, fbr = FALSE;
+	bool rr = true, fbr = false;
 	uint i, count = 0, fifo, seg_cnt = 0;
-	uint16 plen, len, seq = 0, mcl, mch, index, frameid, dma_len = 0;
-	uint32 ampdu_len, maxlen = 0;
+	u16 plen, len, seq = 0, mcl, mch, index, frameid, dma_len = 0;
+	u32 ampdu_len, maxlen = 0;
 	d11txh_t *txh = NULL;
-	uint8 *plcp;
+	u8 *plcp;
 	struct dot11_header *h;
 	struct scb *scb;
 	scb_ampdu_t *scb_ampdu;
 	scb_ampdu_tid_ini_t *ini;
-	uint8 mcs = 0;
-	bool use_rts = FALSE, use_cts = FALSE;
+	u8 mcs = 0;
+	bool use_rts = false, use_cts = false;
 	ratespec_t rspec = 0, rspec_fallback = 0;
 	ratespec_t rts_rspec = 0, rts_rspec_fallback = 0;
-	uint16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;
+	u16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;
 	struct dot11_rts_frame *rts;
-	uint8 rr_retry_limit;
+	u8 rr_retry_limit;
 	wlc_fifo_info_t *f;
 	bool fbr_iscck;
 	struct ieee80211_tx_info *tx_info;
-	uint16 qlen;
+	u16 qlen;
 
 	wlc = ampdu->wlc;
 	osh = wlc->osh;
@@ -547,7 +540,7 @@ wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
 
 	ASSERT(p);
 
-	tid = (uint8) PKTPRIO(p);
+	tid = (u8) PKTPRIO(p);
 	ASSERT(tid < AMPDU_MAX_SCB_TID);
 
 	f = ampdu->fifo_tb + prio2fifo[tid];
@@ -608,7 +601,7 @@ wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
 		/* pkt is good to be aggregated */
 		ASSERT(tx_info->flags & IEEE80211_TX_CTL_AMPDU);
 		txh = (d11txh_t *) PKTDATA(p);
-		plcp = (uint8 *) (txh + 1);
+		plcp = (u8 *) (txh + 1);
 		h = (struct dot11_header *)(plcp + D11_PHY_HDR_LEN);
 		seq = ltoh16(h->seq) >> SEQNUM_SHIFT;
 		index = TX_SEQ_TO_INDEX(seq);
@@ -623,12 +616,12 @@ wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
 		/*  Handle retry limits */
 		if (txrate[0].count <= rr_retry_limit) {
 			txrate[0].count++;
-			rr = TRUE;
-			fbr = FALSE;
+			rr = true;
+			fbr = false;
 			ASSERT(!fbr);
 		} else {
-			fbr = TRUE;
-			rr = FALSE;
+			fbr = true;
+			rr = false;
 			txrate[1].count++;
 		}
 
@@ -648,7 +641,7 @@ wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
 		 * test whether need to break or change the epoch
 		 */
 		if (count == 0) {
-			uint16 fc;
+			u16 fc;
 			mcl |= (TXC_AMPDU_FIRST << TXC_AMPDU_SHIFT);
 			/* refill the bits since might be a retx mpdu */
 			mcl |= TXC_STARTMSDU;
@@ -656,21 +649,21 @@ wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
 			fc = ltoh16(rts->fc);
 			if ((fc & FC_KIND_MASK) == FC_RTS) {
 				mcl |= TXC_SENDRTS;
-				use_rts = TRUE;
+				use_rts = true;
 			}
 			if ((fc & FC_KIND_MASK) == FC_CTS) {
 				mcl |= TXC_SENDCTS;
-				use_cts = TRUE;
+				use_cts = true;
 			}
 		} else {
 			mcl |= (TXC_AMPDU_MIDDLE << TXC_AMPDU_SHIFT);
 			mcl &= ~(TXC_STARTMSDU | TXC_SENDRTS | TXC_SENDCTS);
 		}
 
-		len = ROUNDUP(len, 4);
+		len = roundup(len, 4);
 		ampdu_len += (len + (ndelim + 1) * AMPDU_DELIMITER_LEN);
 
-		dma_len += (uint16) pkttotlen(osh, p);
+		dma_len += (u16) pkttotlen(osh, p);
 
 		WL_AMPDU_TX(("wl%d: wlc_sendampdu: ampdu_len %d seg_cnt %d null delim %d\n", wlc->pub->unit, ampdu_len, seg_cnt, ndelim));
 
@@ -681,7 +674,7 @@ wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
 
 		/* patch the first MPDU */
 		if (count == 1) {
-			uint8 plcp0, plcp3, is40, sgi;
+			u8 plcp0, plcp3, is40, sgi;
 			struct ieee80211_sta *sta;
 
 			sta = tx_info->control.sta;
@@ -699,7 +692,7 @@ wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
 			mcs = plcp0 & ~MIMO_PLCP_40MHZ;
 			ASSERT(mcs < MCS_TABLE_SIZE);
 			maxlen =
-			    MIN(scb_ampdu->max_rxlen,
+			    min(scb_ampdu->max_rxlen,
 				ampdu->max_txlen[mcs][is40][sgi]);
 
 			WL_NONE(("sendampdu: sgi %d, is40 %d, mcs %d\n", sgi,
@@ -734,17 +727,17 @@ wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
 
 			if (use_rts || use_cts) {
 				rts_rspec =
-				    wlc_rspec_to_rts_rspec(wlc, rspec, FALSE,
+				    wlc_rspec_to_rts_rspec(wlc, rspec, false,
 							   mimo_ctlchbw);
 				rts_rspec_fallback =
 				    wlc_rspec_to_rts_rspec(wlc, rspec_fallback,
-							   FALSE, mimo_ctlchbw);
+							   false, mimo_ctlchbw);
 			}
 		}
 
 		/* if (first mpdu for host agg) */
 		/* test whether to add more */
-		if ((MCS_RATE(mcs, TRUE, FALSE) >= f->dmaxferrate) &&
+		if ((MCS_RATE(mcs, true, false) >= f->dmaxferrate) &&
 		    (count == f->mcs2ampdu_table[mcs])) {
 			WL_AMPDU_ERR(("wl%d: PR 37644: stopping ampdu at %d for mcs %d", wlc->pub->unit, count, mcs));
 			break;
@@ -762,11 +755,11 @@ wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
 
 		if (p) {
 			if ((tx_info->flags & IEEE80211_TX_CTL_AMPDU) &&
-			    ((uint8) PKTPRIO(p) == tid)) {
+			    ((u8) PKTPRIO(p) == tid)) {
 
 				plen =
 				    pkttotlen(osh, p) + AMPDU_MAX_MPDU_OVERHEAD;
-				plen = MAX(scb_ampdu->min_len, plen);
+				plen = max(scb_ampdu->min_len, plen);
 
 				if ((plen + ampdu_len) > maxlen) {
 					p = NULL;
@@ -811,11 +804,11 @@ wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
 		fbr_iscck = ((ltoh16(txh->XtraFrameTypes) & 0x3) == 0);
 		len = fbr_iscck ? WLC_GET_CCK_PLCP_LEN(txh->FragPLCPFallback)
 		    : WLC_GET_MIMO_PLCP_LEN(txh->FragPLCPFallback);
-		ampdu_len -= ROUNDUP(len, 4) - len;
+		ampdu_len -= roundup(len, 4) - len;
 
 		/* patch up the first txh & plcp */
 		txh = (d11txh_t *) PKTDATA(pkt[0]);
-		plcp = (uint8 *) (txh + 1);
+		plcp = (u8 *) (txh + 1);
 
 		WLC_SET_MIMO_PLCP_LEN(plcp, ampdu_len);
 		/* mark plcp to indicate ampdu */
@@ -823,21 +816,21 @@ wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
 
 		/* reset the mixed mode header durations */
 		if (txh->MModeLen) {
-			uint16 mmodelen =
+			u16 mmodelen =
 			    wlc_calc_lsig_len(wlc, rspec, ampdu_len);
 			txh->MModeLen = htol16(mmodelen);
 			preamble_type = WLC_MM_PREAMBLE;
 		}
 		if (txh->MModeFbrLen) {
-			uint16 mmfbrlen =
+			u16 mmfbrlen =
 			    wlc_calc_lsig_len(wlc, rspec_fallback, ampdu_len);
 			txh->MModeFbrLen = htol16(mmfbrlen);
 			fbr_preamble_type = WLC_MM_PREAMBLE;
 		}
 
 		/* set the preload length */
-		if (MCS_RATE(mcs, TRUE, FALSE) >= f->dmaxferrate) {
-			dma_len = MIN(dma_len, f->ampdu_pld_size);
+		if (MCS_RATE(mcs, true, false) >= f->dmaxferrate) {
+			dma_len = min(dma_len, f->ampdu_pld_size);
 			txh->PreloadSize = htol16(dma_len);
 		} else
 			txh->PreloadSize = 0;
@@ -846,7 +839,7 @@ wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
 
 		/* update RTS dur fields */
 		if (use_rts || use_cts) {
-			uint16 durid;
+			u16 durid;
 			rts = (struct dot11_rts_frame *)&txh->rts_frame;
 			if ((mch & TXC_PREAMBLE_RTS_MAIN_SHORT) ==
 			    TXC_PREAMBLE_RTS_MAIN_SHORT)
@@ -860,14 +853,14 @@ wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
 			    wlc_compute_rtscts_dur(wlc, use_cts, rts_rspec,
 						   rspec, rts_preamble_type,
 						   preamble_type, ampdu_len,
-						   TRUE);
+						   true);
 			rts->durid = htol16(durid);
 			durid = wlc_compute_rtscts_dur(wlc, use_cts,
 						       rts_rspec_fallback,
 						       rspec_fallback,
 						       rts_fbr_preamble_type,
 						       fbr_preamble_type,
-						       ampdu_len, TRUE);
+						       ampdu_len, true);
 			txh->RTSDurFallback = htol16(durid);
 			/* set TxFesTimeNormal */
 			txh->TxFesTimeNormal = rts->durid;
@@ -896,7 +889,7 @@ wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
 #ifdef WLC_HIGH_ONLY
 		if (wlc->rpc_agg & BCM_RPC_TP_HOST_AGG_AMPDU)
 			bcm_rpc_tp_agg_set(bcm_rpc_tp_get(wlc->rpc),
-					   BCM_RPC_TP_HOST_AGG_AMPDU, TRUE);
+					   BCM_RPC_TP_HOST_AGG_AMPDU, true);
 #endif
 		for (i = 0; i < count; i++)
 			wlc_txfifo(wlc, fifo, pkt[i], i == (count - 1),
@@ -904,7 +897,7 @@ wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
 #ifdef WLC_HIGH_ONLY
 		if (wlc->rpc_agg & BCM_RPC_TP_HOST_AGG_AMPDU)
 			bcm_rpc_tp_agg_set(bcm_rpc_tp_get(wlc->rpc),
-					   BCM_RPC_TP_HOST_AGG_AMPDU, FALSE);
+					   BCM_RPC_TP_HOST_AGG_AMPDU, false);
 #endif
 
 	}
@@ -913,13 +906,13 @@ wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
 }
 
 void BCMFASTPATH
-wlc_ampdu_dotxstatus(ampdu_info_t * ampdu, struct scb *scb, void *p,
-		     tx_status_t * txs)
+wlc_ampdu_dotxstatus(ampdu_info_t *ampdu, struct scb *scb, void *p,
+		     tx_status_t *txs)
 {
 	scb_ampdu_t *scb_ampdu;
 	wlc_info_t *wlc = ampdu->wlc;
 	scb_ampdu_tid_ini_t *ini;
-	uint32 s1 = 0, s2 = 0;
+	u32 s1 = 0, s2 = 0;
 	struct ieee80211_tx_info *tx_info;
 
 	tx_info = IEEE80211_SKB_CB(p);
@@ -938,13 +931,13 @@ wlc_ampdu_dotxstatus(ampdu_info_t * ampdu, struct scb *scb, void *p,
 	 */
 	if (txs->status & TX_STATUS_ACK_RCV) {
 #ifdef WLC_LOW
-		uint8 status_delay = 0;
+		u8 status_delay = 0;
 
 		/* wait till the next 8 bytes of txstatus is available */
 		while (((s1 =
 			 R_REG(wlc->osh,
 			       &wlc->regs->frmtxstatus)) & TXS_V) == 0) {
-			OSL_DELAY(1);
+			udelay(1);
 			status_delay++;
 			if (status_delay > 10) {
 				ASSERT(status_delay <= 10);
@@ -964,7 +957,7 @@ wlc_ampdu_dotxstatus(ampdu_info_t * ampdu, struct scb *scb, void *p,
 		ASSERT(!ampdu->p);
 		ampdu->p = p;
 		bcopy(txs, &ampdu->txs, sizeof(tx_status_t));
-		ampdu->waiting_status = TRUE;
+		ampdu->waiting_status = true;
 		return;
 #endif				/* WLC_LOW */
 	}
@@ -974,7 +967,7 @@ wlc_ampdu_dotxstatus(ampdu_info_t * ampdu, struct scb *scb, void *p,
 }
 
 #ifdef WLC_HIGH_ONLY
-void wlc_ampdu_txstatus_complete(ampdu_info_t * ampdu, uint32 s1, uint32 s2)
+void wlc_ampdu_txstatus_complete(ampdu_info_t *ampdu, u32 s1, u32 s2)
 {
 	WL_AMPDU_TX(("wl%d: wlc_ampdu_txstatus_complete: High Recvd 0x%x 0x%x p:%p\n", ampdu->wlc->pub->unit, s1, s2, ampdu->p));
 
@@ -995,15 +988,15 @@ void wlc_ampdu_txstatus_complete(ampdu_info_t * ampdu, uint32 s1, uint32 s2)
 		ampdu->p = NULL;
 	}
 
-	ampdu->waiting_status = FALSE;
+	ampdu->waiting_status = false;
 }
 #endif				/* WLC_HIGH_ONLY */
-void rate_status(wlc_info_t * wlc, struct ieee80211_tx_info *tx_info,
-		 tx_status_t * txs, uint8 mcs);
+void rate_status(wlc_info_t *wlc, struct ieee80211_tx_info *tx_info,
+		 tx_status_t *txs, u8 mcs);
 
 void
-rate_status(wlc_info_t * wlc, struct ieee80211_tx_info *tx_info,
-	    tx_status_t * txs, uint8 mcs)
+rate_status(wlc_info_t *wlc, struct ieee80211_tx_info *tx_info,
+	    tx_status_t *txs, u8 mcs)
 {
 	struct ieee80211_tx_rate *txrate = tx_info->status.rates;
 	int i;
@@ -1015,35 +1008,35 @@ rate_status(wlc_info_t * wlc, struct ieee80211_tx_info *tx_info,
 	}
 }
 
-extern void wlc_txq_enq(wlc_info_t * wlc, struct scb *scb, void *sdu,
+extern void wlc_txq_enq(wlc_info_t *wlc, struct scb *scb, void *sdu,
 			uint prec);
 
 #define SHORTNAME "AMPDU status"
 
 static void BCMFASTPATH
-wlc_ampdu_dotxstatus_complete(ampdu_info_t * ampdu, struct scb *scb, void *p,
-			      tx_status_t * txs, uint32 s1, uint32 s2)
+wlc_ampdu_dotxstatus_complete(ampdu_info_t *ampdu, struct scb *scb, void *p,
+			      tx_status_t *txs, u32 s1, u32 s2)
 {
 	scb_ampdu_t *scb_ampdu;
 	wlc_info_t *wlc = ampdu->wlc;
 	scb_ampdu_tid_ini_t *ini;
-	uint8 bitmap[8], queue, tid;
+	u8 bitmap[8], queue, tid;
 	d11txh_t *txh;
-	uint8 *plcp;
+	u8 *plcp;
 	struct dot11_header *h;
-	uint16 seq, start_seq = 0, bindex, index, mcl;
-	uint8 mcs = 0;
-	bool ba_recd = FALSE, ack_recd = FALSE;
-	uint8 suc_mpdu = 0, tot_mpdu = 0;
+	u16 seq, start_seq = 0, bindex, index, mcl;
+	u8 mcs = 0;
+	bool ba_recd = false, ack_recd = false;
+	u8 suc_mpdu = 0, tot_mpdu = 0;
 	uint supr_status;
-	bool update_rate = TRUE, retry = TRUE, tx_error = FALSE;
-	uint16 mimoantsel = 0;
-	uint8 antselid = 0;
-	uint8 retry_limit, rr_retry_limit;
+	bool update_rate = true, retry = true, tx_error = false;
+	u16 mimoantsel = 0;
+	u8 antselid = 0;
+	u8 retry_limit, rr_retry_limit;
 	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(p);
 
 #ifdef BCMDBG
-	uint8 hole[AMPDU_MAX_MPDU];
+	u8 hole[AMPDU_MAX_MPDU];
 	bzero(hole, sizeof(hole));
 #endif
 
@@ -1053,7 +1046,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info_t * ampdu, struct scb *scb, void *p,
 	scb_ampdu = SCB_AMPDU_CUBBY(ampdu, scb);
 	ASSERT(scb_ampdu);
 
-	tid = (uint8) PKTPRIO(p);
+	tid = (u8) PKTPRIO(p);
 
 	ini = SCB_AMPDU_INI(scb_ampdu, tid);
 	retry_limit = ampdu->retry_limit_tid[tid];
@@ -1069,7 +1062,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info_t * ampdu, struct scb *scb, void *p,
 
 	if (txs->status & TX_STATUS_ACK_RCV) {
 		if (TX_STATUS_SUPR_UF == supr_status) {
-			update_rate = FALSE;
+			update_rate = false;
 		}
 
 		ASSERT(txs->status & TX_STATUS_INTERMEDIATE);
@@ -1092,11 +1085,11 @@ wlc_ampdu_dotxstatus_complete(ampdu_info_t * ampdu, struct scb *scb, void *p,
 		bitmap[6] = (s2 >> 16) & 0xff;
 		bitmap[7] = (s2 >> 24) & 0xff;
 
-		ba_recd = TRUE;
+		ba_recd = true;
 	} else {
 		WLCNTINCR(ampdu->cnt->noba);
 		if (supr_status) {
-			update_rate = FALSE;
+			update_rate = false;
 			if (supr_status == TX_STATUS_SUPR_BADCH) {
 				WL_ERROR(("%s: Pkt tx suppressed, illegal channel possibly %d\n", __func__, CHSPEC_CHANNEL(wlc->default_bss->chanspec)));
 			} else {
@@ -1109,7 +1102,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info_t * ampdu, struct scb *scb, void *p,
 			/* no need to retry for badch; will fail again */
 			if (supr_status == TX_STATUS_SUPR_BADCH ||
 			    supr_status == TX_STATUS_SUPR_EXPTIME) {
-				retry = FALSE;
+				retry = false;
 				WLCNTINCR(wlc->pub->_cnt->txchanrej);
 			} else if (supr_status == TX_STATUS_SUPR_EXPTIME) {
 
@@ -1122,7 +1115,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info_t * ampdu, struct scb *scb, void *p,
 				 */
 				if (wlc_ffpld_check_txfunfl(wlc, prio2fifo[tid])
 				    > 0) {
-					tx_error = TRUE;
+					tx_error = true;
 #ifdef WLC_HIGH_ONLY
 					/* With BMAC, TX Underflows should not happen */
 					WL_ERROR(("wl%d: BMAC TX Underflow?",
@@ -1131,7 +1124,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info_t * ampdu, struct scb *scb, void *p,
 				}
 			}
 		} else if (txs->phyerr) {
-			update_rate = FALSE;
+			update_rate = false;
 			WLCNTINCR(wlc->pub->_cnt->txphyerr);
 			WL_ERROR(("wl%d: wlc_ampdu_dotxstatus: tx phy error (0x%x)\n", wlc->pub->unit, txs->phyerr));
 
@@ -1151,7 +1144,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info_t * ampdu, struct scb *scb, void *p,
 		ASSERT(tx_info->flags & IEEE80211_TX_CTL_AMPDU);
 		txh = (d11txh_t *) PKTDATA(p);
 		mcl = ltoh16(txh->MacTxControlLow);
-		plcp = (uint8 *) (txh + 1);
+		plcp = (u8 *) (txh + 1);
 		h = (struct dot11_header *)(plcp + D11_PHY_HDR_LEN);
 		seq = ltoh16(h->seq) >> SEQNUM_SHIFT;
 
@@ -1161,7 +1154,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info_t * ampdu, struct scb *scb, void *p,
 		}
 
 		index = TX_SEQ_TO_INDEX(seq);
-		ack_recd = FALSE;
+		ack_recd = false;
 		if (ba_recd) {
 			bindex = MODSUB_POW2(seq, start_seq, SEQNUM_MAX);
 
@@ -1198,7 +1191,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info_t * ampdu, struct scb *scb, void *p,
 
 				ieee80211_tx_status_irqsafe(wlc->pub->ieee_hw,
 							    p);
-				ack_recd = TRUE;
+				ack_recd = true;
 				suc_mpdu++;
 			}
 		}
@@ -1249,11 +1242,12 @@ wlc_ampdu_dotxstatus_complete(ampdu_info_t * ampdu, struct scb *scb, void *p,
 }
 
 static void
-ampdu_cleanup_tid_ini(ampdu_info_t * ampdu, scb_ampdu_t * scb_ampdu, uint8 tid,
+ampdu_cleanup_tid_ini(ampdu_info_t *ampdu, scb_ampdu_t *scb_ampdu, u8 tid,
 		      bool force)
 {
 	scb_ampdu_tid_ini_t *ini;
-	if (!(ini = SCB_AMPDU_INI(scb_ampdu, tid)))
+	ini = SCB_AMPDU_INI(scb_ampdu, tid);
+	if (!ini)
 		return;
 
 	WL_AMPDU_CTL(("wl%d: ampdu_cleanup_tid_ini: tid %d\n",
@@ -1266,13 +1260,13 @@ ampdu_cleanup_tid_ini(ampdu_info_t * ampdu, scb_ampdu_t * scb_ampdu, uint8 tid,
 	ASSERT(ini == &scb_ampdu->ini[ini->tid]);
 
 	/* free all buffered tx packets */
-	pktq_pflush(ampdu->wlc->osh, &scb_ampdu->txq, ini->tid, TRUE, NULL, 0);
+	pktq_pflush(ampdu->wlc->osh, &scb_ampdu->txq, ini->tid, true, NULL, 0);
 }
 
 /* initialize the initiator code for tid */
-static scb_ampdu_tid_ini_t *wlc_ampdu_init_tid_ini(ampdu_info_t * ampdu,
-						   scb_ampdu_t * scb_ampdu,
-						   uint8 tid, bool override)
+static scb_ampdu_tid_ini_t *wlc_ampdu_init_tid_ini(ampdu_info_t *ampdu,
+						   scb_ampdu_t *scb_ampdu,
+						   u8 tid, bool override)
 {
 	scb_ampdu_tid_ini_t *ini;
 
@@ -1296,11 +1290,11 @@ static scb_ampdu_tid_ini_t *wlc_ampdu_init_tid_ini(ampdu_info_t * ampdu,
 	return ini;
 }
 
-int wlc_ampdu_set(ampdu_info_t * ampdu, bool on)
+int wlc_ampdu_set(ampdu_info_t *ampdu, bool on)
 {
 	wlc_info_t *wlc = ampdu->wlc;
 
-	wlc->pub->_ampdu = FALSE;
+	wlc->pub->_ampdu = false;
 
 	if (on) {
 		if (!N_ENAB(wlc->pub)) {
@@ -1319,42 +1313,42 @@ int wlc_ampdu_set(ampdu_info_t * ampdu, bool on)
 	return 0;
 }
 
-bool wlc_ampdu_cap(ampdu_info_t * ampdu)
+bool wlc_ampdu_cap(ampdu_info_t *ampdu)
 {
 	if (WLC_PHY_11N_CAP(ampdu->wlc->band))
-		return TRUE;
+		return true;
 	else
-		return FALSE;
+		return false;
 }
 
-static void ampdu_update_max_txlen(ampdu_info_t * ampdu, uint8 dur)
+static void ampdu_update_max_txlen(ampdu_info_t *ampdu, u8 dur)
 {
-	uint32 rate, mcs;
+	u32 rate, mcs;
 
 	for (mcs = 0; mcs < MCS_TABLE_SIZE; mcs++) {
 		/* rate is in Kbps; dur is in msec ==> len = (rate * dur) / 8 */
 		/* 20MHz, No SGI */
-		rate = MCS_RATE(mcs, FALSE, FALSE);
+		rate = MCS_RATE(mcs, false, false);
 		ampdu->max_txlen[mcs][0][0] = (rate * dur) >> 3;
 		/* 40 MHz, No SGI */
-		rate = MCS_RATE(mcs, TRUE, FALSE);
+		rate = MCS_RATE(mcs, true, false);
 		ampdu->max_txlen[mcs][1][0] = (rate * dur) >> 3;
 		/* 20MHz, SGI */
-		rate = MCS_RATE(mcs, FALSE, TRUE);
+		rate = MCS_RATE(mcs, false, true);
 		ampdu->max_txlen[mcs][0][1] = (rate * dur) >> 3;
 		/* 40 MHz, SGI */
-		rate = MCS_RATE(mcs, TRUE, TRUE);
+		rate = MCS_RATE(mcs, true, true);
 		ampdu->max_txlen[mcs][1][1] = (rate * dur) >> 3;
 	}
 }
 
-uint8 BCMFASTPATH
-wlc_ampdu_null_delim_cnt(ampdu_info_t * ampdu, struct scb *scb,
+u8 BCMFASTPATH
+wlc_ampdu_null_delim_cnt(ampdu_info_t *ampdu, struct scb *scb,
 			 ratespec_t rspec, int phylen)
 {
 	scb_ampdu_t *scb_ampdu;
 	int bytes, cnt, tmp;
-	uint8 tx_density;
+	u8 tx_density;
 
 	ASSERT(scb);
 	ASSERT(SCB_AMPDU(scb));
@@ -1380,12 +1374,12 @@ wlc_ampdu_null_delim_cnt(ampdu_info_t * ampdu, struct scb *scb,
 	if (bytes > phylen) {
 		cnt = CEIL(bytes - phylen, AMPDU_DELIMITER_LEN);
 		ASSERT(cnt <= 255);
-		return (uint8) cnt;
+		return (u8) cnt;
 	} else
 		return 0;
 }
 
-void wlc_ampdu_macaddr_upd(wlc_info_t * wlc)
+void wlc_ampdu_macaddr_upd(wlc_info_t *wlc)
 {
 	char template[T_RAM_ACCESS_SZ * 2];
 
@@ -1396,12 +1390,12 @@ void wlc_ampdu_macaddr_upd(wlc_info_t * wlc)
 			       template);
 }
 
-bool wlc_aggregatable(wlc_info_t * wlc, uint8 tid)
+bool wlc_aggregatable(wlc_info_t *wlc, u8 tid)
 {
-	return (wlc->ampdu->ini_enable[tid]);
+	return wlc->ampdu->ini_enable[tid];
 }
 
-void wlc_ampdu_shm_upd(ampdu_info_t * ampdu)
+void wlc_ampdu_shm_upd(ampdu_info_t *ampdu)
 {
 	wlc_info_t *wlc = ampdu->wlc;
 
diff --git a/drivers/staging/brcm80211/sys/wlc_ampdu.h b/drivers/staging/brcm80211/sys/wlc_ampdu.h
index 775faf6..c721b16 100644
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.h
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.h
@@ -17,24 +17,24 @@
 #ifndef _wlc_ampdu_h_
 #define _wlc_ampdu_h_
 
-extern ampdu_info_t *wlc_ampdu_attach(wlc_info_t * wlc);
-extern void wlc_ampdu_detach(ampdu_info_t * ampdu);
-extern bool wlc_ampdu_cap(ampdu_info_t * ampdu);
-extern int wlc_ampdu_set(ampdu_info_t * ampdu, bool on);
-extern int wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **aggp,
+extern ampdu_info_t *wlc_ampdu_attach(wlc_info_t *wlc);
+extern void wlc_ampdu_detach(ampdu_info_t *ampdu);
+extern bool wlc_ampdu_cap(ampdu_info_t *ampdu);
+extern int wlc_ampdu_set(ampdu_info_t *ampdu, bool on);
+extern int wlc_sendampdu(ampdu_info_t *ampdu, wlc_txq_info_t *qi, void **aggp,
 			 int prec);
-extern void wlc_ampdu_dotxstatus(ampdu_info_t * ampdu, struct scb *scb, void *p,
-				 tx_status_t * txs);
-extern void wlc_ampdu_reset(ampdu_info_t * ampdu);
-extern void wlc_ampdu_macaddr_upd(wlc_info_t * wlc);
-extern void wlc_ampdu_shm_upd(ampdu_info_t * ampdu);
+extern void wlc_ampdu_dotxstatus(ampdu_info_t *ampdu, struct scb *scb, void *p,
+				 tx_status_t *txs);
+extern void wlc_ampdu_reset(ampdu_info_t *ampdu);
+extern void wlc_ampdu_macaddr_upd(wlc_info_t *wlc);
+extern void wlc_ampdu_shm_upd(ampdu_info_t *ampdu);
 
-extern uint8 wlc_ampdu_null_delim_cnt(ampdu_info_t * ampdu, struct scb *scb,
+extern u8 wlc_ampdu_null_delim_cnt(ampdu_info_t *ampdu, struct scb *scb,
 				      ratespec_t rspec, int phylen);
-extern void scb_ampdu_cleanup(ampdu_info_t * ampdu, struct scb *scb);
+extern void scb_ampdu_cleanup(ampdu_info_t *ampdu, struct scb *scb);
 #ifdef WLC_HIGH_ONLY
-extern void wlc_ampdu_txstatus_complete(ampdu_info_t * ampdu, uint32 s1,
-					uint32 s2);
+extern void wlc_ampdu_txstatus_complete(ampdu_info_t *ampdu, u32 s1,
+					u32 s2);
 #endif
 
 #endif				/* _wlc_ampdu_h_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_antsel.c b/drivers/staging/brcm80211/sys/wlc_antsel.c
index a7ad9bb..5ff8831 100644
--- a/drivers/staging/brcm80211/sys/wlc_antsel.c
+++ b/drivers/staging/brcm80211/sys/wlc_antsel.c
@@ -18,23 +18,18 @@
 
 #ifdef WLANTSEL
 
-#include <typedefs.h>
-#include <qmath.h>
+#include <linux/kernel.h>
+#include <linuxver.h>
 #include <bcmdefs.h>
 #include <osl.h>
 #include <bcmutils.h>
 #include <siutils.h>
-#include <bcmendian.h>
 #include <wlioctl.h>
-#include <wlc_phy_radio.h>
-#include <bitfuncs.h>
 
-#include <proto/802.11.h>
 #include <d11.h>
 #include <wlc_rate.h>
 #include <wlc_key.h>
 #include <wlc_pub.h>
-#include <wlc_bsscfg.h>
 #include <wl_dbg.h>
 #include <wlc_mac80211.h>
 #include <wlc_bmac.h>
@@ -63,53 +58,52 @@
 #define ANT_SELCFG_DEF_2x4	0x02	/* default antenna configuration */
 
 /* static functions */
-static int wlc_antsel_cfgupd(antsel_info_t * asi, wlc_antselcfg_t * antsel);
-static uint8 wlc_antsel_id2antcfg(antsel_info_t * asi, uint8 id);
-static uint16 wlc_antsel_antcfg2antsel(antsel_info_t * asi, uint8 ant_cfg);
-static void wlc_antsel_init_cfg(antsel_info_t * asi, wlc_antselcfg_t * antsel,
+static int wlc_antsel_cfgupd(antsel_info_t *asi, wlc_antselcfg_t *antsel);
+static u8 wlc_antsel_id2antcfg(antsel_info_t *asi, u8 id);
+static u16 wlc_antsel_antcfg2antsel(antsel_info_t *asi, u8 ant_cfg);
+static void wlc_antsel_init_cfg(antsel_info_t *asi, wlc_antselcfg_t *antsel,
 				bool auto_sel);
 
-const uint16 mimo_2x4_div_antselpat_tbl[] = {
+const u16 mimo_2x4_div_antselpat_tbl[] = {
 	0, 0, 0x9, 0xa,		/* ant0: 0 ant1: 2,3 */
 	0, 0, 0x5, 0x6,		/* ant0: 1 ant1: 2,3 */
 	0, 0, 0, 0,		/* n.a.              */
 	0, 0, 0, 0		/* n.a.              */
 };
 
-const uint8 mimo_2x4_div_antselid_tbl[16] = {
+const u8 mimo_2x4_div_antselid_tbl[16] = {
 	0, 0, 0, 0, 0, 2, 3, 0,
 	0, 0, 1, 0, 0, 0, 0, 0	/* pat to antselid */
 };
 
-const uint16 mimo_2x3_div_antselpat_tbl[] = {
+const u16 mimo_2x3_div_antselpat_tbl[] = {
 	16, 0, 1, 16,		/* ant0: 0 ant1: 1,2 */
 	16, 16, 16, 16,		/* n.a.              */
 	16, 2, 16, 16,		/* ant0: 2 ant1: 1   */
 	16, 16, 16, 16		/* n.a.              */
 };
 
-const uint8 mimo_2x3_div_antselid_tbl[16] = {
+const u8 mimo_2x3_div_antselid_tbl[16] = {
 	0, 1, 2, 0, 0, 0, 0, 0,
 	0, 0, 0, 0, 0, 0, 0, 0	/* pat to antselid */
 };
 
-antsel_info_t *BCMNMIATTACHFN(wlc_antsel_attach) (wlc_info_t * wlc, osl_t * osh,
-						  wlc_pub_t * pub,
-						  wlc_hw_info_t * wlc_hw) {
+antsel_info_t *wlc_antsel_attach(wlc_info_t *wlc, osl_t *osh,
+						  wlc_pub_t *pub,
+						  wlc_hw_info_t *wlc_hw) {
 	antsel_info_t *asi;
 
-	if (!(asi = (antsel_info_t *) MALLOC(osh, sizeof(antsel_info_t)))) {
-		WL_ERROR(("wl%d: wlc_antsel_attach: out of mem, malloced %d bytes\n", pub->unit, MALLOCED(osh)));
+	asi = kzalloc(sizeof(antsel_info_t), GFP_ATOMIC);
+	if (!asi) {
+		WL_ERROR(("wl%d: wlc_antsel_attach: out of mem\n", pub->unit));
 		return NULL;
 	}
 
-	bzero((char *)asi, sizeof(antsel_info_t));
-
 	asi->wlc = wlc;
 	asi->pub = pub;
 	asi->antsel_type = ANTSEL_NA;
-	asi->antsel_avail = FALSE;
-	asi->antsel_antswitch = (uint8) getintvar(asi->pub->vars, "antswitch");
+	asi->antsel_avail = false;
+	asi->antsel_antswitch = (u8) getintvar(asi->pub->vars, "antswitch");
 
 	if ((asi->pub->sromrev >= 4) && (asi->antsel_antswitch != 0)) {
 		switch (asi->antsel_antswitch) {
@@ -119,17 +113,17 @@ antsel_info_t *BCMNMIATTACHFN(wlc_antsel_attach) (wlc_info_t * wlc, osl_t * osh,
 			/* 4321/2 board with 2x3 switch logic */
 			asi->antsel_type = ANTSEL_2x3;
 			/* Antenna selection availability */
-			if (((uint16) getintvar(asi->pub->vars, "aa2g") == 7) ||
-			    ((uint16) getintvar(asi->pub->vars, "aa5g") == 7)) {
-				asi->antsel_avail = TRUE;
+			if (((u16) getintvar(asi->pub->vars, "aa2g") == 7) ||
+			    ((u16) getintvar(asi->pub->vars, "aa5g") == 7)) {
+				asi->antsel_avail = true;
 			} else
-			    if (((uint16) getintvar(asi->pub->vars, "aa2g") ==
+			    if (((u16) getintvar(asi->pub->vars, "aa2g") ==
 				 3)
-				|| ((uint16) getintvar(asi->pub->vars, "aa5g")
+				|| ((u16) getintvar(asi->pub->vars, "aa5g")
 				    == 3)) {
-				asi->antsel_avail = FALSE;
+				asi->antsel_avail = false;
 			} else {
-				asi->antsel_avail = FALSE;
+				asi->antsel_avail = false;
 				WL_ERROR(("wlc_antsel_attach: 2o3 board cfg invalid\n"));
 				ASSERT(0);
 			}
@@ -138,34 +132,35 @@ antsel_info_t *BCMNMIATTACHFN(wlc_antsel_attach) (wlc_info_t * wlc, osl_t * osh,
 			break;
 		}
 	} else if ((asi->pub->sromrev == 4) &&
-		   ((uint16) getintvar(asi->pub->vars, "aa2g") == 7) &&
-		   ((uint16) getintvar(asi->pub->vars, "aa5g") == 0)) {
+		   ((u16) getintvar(asi->pub->vars, "aa2g") == 7) &&
+		   ((u16) getintvar(asi->pub->vars, "aa5g") == 0)) {
 		/* hack to match old 4321CB2 cards with 2of3 antenna switch */
 		asi->antsel_type = ANTSEL_2x3;
-		asi->antsel_avail = TRUE;
+		asi->antsel_avail = true;
 	} else if (asi->pub->boardflags2 & BFL2_2X4_DIV) {
 		asi->antsel_type = ANTSEL_2x4;
-		asi->antsel_avail = TRUE;
+		asi->antsel_avail = true;
 	}
 
 	/* Set the antenna selection type for the low driver */
 	wlc_bmac_antsel_type_set(wlc_hw, asi->antsel_type);
 
 	/* Init (auto/manual) antenna selection */
-	wlc_antsel_init_cfg(asi, &asi->antcfg_11n, TRUE);
-	wlc_antsel_init_cfg(asi, &asi->antcfg_cur, TRUE);
+	wlc_antsel_init_cfg(asi, &asi->antcfg_11n, true);
+	wlc_antsel_init_cfg(asi, &asi->antcfg_cur, true);
 
 	return asi;
 }
 
-void BCMATTACHFN(wlc_antsel_detach) (antsel_info_t * asi) {
+void wlc_antsel_detach(antsel_info_t *asi)
+{
 	if (!asi)
 		return;
 
-	MFREE(asi->pub->osh, asi, sizeof(antsel_info_t));
+	kfree(asi);
 }
 
-void wlc_antsel_init(antsel_info_t * asi)
+void wlc_antsel_init(antsel_info_t *asi)
 {
 	if ((asi->antsel_type == ANTSEL_2x3) ||
 	    (asi->antsel_type == ANTSEL_2x4))
@@ -174,11 +169,11 @@ void wlc_antsel_init(antsel_info_t * asi)
 
 /* boardlevel antenna selection: init antenna selection structure */
 static void
-wlc_antsel_init_cfg(antsel_info_t * asi, wlc_antselcfg_t * antsel,
+wlc_antsel_init_cfg(antsel_info_t *asi, wlc_antselcfg_t *antsel,
 		    bool auto_sel)
 {
 	if (asi->antsel_type == ANTSEL_2x3) {
-		uint8 antcfg_def = ANT_SELCFG_DEF_2x3 |
+		u8 antcfg_def = ANT_SELCFG_DEF_2x3 |
 		    ((asi->antsel_avail && auto_sel) ? ANT_SELCFG_AUTO : 0);
 		antsel->ant_config[ANT_SELCFG_TX_DEF] = antcfg_def;
 		antsel->ant_config[ANT_SELCFG_TX_UNICAST] = antcfg_def;
@@ -205,11 +200,11 @@ wlc_antsel_init_cfg(antsel_info_t * asi, wlc_antselcfg_t * antsel,
 }
 
 void BCMFASTPATH
-wlc_antsel_antcfg_get(antsel_info_t * asi, bool usedef, bool sel,
-		      uint8 antselid, uint8 fbantselid, uint8 * antcfg,
-		      uint8 * fbantcfg)
+wlc_antsel_antcfg_get(antsel_info_t *asi, bool usedef, bool sel,
+		      u8 antselid, u8 fbantselid, u8 *antcfg,
+		      u8 *fbantcfg)
 {
-	uint8 ant;
+	u8 ant;
 
 	/* if use default, assign it and return */
 	if (usedef) {
@@ -237,9 +232,9 @@ wlc_antsel_antcfg_get(antsel_info_t * asi, bool usedef, bool sel,
 }
 
 /* boardlevel antenna selection: convert mimo_antsel (ucode interface) to id */
-uint8 wlc_antsel_antsel2id(antsel_info_t * asi, uint16 antsel)
+u8 wlc_antsel_antsel2id(antsel_info_t *asi, u16 antsel)
 {
-	uint8 antselid = 0;
+	u8 antselid = 0;
 
 	if (asi->antsel_type == ANTSEL_2x4) {
 		/* 2x4 antenna diversity board, 4 cfgs: 0-2 0-3 1-2 1-3 */
@@ -256,9 +251,9 @@ uint8 wlc_antsel_antsel2id(antsel_info_t * asi, uint16 antsel)
 }
 
 /* boardlevel antenna selection: convert id to ant_cfg */
-static uint8 wlc_antsel_id2antcfg(antsel_info_t * asi, uint8 id)
+static u8 wlc_antsel_id2antcfg(antsel_info_t *asi, u8 id)
 {
-	uint8 antcfg = ANT_SELCFG_DEF_2x2;
+	u8 antcfg = ANT_SELCFG_DEF_2x2;
 
 	if (asi->antsel_type == ANTSEL_2x4) {
 		/* 2x4 antenna diversity board, 4 cfgs: 0-2 0-3 1-2 1-3 */
@@ -275,10 +270,10 @@ static uint8 wlc_antsel_id2antcfg(antsel_info_t * asi, uint8 id)
 }
 
 /* boardlevel antenna selection: convert ant_cfg to mimo_antsel (ucode interface) */
-static uint16 wlc_antsel_antcfg2antsel(antsel_info_t * asi, uint8 ant_cfg)
+static u16 wlc_antsel_antcfg2antsel(antsel_info_t *asi, u8 ant_cfg)
 {
-	uint8 idx = WLC_ANTIDX_11N(WLC_ANTSEL_11N(ant_cfg));
-	uint16 mimo_antsel = 0;
+	u8 idx = WLC_ANTIDX_11N(WLC_ANTSEL_11N(ant_cfg));
+	u16 mimo_antsel = 0;
 
 	if (asi->antsel_type == ANTSEL_2x4) {
 		/* 2x4 antenna diversity board, 4 cfgs: 0-2 0-3 1-2 1-3 */
@@ -295,11 +290,11 @@ static uint16 wlc_antsel_antcfg2antsel(antsel_info_t * asi, uint8 ant_cfg)
 }
 
 /* boardlevel antenna selection: ucode interface control */
-static int wlc_antsel_cfgupd(antsel_info_t * asi, wlc_antselcfg_t * antsel)
+static int wlc_antsel_cfgupd(antsel_info_t *asi, wlc_antselcfg_t *antsel)
 {
 	wlc_info_t *wlc = asi->wlc;
-	uint8 ant_cfg;
-	uint16 mimo_antsel;
+	u8 ant_cfg;
+	u16 mimo_antsel;
 
 	ASSERT(asi->antsel_type != ANTSEL_NA);
 
diff --git a/drivers/staging/brcm80211/sys/wlc_antsel.h b/drivers/staging/brcm80211/sys/wlc_antsel.h
index 1e51bfd..1d048bb 100644
--- a/drivers/staging/brcm80211/sys/wlc_antsel.h
+++ b/drivers/staging/brcm80211/sys/wlc_antsel.h
@@ -16,13 +16,13 @@
 
 #ifndef _wlc_antsel_h_
 #define _wlc_antsel_h_
-extern antsel_info_t *wlc_antsel_attach(wlc_info_t * wlc, osl_t * osh,
-					wlc_pub_t * pub,
-					wlc_hw_info_t * wlc_hw);
-extern void wlc_antsel_detach(antsel_info_t * asi);
-extern void wlc_antsel_init(antsel_info_t * asi);
-extern void wlc_antsel_antcfg_get(antsel_info_t * asi, bool usedef, bool sel,
-				  uint8 id, uint8 fbid, uint8 * antcfg,
-				  uint8 * fbantcfg);
-extern uint8 wlc_antsel_antsel2id(antsel_info_t * asi, uint16 antsel);
+extern antsel_info_t *wlc_antsel_attach(wlc_info_t *wlc, osl_t *osh,
+					wlc_pub_t *pub,
+					wlc_hw_info_t *wlc_hw);
+extern void wlc_antsel_detach(antsel_info_t *asi);
+extern void wlc_antsel_init(antsel_info_t *asi);
+extern void wlc_antsel_antcfg_get(antsel_info_t *asi, bool usedef, bool sel,
+				  u8 id, u8 fbid, u8 *antcfg,
+				  u8 *fbantcfg);
+extern u8 wlc_antsel_antsel2id(antsel_info_t *asi, u16 antsel);
 #endif				/* _wlc_antsel_h_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_bmac.c b/drivers/staging/brcm80211/sys/wlc_bmac.c
index 70aa98b..b70f9d0 100644
--- a/drivers/staging/brcm80211/sys/wlc_bmac.c
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.c
@@ -18,8 +18,9 @@
 #error "This file needs WLC_LOW"
 #endif
 
+#include <linux/kernel.h>
 #include <wlc_cfg.h>
-#include <typedefs.h>
+#include <linuxver.h>
 #include <bcmdefs.h>
 #include <osl.h>
 #include <proto/802.11.h>
@@ -87,11 +88,11 @@
 
 #define DMAREG(wlc_hw, direction, fifonum)	(D11REV_LT(wlc_hw->corerev, 11) ? \
 	((direction == DMA_TX) ? \
-		(void*)(uintptr)&(wlc_hw->regs->fifo.f32regs.dmaregs[fifonum].xmt) : \
-		(void*)(uintptr)&(wlc_hw->regs->fifo.f32regs.dmaregs[fifonum].rcv)) : \
+		(void *)&(wlc_hw->regs->fifo.f32regs.dmaregs[fifonum].xmt) : \
+		(void *)&(wlc_hw->regs->fifo.f32regs.dmaregs[fifonum].rcv)) : \
 	((direction == DMA_TX) ? \
-		(void*)(uintptr)&(wlc_hw->regs->fifo.f64regs[fifonum].dmaxmt) : \
-		(void*)(uintptr)&(wlc_hw->regs->fifo.f64regs[fifonum].dmarcv)))
+		(void *)&(wlc_hw->regs->fifo.f64regs[fifonum].dmaxmt) : \
+		(void *)&(wlc_hw->regs->fifo.f64regs[fifonum].dmarcv)))
 
 /*
  * The following table lists the buffer memory allocated to xmt fifos in HW.
@@ -104,7 +105,7 @@
 
 #define XMTFIFOTBL_STARTREV	20	/* Starting corerev for the fifo size table */
 
-static uint16 xmtfifo_sz[][NFIFO] = {
+static u16 xmtfifo_sz[][NFIFO] = {
 	{20, 192, 192, 21, 17, 5},	/* corerev 20: 5120, 49152, 49152, 5376, 4352, 1280 */
 	{9, 58, 22, 14, 14, 5},	/* corerev 21: 2304, 14848, 5632, 3584, 3584, 1280 */
 	{20, 192, 192, 21, 17, 5},	/* corerev 22: 5120, 49152, 49152, 5376, 4352, 1280 */
@@ -112,64 +113,64 @@ static uint16 xmtfifo_sz[][NFIFO] = {
 	{9, 58, 22, 14, 14, 5},	/* corerev 24: 2304, 14848, 5632, 3584, 3584, 1280 */
 };
 
-static void wlc_clkctl_clk(wlc_hw_info_t * wlc, uint mode);
-static void wlc_coreinit(wlc_info_t * wlc);
+static void wlc_clkctl_clk(wlc_hw_info_t *wlc, uint mode);
+static void wlc_coreinit(wlc_info_t *wlc);
 
 /* used by wlc_wakeucode_init() */
-static void wlc_write_inits(wlc_hw_info_t * wlc_hw, const d11init_t * inits);
-static void wlc_ucode_write(wlc_hw_info_t * wlc_hw, const uint32 ucode[],
+static void wlc_write_inits(wlc_hw_info_t *wlc_hw, const d11init_t *inits);
+static void wlc_ucode_write(wlc_hw_info_t *wlc_hw, const u32 ucode[],
 			    const uint nbytes);
-static void wlc_ucode_download(wlc_hw_info_t * wlc);
-static void wlc_ucode_txant_set(wlc_hw_info_t * wlc_hw);
+static void wlc_ucode_download(wlc_hw_info_t *wlc);
+static void wlc_ucode_txant_set(wlc_hw_info_t *wlc_hw);
 
 /* used by wlc_dpc() */
-static bool wlc_bmac_dotxstatus(wlc_hw_info_t * wlc, tx_status_t * txs,
-				uint32 s2);
-static bool wlc_bmac_txstatus_corerev4(wlc_hw_info_t * wlc);
-static bool wlc_bmac_txstatus(wlc_hw_info_t * wlc, bool bound, bool * fatal);
-static bool wlc_bmac_recv(wlc_hw_info_t * wlc_hw, uint fifo, bool bound);
+static bool wlc_bmac_dotxstatus(wlc_hw_info_t *wlc, tx_status_t *txs,
+				u32 s2);
+static bool wlc_bmac_txstatus_corerev4(wlc_hw_info_t *wlc);
+static bool wlc_bmac_txstatus(wlc_hw_info_t *wlc, bool bound, bool *fatal);
+static bool wlc_bmac_recv(wlc_hw_info_t *wlc_hw, uint fifo, bool bound);
 
 /* used by wlc_down() */
-static void wlc_flushqueues(wlc_info_t * wlc);
+static void wlc_flushqueues(wlc_info_t *wlc);
 
-static void wlc_write_mhf(wlc_hw_info_t * wlc_hw, uint16 * mhfs);
-static void wlc_mctrl_reset(wlc_hw_info_t * wlc_hw);
-static void wlc_corerev_fifofixup(wlc_hw_info_t * wlc_hw);
+static void wlc_write_mhf(wlc_hw_info_t *wlc_hw, u16 *mhfs);
+static void wlc_mctrl_reset(wlc_hw_info_t *wlc_hw);
+static void wlc_corerev_fifofixup(wlc_hw_info_t *wlc_hw);
 
 /* Low Level Prototypes */
-static uint16 wlc_bmac_read_objmem(wlc_hw_info_t * wlc_hw, uint offset,
-				   uint32 sel);
-static void wlc_bmac_write_objmem(wlc_hw_info_t * wlc_hw, uint offset, uint16 v,
-				  uint32 sel);
-static bool wlc_bmac_attach_dmapio(wlc_info_t * wlc, uint j, bool wme);
-static void wlc_bmac_detach_dmapio(wlc_hw_info_t * wlc_hw);
-static void wlc_ucode_bsinit(wlc_hw_info_t * wlc_hw);
-static bool wlc_validboardtype(wlc_hw_info_t * wlc);
-static bool wlc_isgoodchip(wlc_hw_info_t * wlc_hw);
-static char *wlc_get_macaddr(wlc_hw_info_t * wlc_hw);
-static void wlc_mhfdef(wlc_info_t * wlc, uint16 * mhfs, uint16 mhf2_init);
-static void wlc_mctrl_write(wlc_hw_info_t * wlc_hw);
-static void wlc_ucode_mute_override_set(wlc_hw_info_t * wlc_hw);
-static void wlc_ucode_mute_override_clear(wlc_hw_info_t * wlc_hw);
-static uint32 wlc_wlintrsoff(wlc_info_t * wlc);
-static void wlc_wlintrsrestore(wlc_info_t * wlc, uint32 macintmask);
-static void wlc_gpio_init(wlc_info_t * wlc);
-static void wlc_write_hw_bcntemplate0(wlc_hw_info_t * wlc_hw, void *bcn,
+static u16 wlc_bmac_read_objmem(wlc_hw_info_t *wlc_hw, uint offset,
+				   u32 sel);
+static void wlc_bmac_write_objmem(wlc_hw_info_t *wlc_hw, uint offset, u16 v,
+				  u32 sel);
+static bool wlc_bmac_attach_dmapio(wlc_info_t *wlc, uint j, bool wme);
+static void wlc_bmac_detach_dmapio(wlc_hw_info_t *wlc_hw);
+static void wlc_ucode_bsinit(wlc_hw_info_t *wlc_hw);
+static bool wlc_validboardtype(wlc_hw_info_t *wlc);
+static bool wlc_isgoodchip(wlc_hw_info_t *wlc_hw);
+static char *wlc_get_macaddr(wlc_hw_info_t *wlc_hw);
+static void wlc_mhfdef(wlc_info_t *wlc, u16 *mhfs, u16 mhf2_init);
+static void wlc_mctrl_write(wlc_hw_info_t *wlc_hw);
+static void wlc_ucode_mute_override_set(wlc_hw_info_t *wlc_hw);
+static void wlc_ucode_mute_override_clear(wlc_hw_info_t *wlc_hw);
+static u32 wlc_wlintrsoff(wlc_info_t *wlc);
+static void wlc_wlintrsrestore(wlc_info_t *wlc, u32 macintmask);
+static void wlc_gpio_init(wlc_info_t *wlc);
+static void wlc_write_hw_bcntemplate0(wlc_hw_info_t *wlc_hw, void *bcn,
 				      int len);
-static void wlc_write_hw_bcntemplate1(wlc_hw_info_t * wlc_hw, void *bcn,
+static void wlc_write_hw_bcntemplate1(wlc_hw_info_t *wlc_hw, void *bcn,
 				      int len);
-static void wlc_bmac_bsinit(wlc_info_t * wlc, chanspec_t chanspec);
-static uint32 wlc_setband_inact(wlc_info_t * wlc, uint bandunit);
-static void wlc_bmac_setband(wlc_hw_info_t * wlc_hw, uint bandunit,
+static void wlc_bmac_bsinit(wlc_info_t *wlc, chanspec_t chanspec);
+static u32 wlc_setband_inact(wlc_info_t *wlc, uint bandunit);
+static void wlc_bmac_setband(wlc_hw_info_t *wlc_hw, uint bandunit,
 			     chanspec_t chanspec);
-static void wlc_bmac_update_slot_timing(wlc_hw_info_t * wlc_hw, bool shortslot);
-static void wlc_upd_ofdm_pctl1_table(wlc_hw_info_t * wlc_hw);
-static uint16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t * wlc_hw,
-					     uint8 rate);
+static void wlc_bmac_update_slot_timing(wlc_hw_info_t *wlc_hw, bool shortslot);
+static void wlc_upd_ofdm_pctl1_table(wlc_hw_info_t *wlc_hw);
+static u16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t *wlc_hw,
+					     u8 rate);
 
 /* === Low Level functions === */
 
-void wlc_bmac_set_shortslot(wlc_hw_info_t * wlc_hw, bool shortslot)
+void wlc_bmac_set_shortslot(wlc_hw_info_t *wlc_hw, bool shortslot)
 {
 	wlc_hw->shortslot = shortslot;
 
@@ -185,7 +186,7 @@ void wlc_bmac_set_shortslot(wlc_hw_info_t * wlc_hw, bool shortslot)
  * or shortslot 11g (9us slots)
  * The PSM needs to be suspended for this call.
  */
-static void wlc_bmac_update_slot_timing(wlc_hw_info_t * wlc_hw, bool shortslot)
+static void wlc_bmac_update_slot_timing(wlc_hw_info_t *wlc_hw, bool shortslot)
 {
 	osl_t *osh;
 	d11regs_t *regs;
@@ -204,7 +205,8 @@ static void wlc_bmac_update_slot_timing(wlc_hw_info_t * wlc_hw, bool shortslot)
 	}
 }
 
-static void WLBANDINITFN(wlc_ucode_bsinit) (wlc_hw_info_t * wlc_hw) {
+static void WLBANDINITFN(wlc_ucode_bsinit) (wlc_hw_info_t *wlc_hw)
+{
 	/* init microcode host flags */
 	wlc_write_mhf(wlc_hw, wlc_hw->band->mhfs);
 
@@ -230,10 +232,11 @@ static void WLBANDINITFN(wlc_ucode_bsinit) (wlc_hw_info_t * wlc_hw) {
 }
 
 /* switch to new band but leave it inactive */
-static uint32 WLBANDINITFN(wlc_setband_inact) (wlc_info_t * wlc, uint bandunit) {
+static u32 WLBANDINITFN(wlc_setband_inact) (wlc_info_t *wlc, uint bandunit)
+{
 	wlc_hw_info_t *wlc_hw = wlc->hw;
-	uint32 macintmask;
-	uint32 tmp;
+	u32 macintmask;
+	u32 tmp;
 
 	WL_TRACE(("wl%d: wlc_setband_inact\n", wlc_hw->unit));
 
@@ -257,23 +260,23 @@ static uint32 WLBANDINITFN(wlc_setband_inact) (wlc_info_t * wlc, uint bandunit)
 
 	wlc_setxband(wlc_hw, bandunit);
 
-	return (macintmask);
+	return macintmask;
 }
 
 /* Process received frames */
 /*
- * Return TRUE if more frames need to be processed. FALSE otherwise.
+ * Return true if more frames need to be processed. false otherwise.
  * Param 'bound' indicates max. # frames to process before break out.
  */
 static bool BCMFASTPATH
-wlc_bmac_recv(wlc_hw_info_t * wlc_hw, uint fifo, bool bound)
+wlc_bmac_recv(wlc_hw_info_t *wlc_hw, uint fifo, bool bound)
 {
 	void *p;
 	void *head = NULL;
 	void *tail = NULL;
 	uint n = 0;
 	uint bound_limit = bound ? wlc_hw->wlc->pub->tunables->rxbnd : -1;
-	uint32 tsf_h, tsf_l;
+	u32 tsf_h, tsf_l;
 	wlc_d11rxhdr_t *wlc_rxhdr = NULL;
 
 	WL_TRACE(("wl%d: %s\n", wlc_hw->unit, __func__));
@@ -313,24 +316,24 @@ wlc_bmac_recv(wlc_hw_info_t * wlc_hw, uint fifo, bool bound)
 		wlc_recv(wlc_hw->wlc, p);
 	}
 
-	return (n >= bound_limit);
+	return n >= bound_limit;
 }
 
 /* second-level interrupt processing
- *   Return TRUE if another dpc needs to be re-scheduled. FALSE otherwise.
+ *   Return true if another dpc needs to be re-scheduled. false otherwise.
  *   Param 'bounded' indicates if applicable loops should be bounded.
  */
-bool BCMFASTPATH wlc_dpc(wlc_info_t * wlc, bool bounded)
+bool BCMFASTPATH wlc_dpc(wlc_info_t *wlc, bool bounded)
 {
-	uint32 macintstatus;
+	u32 macintstatus;
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs = wlc_hw->regs;
-	bool fatal = FALSE;
+	bool fatal = false;
 
 	if (DEVICEREMOVED(wlc)) {
 		WL_ERROR(("wl%d: %s: dead chip\n", wlc_hw->unit, __func__));
 		wl_down(wlc->wl);
-		return FALSE;
+		return false;
 	}
 
 	/* grab and clear the saved software intstatus bits */
@@ -421,7 +424,7 @@ bool BCMFASTPATH wlc_dpc(wlc_info_t * wlc, bool bounded)
 
 	if (macintstatus & MI_RFDISABLE) {
 #if defined(BCMDBG)
-		uint32 rfd = R_REG(wlc_hw->osh, &regs->phydebug) & PDBG_RFD;
+		u32 rfd = R_REG(wlc_hw->osh, &regs->phydebug) & PDBG_RFD;
 #endif
 
 		WL_ERROR(("wl%d: MAC Detected a change on the RF Disable Input 0x%x\n", wlc_hw->unit, rfd));
@@ -436,14 +439,14 @@ bool BCMFASTPATH wlc_dpc(wlc_info_t * wlc, bool bounded)
 	ASSERT(wlc_ps_check(wlc));
 
 	/* make sure the bound indication and the implementation are in sync */
-	ASSERT(bounded == TRUE || wlc->macintstatus == 0);
+	ASSERT(bounded == true || wlc->macintstatus == 0);
 
 	/* it isn't done and needs to be resched if macintstatus is non-zero */
-	return (wlc->macintstatus != 0);
+	return wlc->macintstatus != 0;
 
  fatal:
 	wl_init(wlc->wl);
-	return (wlc->macintstatus != 0);
+	return wlc->macintstatus != 0;
 }
 
 /* common low-level watchdog code */
@@ -473,7 +476,7 @@ void wlc_bmac_watchdog(void *arg)
 }
 
 void
-wlc_bmac_set_chanspec(wlc_hw_info_t * wlc_hw, chanspec_t chanspec, bool mute,
+wlc_bmac_set_chanspec(wlc_hw_info_t *wlc_hw, chanspec_t chanspec, bool mute,
 		      struct txpwr_limits *txpwr)
 {
 	uint bandunit;
@@ -517,7 +520,7 @@ wlc_bmac_set_chanspec(wlc_hw_info_t * wlc_hw, chanspec_t chanspec, bool mute,
 	}
 }
 
-int wlc_bmac_revinfo_get(wlc_hw_info_t * wlc_hw, wlc_bmac_revinfo_t * revinfo)
+int wlc_bmac_revinfo_get(wlc_hw_info_t *wlc_hw, wlc_bmac_revinfo_t *revinfo)
 {
 	si_t *sih = wlc_hw->sih;
 	uint idx;
@@ -555,19 +558,19 @@ int wlc_bmac_revinfo_get(wlc_hw_info_t * wlc_hw, wlc_bmac_revinfo_t * revinfo)
 	return 0;
 }
 
-int wlc_bmac_state_get(wlc_hw_info_t * wlc_hw, wlc_bmac_state_t * state)
+int wlc_bmac_state_get(wlc_hw_info_t *wlc_hw, wlc_bmac_state_t *state)
 {
 	state->machwcap = wlc_hw->machwcap;
 
 	return 0;
 }
 
-static bool
-BCMATTACHFN(wlc_bmac_attach_dmapio) (wlc_info_t * wlc, uint j, bool wme) {
+static bool wlc_bmac_attach_dmapio(wlc_info_t *wlc, uint j, bool wme)
+{
 	uint i;
 	char name[8];
 	/* ucode host flag 2 needed for pio mode, independent of band and fifo */
-	uint16 pio_mhf2 = 0;
+	u16 pio_mhf2 = 0;
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	uint unit = wlc_hw->unit;
 	wlc_tunables_t *tune = wlc->pub->tunables;
@@ -590,7 +593,7 @@ BCMATTACHFN(wlc_bmac_attach_dmapio) (wlc_info_t * wlc, uint j, bool wme) {
 
 		if (!wl_alloc_dma_resources(wlc_hw->wlc->wl, addrwidth)) {
 			WL_ERROR(("wl%d: wlc_attach: alloc_dma_resources failed\n", unit));
-			return FALSE;
+			return false;
 		}
 
 		/*
@@ -664,7 +667,7 @@ BCMATTACHFN(wlc_bmac_attach_dmapio) (wlc_info_t * wlc, uint j, bool wme) {
 		if (dma_attach_err) {
 			WL_ERROR(("wl%d: wlc_attach: dma_attach failed\n",
 				  unit));
-			return FALSE;
+			return false;
 		}
 
 		/* get pointer to dma engine tx flow control variable */
@@ -678,10 +681,11 @@ BCMATTACHFN(wlc_bmac_attach_dmapio) (wlc_info_t * wlc, uint j, bool wme) {
 	/* initial ucode host flags */
 	wlc_mhfdef(wlc, wlc_hw->band->mhfs, pio_mhf2);
 
-	return TRUE;
+	return true;
 }
 
-static void BCMATTACHFN(wlc_bmac_detach_dmapio) (wlc_hw_info_t * wlc_hw) {
+static void wlc_bmac_detach_dmapio(wlc_hw_info_t *wlc_hw)
+{
 	uint j;
 
 	for (j = 0; j < NFIFO; j++) {
@@ -698,18 +702,17 @@ static void BCMATTACHFN(wlc_bmac_detach_dmapio) (wlc_hw_info_t * wlc_hw) {
  *    initialize software state for each core and band
  *    put the whole chip in reset(driver down state), no clock
  */
-
-int
-BCMATTACHFN(wlc_bmac_attach) (wlc_info_t * wlc, uint16 vendor, uint16 device,
-			      uint unit, bool piomode, osl_t * osh,
-			      void *regsva, uint bustype, void *btparam) {
+int wlc_bmac_attach(wlc_info_t *wlc, u16 vendor, u16 device, uint unit,
+		    bool piomode, osl_t *osh, void *regsva, uint bustype,
+		    void *btparam)
+{
 	wlc_hw_info_t *wlc_hw;
 	d11regs_t *regs;
 	char *macaddr = NULL;
 	char *vars;
 	uint err = 0;
 	uint j;
-	bool wme = FALSE;
+	bool wme = false;
 	shared_phy_params_t sha_params;
 
 	WL_TRACE(("wl%d: wlc_bmac_attach: vendor 0x%x device 0x%x\n", unit,
@@ -717,7 +720,7 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t * wlc, uint16 vendor, uint16 device,
 
 	ASSERT(sizeof(wlc_d11rxhdr_t) <= WL_HWRXOFF);
 
-	wme = TRUE;
+	wme = true;
 
 	wlc_hw = wlc->hw;
 	wlc_hw->wlc = wlc;
@@ -754,12 +757,14 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t * wlc, uint16 vendor, uint16 device,
 	if (bustype != SI_BUS) {
 		char *var;
 
-		if ((var = getvar(vars, "vendid"))) {
-			vendor = (uint16) bcm_strtoul(var, NULL, 0);
+		var = getvar(vars, "vendid");
+		if (var) {
+			vendor = (u16) simple_strtoul(var, NULL, 0);
 			WL_ERROR(("Overriding vendor id = 0x%x\n", vendor));
 		}
-		if ((var = getvar(vars, "devid"))) {
-			uint16 devid = (uint16) bcm_strtoul(var, NULL, 0);
+		var = getvar(vars, "devid");
+		if (var) {
+			u16 devid = (u16) simple_strtoul(var, NULL, 0);
 			if (devid != 0xffff) {
 				device = devid;
 				WL_ERROR(("Overriding device id = 0x%x\n",
@@ -797,7 +802,7 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t * wlc, uint16 vendor, uint16 device,
 
 	/* request fastclock and force fastclock for the rest of attach
 	 * bring the d11 core out of reset.
-	 *   For PMU chips, the first wlc_clkctl_clk is no-op since core-clk is still FALSE;
+	 *   For PMU chips, the first wlc_clkctl_clk is no-op since core-clk is still false;
 	 *   But it will be called again inside wlc_corereset, after d11 is out of reset.
 	 */
 	wlc_clkctl_clk(wlc_hw, CLK_FAST);
@@ -814,23 +819,23 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t * wlc, uint16 vendor, uint16 device,
 	/* promote srom boardrev of 0xFF to 1 */
 	if (j == BOARDREV_PROMOTABLE)
 		j = BOARDREV_PROMOTED;
-	wlc_hw->boardrev = (uint16) j;
+	wlc_hw->boardrev = (u16) j;
 	if (!wlc_validboardtype(wlc_hw)) {
 		WL_ERROR(("wl%d: wlc_bmac_attach: Unsupported Broadcom board type (0x%x)" " or revision level (0x%x)\n", unit, wlc_hw->sih->boardtype, wlc_hw->boardrev));
 		err = 15;
 		goto fail;
 	}
-	wlc_hw->sromrev = (uint8) getintvar(vars, "sromrev");
-	wlc_hw->boardflags = (uint32) getintvar(vars, "boardflags");
-	wlc_hw->boardflags2 = (uint32) getintvar(vars, "boardflags2");
+	wlc_hw->sromrev = (u8) getintvar(vars, "sromrev");
+	wlc_hw->boardflags = (u32) getintvar(vars, "boardflags");
+	wlc_hw->boardflags2 = (u32) getintvar(vars, "boardflags2");
 
 	if (D11REV_LE(wlc_hw->corerev, 4)
 	    || (wlc_hw->boardflags & BFL_NOPLLDOWN))
-		wlc_bmac_pllreq(wlc_hw, TRUE, WLC_PLLREQ_SHARED);
+		wlc_bmac_pllreq(wlc_hw, true, WLC_PLLREQ_SHARED);
 
 	if ((BUSTYPE(wlc_hw->sih->bustype) == PCI_BUS)
 	    && (si_pci_war16165(wlc_hw->sih)))
-		wlc->war16165 = TRUE;
+		wlc->war16165 = true;
 
 	/* check device id(srom, nvram etc.) to set bands */
 	if (wlc_hw->deviceid == BCM43224_D11N_ID) {
@@ -918,14 +923,14 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t * wlc, uint16 vendor, uint16 device,
 
 		/* init tx fifo size */
 		ASSERT((wlc_hw->corerev - XMTFIFOTBL_STARTREV) <
-		       ARRAYSIZE(xmtfifo_sz));
+		       ARRAY_SIZE(xmtfifo_sz));
 		wlc_hw->xmtfifo_sz =
 		    xmtfifo_sz[(wlc_hw->corerev - XMTFIFOTBL_STARTREV)];
 
 		/* Get a phy for this band */
-		if ((wlc_hw->band->pi =
-		     wlc_phy_attach(wlc_hw->phy_sh, (void *)(uintptr) regs,
-				    wlc_hw->band->bandtype, vars)) == NULL) {
+		wlc_hw->band->pi = wlc_phy_attach(wlc_hw->phy_sh,
+			(void *)regs, wlc_hw->band->bandtype, vars);
+		if (wlc_hw->band->pi == NULL) {
 			WL_ERROR(("wl%d: wlc_bmac_attach: wlc_phy_attach failed\n", unit));
 			err = 17;
 			goto fail;
@@ -1003,13 +1008,14 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t * wlc, uint16 vendor, uint16 device,
 	 * or cores are in reset with clocks off, and the board PLLs
 	 * are off if possible.
 	 *
-	 * Beyond this point, wlc->sbclk == FALSE and chip registers
+	 * Beyond this point, wlc->sbclk == false and chip registers
 	 * should not be touched.
 	 *********************************************************************
 	 */
 
 	/* init etheraddr state variables */
-	if ((macaddr = wlc_get_macaddr(wlc_hw)) == NULL) {
+	macaddr = wlc_get_macaddr(wlc_hw);
+	if (macaddr == NULL) {
 		WL_ERROR(("wl%d: wlc_bmac_attach: macaddr not found\n", unit));
 		err = 21;
 		goto fail;
@@ -1039,14 +1045,15 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t * wlc, uint16 vendor, uint16 device,
  * may get overrides later in this function
  *  BMAC_NOTES, move low out and resolve the dangling ones
  */
-void BCMATTACHFN(wlc_bmac_info_init) (wlc_hw_info_t * wlc_hw) {
+void wlc_bmac_info_init(wlc_hw_info_t *wlc_hw)
+{
 	wlc_info_t *wlc = wlc_hw->wlc;
 
 	/* set default sw macintmask value */
 	wlc->defmacintmask = DEF_MACINTMASK;
 
 	/* various 802.11g modes */
-	wlc_hw->shortslot = FALSE;
+	wlc_hw->shortslot = false;
 
 	wlc_hw->SFBL = RETRY_SHORT_FB;
 	wlc_hw->LFBL = RETRY_LONG_FB;
@@ -1060,7 +1067,8 @@ void BCMATTACHFN(wlc_bmac_info_init) (wlc_hw_info_t * wlc_hw) {
 /*
  * low level detach
  */
-int BCMATTACHFN(wlc_bmac_detach) (wlc_info_t * wlc) {
+int wlc_bmac_detach(wlc_info_t *wlc)
+{
 	uint i;
 	wlc_hwband_t *band;
 	wlc_hw_info_t *wlc_hw = wlc->hw;
@@ -1097,7 +1105,7 @@ int BCMATTACHFN(wlc_bmac_detach) (wlc_info_t * wlc) {
 
 	/* free vars */
 	if (wlc_hw->vars) {
-		MFREE(wlc_hw->osh, wlc_hw->vars, wlc_hw->vars_size);
+		kfree(wlc_hw->vars);
 		wlc_hw->vars = NULL;
 	}
 
@@ -1110,7 +1118,8 @@ int BCMATTACHFN(wlc_bmac_detach) (wlc_info_t * wlc) {
 
 }
 
-void BCMINITFN(wlc_bmac_reset) (wlc_hw_info_t * wlc_hw) {
+void wlc_bmac_reset(wlc_hw_info_t *wlc_hw)
+{
 	WL_TRACE(("wl%d: wlc_bmac_reset\n", wlc_hw->unit));
 
 	WLCNTINCR(wlc_hw->wlc->pub->_cnt->reset);
@@ -1126,16 +1135,17 @@ void BCMINITFN(wlc_bmac_reset) (wlc_hw_info_t * wlc_hw) {
 }
 
 void
-BCMINITFN(wlc_bmac_init) (wlc_hw_info_t * wlc_hw, chanspec_t chanspec,
+wlc_bmac_init(wlc_hw_info_t *wlc_hw, chanspec_t chanspec,
 			  bool mute) {
-	uint32 macintmask;
+	u32 macintmask;
 	bool fastclk;
 	wlc_info_t *wlc = wlc_hw->wlc;
 
 	WL_TRACE(("wl%d: wlc_bmac_init\n", wlc_hw->unit));
 
 	/* request FAST clock if not on */
-	if (!(fastclk = wlc_hw->forcefastclk))
+	fastclk = wlc_hw->forcefastclk;
+	if (!fastclk)
 		wlc_clkctl_clk(wlc_hw, CLK_FAST);
 
 	/* disable interrupts */
@@ -1176,7 +1186,8 @@ BCMINITFN(wlc_bmac_init) (wlc_hw_info_t * wlc_hw, chanspec_t chanspec,
 		wlc_clkctl_clk(wlc_hw, CLK_DYNAMIC);
 }
 
-int BCMINITFN(wlc_bmac_up_prep) (wlc_hw_info_t * wlc_hw) {
+int wlc_bmac_up_prep(wlc_hw_info_t *wlc_hw)
+{
 	uint coremask;
 
 	WL_TRACE(("wl%d: %s:\n", wlc_hw->unit, __func__));
@@ -1223,11 +1234,12 @@ int BCMINITFN(wlc_bmac_up_prep) (wlc_hw_info_t * wlc_hw) {
 	return 0;
 }
 
-int BCMINITFN(wlc_bmac_up_finish) (wlc_hw_info_t * wlc_hw) {
+int wlc_bmac_up_finish(wlc_hw_info_t *wlc_hw)
+{
 	WL_TRACE(("wl%d: %s:\n", wlc_hw->unit, __func__));
 
-	wlc_hw->up = TRUE;
-	wlc_phy_hw_state_upd(wlc_hw->band->pi, TRUE);
+	wlc_hw->up = true;
+	wlc_phy_hw_state_upd(wlc_hw->band->pi, true);
 
 	/* FULLY enable dynamic power control and d11 core interrupt */
 	wlc_clkctl_clk(wlc_hw, CLK_DYNAMIC);
@@ -1236,7 +1248,8 @@ int BCMINITFN(wlc_bmac_up_finish) (wlc_hw_info_t * wlc_hw) {
 	return 0;
 }
 
-int BCMUNINITFN(wlc_bmac_down_prep) (wlc_hw_info_t * wlc_hw) {
+int wlc_bmac_down_prep(wlc_hw_info_t *wlc_hw)
+{
 	bool dev_gone;
 	uint callbacks = 0;
 
@@ -1263,7 +1276,8 @@ int BCMUNINITFN(wlc_bmac_down_prep) (wlc_hw_info_t * wlc_hw) {
 	return callbacks;
 }
 
-int BCMUNINITFN(wlc_bmac_down_finish) (wlc_hw_info_t * wlc_hw) {
+int wlc_bmac_down_finish(wlc_hw_info_t *wlc_hw)
+{
 	uint callbacks = 0;
 	bool dev_gone;
 
@@ -1272,15 +1286,15 @@ int BCMUNINITFN(wlc_bmac_down_finish) (wlc_hw_info_t * wlc_hw) {
 	if (!wlc_hw->up)
 		return callbacks;
 
-	wlc_hw->up = FALSE;
-	wlc_phy_hw_state_upd(wlc_hw->band->pi, FALSE);
+	wlc_hw->up = false;
+	wlc_phy_hw_state_upd(wlc_hw->band->pi, false);
 
 	dev_gone = DEVICEREMOVED(wlc_hw->wlc);
 
 	if (dev_gone) {
-		wlc_hw->sbclk = FALSE;
-		wlc_hw->clk = FALSE;
-		wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, FALSE);
+		wlc_hw->sbclk = false;
+		wlc_hw->clk = false;
+		wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, false);
 
 		/* reclaim any posted packets */
 		wlc_flushqueues(wlc_hw->wlc);
@@ -1306,13 +1320,13 @@ int BCMUNINITFN(wlc_bmac_down_finish) (wlc_hw_info_t * wlc_hw) {
 	return callbacks;
 }
 
-void wlc_bmac_wait_for_wake(wlc_hw_info_t * wlc_hw)
+void wlc_bmac_wait_for_wake(wlc_hw_info_t *wlc_hw)
 {
 	if (D11REV_IS(wlc_hw->corerev, 4))	/* no slowclock */
-		OSL_DELAY(5);
+		udelay(5);
 	else {
 		/* delay before first read of ucode state */
-		OSL_DELAY(40);
+		udelay(40);
 
 		/* wait until ucode is no longer asleep */
 		SPINWAIT((wlc_bmac_read_shm(wlc_hw, M_UCODE_DBGST) ==
@@ -1322,29 +1336,29 @@ void wlc_bmac_wait_for_wake(wlc_hw_info_t * wlc_hw)
 	ASSERT(wlc_bmac_read_shm(wlc_hw, M_UCODE_DBGST) != DBGST_ASLEEP);
 }
 
-void wlc_bmac_hw_etheraddr(wlc_hw_info_t * wlc_hw, struct ether_addr *ea)
+void wlc_bmac_hw_etheraddr(wlc_hw_info_t *wlc_hw, struct ether_addr *ea)
 {
 	bcopy(&wlc_hw->etheraddr, ea, ETHER_ADDR_LEN);
 }
 
-void wlc_bmac_set_hw_etheraddr(wlc_hw_info_t * wlc_hw, struct ether_addr *ea)
+void wlc_bmac_set_hw_etheraddr(wlc_hw_info_t *wlc_hw, struct ether_addr *ea)
 {
 	bcopy(ea, &wlc_hw->etheraddr, ETHER_ADDR_LEN);
 }
 
-int wlc_bmac_bandtype(wlc_hw_info_t * wlc_hw)
+int wlc_bmac_bandtype(wlc_hw_info_t *wlc_hw)
 {
-	return (wlc_hw->band->bandtype);
+	return wlc_hw->band->bandtype;
 }
 
-void *wlc_cur_phy(wlc_info_t * wlc)
+void *wlc_cur_phy(wlc_info_t *wlc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
-	return ((void *)wlc_hw->band->pi);
+	return (void *)wlc_hw->band->pi;
 }
 
 /* control chip clock to save power, enable dynamic clock or force fast clock */
-static void wlc_clkctl_clk(wlc_hw_info_t * wlc_hw, uint mode)
+static void wlc_clkctl_clk(wlc_hw_info_t *wlc_hw, uint mode)
 {
 	if (PMUCTL_ENAB(wlc_hw->sih)) {
 		/* new chips with PMU, CCS_FORCEHT will distribute the HT clock on backplane,
@@ -1358,7 +1372,7 @@ static void wlc_clkctl_clk(wlc_hw_info_t * wlc_hw, uint mode)
 				OR_REG(wlc_hw->osh, &wlc_hw->regs->clk_ctl_st,
 				       CCS_FORCEHT);
 
-				OSL_DELAY(64);
+				udelay(64);
 
 				SPINWAIT(((R_REG
 					   (wlc_hw->osh,
@@ -1441,10 +1455,11 @@ static void wlc_clkctl_clk(wlc_hw_info_t * wlc_hw, uint mode)
 
 /* set initial host flags value */
 static void
-BCMINITFN(wlc_mhfdef) (wlc_info_t * wlc, uint16 * mhfs, uint16 mhf2_init) {
+wlc_mhfdef(wlc_info_t *wlc, u16 *mhfs, u16 mhf2_init)
+{
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 
-	bzero(mhfs, sizeof(uint16) * MHFMAX);
+	bzero(mhfs, sizeof(u16) * MHFMAX);
 
 	mhfs[MHF2] |= mhf2_init;
 
@@ -1470,19 +1485,19 @@ BCMINITFN(wlc_mhfdef) (wlc_info_t * wlc, uint16 * mhfs, uint16 mhf2_init) {
  *                   WLC_BAND_ALL  <--- All bands
  */
 void
-wlc_bmac_mhf(wlc_hw_info_t * wlc_hw, uint8 idx, uint16 mask, uint16 val,
+wlc_bmac_mhf(wlc_hw_info_t *wlc_hw, u8 idx, u16 mask, u16 val,
 	     int bands)
 {
-	uint16 save;
-	uint16 addr[MHFMAX] =
-	    { M_HOST_FLAGS1, M_HOST_FLAGS2, M_HOST_FLAGS3, M_HOST_FLAGS4,
+	u16 save;
+	u16 addr[MHFMAX] = {
+		M_HOST_FLAGS1, M_HOST_FLAGS2, M_HOST_FLAGS3, M_HOST_FLAGS4,
 		M_HOST_FLAGS5
 	};
 	wlc_hwband_t *band;
 
 	ASSERT((val & ~mask) == 0);
 	ASSERT(idx < MHFMAX);
-	ASSERT(ARRAYSIZE(addr) == MHFMAX);
+	ASSERT(ARRAY_SIZE(addr) == MHFMAX);
 
 	switch (bands) {
 		/* Current band only or all bands,
@@ -1513,7 +1528,7 @@ wlc_bmac_mhf(wlc_hw_info_t * wlc_hw, uint8 idx, uint16 mask, uint16 val,
 		if (wlc_hw->clk && (band->mhfs[idx] != save)
 		    && (band == wlc_hw->band))
 			wlc_bmac_write_shm(wlc_hw, addr[idx],
-					   (uint16) band->mhfs[idx]);
+					   (u16) band->mhfs[idx]);
 	}
 
 	if (bands == WLC_BAND_ALL) {
@@ -1524,7 +1539,7 @@ wlc_bmac_mhf(wlc_hw_info_t * wlc_hw, uint8 idx, uint16 mask, uint16 val,
 	}
 }
 
-uint16 wlc_bmac_mhf_get(wlc_hw_info_t * wlc_hw, uint8 idx, int bands)
+u16 wlc_bmac_mhf_get(wlc_hw_info_t *wlc_hw, u8 idx, int bands)
 {
 	wlc_hwband_t *band;
 	ASSERT(idx < MHFMAX);
@@ -1550,15 +1565,15 @@ uint16 wlc_bmac_mhf_get(wlc_hw_info_t * wlc_hw, uint8 idx, int bands)
 	return band->mhfs[idx];
 }
 
-static void wlc_write_mhf(wlc_hw_info_t * wlc_hw, uint16 * mhfs)
+static void wlc_write_mhf(wlc_hw_info_t *wlc_hw, u16 *mhfs)
 {
-	uint8 idx;
-	uint16 addr[] =
-	    { M_HOST_FLAGS1, M_HOST_FLAGS2, M_HOST_FLAGS3, M_HOST_FLAGS4,
+	u8 idx;
+	u16 addr[] = {
+		M_HOST_FLAGS1, M_HOST_FLAGS2, M_HOST_FLAGS3, M_HOST_FLAGS4,
 		M_HOST_FLAGS5
 	};
 
-	ASSERT(ARRAYSIZE(addr) == MHFMAX);
+	ASSERT(ARRAY_SIZE(addr) == MHFMAX);
 
 	for (idx = 0; idx < MHFMAX; idx++) {
 		wlc_bmac_write_shm(wlc_hw, addr[idx], mhfs[idx]);
@@ -1568,7 +1583,7 @@ static void wlc_write_mhf(wlc_hw_info_t * wlc_hw, uint16 * mhfs)
 /* set the maccontrol register to desired reset state and
  * initialize the sw cache of the register
  */
-static void wlc_mctrl_reset(wlc_hw_info_t * wlc_hw)
+static void wlc_mctrl_reset(wlc_hw_info_t *wlc_hw)
 {
 	/* IHR accesses are always enabled, PSM disabled, HPS off and WAKE on */
 	wlc_hw->maccontrol = 0;
@@ -1579,10 +1594,10 @@ static void wlc_mctrl_reset(wlc_hw_info_t * wlc_hw)
 }
 
 /* set or clear maccontrol bits */
-void wlc_bmac_mctrl(wlc_hw_info_t * wlc_hw, uint32 mask, uint32 val)
+void wlc_bmac_mctrl(wlc_hw_info_t *wlc_hw, u32 mask, u32 val)
 {
-	uint32 maccontrol;
-	uint32 new_maccontrol;
+	u32 maccontrol;
+	u32 new_maccontrol;
 
 	ASSERT((val & ~mask) == 0);
 
@@ -1601,9 +1616,9 @@ void wlc_bmac_mctrl(wlc_hw_info_t * wlc_hw, uint32 mask, uint32 val)
 }
 
 /* write the software state of maccontrol and overrides to the maccontrol register */
-static void wlc_mctrl_write(wlc_hw_info_t * wlc_hw)
+static void wlc_mctrl_write(wlc_hw_info_t *wlc_hw)
 {
-	uint32 maccontrol = wlc_hw->maccontrol;
+	u32 maccontrol = wlc_hw->maccontrol;
 
 	/* OR in the wake bit if overridden */
 	if (wlc_hw->wake_override)
@@ -1618,7 +1633,7 @@ static void wlc_mctrl_write(wlc_hw_info_t * wlc_hw)
 	W_REG(wlc_hw->osh, &wlc_hw->regs->maccontrol, maccontrol);
 }
 
-void wlc_ucode_wake_override_set(wlc_hw_info_t * wlc_hw, uint32 override_bit)
+void wlc_ucode_wake_override_set(wlc_hw_info_t *wlc_hw, u32 override_bit)
 {
 	ASSERT((wlc_hw->wake_override & override_bit) == 0);
 
@@ -1635,7 +1650,7 @@ void wlc_ucode_wake_override_set(wlc_hw_info_t * wlc_hw, uint32 override_bit)
 	return;
 }
 
-void wlc_ucode_wake_override_clear(wlc_hw_info_t * wlc_hw, uint32 override_bit)
+void wlc_ucode_wake_override_clear(wlc_hw_info_t *wlc_hw, u32 override_bit)
 {
 	ASSERT(wlc_hw->wake_override & override_bit);
 
@@ -1656,7 +1671,7 @@ void wlc_ucode_wake_override_clear(wlc_hw_info_t * wlc_hw, uint32 override_bit)
  * STA               0              1 <--- This will ensure no beacons
  * IBSS              0              0
  */
-static void wlc_ucode_mute_override_set(wlc_hw_info_t * wlc_hw)
+static void wlc_ucode_mute_override_set(wlc_hw_info_t *wlc_hw)
 {
 	wlc_hw->mute_override = 1;
 
@@ -1672,7 +1687,7 @@ static void wlc_ucode_mute_override_set(wlc_hw_info_t * wlc_hw)
 }
 
 /* Clear the override on AP and INFRA bits */
-static void wlc_ucode_mute_override_clear(wlc_hw_info_t * wlc_hw)
+static void wlc_ucode_mute_override_clear(wlc_hw_info_t *wlc_hw)
 {
 	if (wlc_hw->mute_override == 0)
 		return;
@@ -1692,14 +1707,13 @@ static void wlc_ucode_mute_override_clear(wlc_hw_info_t * wlc_hw)
  * Write a MAC address to the rcmta structure
  */
 void
-wlc_bmac_set_rcmta(wlc_hw_info_t * wlc_hw, int idx,
+wlc_bmac_set_rcmta(wlc_hw_info_t *wlc_hw, int idx,
 		   const struct ether_addr *addr)
 {
 	d11regs_t *regs = wlc_hw->regs;
-	volatile uint16 *objdata16 =
-	    (volatile uint16 *)(uintptr) & regs->objdata;
-	uint32 mac_hm;
-	uint16 mac_l;
+	volatile u16 *objdata16 = (volatile u16 *)&regs->objdata;
+	u32 mac_hm;
+	u16 mac_l;
 	osl_t *osh;
 
 	WL_TRACE(("wl%d: %s\n", wlc_hw->unit, __func__));
@@ -1726,13 +1740,13 @@ wlc_bmac_set_rcmta(wlc_hw_info_t * wlc_hw, int idx,
  * Write a MAC address to the given match reg offset in the RXE match engine.
  */
 void
-wlc_bmac_set_addrmatch(wlc_hw_info_t * wlc_hw, int match_reg_offset,
+wlc_bmac_set_addrmatch(wlc_hw_info_t *wlc_hw, int match_reg_offset,
 		       const struct ether_addr *addr)
 {
 	d11regs_t *regs;
-	uint16 mac_l;
-	uint16 mac_m;
-	uint16 mac_h;
+	u16 mac_l;
+	u16 mac_m;
+	u16 mac_h;
 	osl_t *osh;
 
 	WL_TRACE(("wl%d: wlc_bmac_set_addrmatch\n", wlc_hw->unit));
@@ -1755,14 +1769,14 @@ wlc_bmac_set_addrmatch(wlc_hw_info_t * wlc_hw, int match_reg_offset,
 }
 
 void
-wlc_bmac_write_template_ram(wlc_hw_info_t * wlc_hw, int offset, int len,
+wlc_bmac_write_template_ram(wlc_hw_info_t *wlc_hw, int offset, int len,
 			    void *buf)
 {
 	d11regs_t *regs;
-	uint32 word;
+	u32 word;
 	bool be_bit;
 #ifdef IL_BIGENDIAN
-	volatile uint16 *dptr = NULL;
+	volatile u16 *dptr = NULL;
 #endif				/* IL_BIGENDIAN */
 	osl_t *osh;
 
@@ -1771,8 +1785,8 @@ wlc_bmac_write_template_ram(wlc_hw_info_t * wlc_hw, int offset, int len,
 	regs = wlc_hw->regs;
 	osh = wlc_hw->osh;
 
-	ASSERT(ISALIGNED(offset, sizeof(uint32)));
-	ASSERT(ISALIGNED(len, sizeof(uint32)));
+	ASSERT(IS_ALIGNED(offset, sizeof(u32)));
+	ASSERT(IS_ALIGNED(len, sizeof(u32)));
 	ASSERT((offset & ~0xffff) == 0);
 
 	W_REG(osh, &regs->tplatewrptr, offset);
@@ -1784,7 +1798,7 @@ wlc_bmac_write_template_ram(wlc_hw_info_t * wlc_hw, int offset, int len,
 	be_bit = (R_REG(osh, &regs->maccontrol) & MCTL_BIGEND) != 0;
 
 	while (len > 0) {
-		bcopy((uint8 *) buf, &word, sizeof(uint32));
+		bcopy((u8 *) buf, &word, sizeof(u32));
 
 		if (be_bit)
 			word = hton32(word);
@@ -1793,12 +1807,12 @@ wlc_bmac_write_template_ram(wlc_hw_info_t * wlc_hw, int offset, int len,
 
 		W_REG(osh, &regs->tplatewrdata, word);
 
-		buf = (uint8 *) buf + sizeof(uint32);
-		len -= sizeof(uint32);
+		buf = (u8 *) buf + sizeof(u32);
+		len -= sizeof(u32);
 	}
 }
 
-void wlc_bmac_set_cwmin(wlc_hw_info_t * wlc_hw, uint16 newmin)
+void wlc_bmac_set_cwmin(wlc_hw_info_t *wlc_hw, u16 newmin)
 {
 	osl_t *osh;
 
@@ -1810,7 +1824,7 @@ void wlc_bmac_set_cwmin(wlc_hw_info_t * wlc_hw, uint16 newmin)
 	W_REG(osh, &wlc_hw->regs->objdata, newmin);
 }
 
-void wlc_bmac_set_cwmax(wlc_hw_info_t * wlc_hw, uint16 newmax)
+void wlc_bmac_set_cwmax(wlc_hw_info_t *wlc_hw, u16 newmax)
 {
 	osl_t *osh;
 
@@ -1822,13 +1836,14 @@ void wlc_bmac_set_cwmax(wlc_hw_info_t * wlc_hw, uint16 newmax)
 	W_REG(osh, &wlc_hw->regs->objdata, newmax);
 }
 
-void wlc_bmac_bw_set(wlc_hw_info_t * wlc_hw, uint16 bw)
+void wlc_bmac_bw_set(wlc_hw_info_t *wlc_hw, u16 bw)
 {
 	bool fastclk;
-	uint32 tmp;
+	u32 tmp;
 
 	/* request FAST clock if not on */
-	if (!(fastclk = wlc_hw->forcefastclk))
+	fastclk = wlc_hw->forcefastclk;
+	if (!fastclk)
 		wlc_clkctl_clk(wlc_hw, CLK_FAST);
 
 	wlc_phy_bw_state_set(wlc_hw->band->pi, bw);
@@ -1846,7 +1861,7 @@ void wlc_bmac_bw_set(wlc_hw_info_t * wlc_hw, uint16 bw)
 }
 
 static void
-wlc_write_hw_bcntemplate0(wlc_hw_info_t * wlc_hw, void *bcn, int len)
+wlc_write_hw_bcntemplate0(wlc_hw_info_t *wlc_hw, void *bcn, int len)
 {
 	d11regs_t *regs = wlc_hw->regs;
 
@@ -1854,13 +1869,13 @@ wlc_write_hw_bcntemplate0(wlc_hw_info_t * wlc_hw, void *bcn, int len)
 				    bcn);
 	/* write beacon length to SCR */
 	ASSERT(len < 65536);
-	wlc_bmac_write_shm(wlc_hw, M_BCN0_FRM_BYTESZ, (uint16) len);
+	wlc_bmac_write_shm(wlc_hw, M_BCN0_FRM_BYTESZ, (u16) len);
 	/* mark beacon0 valid */
 	OR_REG(wlc_hw->osh, &regs->maccommand, MCMD_BCN0VLD);
 }
 
 static void
-wlc_write_hw_bcntemplate1(wlc_hw_info_t * wlc_hw, void *bcn, int len)
+wlc_write_hw_bcntemplate1(wlc_hw_info_t *wlc_hw, void *bcn, int len)
 {
 	d11regs_t *regs = wlc_hw->regs;
 
@@ -1868,14 +1883,14 @@ wlc_write_hw_bcntemplate1(wlc_hw_info_t * wlc_hw, void *bcn, int len)
 				    bcn);
 	/* write beacon length to SCR */
 	ASSERT(len < 65536);
-	wlc_bmac_write_shm(wlc_hw, M_BCN1_FRM_BYTESZ, (uint16) len);
+	wlc_bmac_write_shm(wlc_hw, M_BCN1_FRM_BYTESZ, (u16) len);
 	/* mark beacon1 valid */
 	OR_REG(wlc_hw->osh, &regs->maccommand, MCMD_BCN1VLD);
 }
 
 /* mac is assumed to be suspended at this point */
 void
-wlc_bmac_write_hw_bcntemplates(wlc_hw_info_t * wlc_hw, void *bcn, int len,
+wlc_bmac_write_hw_bcntemplates(wlc_hw_info_t *wlc_hw, void *bcn, int len,
 			       bool both)
 {
 	d11regs_t *regs = wlc_hw->regs;
@@ -1896,8 +1911,9 @@ wlc_bmac_write_hw_bcntemplates(wlc_hw_info_t * wlc_hw, void *bcn, int len,
 	}
 }
 
-static void WLBANDINITFN(wlc_bmac_upd_synthpu) (wlc_hw_info_t * wlc_hw) {
-	uint16 v;
+static void WLBANDINITFN(wlc_bmac_upd_synthpu) (wlc_hw_info_t *wlc_hw)
+{
+	u16 v;
 	wlc_info_t *wlc = wlc_hw->wlc;
 	/* update SYNTHPU_DLY */
 
@@ -1914,7 +1930,8 @@ static void WLBANDINITFN(wlc_bmac_upd_synthpu) (wlc_hw_info_t * wlc_hw) {
 
 /* band-specific init */
 static void
-WLBANDINITFN(wlc_bmac_bsinit) (wlc_info_t * wlc, chanspec_t chanspec) {
+WLBANDINITFN(wlc_bmac_bsinit) (wlc_info_t *wlc, chanspec_t chanspec)
+{
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 
 	WL_TRACE(("wl%d: wlc_bmac_bsinit: bandunit %d\n", wlc_hw->unit,
@@ -1939,12 +1956,12 @@ WLBANDINITFN(wlc_bmac_bsinit) (wlc_info_t * wlc, chanspec_t chanspec) {
 
 	wlc_bmac_update_slot_timing(wlc_hw,
 				    BAND_5G(wlc_hw->band->
-					    bandtype) ? TRUE : wlc_hw->
+					    bandtype) ? true : wlc_hw->
 				    shortslot);
 
 	/* write phytype and phyvers */
-	wlc_bmac_write_shm(wlc_hw, M_PHYTYPE, (uint16) wlc_hw->band->phytype);
-	wlc_bmac_write_shm(wlc_hw, M_PHYVER, (uint16) wlc_hw->band->phyrev);
+	wlc_bmac_write_shm(wlc_hw, M_PHYTYPE, (u16) wlc_hw->band->phytype);
+	wlc_bmac_write_shm(wlc_hw, M_PHYVER, (u16) wlc_hw->band->phyrev);
 
 	/* initialize the txphyctl1 rate table since shmem is shared between bands */
 	wlc_upd_ofdm_pctl1_table(wlc_hw);
@@ -1952,7 +1969,7 @@ WLBANDINITFN(wlc_bmac_bsinit) (wlc_info_t * wlc, chanspec_t chanspec) {
 	wlc_bmac_upd_synthpu(wlc_hw);
 }
 
-void wlc_bmac_core_phy_clk(wlc_hw_info_t * wlc_hw, bool clk)
+void wlc_bmac_core_phy_clk(wlc_hw_info_t *wlc_hw, bool clk)
 {
 	WL_TRACE(("wl%d: wlc_bmac_core_phy_clk: clk %d\n", wlc_hw->unit, clk));
 
@@ -1962,43 +1979,43 @@ void wlc_bmac_core_phy_clk(wlc_hw_info_t * wlc_hw, bool clk)
 
 		si_core_cflags(wlc_hw->sih, (SICF_PRST | SICF_FGC | SICF_GMODE),
 			       (SICF_PRST | SICF_FGC));
-		OSL_DELAY(1);
+		udelay(1);
 		si_core_cflags(wlc_hw->sih, (SICF_PRST | SICF_FGC), SICF_PRST);
-		OSL_DELAY(1);
+		udelay(1);
 
 	} else {		/* take phy out of reset */
 
 		si_core_cflags(wlc_hw->sih, (SICF_PRST | SICF_FGC), SICF_FGC);
-		OSL_DELAY(1);
+		udelay(1);
 		si_core_cflags(wlc_hw->sih, (SICF_FGC), 0);
-		OSL_DELAY(1);
+		udelay(1);
 
 	}
 }
 
 /* Perform a soft reset of the PHY PLL */
-void wlc_bmac_core_phypll_reset(wlc_hw_info_t * wlc_hw)
+void wlc_bmac_core_phypll_reset(wlc_hw_info_t *wlc_hw)
 {
 	WL_TRACE(("wl%d: wlc_bmac_core_phypll_reset\n", wlc_hw->unit));
 
 	si_corereg(wlc_hw->sih, SI_CC_IDX,
-		   OFFSETOF(chipcregs_t, chipcontrol_addr), ~0, 0);
-	OSL_DELAY(1);
+		   offsetof(chipcregs_t, chipcontrol_addr), ~0, 0);
+	udelay(1);
 	si_corereg(wlc_hw->sih, SI_CC_IDX,
-		   OFFSETOF(chipcregs_t, chipcontrol_data), 0x4, 0);
-	OSL_DELAY(1);
+		   offsetof(chipcregs_t, chipcontrol_data), 0x4, 0);
+	udelay(1);
 	si_corereg(wlc_hw->sih, SI_CC_IDX,
-		   OFFSETOF(chipcregs_t, chipcontrol_data), 0x4, 4);
-	OSL_DELAY(1);
+		   offsetof(chipcregs_t, chipcontrol_data), 0x4, 4);
+	udelay(1);
 	si_corereg(wlc_hw->sih, SI_CC_IDX,
-		   OFFSETOF(chipcregs_t, chipcontrol_data), 0x4, 0);
-	OSL_DELAY(1);
+		   offsetof(chipcregs_t, chipcontrol_data), 0x4, 0);
+	udelay(1);
 }
 
 /* light way to turn on phy clock without reset for NPHY only
  *  refer to wlc_bmac_core_phy_clk for full version
  */
-void wlc_bmac_phyclk_fgc(wlc_hw_info_t * wlc_hw, bool clk)
+void wlc_bmac_phyclk_fgc(wlc_hw_info_t *wlc_hw, bool clk)
 {
 	/* support(necessary for NPHY and HYPHY) only */
 	if (!WLCISNPHY(wlc_hw->band))
@@ -2011,7 +2028,7 @@ void wlc_bmac_phyclk_fgc(wlc_hw_info_t * wlc_hw, bool clk)
 
 }
 
-void wlc_bmac_macphyclk_set(wlc_hw_info_t * wlc_hw, bool clk)
+void wlc_bmac_macphyclk_set(wlc_hw_info_t *wlc_hw, bool clk)
 {
 	if (ON == clk)
 		si_core_cflags(wlc_hw->sih, SICF_MPCLKE, SICF_MPCLKE);
@@ -2019,11 +2036,11 @@ void wlc_bmac_macphyclk_set(wlc_hw_info_t * wlc_hw, bool clk)
 		si_core_cflags(wlc_hw->sih, SICF_MPCLKE, 0);
 }
 
-void wlc_bmac_phy_reset(wlc_hw_info_t * wlc_hw)
+void wlc_bmac_phy_reset(wlc_hw_info_t *wlc_hw)
 {
 	wlc_phy_t *pih = wlc_hw->band->pi;
-	uint32 phy_bw_clkbits;
-	bool phy_in_reset = FALSE;
+	u32 phy_bw_clkbits;
+	bool phy_in_reset = false;
 
 	WL_TRACE(("wl%d: wlc_bmac_phy_reset\n", wlc_hw->unit));
 
@@ -2038,7 +2055,7 @@ void wlc_bmac_phy_reset(wlc_hw_info_t * wlc_hw)
 		/* Set the PHY bandwidth */
 		si_core_cflags(wlc_hw->sih, SICF_BWMASK, phy_bw_clkbits);
 
-		OSL_DELAY(1);
+		udelay(1);
 
 		/* Perform a soft reset of the PHY PLL */
 		wlc_bmac_core_phypll_reset(wlc_hw);
@@ -2046,7 +2063,7 @@ void wlc_bmac_phy_reset(wlc_hw_info_t * wlc_hw)
 		/* reset the PHY */
 		si_core_cflags(wlc_hw->sih, (SICF_PRST | SICF_PCLKE),
 			       (SICF_PRST | SICF_PCLKE));
-		phy_in_reset = TRUE;
+		phy_in_reset = true;
 	} else {
 
 		si_core_cflags(wlc_hw->sih,
@@ -2054,7 +2071,7 @@ void wlc_bmac_phy_reset(wlc_hw_info_t * wlc_hw)
 			       (SICF_PRST | SICF_PCLKE | phy_bw_clkbits));
 	}
 
-	OSL_DELAY(2);
+	udelay(2);
 	wlc_bmac_core_phy_clk(wlc_hw, ON);
 
 	if (pih)
@@ -2063,10 +2080,10 @@ void wlc_bmac_phy_reset(wlc_hw_info_t * wlc_hw)
 
 /* switch to and initialize new band */
 static void
-WLBANDINITFN(wlc_bmac_setband) (wlc_hw_info_t * wlc_hw, uint bandunit,
+WLBANDINITFN(wlc_bmac_setband) (wlc_hw_info_t *wlc_hw, uint bandunit,
 				chanspec_t chanspec) {
 	wlc_info_t *wlc = wlc_hw->wlc;
-	uint32 macintmask;
+	u32 macintmask;
 
 	ASSERT(NBANDS_HW(wlc_hw) > 1);
 	ASSERT(bandunit != wlc_hw->band->bandunit);
@@ -2105,7 +2122,8 @@ WLBANDINITFN(wlc_bmac_setband) (wlc_hw_info_t * wlc_hw, uint bandunit,
 }
 
 /* low-level band switch utility routine */
-void WLBANDINITFN(wlc_setxband) (wlc_hw_info_t * wlc_hw, uint bandunit) {
+void WLBANDINITFN(wlc_setxband) (wlc_hw_info_t *wlc_hw, uint bandunit)
+{
 	WL_TRACE(("wl%d: wlc_setxband: bandunit %d\n", wlc_hw->unit, bandunit));
 
 	wlc_hw->band = wlc_hw->bandstate[bandunit];
@@ -2120,23 +2138,25 @@ void WLBANDINITFN(wlc_setxband) (wlc_hw_info_t * wlc_hw, uint bandunit) {
 	}
 }
 
-static bool BCMATTACHFN(wlc_isgoodchip) (wlc_hw_info_t * wlc_hw) {
+static bool wlc_isgoodchip(wlc_hw_info_t *wlc_hw)
+{
 
 	/* reject unsupported corerev */
 	if (!VALID_COREREV(wlc_hw->corerev)) {
 		WL_ERROR(("unsupported core rev %d\n", wlc_hw->corerev));
-		return FALSE;
+		return false;
 	}
 
-	return TRUE;
+	return true;
 }
 
-static bool BCMATTACHFN(wlc_validboardtype) (wlc_hw_info_t * wlc_hw) {
-	bool goodboard = TRUE;
+static bool wlc_validboardtype(wlc_hw_info_t *wlc_hw)
+{
+	bool goodboard = true;
 	uint boardrev = wlc_hw->boardrev;
 
 	if (boardrev == 0)
-		goodboard = FALSE;
+		goodboard = false;
 	else if (boardrev > 0xff) {
 		uint brt = (boardrev & 0xf000) >> 12;
 		uint b0 = (boardrev & 0xf00) >> 8;
@@ -2145,7 +2165,7 @@ static bool BCMATTACHFN(wlc_validboardtype) (wlc_hw_info_t * wlc_hw) {
 
 		if ((brt > 2) || (brt == 0) || (b0 > 9) || (b0 == 0) || (b1 > 9)
 		    || (b2 > 9))
-			goodboard = FALSE;
+			goodboard = false;
 	}
 
 	if (wlc_hw->sih->boardvendor != VENDOR_BROADCOM)
@@ -2154,12 +2174,14 @@ static bool BCMATTACHFN(wlc_validboardtype) (wlc_hw_info_t * wlc_hw) {
 	return goodboard;
 }
 
-static char *BCMINITFN(wlc_get_macaddr) (wlc_hw_info_t * wlc_hw) {
+static char *wlc_get_macaddr(wlc_hw_info_t *wlc_hw)
+{
 	const char *varname = "macaddr";
 	char *macaddr;
 
 	/* If macaddr exists, use it (Sromrev4, CIS, ...). */
-	if ((macaddr = getvar(wlc_hw->vars, varname)) != NULL)
+	macaddr = getvar(wlc_hw->vars, varname);
+	if (macaddr != NULL)
 		return macaddr;
 
 	if (NBANDS_HW(wlc_hw) > 1)
@@ -2167,7 +2189,8 @@ static char *BCMINITFN(wlc_get_macaddr) (wlc_hw_info_t * wlc_hw) {
 	else
 		varname = "il0macaddr";
 
-	if ((macaddr = getvar(wlc_hw->vars, varname)) == NULL) {
+	macaddr = getvar(wlc_hw->vars, varname);
+	if (macaddr == NULL) {
 		WL_ERROR(("wl%d: wlc_get_macaddr: macaddr getvar(%s) not found\n", wlc_hw->unit, varname));
 	}
 
@@ -2175,15 +2198,15 @@ static char *BCMINITFN(wlc_get_macaddr) (wlc_hw_info_t * wlc_hw) {
 }
 
 /*
- * Return TRUE if radio is disabled, otherwise FALSE.
+ * Return true if radio is disabled, otherwise false.
  * hw radio disable signal is an external pin, users activate it asynchronously
  * this function could be called when driver is down and w/o clock
  * it operates on different registers depending on corerev and boardflag.
  */
-bool wlc_bmac_radio_read_hwdisabled(wlc_hw_info_t * wlc_hw)
+bool wlc_bmac_radio_read_hwdisabled(wlc_hw_info_t *wlc_hw)
 {
 	bool v, clk, xtal;
-	uint32 resetbits = 0, flags = 0;
+	u32 resetbits = 0, flags = 0;
 
 	xtal = wlc_hw->sbclk;
 	if (!xtal)
@@ -2222,11 +2245,12 @@ bool wlc_bmac_radio_read_hwdisabled(wlc_hw_info_t * wlc_hw)
 	if (!xtal)
 		wlc_bmac_xtal(wlc_hw, OFF);
 
-	return (v);
+	return v;
 }
 
 /* Initialize just the hardware when coming out of POR or S3/S5 system states */
-void BCMINITFN(wlc_bmac_hw_up) (wlc_hw_info_t * wlc_hw) {
+void wlc_bmac_hw_up(wlc_hw_info_t *wlc_hw)
+{
 	if (wlc_hw->wlc->pub->hw_up)
 		return;
 
@@ -2255,8 +2279,8 @@ void BCMINITFN(wlc_bmac_hw_up) (wlc_hw_info_t * wlc_hw) {
 	/* Inform phy that a POR reset has occurred so it does a complete phy init */
 	wlc_phy_por_inform(wlc_hw->band->pi);
 
-	wlc_hw->ucode_loaded = FALSE;
-	wlc_hw->wlc->pub->hw_up = TRUE;
+	wlc_hw->ucode_loaded = false;
+	wlc_hw->wlc->pub->hw_up = true;
 
 	if ((wlc_hw->boardflags & BFL_FEM)
 	    && (CHIPID(wlc_hw->sih->chip) == BCM4313_CHIP_ID)) {
@@ -2267,14 +2291,14 @@ void BCMINITFN(wlc_bmac_hw_up) (wlc_hw_info_t * wlc_hw) {
 	}
 }
 
-static bool wlc_dma_rxreset(wlc_hw_info_t * wlc_hw, uint fifo)
+static bool wlc_dma_rxreset(wlc_hw_info_t *wlc_hw, uint fifo)
 {
 	hnddma_t *di = wlc_hw->di[fifo];
 	osl_t *osh;
 
 	if (D11REV_LT(wlc_hw->corerev, 12)) {
-		bool rxidle = TRUE;
-		uint16 rcv_frm_cnt = 0;
+		bool rxidle = true;
+		u16 rcv_frm_cnt = 0;
 
 		osh = wlc_hw->osh;
 
@@ -2286,10 +2310,10 @@ static bool wlc_dma_rxreset(wlc_hw_info_t * wlc_hw, uint fifo)
 
 		if (!rxidle && (rcv_frm_cnt != 0))
 			WL_ERROR(("wl%d: %s: rxdma[%d] not idle && rcv_frm_cnt(%d) not zero\n", wlc_hw->unit, __func__, fifo, rcv_frm_cnt));
-		OSL_DELAY(2000);
+		mdelay(2);
 	}
 
-	return (dma_rxreset(di));
+	return dma_rxreset(di);
 }
 
 /* d11 core reset
@@ -2300,11 +2324,12 @@ static bool wlc_dma_rxreset(wlc_hw_info_t * wlc_hw, uint fifo)
  *   clear software macintstatus for fresh new start
  * one testing hack wlc_hw->noreset will bypass the d11/phy reset
  */
-void BCMINITFN(wlc_bmac_corereset) (wlc_hw_info_t * wlc_hw, uint32 flags) {
+void wlc_bmac_corereset(wlc_hw_info_t *wlc_hw, u32 flags)
+{
 	d11regs_t *regs;
 	uint i;
 	bool fastclk;
-	uint32 resetbits = 0;
+	u32 resetbits = 0;
 
 	if (flags == WLC_USE_COREFLAGS)
 		flags = (wlc_hw->band->pi ? wlc_hw->band->core_flags : 0);
@@ -2314,7 +2339,8 @@ void BCMINITFN(wlc_bmac_corereset) (wlc_hw_info_t * wlc_hw, uint32 flags) {
 	regs = wlc_hw->regs;
 
 	/* request FAST clock if not on  */
-	if (!(fastclk = wlc_hw->forcefastclk))
+	fastclk = wlc_hw->forcefastclk;
+	if (!fastclk)
 		wlc_clkctl_clk(wlc_hw, CLK_FAST);
 
 	/* reset the dma engines except first time thru */
@@ -2359,11 +2385,11 @@ void BCMINITFN(wlc_bmac_corereset) (wlc_hw_info_t * wlc_hw, uint32 flags) {
 	 *  chipcommon during this period if necessary. But that has to work coordinate
 	 *  with other driver like mips/arm since they may touch chipcommon as well.
 	 */
-	wlc_hw->clk = FALSE;
+	wlc_hw->clk = false;
 	si_core_reset(wlc_hw->sih, flags, resetbits);
-	wlc_hw->clk = TRUE;
+	wlc_hw->clk = true;
 	if (wlc_hw->band && wlc_hw->band->pi)
-		wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, TRUE);
+		wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, true);
 
 	wlc_mctrl_reset(wlc_hw);
 
@@ -2373,7 +2399,7 @@ void BCMINITFN(wlc_bmac_corereset) (wlc_hw_info_t * wlc_hw, uint32 flags) {
 	wlc_bmac_phy_reset(wlc_hw);
 
 	/* turn on PHY_PLL */
-	wlc_bmac_core_phypll_ctl(wlc_hw, TRUE);
+	wlc_bmac_core_phypll_ctl(wlc_hw, true);
 
 	/* clear sw intstatus */
 	wlc_hw->wlc->macintstatus = 0;
@@ -2387,12 +2413,13 @@ void BCMINITFN(wlc_bmac_corereset) (wlc_hw_info_t * wlc_hw, uint32 flags) {
  * txfifo sizes needs to be modified(increased) since the newer cores
  * have more memory.
  */
-static void BCMINITFN(wlc_corerev_fifofixup) (wlc_hw_info_t * wlc_hw) {
+static void wlc_corerev_fifofixup(wlc_hw_info_t *wlc_hw)
+{
 	d11regs_t *regs = wlc_hw->regs;
-	uint16 fifo_nu;
-	uint16 txfifo_startblk = TXFIFO_START_BLK, txfifo_endblk;
-	uint16 txfifo_def, txfifo_def1;
-	uint16 txfifo_cmd;
+	u16 fifo_nu;
+	u16 txfifo_startblk = TXFIFO_START_BLK, txfifo_endblk;
+	u16 txfifo_def, txfifo_def1;
+	u16 txfifo_cmd;
 	osl_t *osh;
 
 	if (D11REV_LT(wlc_hw->corerev, 9))
@@ -2446,16 +2473,17 @@ static void BCMINITFN(wlc_corerev_fifofixup) (wlc_hw_info_t * wlc_hw) {
  *   config other core registers
  *   init dma
  */
-static void BCMINITFN(wlc_coreinit) (wlc_info_t * wlc) {
+static void wlc_coreinit(wlc_info_t *wlc)
+{
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs;
-	uint32 sflags;
+	u32 sflags;
 	uint bcnint_us;
 	uint i = 0;
-	bool fifosz_fixup = FALSE;
+	bool fifosz_fixup = false;
 	osl_t *osh;
 	int err = 0;
-	uint16 buf[NFIFO];
+	u16 buf[NFIFO];
 
 	regs = wlc_hw->regs;
 	osh = wlc_hw->osh;
@@ -2472,7 +2500,7 @@ static void BCMINITFN(wlc_coreinit) (wlc_info_t * wlc) {
 	 * 2) newer chips, driver wants to controls the fifo allocation
 	 */
 	if (D11REV_GE(wlc_hw->corerev, 4))
-		fifosz_fixup = TRUE;
+		fifosz_fixup = true;
 
 	/* let the PSM run to the suspended state, set mode to BSS STA */
 	W_REG(osh, &regs->macintstatus, -1);
@@ -2509,7 +2537,7 @@ static void BCMINITFN(wlc_coreinit) (wlc_info_t * wlc) {
 	}
 
 	/* For old ucode, txfifo sizes needs to be modified(increased) for Corerev >= 9 */
-	if (fifosz_fixup == TRUE) {
+	if (fifosz_fixup == true) {
 		wlc_corerev_fifofixup(wlc_hw);
 	}
 
@@ -2597,14 +2625,14 @@ static void BCMINITFN(wlc_coreinit) (wlc_info_t * wlc) {
 	}
 
 	/* tell the ucode the corerev */
-	wlc_bmac_write_shm(wlc_hw, M_MACHW_VER, (uint16) wlc_hw->corerev);
+	wlc_bmac_write_shm(wlc_hw, M_MACHW_VER, (u16) wlc_hw->corerev);
 
 	/* tell the ucode MAC capabilities */
 	if (D11REV_GE(wlc_hw->corerev, 13)) {
 		wlc_bmac_write_shm(wlc_hw, M_MACHW_CAP_L,
-				   (uint16) (wlc_hw->machwcap & 0xffff));
+				   (u16) (wlc_hw->machwcap & 0xffff));
 		wlc_bmac_write_shm(wlc_hw, M_MACHW_CAP_H,
-				   (uint16) ((wlc_hw->
+				   (u16) ((wlc_hw->
 					      machwcap >> 16) & 0xffff));
 	}
 
@@ -2656,7 +2684,7 @@ static void BCMINITFN(wlc_coreinit) (wlc_info_t * wlc) {
  *  - 559241 = 0x88889 => tsf_clk_frac_h = 0x8, tsf_clk_frac_l = 0x8889
  */
 
-void wlc_bmac_switch_macfreq(wlc_hw_info_t * wlc_hw, uint8 spurmode)
+void wlc_bmac_switch_macfreq(wlc_hw_info_t *wlc_hw, u8 spurmode)
 {
 	d11regs_t *regs;
 	osl_t *osh;
@@ -2687,10 +2715,11 @@ void wlc_bmac_switch_macfreq(wlc_hw_info_t * wlc_hw, uint8 spurmode)
 }
 
 /* Initialize GPIOs that are controlled by D11 core */
-static void BCMINITFN(wlc_gpio_init) (wlc_info_t * wlc) {
+static void wlc_gpio_init(wlc_info_t *wlc)
+{
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs;
-	uint32 gc, gm;
+	u32 gc, gm;
 	osl_t *osh;
 
 	regs = wlc_hw->regs;
@@ -2719,7 +2748,7 @@ static void BCMINITFN(wlc_gpio_init) (wlc_info_t * wlc) {
 				     MHF3_ANTSEL_MODE, WLC_BAND_ALL);
 
 			/* init superswitch control */
-			wlc_phy_antsel_init(wlc_hw->band->pi, FALSE);
+			wlc_phy_antsel_init(wlc_hw->band->pi, false);
 
 		} else if (wlc_hw->antsel_type == ANTSEL_2x4) {
 			ASSERT((gm & BOARD_GPIO_12) == 0);
@@ -2751,7 +2780,8 @@ static void BCMINITFN(wlc_gpio_init) (wlc_info_t * wlc) {
 	si_gpiocontrol(wlc_hw->sih, gm, gc, GPIO_DRV_PRIORITY);
 }
 
-static void BCMATTACHFN(wlc_ucode_download) (wlc_hw_info_t * wlc_hw) {
+static void wlc_ucode_download(wlc_hw_info_t *wlc_hw)
+{
 	wlc_info_t *wlc;
 	wlc = wlc_hw->wlc;
 
@@ -2762,7 +2792,7 @@ static void BCMATTACHFN(wlc_ucode_download) (wlc_hw_info_t * wlc_hw) {
 		if (WLCISNPHY(wlc_hw->band)) {
 			wlc_ucode_write(wlc_hw, bcm43xx_16_mimo,
 					bcm43xx_16_mimosz);
-			wlc_hw->ucode_loaded = TRUE;
+			wlc_hw->ucode_loaded = true;
 		} else
 			WL_ERROR(("%s: wl%d: unsupported phy in corerev %d\n",
 				  __func__, wlc_hw->unit, wlc_hw->corerev));
@@ -2770,7 +2800,7 @@ static void BCMATTACHFN(wlc_ucode_download) (wlc_hw_info_t * wlc_hw) {
 		if (WLCISLCNPHY(wlc_hw->band)) {
 			wlc_ucode_write(wlc_hw, bcm43xx_24_lcn,
 					bcm43xx_24_lcnsz);
-			wlc_hw->ucode_loaded = TRUE;
+			wlc_hw->ucode_loaded = true;
 		} else {
 			WL_ERROR(("%s: wl%d: unsupported phy in corerev %d\n",
 				  __func__, wlc_hw->unit, wlc_hw->corerev));
@@ -2778,8 +2808,7 @@ static void BCMATTACHFN(wlc_ucode_download) (wlc_hw_info_t * wlc_hw) {
 	}
 }
 
-static void
-BCMATTACHFN(wlc_ucode_write) (wlc_hw_info_t * wlc_hw, const uint32 ucode[],
+static void wlc_ucode_write(wlc_hw_info_t *wlc_hw, const u32 ucode[],
 			      const uint nbytes) {
 	osl_t *osh;
 	d11regs_t *regs = wlc_hw->regs;
@@ -2790,9 +2819,9 @@ BCMATTACHFN(wlc_ucode_write) (wlc_hw_info_t * wlc_hw, const uint32 ucode[],
 
 	WL_TRACE(("wl%d: wlc_ucode_write\n", wlc_hw->unit));
 
-	ASSERT(ISALIGNED(nbytes, sizeof(uint32)));
+	ASSERT(IS_ALIGNED(nbytes, sizeof(u32)));
 
-	count = (nbytes / sizeof(uint32));
+	count = (nbytes / sizeof(u32));
 
 	W_REG(osh, &regs->objaddr, (OBJADDR_AUTO_INC | OBJADDR_UCM_SEL));
 	(void)R_REG(osh, &regs->objaddr);
@@ -2800,34 +2829,34 @@ BCMATTACHFN(wlc_ucode_write) (wlc_hw_info_t * wlc_hw, const uint32 ucode[],
 		W_REG(osh, &regs->objdata, ucode[i]);
 }
 
-static void wlc_write_inits(wlc_hw_info_t * wlc_hw, const d11init_t * inits)
+static void wlc_write_inits(wlc_hw_info_t *wlc_hw, const d11init_t *inits)
 {
 	int i;
 	osl_t *osh;
-	volatile uint8 *base;
+	volatile u8 *base;
 
 	WL_TRACE(("wl%d: wlc_write_inits\n", wlc_hw->unit));
 
 	osh = wlc_hw->osh;
-	base = (volatile uint8 *)wlc_hw->regs;
+	base = (volatile u8 *)wlc_hw->regs;
 
 	for (i = 0; inits[i].addr != 0xffff; i++) {
 		ASSERT((inits[i].size == 2) || (inits[i].size == 4));
 
 		if (inits[i].size == 2)
-			W_REG(osh, (uint16 *) (uintptr) (base + inits[i].addr),
+			W_REG(osh, (u16 *)(base + inits[i].addr),
 			      inits[i].value);
 		else if (inits[i].size == 4)
-			W_REG(osh, (uint32 *) (uintptr) (base + inits[i].addr),
+			W_REG(osh, (u32 *)(base + inits[i].addr),
 			      inits[i].value);
 	}
 }
 
-static void wlc_ucode_txant_set(wlc_hw_info_t * wlc_hw)
+static void wlc_ucode_txant_set(wlc_hw_info_t *wlc_hw)
 {
-	uint16 phyctl;
-	uint16 phytxant = wlc_hw->bmac_phytxant;
-	uint16 mask = PHY_TXC_ANT_MASK;
+	u16 phyctl;
+	u16 phytxant = wlc_hw->bmac_phytxant;
+	u16 mask = PHY_TXC_ANT_MASK;
 
 	/* set the Probe Response frame phy control word */
 	phyctl = wlc_bmac_read_shm(wlc_hw, M_CTXPRS_BLK + C_CTX_PCTLWD_POS);
@@ -2840,7 +2869,7 @@ static void wlc_ucode_txant_set(wlc_hw_info_t * wlc_hw)
 	wlc_bmac_write_shm(wlc_hw, M_RSP_PCTLWD, phyctl);
 }
 
-void wlc_bmac_txant_set(wlc_hw_info_t * wlc_hw, uint16 phytxant)
+void wlc_bmac_txant_set(wlc_hw_info_t *wlc_hw, u16 phytxant)
 {
 	/* update sw state */
 	wlc_hw->bmac_phytxant = phytxant;
@@ -2852,12 +2881,12 @@ void wlc_bmac_txant_set(wlc_hw_info_t * wlc_hw, uint16 phytxant)
 
 }
 
-uint16 wlc_bmac_get_txant(wlc_hw_info_t * wlc_hw)
+u16 wlc_bmac_get_txant(wlc_hw_info_t *wlc_hw)
 {
-	return (uint16) wlc_hw->wlc->stf->txant;
+	return (u16) wlc_hw->wlc->stf->txant;
 }
 
-void wlc_bmac_antsel_type_set(wlc_hw_info_t * wlc_hw, uint8 antsel_type)
+void wlc_bmac_antsel_type_set(wlc_hw_info_t *wlc_hw, u8 antsel_type)
 {
 	wlc_hw->antsel_type = antsel_type;
 
@@ -2865,9 +2894,9 @@ void wlc_bmac_antsel_type_set(wlc_hw_info_t * wlc_hw, uint8 antsel_type)
 	wlc_phy_antsel_type_set(wlc_hw->band->pi, antsel_type);
 }
 
-void wlc_bmac_fifoerrors(wlc_hw_info_t * wlc_hw)
+void wlc_bmac_fifoerrors(wlc_hw_info_t *wlc_hw)
 {
-	bool fatal = FALSE;
+	bool fatal = false;
 	uint unit;
 	uint intstatus, idx;
 	d11regs_t *regs = wlc_hw->regs;
@@ -2889,27 +2918,27 @@ void wlc_bmac_fifoerrors(wlc_hw_info_t * wlc_hw)
 			WL_ERROR(("wl%d: fifo %d: receive fifo overflow\n",
 				  unit, idx));
 			WLCNTINCR(wlc_hw->wlc->pub->_cnt->rxoflo);
-			fatal = TRUE;
+			fatal = true;
 		}
 
 		if (intstatus & I_PC) {
 			WL_ERROR(("wl%d: fifo %d: descriptor error\n", unit,
 				  idx));
 			WLCNTINCR(wlc_hw->wlc->pub->_cnt->dmade);
-			fatal = TRUE;
+			fatal = true;
 		}
 
 		if (intstatus & I_PD) {
 			WL_ERROR(("wl%d: fifo %d: data error\n", unit, idx));
 			WLCNTINCR(wlc_hw->wlc->pub->_cnt->dmada);
-			fatal = TRUE;
+			fatal = true;
 		}
 
 		if (intstatus & I_DE) {
 			WL_ERROR(("wl%d: fifo %d: descriptor protocol error\n",
 				  unit, idx));
 			WLCNTINCR(wlc_hw->wlc->pub->_cnt->dmape);
-			fatal = TRUE;
+			fatal = true;
 		}
 
 		if (intstatus & I_RU) {
@@ -2921,7 +2950,7 @@ void wlc_bmac_fifoerrors(wlc_hw_info_t * wlc_hw)
 			WL_ERROR(("wl%d: fifo %d: transmit fifo underflow\n",
 				  idx, unit));
 			WLCNTINCR(wlc_hw->wlc->pub->_cnt->txuflo);
-			fatal = TRUE;
+			fatal = true;
 		}
 
 		if (fatal) {
@@ -2933,7 +2962,7 @@ void wlc_bmac_fifoerrors(wlc_hw_info_t * wlc_hw)
 	}
 }
 
-void wlc_intrson(wlc_info_t * wlc)
+void wlc_intrson(wlc_info_t *wlc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	ASSERT(wlc->defmacintmask);
@@ -2946,7 +2975,7 @@ void wlc_intrson(wlc_info_t * wlc)
  *  but also because per-port code may require sync with valid interrupt.
  */
 
-static uint32 wlc_wlintrsoff(wlc_info_t * wlc)
+static u32 wlc_wlintrsoff(wlc_info_t *wlc)
 {
 	if (!wlc->hw->up)
 		return 0;
@@ -2954,7 +2983,7 @@ static uint32 wlc_wlintrsoff(wlc_info_t * wlc)
 	return wl_intrsoff(wlc->wl);
 }
 
-static void wlc_wlintrsrestore(wlc_info_t * wlc, uint32 macintmask)
+static void wlc_wlintrsrestore(wlc_info_t *wlc, u32 macintmask)
 {
 	if (!wlc->hw->up)
 		return;
@@ -2962,10 +2991,10 @@ static void wlc_wlintrsrestore(wlc_info_t * wlc, uint32 macintmask)
 	wl_intrsrestore(wlc->wl, macintmask);
 }
 
-uint32 wlc_intrsoff(wlc_info_t * wlc)
+u32 wlc_intrsoff(wlc_info_t *wlc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
-	uint32 macintmask;
+	u32 macintmask;
 
 	if (!wlc_hw->clk)
 		return 0;
@@ -2974,14 +3003,14 @@ uint32 wlc_intrsoff(wlc_info_t * wlc)
 
 	W_REG(wlc_hw->osh, &wlc_hw->regs->macintmask, 0);
 	(void)R_REG(wlc_hw->osh, &wlc_hw->regs->macintmask);	/* sync readback */
-	OSL_DELAY(1);		/* ensure int line is no longer driven */
+	udelay(1);		/* ensure int line is no longer driven */
 	wlc->macintmask = 0;
 
 	/* return previous macintmask; resolve race between us and our isr */
-	return (wlc->macintstatus ? 0 : macintmask);
+	return wlc->macintstatus ? 0 : macintmask;
 }
 
-void wlc_intrsrestore(wlc_info_t * wlc, uint32 macintmask)
+void wlc_intrsrestore(wlc_info_t *wlc, u32 macintmask)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	if (!wlc_hw->clk)
@@ -2991,7 +3020,7 @@ void wlc_intrsrestore(wlc_info_t * wlc, uint32 macintmask)
 	W_REG(wlc_hw->osh, &wlc_hw->regs->macintmask, wlc->macintmask);
 }
 
-void wlc_bmac_mute(wlc_hw_info_t * wlc_hw, bool on, mbool flags)
+void wlc_bmac_mute(wlc_hw_info_t *wlc_hw, bool on, mbool flags)
 {
 	struct ether_addr null_ether_addr = { {0, 0, 0, 0, 0, 0} };
 
@@ -3027,12 +3056,12 @@ void wlc_bmac_mute(wlc_hw_info_t * wlc_hw, bool on, mbool flags)
 		wlc_ucode_mute_override_clear(wlc_hw);
 }
 
-void wlc_bmac_set_deaf(wlc_hw_info_t * wlc_hw, bool user_flag)
+void wlc_bmac_set_deaf(wlc_hw_info_t *wlc_hw, bool user_flag)
 {
 	wlc_phy_set_deaf(wlc_hw->band->pi, user_flag);
 }
 
-int wlc_bmac_xmtfifo_sz_get(wlc_hw_info_t * wlc_hw, uint fifo, uint * blocks)
+int wlc_bmac_xmtfifo_sz_get(wlc_hw_info_t *wlc_hw, uint fifo, uint *blocks)
 {
 	if (fifo >= NFIFO)
 		return BCME_RANGE;
@@ -3042,13 +3071,13 @@ int wlc_bmac_xmtfifo_sz_get(wlc_hw_info_t * wlc_hw, uint fifo, uint * blocks)
 	return 0;
 }
 
-int wlc_bmac_xmtfifo_sz_set(wlc_hw_info_t * wlc_hw, uint fifo, uint blocks)
+int wlc_bmac_xmtfifo_sz_set(wlc_hw_info_t *wlc_hw, uint fifo, uint blocks)
 {
 	if (fifo >= NFIFO || blocks > 299)
 		return BCME_RANGE;
 
-	/* BMAC_NOTE, change blocks to uint16 */
-	wlc_hw->xmtfifo_sz[fifo] = (uint16) blocks;
+	/* BMAC_NOTE, change blocks to u16 */
+	wlc_hw->xmtfifo_sz[fifo] = (u16) blocks;
 
 	return 0;
 }
@@ -3062,7 +3091,7 @@ int wlc_bmac_xmtfifo_sz_set(wlc_hw_info_t * wlc_hw, uint fifo, uint blocks)
  * be pulling data into a tx fifo, by the time the MAC acks the suspend
  * request.
  */
-bool wlc_bmac_tx_fifo_suspended(wlc_hw_info_t * wlc_hw, uint tx_fifo)
+bool wlc_bmac_tx_fifo_suspended(wlc_hw_info_t *wlc_hw, uint tx_fifo)
 {
 	/* check that a suspend has been requested and is no longer pending */
 
@@ -3076,14 +3105,14 @@ bool wlc_bmac_tx_fifo_suspended(wlc_hw_info_t * wlc_hw, uint tx_fifo)
 	if (dma_txsuspended(wlc_hw->di[tx_fifo]) &&
 	    (R_REG(wlc_hw->osh, &wlc_hw->regs->chnstatus) &
 	     (1 << tx_fifo)) == 0)
-		return TRUE;
+		return true;
 
-	return FALSE;
+	return false;
 }
 
-void wlc_bmac_tx_fifo_suspend(wlc_hw_info_t * wlc_hw, uint tx_fifo)
+void wlc_bmac_tx_fifo_suspend(wlc_hw_info_t *wlc_hw, uint tx_fifo)
 {
-	uint8 fifo = 1 << tx_fifo;
+	u8 fifo = 1 << tx_fifo;
 
 	/* Two clients of this code, 11h Quiet period and scanning. */
 
@@ -3112,7 +3141,7 @@ void wlc_bmac_tx_fifo_suspend(wlc_hw_info_t * wlc_hw, uint tx_fifo)
 	}
 }
 
-void wlc_bmac_tx_fifo_resume(wlc_hw_info_t * wlc_hw, uint tx_fifo)
+void wlc_bmac_tx_fifo_resume(wlc_hw_info_t *wlc_hw, uint tx_fifo)
 {
 	/* BMAC_NOTE: WLC_TX_FIFO_ENAB is done in wlc_dpc() for DMA case but need to be done
 	 * here for PIO otherwise the watchdog will catch the inconsistency and fire
@@ -3136,16 +3165,16 @@ void wlc_bmac_tx_fifo_resume(wlc_hw_info_t * wlc_hw, uint tx_fifo)
  * Read and clear macintmask and macintstatus and intstatus registers.
  * This routine should be called with interrupts off
  * Return:
- *   -1 if DEVICEREMOVED(wlc) evaluates to TRUE;
+ *   -1 if DEVICEREMOVED(wlc) evaluates to true;
  *   0 if the interrupt is not for us, or we are in some special cases;
  *   device interrupt status bits otherwise.
  */
-static INLINE uint32 wlc_intstatus(wlc_info_t * wlc, bool in_isr)
+static inline u32 wlc_intstatus(wlc_info_t *wlc, bool in_isr)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs = wlc_hw->regs;
-	uint32 macintstatus;
-	uint32 intstatus_rxfifo, intstatus_txsfifo;
+	u32 macintstatus;
+	u32 intstatus_rxfifo, intstatus_txsfifo;
 	osl_t *osh;
 
 	osh = wlc_hw->osh;
@@ -3231,69 +3260,69 @@ static INLINE uint32 wlc_intstatus(wlc_info_t * wlc, bool in_isr)
 }
 
 /* Update wlc->macintstatus and wlc->intstatus[]. */
-/* Return TRUE if they are updated successfully. FALSE otherwise */
-bool wlc_intrsupd(wlc_info_t * wlc)
+/* Return true if they are updated successfully. false otherwise */
+bool wlc_intrsupd(wlc_info_t *wlc)
 {
-	uint32 macintstatus;
+	u32 macintstatus;
 
 	ASSERT(wlc->macintstatus != 0);
 
 	/* read and clear macintstatus and intstatus registers */
-	macintstatus = wlc_intstatus(wlc, FALSE);
+	macintstatus = wlc_intstatus(wlc, false);
 
 	/* device is removed */
 	if (macintstatus == 0xffffffff)
-		return FALSE;
+		return false;
 
 	/* update interrupt status in software */
 	wlc->macintstatus |= macintstatus;
 
-	return TRUE;
+	return true;
 }
 
 /*
  * First-level interrupt processing.
- * Return TRUE if this was our interrupt, FALSE otherwise.
- * *wantdpc will be set to TRUE if further wlc_dpc() processing is required,
- * FALSE otherwise.
+ * Return true if this was our interrupt, false otherwise.
+ * *wantdpc will be set to true if further wlc_dpc() processing is required,
+ * false otherwise.
  */
-bool BCMFASTPATH wlc_isr(wlc_info_t * wlc, bool * wantdpc)
+bool BCMFASTPATH wlc_isr(wlc_info_t *wlc, bool *wantdpc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
-	uint32 macintstatus;
+	u32 macintstatus;
 
-	*wantdpc = FALSE;
+	*wantdpc = false;
 
 	if (!wlc_hw->up || !wlc->macintmask)
-		return (FALSE);
+		return false;
 
 	/* read and clear macintstatus and intstatus registers */
-	macintstatus = wlc_intstatus(wlc, TRUE);
+	macintstatus = wlc_intstatus(wlc, true);
 
 	if (macintstatus == 0xffffffff)
 		WL_ERROR(("DEVICEREMOVED detected in the ISR code path.\n"));
 
 	/* it is not for us */
 	if (macintstatus == 0)
-		return (FALSE);
+		return false;
 
-	*wantdpc = TRUE;
+	*wantdpc = true;
 
 	/* save interrupt status bits */
 	ASSERT(wlc->macintstatus == 0);
 	wlc->macintstatus = macintstatus;
 
-	return (TRUE);
+	return true;
 
 }
 
 /* process tx completion events for corerev < 5 */
-static bool wlc_bmac_txstatus_corerev4(wlc_hw_info_t * wlc_hw)
+static bool wlc_bmac_txstatus_corerev4(wlc_hw_info_t *wlc_hw)
 {
 	void *status_p;
 	tx_status_t *txs;
 	osl_t *osh;
-	bool fatal = FALSE;
+	bool fatal = false;
 
 	WL_TRACE(("wl%d: wlc_txstatusrecv\n", wlc_hw->unit));
 
@@ -3311,20 +3340,20 @@ static bool wlc_bmac_txstatus_corerev4(wlc_hw_info_t * wlc_hw)
 
 		fatal = wlc_bmac_dotxstatus(wlc_hw, txs, 0);
 
-		PKTFREE(osh, status_p, FALSE);
+		PKTFREE(osh, status_p, false);
 	}
 
 	if (fatal)
-		return TRUE;
+		return true;
 
 	/* post more rbufs */
 	dma_rxfill(wlc_hw->di[RX_TXSTATUS_FIFO]);
 
-	return FALSE;
+	return false;
 }
 
 static bool BCMFASTPATH
-wlc_bmac_dotxstatus(wlc_hw_info_t * wlc_hw, tx_status_t * txs, uint32 s2)
+wlc_bmac_dotxstatus(wlc_hw_info_t *wlc_hw, tx_status_t *txs, u32 s2)
 {
 	/* discard intermediate indications for ucode with one legitimate case:
 	 *   e.g. if "useRTS" is set. ucode did a successful rts/cts exchange, but the subsequent
@@ -3333,19 +3362,19 @@ wlc_bmac_dotxstatus(wlc_hw_info_t * wlc_hw, tx_status_t * txs, uint32 s2)
 	 */
 	if (!(txs->status & TX_STATUS_AMPDU)
 	    && (txs->status & TX_STATUS_INTERMEDIATE)) {
-		return FALSE;
+		return false;
 	}
 
 	return wlc_dotxstatus(wlc_hw->wlc, txs, s2);
 }
 
 /* process tx completion events in BMAC
- * Return TRUE if more tx status need to be processed. FALSE otherwise.
+ * Return true if more tx status need to be processed. false otherwise.
  */
 static bool BCMFASTPATH
-wlc_bmac_txstatus(wlc_hw_info_t * wlc_hw, bool bound, bool * fatal)
+wlc_bmac_txstatus(wlc_hw_info_t *wlc_hw, bool bound, bool *fatal)
 {
-	bool morepending = FALSE;
+	bool morepending = false;
 	wlc_info_t *wlc = wlc_hw->wlc;
 
 	WL_TRACE(("wl%d: wlc_bmac_txstatus\n", wlc_hw->unit));
@@ -3361,7 +3390,7 @@ wlc_bmac_txstatus(wlc_hw_info_t * wlc_hw, bool bound, bool * fatal)
 		d11regs_t *regs;
 		osl_t *osh;
 		tx_status_t txstatus, *txs;
-		uint32 s1, s2;
+		u32 s1, s2;
 		uint n = 0;
 		/* Param 'max_tx_num' indicates max. # tx status to process before break out. */
 		uint max_tx_num = bound ? wlc->pub->tunables->txsbnd : -1;
@@ -3398,7 +3427,7 @@ wlc_bmac_txstatus(wlc_hw_info_t * wlc_hw, bool bound, bool * fatal)
 			return 0;
 
 		if (n >= max_tx_num)
-			morepending = TRUE;
+			morepending = true;
 	}
 
 	if (!pktq_empty(&wlc->active_queue->q))
@@ -3407,11 +3436,11 @@ wlc_bmac_txstatus(wlc_hw_info_t * wlc_hw, bool bound, bool * fatal)
 	return morepending;
 }
 
-void wlc_suspend_mac_and_wait(wlc_info_t * wlc)
+void wlc_suspend_mac_and_wait(wlc_info_t *wlc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs = wlc_hw->regs;
-	uint32 mc, mi;
+	u32 mc, mi;
 	osl_t *osh;
 
 	WL_TRACE(("wl%d: wlc_suspend_mac_and_wait: bandunit %d\n", wlc_hw->unit,
@@ -3471,11 +3500,11 @@ void wlc_suspend_mac_and_wait(wlc_info_t * wlc)
 	ASSERT(!(mc & MCTL_EN_MAC));
 }
 
-void wlc_enable_mac(wlc_info_t * wlc)
+void wlc_enable_mac(wlc_info_t *wlc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs = wlc_hw->regs;
-	uint32 mc, mi;
+	u32 mc, mi;
 	osl_t *osh;
 
 	WL_TRACE(("wl%d: wlc_enable_mac: bandunit %d\n", wlc_hw->unit,
@@ -3510,7 +3539,7 @@ void wlc_enable_mac(wlc_info_t * wlc)
 	wlc_ucode_wake_override_clear(wlc_hw, WLC_WAKE_OVERRIDE_MACSUSPEND);
 }
 
-void wlc_bmac_ifsctl_edcrs_set(wlc_hw_info_t * wlc_hw, bool abie, bool isht)
+void wlc_bmac_ifsctl_edcrs_set(wlc_hw_info_t *wlc_hw, bool abie, bool isht)
 {
 	if (!(WLCISNPHY(wlc_hw->band) && (D11REV_GE(wlc_hw->corerev, 16))))
 		return;
@@ -3546,22 +3575,22 @@ void wlc_bmac_ifsctl_edcrs_set(wlc_hw_info_t * wlc_hw, bool abie, bool isht)
 	}
 }
 
-static void wlc_upd_ofdm_pctl1_table(wlc_hw_info_t * wlc_hw)
+static void wlc_upd_ofdm_pctl1_table(wlc_hw_info_t *wlc_hw)
 {
-	uint8 rate;
-	uint8 rates[8] = {
+	u8 rate;
+	u8 rates[8] = {
 		WLC_RATE_6M, WLC_RATE_9M, WLC_RATE_12M, WLC_RATE_18M,
 		WLC_RATE_24M, WLC_RATE_36M, WLC_RATE_48M, WLC_RATE_54M
 	};
-	uint16 entry_ptr;
-	uint16 pctl1;
+	u16 entry_ptr;
+	u16 pctl1;
 	uint i;
 
 	if (!WLC_PHY_11N_CAP(wlc_hw->band))
 		return;
 
 	/* walk the phy rate table and update the entries */
-	for (i = 0; i < ARRAYSIZE(rates); i++) {
+	for (i = 0; i < ARRAY_SIZE(rates); i++) {
 		rate = rates[i];
 
 		entry_ptr = wlc_bmac_ofdm_ratetable_offset(wlc_hw, rate);
@@ -3580,13 +3609,13 @@ static void wlc_upd_ofdm_pctl1_table(wlc_hw_info_t * wlc_hw)
 	}
 }
 
-static uint16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t * wlc_hw, uint8 rate)
+static u16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t *wlc_hw, u8 rate)
 {
 	uint i;
-	uint8 plcp_rate = 0;
+	u8 plcp_rate = 0;
 	struct plcp_signal_rate_lookup {
-		uint8 rate;
-		uint8 signal_rate;
+		u8 rate;
+		u8 signal_rate;
 	};
 	/* OFDM RATE sub-field of PLCP SIGNAL field, per 802.11 sec 17.3.4.1 */
 	const struct plcp_signal_rate_lookup rate_lookup[] = {
@@ -3600,7 +3629,7 @@ static uint16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t * wlc_hw, uint8 rate)
 		{WLC_RATE_54M, 0xC}
 	};
 
-	for (i = 0; i < ARRAYSIZE(rate_lookup); i++) {
+	for (i = 0; i < ARRAY_SIZE(rate_lookup); i++) {
 		if (rate == rate_lookup[i].rate) {
 			plcp_rate = rate_lookup[i].signal_rate;
 			break;
@@ -3610,10 +3639,10 @@ static uint16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t * wlc_hw, uint8 rate)
 	/* Find the SHM pointer to the rate table entry by looking in the
 	 * Direct-map Table
 	 */
-	return (2 * wlc_bmac_read_shm(wlc_hw, M_RT_DIRMAP_A + (plcp_rate * 2)));
+	return 2 * wlc_bmac_read_shm(wlc_hw, M_RT_DIRMAP_A + (plcp_rate * 2));
 }
 
-void wlc_bmac_band_stf_ss_set(wlc_hw_info_t * wlc_hw, uint8 stf_mode)
+void wlc_bmac_band_stf_ss_set(wlc_hw_info_t *wlc_hw, u8 stf_mode)
 {
 	wlc_hw->hw_stf_ss_opmode = stf_mode;
 
@@ -3622,8 +3651,8 @@ void wlc_bmac_band_stf_ss_set(wlc_hw_info_t * wlc_hw, uint8 stf_mode)
 }
 
 void BCMFASTPATH
-wlc_bmac_read_tsf(wlc_hw_info_t * wlc_hw, uint32 * tsf_l_ptr,
-		  uint32 * tsf_h_ptr)
+wlc_bmac_read_tsf(wlc_hw_info_t *wlc_hw, u32 *tsf_l_ptr,
+		  u32 *tsf_h_ptr)
 {
 	d11regs_t *regs = wlc_hw->regs;
 
@@ -3634,10 +3663,11 @@ wlc_bmac_read_tsf(wlc_hw_info_t * wlc_hw, uint32 * tsf_l_ptr,
 	return;
 }
 
-bool BCMATTACHFN(wlc_bmac_validate_chip_access) (wlc_hw_info_t * wlc_hw) {
+bool wlc_bmac_validate_chip_access(wlc_hw_info_t *wlc_hw)
+{
 	d11regs_t *regs;
-	uint32 w, val;
-	volatile uint16 *reg16;
+	u32 w, val;
+	volatile u16 *reg16;
 	osl_t *osh;
 
 	WL_TRACE(("wl%d: validate_chip_access\n", wlc_hw->unit));
@@ -3654,26 +3684,26 @@ bool BCMATTACHFN(wlc_bmac_validate_chip_access) (wlc_hw_info_t * wlc_hw) {
 	/* Can we write and read back a 32bit register? */
 	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
 	(void)R_REG(osh, &regs->objaddr);
-	W_REG(osh, &regs->objdata, (uint32) 0xaa5555aa);
+	W_REG(osh, &regs->objdata, (u32) 0xaa5555aa);
 
 	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
 	(void)R_REG(osh, &regs->objaddr);
 	val = R_REG(osh, &regs->objdata);
-	if (val != (uint32) 0xaa5555aa) {
+	if (val != (u32) 0xaa5555aa) {
 		WL_ERROR(("wl%d: validate_chip_access: SHM = 0x%x, expected 0xaa5555aa\n", wlc_hw->unit, val));
-		return (FALSE);
+		return false;
 	}
 
 	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
 	(void)R_REG(osh, &regs->objaddr);
-	W_REG(osh, &regs->objdata, (uint32) 0x55aaaa55);
+	W_REG(osh, &regs->objdata, (u32) 0x55aaaa55);
 
 	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
 	(void)R_REG(osh, &regs->objaddr);
 	val = R_REG(osh, &regs->objdata);
-	if (val != (uint32) 0x55aaaa55) {
+	if (val != (u32) 0x55aaaa55) {
 		WL_ERROR(("wl%d: validate_chip_access: SHM = 0x%x, expected 0x55aaaa55\n", wlc_hw->unit, val));
-		return (FALSE);
+		return false;
 	}
 
 	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
@@ -3684,7 +3714,7 @@ bool BCMATTACHFN(wlc_bmac_validate_chip_access) (wlc_hw_info_t * wlc_hw) {
 		/* if 32 bit writes are split into 16 bit writes, are they in the correct order
 		 * for our interface, low to high
 		 */
-		reg16 = (volatile uint16 *)(uintptr) & regs->tsf_cfpstart;
+		reg16 = (volatile u16 *)&regs->tsf_cfpstart;
 
 		/* write the CFPStart register low half explicitly, starting a buffered write */
 		W_REG(osh, reg16, 0xAAAA);
@@ -3703,12 +3733,12 @@ bool BCMATTACHFN(wlc_bmac_validate_chip_access) (wlc_hw_info_t * wlc_hw) {
 		val = R_REG(osh, &regs->tsf_cfpstrt_l);
 		if (val != (uint) 0xBBBB) {
 			WL_ERROR(("wl%d: validate_chip_access: tsf_cfpstrt_l = 0x%x, expected" " 0x%x\n", wlc_hw->unit, val, 0xBBBB));
-			return (FALSE);
+			return false;
 		}
 		val = R_REG(osh, &regs->tsf_cfpstrt_h);
 		if (val != (uint) 0xCCCC) {
 			WL_ERROR(("wl%d: validate_chip_access: tsf_cfpstrt_h = 0x%x, expected" " 0x%x\n", wlc_hw->unit, val, 0xCCCC));
-			return (FALSE);
+			return false;
 		}
 
 	}
@@ -3720,19 +3750,19 @@ bool BCMATTACHFN(wlc_bmac_validate_chip_access) (wlc_hw_info_t * wlc_hw) {
 	if ((w != (MCTL_IHR_EN | MCTL_WAKE)) &&
 	    (w != (MCTL_IHR_EN | MCTL_GMODE | MCTL_WAKE))) {
 		WL_ERROR(("wl%d: validate_chip_access: maccontrol = 0x%x, expected 0x%x or 0x%x\n", wlc_hw->unit, w, (MCTL_IHR_EN | MCTL_WAKE), (MCTL_IHR_EN | MCTL_GMODE | MCTL_WAKE)));
-		return (FALSE);
+		return false;
 	}
 
-	return (TRUE);
+	return true;
 }
 
 #define PHYPLL_WAIT_US	100000
 
-void wlc_bmac_core_phypll_ctl(wlc_hw_info_t * wlc_hw, bool on)
+void wlc_bmac_core_phypll_ctl(wlc_hw_info_t *wlc_hw, bool on)
 {
 	d11regs_t *regs;
 	osl_t *osh;
-	uint32 tmp;
+	u32 tmp;
 
 	WL_TRACE(("wl%d: wlc_bmac_core_phypll_ctl\n", wlc_hw->unit));
 
@@ -3787,7 +3817,7 @@ void wlc_bmac_core_phypll_ctl(wlc_hw_info_t * wlc_hw, bool on)
 	}
 }
 
-void wlc_coredisable(wlc_hw_info_t * wlc_hw)
+void wlc_coredisable(wlc_hw_info_t *wlc_hw)
 {
 	bool dev_gone;
 
@@ -3810,7 +3840,7 @@ void wlc_coredisable(wlc_hw_info_t * wlc_hw)
 	wlc_phy_anacore(wlc_hw->band->pi, OFF);
 
 	/* turn off PHYPLL to save power */
-	wlc_bmac_core_phypll_ctl(wlc_hw, FALSE);
+	wlc_bmac_core_phypll_ctl(wlc_hw, false);
 
 	/* No need to set wlc->pub->radio_active = OFF
 	 * because this function needs down capability and
@@ -3821,13 +3851,13 @@ void wlc_coredisable(wlc_hw_info_t * wlc_hw)
 	if (wlc_hw->ucode_dbgsel)
 		si_gpiocontrol(wlc_hw->sih, ~0, 0, GPIO_DRV_PRIORITY);
 
-	wlc_hw->clk = FALSE;
+	wlc_hw->clk = false;
 	si_core_disable(wlc_hw->sih, 0);
-	wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, FALSE);
+	wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, false);
 }
 
 /* power both the pll and external oscillator on/off */
-void wlc_bmac_xtal(wlc_hw_info_t * wlc_hw, bool want)
+void wlc_bmac_xtal(wlc_hw_info_t *wlc_hw, bool want)
 {
 	WL_TRACE(("wl%d: wlc_bmac_xtal: want %d\n", wlc_hw->unit, want));
 
@@ -3840,13 +3870,13 @@ void wlc_bmac_xtal(wlc_hw_info_t * wlc_hw, bool want)
 
 	wlc_hw->sbclk = want;
 	if (!wlc_hw->sbclk) {
-		wlc_hw->clk = FALSE;
+		wlc_hw->clk = false;
 		if (wlc_hw->band && wlc_hw->band->pi)
-			wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, FALSE);
+			wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, false);
 	}
 }
 
-static void wlc_flushqueues(wlc_info_t * wlc)
+static void wlc_flushqueues(wlc_info_t *wlc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	uint i;
@@ -3868,12 +3898,12 @@ static void wlc_flushqueues(wlc_info_t * wlc)
 		dma_rxreclaim(wlc_hw->di[RX_TXSTATUS_FIFO]);
 }
 
-uint16 wlc_bmac_read_shm(wlc_hw_info_t * wlc_hw, uint offset)
+u16 wlc_bmac_read_shm(wlc_hw_info_t *wlc_hw, uint offset)
 {
 	return wlc_bmac_read_objmem(wlc_hw, offset, OBJADDR_SHM_SEL);
 }
 
-void wlc_bmac_write_shm(wlc_hw_info_t * wlc_hw, uint offset, uint16 v)
+void wlc_bmac_write_shm(wlc_hw_info_t *wlc_hw, uint offset, u16 v)
 {
 	wlc_bmac_write_objmem(wlc_hw, offset, v, OBJADDR_SHM_SEL);
 }
@@ -3882,7 +3912,7 @@ void wlc_bmac_write_shm(wlc_hw_info_t * wlc_hw, uint offset, uint16 v)
  * SHM 'offset' needs to be an even address and
  * Buffer length 'len' must be an even number of bytes
  */
-void wlc_bmac_set_shm(wlc_hw_info_t * wlc_hw, uint offset, uint16 v, int len)
+void wlc_bmac_set_shm(wlc_hw_info_t *wlc_hw, uint offset, u16 v, int len)
 {
 	int i;
 
@@ -3898,14 +3928,13 @@ void wlc_bmac_set_shm(wlc_hw_info_t * wlc_hw, uint offset, uint16 v, int len)
 	}
 }
 
-static uint16
-wlc_bmac_read_objmem(wlc_hw_info_t * wlc_hw, uint offset, uint32 sel)
+static u16
+wlc_bmac_read_objmem(wlc_hw_info_t *wlc_hw, uint offset, u32 sel)
 {
 	d11regs_t *regs = wlc_hw->regs;
-	volatile uint16 *objdata_lo =
-	    (volatile uint16 *)(uintptr) & regs->objdata;
-	volatile uint16 *objdata_hi = objdata_lo + 1;
-	uint16 v;
+	volatile u16 *objdata_lo = (volatile u16 *)&regs->objdata;
+	volatile u16 *objdata_hi = objdata_lo + 1;
+	u16 v;
 
 	ASSERT((offset & 1) == 0);
 
@@ -3921,12 +3950,11 @@ wlc_bmac_read_objmem(wlc_hw_info_t * wlc_hw, uint offset, uint32 sel)
 }
 
 static void
-wlc_bmac_write_objmem(wlc_hw_info_t * wlc_hw, uint offset, uint16 v, uint32 sel)
+wlc_bmac_write_objmem(wlc_hw_info_t *wlc_hw, uint offset, u16 v, u32 sel)
 {
 	d11regs_t *regs = wlc_hw->regs;
-	volatile uint16 *objdata_lo =
-	    (volatile uint16 *)(uintptr) & regs->objdata;
-	volatile uint16 *objdata_hi = objdata_lo + 1;
+	volatile u16 *objdata_lo = (volatile u16 *)&regs->objdata;
+	volatile u16 *objdata_hi = objdata_lo + 1;
 
 	ASSERT((offset & 1) == 0);
 
@@ -3945,11 +3973,11 @@ wlc_bmac_write_objmem(wlc_hw_info_t * wlc_hw, uint offset, uint16 v, uint32 sel)
  * 'sel' selects the type of memory
  */
 void
-wlc_bmac_copyto_objmem(wlc_hw_info_t * wlc_hw, uint offset, const void *buf,
-		       int len, uint32 sel)
+wlc_bmac_copyto_objmem(wlc_hw_info_t *wlc_hw, uint offset, const void *buf,
+		       int len, u32 sel)
 {
-	uint16 v;
-	const uint8 *p = (const uint8 *)buf;
+	u16 v;
+	const u8 *p = (const u8 *)buf;
 	int i;
 
 	/* offset and len need to be even */
@@ -3971,11 +3999,11 @@ wlc_bmac_copyto_objmem(wlc_hw_info_t * wlc_hw, uint offset, const void *buf,
  * 'sel' selects the type of memory
  */
 void
-wlc_bmac_copyfrom_objmem(wlc_hw_info_t * wlc_hw, uint offset, void *buf,
-			 int len, uint32 sel)
+wlc_bmac_copyfrom_objmem(wlc_hw_info_t *wlc_hw, uint offset, void *buf,
+			 int len, u32 sel)
 {
-	uint16 v;
-	uint8 *p = (uint8 *) buf;
+	u16 v;
+	u8 *p = (u8 *) buf;
 	int i;
 
 	/* offset and len need to be even */
@@ -3992,7 +4020,7 @@ wlc_bmac_copyfrom_objmem(wlc_hw_info_t * wlc_hw, uint offset, void *buf,
 	}
 }
 
-void wlc_bmac_copyfrom_vars(wlc_hw_info_t * wlc_hw, char **buf, uint * len)
+void wlc_bmac_copyfrom_vars(wlc_hw_info_t *wlc_hw, char **buf, uint *len)
 {
 	WL_TRACE(("wlc_bmac_copyfrom_vars, nvram vars totlen=%d\n",
 		  wlc_hw->vars_size));
@@ -4001,7 +4029,7 @@ void wlc_bmac_copyfrom_vars(wlc_hw_info_t * wlc_hw, char **buf, uint * len)
 	*len = wlc_hw->vars_size;
 }
 
-void wlc_bmac_retrylimit_upd(wlc_hw_info_t * wlc_hw, uint16 SRL, uint16 LRL)
+void wlc_bmac_retrylimit_upd(wlc_hw_info_t *wlc_hw, u16 SRL, u16 LRL)
 {
 	wlc_hw->SRL = SRL;
 	wlc_hw->LRL = LRL;
@@ -4019,17 +4047,17 @@ void wlc_bmac_retrylimit_upd(wlc_hw_info_t * wlc_hw, uint16 SRL, uint16 LRL)
 	}
 }
 
-void wlc_bmac_set_noreset(wlc_hw_info_t * wlc_hw, bool noreset_flag)
+void wlc_bmac_set_noreset(wlc_hw_info_t *wlc_hw, bool noreset_flag)
 {
 	wlc_hw->noreset = noreset_flag;
 }
 
-void wlc_bmac_set_ucode_loaded(wlc_hw_info_t * wlc_hw, bool ucode_loaded)
+void wlc_bmac_set_ucode_loaded(wlc_hw_info_t *wlc_hw, bool ucode_loaded)
 {
 	wlc_hw->ucode_loaded = ucode_loaded;
 }
 
-void wlc_bmac_pllreq(wlc_hw_info_t * wlc_hw, bool set, mbool req_bit)
+void wlc_bmac_pllreq(wlc_hw_info_t *wlc_hw, bool set, mbool req_bit)
 {
 	ASSERT(req_bit);
 
@@ -4060,7 +4088,7 @@ void wlc_bmac_pllreq(wlc_hw_info_t * wlc_hw, bool set, mbool req_bit)
 	return;
 }
 
-void wlc_bmac_set_clk(wlc_hw_info_t * wlc_hw, bool on)
+void wlc_bmac_set_clk(wlc_hw_info_t *wlc_hw, bool on)
 {
 	if (on) {
 		/* power up pll and oscillator */
@@ -4082,15 +4110,15 @@ void wlc_bmac_set_clk(wlc_hw_info_t * wlc_hw, bool on)
 }
 
 /* this will be true for all ai chips */
-bool wlc_bmac_taclear(wlc_hw_info_t * wlc_hw, bool ta_ok)
+bool wlc_bmac_taclear(wlc_hw_info_t *wlc_hw, bool ta_ok)
 {
-	return TRUE;
+	return true;
 }
 
 /* Lower down relevant GPIOs like LED when going down w/o
  * doing PCI config cycles or touching interrupts
  */
-void wlc_gpio_fast_deinit(wlc_hw_info_t * wlc_hw)
+void wlc_gpio_fast_deinit(wlc_hw_info_t *wlc_hw)
 {
 	if ((wlc_hw == NULL) || (wlc_hw->sih == NULL))
 		return;
@@ -4108,17 +4136,17 @@ void wlc_gpio_fast_deinit(wlc_hw_info_t * wlc_hw)
 	return;
 }
 
-bool wlc_bmac_radio_hw(wlc_hw_info_t * wlc_hw, bool enable)
+bool wlc_bmac_radio_hw(wlc_hw_info_t *wlc_hw, bool enable)
 {
 	/* Do not access Phy registers if core is not up */
-	if (si_iscoreup(wlc_hw->sih) == FALSE)
-		return FALSE;
+	if (si_iscoreup(wlc_hw->sih) == false)
+		return false;
 
 	if (enable) {
 		if (PMUCTL_ENAB(wlc_hw->sih)) {
 			AND_REG(wlc_hw->osh, &wlc_hw->regs->clk_ctl_st,
 				~CCS_FORCEHWREQOFF);
-			si_pmu_radio_enable(wlc_hw->sih, TRUE);
+			si_pmu_radio_enable(wlc_hw->sih, true);
 		}
 
 		wlc_phy_anacore(wlc_hw->band->pi, ON);
@@ -4134,19 +4162,19 @@ bool wlc_bmac_radio_hw(wlc_hw_info_t * wlc_hw, bool enable)
 		wlc_phy_anacore(wlc_hw->band->pi, OFF);
 
 		if (PMUCTL_ENAB(wlc_hw->sih)) {
-			si_pmu_radio_enable(wlc_hw->sih, FALSE);
+			si_pmu_radio_enable(wlc_hw->sih, false);
 			OR_REG(wlc_hw->osh, &wlc_hw->regs->clk_ctl_st,
 			       CCS_FORCEHWREQOFF);
 		}
 	}
 
-	return TRUE;
+	return true;
 }
 
-uint16 wlc_bmac_rate_shm_offset(wlc_hw_info_t * wlc_hw, uint8 rate)
+u16 wlc_bmac_rate_shm_offset(wlc_hw_info_t *wlc_hw, u8 rate)
 {
-	uint16 table_ptr;
-	uint8 phy_rate, index;
+	u16 table_ptr;
+	u8 phy_rate, index;
 
 	/* get the phy specific rate encoding for the PLCP SIGNAL field */
 	/* XXX4321 fixup needed ? */
@@ -4164,15 +4192,15 @@ uint16 wlc_bmac_rate_shm_offset(wlc_hw_info_t * wlc_hw, uint8 rate)
 	/* Find the SHM pointer to the rate table entry by looking in the
 	 * Direct-map Table
 	 */
-	return (2 * wlc_bmac_read_shm(wlc_hw, table_ptr + (index * 2)));
+	return 2 * wlc_bmac_read_shm(wlc_hw, table_ptr + (index * 2));
 }
 
-void wlc_bmac_set_txpwr_percent(wlc_hw_info_t * wlc_hw, uint8 val)
+void wlc_bmac_set_txpwr_percent(wlc_hw_info_t *wlc_hw, u8 val)
 {
 	wlc_phy_txpwr_percent_set(wlc_hw->band->pi, val);
 }
 
-void wlc_bmac_antsel_set(wlc_hw_info_t * wlc_hw, uint32 antsel_avail)
+void wlc_bmac_antsel_set(wlc_hw_info_t *wlc_hw, u32 antsel_avail)
 {
 	wlc_hw->antsel_avail = antsel_avail;
 }
diff --git a/drivers/staging/brcm80211/sys/wlc_bmac.h b/drivers/staging/brcm80211/sys/wlc_bmac.h
index d4f69a0..872bc8d 100644
--- a/drivers/staging/brcm80211/sys/wlc_bmac.h
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.h
@@ -41,7 +41,7 @@ typedef struct wlc_bmac_revinfo {
 	uint bustype;		/* SB_BUS, PCI_BUS  */
 	uint buscoretype;	/* PCI_CORE_ID, PCIE_CORE_ID, PCMCIA_CORE_ID */
 	uint buscorerev;	/* buscore rev */
-	uint32 issim;		/* chip is in simulation or emulation */
+	u32 issim;		/* chip is in simulation or emulation */
 
 	uint nbands;
 
@@ -59,8 +59,8 @@ typedef struct wlc_bmac_revinfo {
 
 /* dup state between BMAC(wlc_hw_info_t) and HIGH(wlc_info_t) driver */
 typedef struct wlc_bmac_state {
-	uint32 machwcap;	/* mac hw capibility */
-	uint32 preamble_ovr;	/* preamble override */
+	u32 machwcap;	/* mac hw capibility */
+	u32 preamble_ovr;	/* preamble override */
 } wlc_bmac_state_t;
 
 enum {
@@ -130,148 +130,148 @@ typedef enum {
 	WLCHW_STATE_LAST
 } wlc_bmac_state_id_t;
 
-extern int wlc_bmac_attach(wlc_info_t * wlc, uint16 vendor, uint16 device,
-			   uint unit, bool piomode, osl_t * osh, void *regsva,
+extern int wlc_bmac_attach(wlc_info_t *wlc, u16 vendor, u16 device,
+			   uint unit, bool piomode, osl_t *osh, void *regsva,
 			   uint bustype, void *btparam);
-extern int wlc_bmac_detach(wlc_info_t * wlc);
+extern int wlc_bmac_detach(wlc_info_t *wlc);
 extern void wlc_bmac_watchdog(void *arg);
-extern void wlc_bmac_info_init(wlc_hw_info_t * wlc_hw);
+extern void wlc_bmac_info_init(wlc_hw_info_t *wlc_hw);
 
 /* up/down, reset, clk */
 #ifdef WLC_LOW
-extern void wlc_bmac_xtal(wlc_hw_info_t * wlc_hw, bool want);
+extern void wlc_bmac_xtal(wlc_hw_info_t *wlc_hw, bool want);
 #endif
 
-extern void wlc_bmac_copyto_objmem(wlc_hw_info_t * wlc_hw,
+extern void wlc_bmac_copyto_objmem(wlc_hw_info_t *wlc_hw,
 				   uint offset, const void *buf, int len,
-				   uint32 sel);
-extern void wlc_bmac_copyfrom_objmem(wlc_hw_info_t * wlc_hw, uint offset,
-				     void *buf, int len, uint32 sel);
+				   u32 sel);
+extern void wlc_bmac_copyfrom_objmem(wlc_hw_info_t *wlc_hw, uint offset,
+				     void *buf, int len, u32 sel);
 #define wlc_bmac_copyfrom_shm(wlc_hw, offset, buf, len)                 \
 	wlc_bmac_copyfrom_objmem(wlc_hw, offset, buf, len, OBJADDR_SHM_SEL)
 #define wlc_bmac_copyto_shm(wlc_hw, offset, buf, len)                   \
 	wlc_bmac_copyto_objmem(wlc_hw, offset, buf, len, OBJADDR_SHM_SEL)
 
-extern void wlc_bmac_core_phy_clk(wlc_hw_info_t * wlc_hw, bool clk);
-extern void wlc_bmac_core_phypll_reset(wlc_hw_info_t * wlc_hw);
-extern void wlc_bmac_core_phypll_ctl(wlc_hw_info_t * wlc_hw, bool on);
-extern void wlc_bmac_phyclk_fgc(wlc_hw_info_t * wlc_hw, bool clk);
-extern void wlc_bmac_macphyclk_set(wlc_hw_info_t * wlc_hw, bool clk);
-extern void wlc_bmac_phy_reset(wlc_hw_info_t * wlc_hw);
-extern void wlc_bmac_corereset(wlc_hw_info_t * wlc_hw, uint32 flags);
-extern void wlc_bmac_reset(wlc_hw_info_t * wlc_hw);
-extern void wlc_bmac_init(wlc_hw_info_t * wlc_hw, chanspec_t chanspec,
+extern void wlc_bmac_core_phy_clk(wlc_hw_info_t *wlc_hw, bool clk);
+extern void wlc_bmac_core_phypll_reset(wlc_hw_info_t *wlc_hw);
+extern void wlc_bmac_core_phypll_ctl(wlc_hw_info_t *wlc_hw, bool on);
+extern void wlc_bmac_phyclk_fgc(wlc_hw_info_t *wlc_hw, bool clk);
+extern void wlc_bmac_macphyclk_set(wlc_hw_info_t *wlc_hw, bool clk);
+extern void wlc_bmac_phy_reset(wlc_hw_info_t *wlc_hw);
+extern void wlc_bmac_corereset(wlc_hw_info_t *wlc_hw, u32 flags);
+extern void wlc_bmac_reset(wlc_hw_info_t *wlc_hw);
+extern void wlc_bmac_init(wlc_hw_info_t *wlc_hw, chanspec_t chanspec,
 			  bool mute);
-extern int wlc_bmac_up_prep(wlc_hw_info_t * wlc_hw);
-extern int wlc_bmac_up_finish(wlc_hw_info_t * wlc_hw);
-extern int wlc_bmac_down_prep(wlc_hw_info_t * wlc_hw);
-extern int wlc_bmac_down_finish(wlc_hw_info_t * wlc_hw);
-extern void wlc_bmac_corereset(wlc_hw_info_t * wlc_hw, uint32 flags);
-extern void wlc_bmac_switch_macfreq(wlc_hw_info_t * wlc_hw, uint8 spurmode);
+extern int wlc_bmac_up_prep(wlc_hw_info_t *wlc_hw);
+extern int wlc_bmac_up_finish(wlc_hw_info_t *wlc_hw);
+extern int wlc_bmac_down_prep(wlc_hw_info_t *wlc_hw);
+extern int wlc_bmac_down_finish(wlc_hw_info_t *wlc_hw);
+extern void wlc_bmac_corereset(wlc_hw_info_t *wlc_hw, u32 flags);
+extern void wlc_bmac_switch_macfreq(wlc_hw_info_t *wlc_hw, u8 spurmode);
 
 /* chanspec, ucode interface */
-extern int wlc_bmac_bandtype(wlc_hw_info_t * wlc_hw);
-extern void wlc_bmac_set_chanspec(wlc_hw_info_t * wlc_hw, chanspec_t chanspec,
+extern int wlc_bmac_bandtype(wlc_hw_info_t *wlc_hw);
+extern void wlc_bmac_set_chanspec(wlc_hw_info_t *wlc_hw, chanspec_t chanspec,
 				  bool mute, struct txpwr_limits *txpwr);
 
-extern void wlc_bmac_txfifo(wlc_hw_info_t * wlc_hw, uint fifo, void *p,
-			    bool commit, uint16 frameid, uint8 txpktpend);
-extern int wlc_bmac_xmtfifo_sz_get(wlc_hw_info_t * wlc_hw, uint fifo,
-				   uint * blocks);
-extern void wlc_bmac_mhf(wlc_hw_info_t * wlc_hw, uint8 idx, uint16 mask,
-			 uint16 val, int bands);
-extern void wlc_bmac_mctrl(wlc_hw_info_t * wlc_hw, uint32 mask, uint32 val);
-extern uint16 wlc_bmac_mhf_get(wlc_hw_info_t * wlc_hw, uint8 idx, int bands);
-extern int wlc_bmac_xmtfifo_sz_set(wlc_hw_info_t * wlc_hw, uint fifo,
+extern void wlc_bmac_txfifo(wlc_hw_info_t *wlc_hw, uint fifo, void *p,
+			    bool commit, u16 frameid, u8 txpktpend);
+extern int wlc_bmac_xmtfifo_sz_get(wlc_hw_info_t *wlc_hw, uint fifo,
+				   uint *blocks);
+extern void wlc_bmac_mhf(wlc_hw_info_t *wlc_hw, u8 idx, u16 mask,
+			 u16 val, int bands);
+extern void wlc_bmac_mctrl(wlc_hw_info_t *wlc_hw, u32 mask, u32 val);
+extern u16 wlc_bmac_mhf_get(wlc_hw_info_t *wlc_hw, u8 idx, int bands);
+extern int wlc_bmac_xmtfifo_sz_set(wlc_hw_info_t *wlc_hw, uint fifo,
 				   uint blocks);
-extern void wlc_bmac_txant_set(wlc_hw_info_t * wlc_hw, uint16 phytxant);
-extern uint16 wlc_bmac_get_txant(wlc_hw_info_t * wlc_hw);
-extern void wlc_bmac_antsel_type_set(wlc_hw_info_t * wlc_hw, uint8 antsel_type);
-extern int wlc_bmac_revinfo_get(wlc_hw_info_t * wlc_hw,
-				wlc_bmac_revinfo_t * revinfo);
-extern int wlc_bmac_state_get(wlc_hw_info_t * wlc_hw, wlc_bmac_state_t * state);
-extern void wlc_bmac_write_shm(wlc_hw_info_t * wlc_hw, uint offset, uint16 v);
-extern uint16 wlc_bmac_read_shm(wlc_hw_info_t * wlc_hw, uint offset);
-extern void wlc_bmac_set_shm(wlc_hw_info_t * wlc_hw, uint offset, uint16 v,
+extern void wlc_bmac_txant_set(wlc_hw_info_t *wlc_hw, u16 phytxant);
+extern u16 wlc_bmac_get_txant(wlc_hw_info_t *wlc_hw);
+extern void wlc_bmac_antsel_type_set(wlc_hw_info_t *wlc_hw, u8 antsel_type);
+extern int wlc_bmac_revinfo_get(wlc_hw_info_t *wlc_hw,
+				wlc_bmac_revinfo_t *revinfo);
+extern int wlc_bmac_state_get(wlc_hw_info_t *wlc_hw, wlc_bmac_state_t *state);
+extern void wlc_bmac_write_shm(wlc_hw_info_t *wlc_hw, uint offset, u16 v);
+extern u16 wlc_bmac_read_shm(wlc_hw_info_t *wlc_hw, uint offset);
+extern void wlc_bmac_set_shm(wlc_hw_info_t *wlc_hw, uint offset, u16 v,
 			     int len);
-extern void wlc_bmac_write_template_ram(wlc_hw_info_t * wlc_hw, int offset,
+extern void wlc_bmac_write_template_ram(wlc_hw_info_t *wlc_hw, int offset,
 					int len, void *buf);
-extern void wlc_bmac_copyfrom_vars(wlc_hw_info_t * wlc_hw, char **buf,
-				   uint * len);
+extern void wlc_bmac_copyfrom_vars(wlc_hw_info_t *wlc_hw, char **buf,
+				   uint *len);
 
-extern void wlc_bmac_process_ps_switch(wlc_hw_info_t * wlc,
-				       struct ether_addr *ea, int8 ps_on);
-extern void wlc_bmac_hw_etheraddr(wlc_hw_info_t * wlc_hw,
+extern void wlc_bmac_process_ps_switch(wlc_hw_info_t *wlc,
+				       struct ether_addr *ea, s8 ps_on);
+extern void wlc_bmac_hw_etheraddr(wlc_hw_info_t *wlc_hw,
 				  struct ether_addr *ea);
-extern void wlc_bmac_set_hw_etheraddr(wlc_hw_info_t * wlc_hw,
+extern void wlc_bmac_set_hw_etheraddr(wlc_hw_info_t *wlc_hw,
 				      struct ether_addr *ea);
-extern bool wlc_bmac_validate_chip_access(wlc_hw_info_t * wlc_hw);
+extern bool wlc_bmac_validate_chip_access(wlc_hw_info_t *wlc_hw);
 
-extern bool wlc_bmac_radio_read_hwdisabled(wlc_hw_info_t * wlc_hw);
-extern void wlc_bmac_set_shortslot(wlc_hw_info_t * wlc_hw, bool shortslot);
-extern void wlc_bmac_mute(wlc_hw_info_t * wlc_hw, bool want, mbool flags);
-extern void wlc_bmac_set_deaf(wlc_hw_info_t * wlc_hw, bool user_flag);
-extern void wlc_bmac_band_stf_ss_set(wlc_hw_info_t * wlc_hw, uint8 stf_mode);
+extern bool wlc_bmac_radio_read_hwdisabled(wlc_hw_info_t *wlc_hw);
+extern void wlc_bmac_set_shortslot(wlc_hw_info_t *wlc_hw, bool shortslot);
+extern void wlc_bmac_mute(wlc_hw_info_t *wlc_hw, bool want, mbool flags);
+extern void wlc_bmac_set_deaf(wlc_hw_info_t *wlc_hw, bool user_flag);
+extern void wlc_bmac_band_stf_ss_set(wlc_hw_info_t *wlc_hw, u8 stf_mode);
 
-extern void wlc_bmac_wait_for_wake(wlc_hw_info_t * wlc_hw);
-extern bool wlc_bmac_tx_fifo_suspended(wlc_hw_info_t * wlc_hw, uint tx_fifo);
-extern void wlc_bmac_tx_fifo_suspend(wlc_hw_info_t * wlc_hw, uint tx_fifo);
-extern void wlc_bmac_tx_fifo_resume(wlc_hw_info_t * wlc_hw, uint tx_fifo);
+extern void wlc_bmac_wait_for_wake(wlc_hw_info_t *wlc_hw);
+extern bool wlc_bmac_tx_fifo_suspended(wlc_hw_info_t *wlc_hw, uint tx_fifo);
+extern void wlc_bmac_tx_fifo_suspend(wlc_hw_info_t *wlc_hw, uint tx_fifo);
+extern void wlc_bmac_tx_fifo_resume(wlc_hw_info_t *wlc_hw, uint tx_fifo);
 
-extern void wlc_ucode_wake_override_set(wlc_hw_info_t * wlc_hw,
-					uint32 override_bit);
-extern void wlc_ucode_wake_override_clear(wlc_hw_info_t * wlc_hw,
-					  uint32 override_bit);
+extern void wlc_ucode_wake_override_set(wlc_hw_info_t *wlc_hw,
+					u32 override_bit);
+extern void wlc_ucode_wake_override_clear(wlc_hw_info_t *wlc_hw,
+					  u32 override_bit);
 
-extern void wlc_bmac_set_rcmta(wlc_hw_info_t * wlc_hw, int idx,
+extern void wlc_bmac_set_rcmta(wlc_hw_info_t *wlc_hw, int idx,
 			       const struct ether_addr *addr);
-extern void wlc_bmac_set_addrmatch(wlc_hw_info_t * wlc_hw, int match_reg_offset,
+extern void wlc_bmac_set_addrmatch(wlc_hw_info_t *wlc_hw, int match_reg_offset,
 				   const struct ether_addr *addr);
-extern void wlc_bmac_write_hw_bcntemplates(wlc_hw_info_t * wlc_hw, void *bcn,
+extern void wlc_bmac_write_hw_bcntemplates(wlc_hw_info_t *wlc_hw, void *bcn,
 					   int len, bool both);
 
-extern void wlc_bmac_read_tsf(wlc_hw_info_t * wlc_hw, uint32 * tsf_l_ptr,
-			      uint32 * tsf_h_ptr);
-extern void wlc_bmac_set_cwmin(wlc_hw_info_t * wlc_hw, uint16 newmin);
-extern void wlc_bmac_set_cwmax(wlc_hw_info_t * wlc_hw, uint16 newmax);
-extern void wlc_bmac_set_noreset(wlc_hw_info_t * wlc, bool noreset_flag);
-extern void wlc_bmac_set_ucode_loaded(wlc_hw_info_t * wlc, bool ucode_loaded);
+extern void wlc_bmac_read_tsf(wlc_hw_info_t *wlc_hw, u32 *tsf_l_ptr,
+			      u32 *tsf_h_ptr);
+extern void wlc_bmac_set_cwmin(wlc_hw_info_t *wlc_hw, u16 newmin);
+extern void wlc_bmac_set_cwmax(wlc_hw_info_t *wlc_hw, u16 newmax);
+extern void wlc_bmac_set_noreset(wlc_hw_info_t *wlc, bool noreset_flag);
+extern void wlc_bmac_set_ucode_loaded(wlc_hw_info_t *wlc, bool ucode_loaded);
 
-extern void wlc_bmac_retrylimit_upd(wlc_hw_info_t * wlc_hw, uint16 SRL,
-				    uint16 LRL);
+extern void wlc_bmac_retrylimit_upd(wlc_hw_info_t *wlc_hw, u16 SRL,
+				    u16 LRL);
 
-extern void wlc_bmac_fifoerrors(wlc_hw_info_t * wlc_hw);
+extern void wlc_bmac_fifoerrors(wlc_hw_info_t *wlc_hw);
 
 #ifdef WLC_HIGH_ONLY
 extern void wlc_bmac_dngl_reboot(rpc_info_t *);
-extern void wlc_bmac_dngl_rpc_agg(rpc_info_t *, uint16 agg);
-extern void wlc_bmac_dngl_rpc_msglevel(rpc_info_t *, uint16 level);
-extern void wlc_bmac_dngl_rpc_txq_wm_set(rpc_info_t * rpc, uint32 wm);
-extern void wlc_bmac_dngl_rpc_txq_wm_get(rpc_info_t * rpc, uint32 * wm);
-extern void wlc_bmac_dngl_rpc_agg_limit_set(rpc_info_t * rpc, uint32 val);
-extern void wlc_bmac_dngl_rpc_agg_limit_get(rpc_info_t * rpc, uint32 * pval);
-extern int wlc_bmac_debug_template(wlc_hw_info_t * wlc_hw);
+extern void wlc_bmac_dngl_rpc_agg(rpc_info_t *, u16 agg);
+extern void wlc_bmac_dngl_rpc_msglevel(rpc_info_t *, u16 level);
+extern void wlc_bmac_dngl_rpc_txq_wm_set(rpc_info_t *rpc, u32 wm);
+extern void wlc_bmac_dngl_rpc_txq_wm_get(rpc_info_t *rpc, u32 *wm);
+extern void wlc_bmac_dngl_rpc_agg_limit_set(rpc_info_t *rpc, u32 val);
+extern void wlc_bmac_dngl_rpc_agg_limit_get(rpc_info_t *rpc, u32 *pval);
+extern int wlc_bmac_debug_template(wlc_hw_info_t *wlc_hw);
 #endif
 
 /* API for BMAC driver (e.g. wlc_phy.c etc) */
 
-extern void wlc_bmac_bw_set(wlc_hw_info_t * wlc_hw, uint16 bw);
-extern void wlc_bmac_pllreq(wlc_hw_info_t * wlc_hw, bool set, mbool req_bit);
-extern void wlc_bmac_set_clk(wlc_hw_info_t * wlc_hw, bool on);
-extern bool wlc_bmac_taclear(wlc_hw_info_t * wlc_hw, bool ta_ok);
+extern void wlc_bmac_bw_set(wlc_hw_info_t *wlc_hw, u16 bw);
+extern void wlc_bmac_pllreq(wlc_hw_info_t *wlc_hw, bool set, mbool req_bit);
+extern void wlc_bmac_set_clk(wlc_hw_info_t *wlc_hw, bool on);
+extern bool wlc_bmac_taclear(wlc_hw_info_t *wlc_hw, bool ta_ok);
 extern void wlc_bmac_hw_up(struct wlc_hw_info *wlc_hw);
 
-extern void wlc_bmac_dump(wlc_hw_info_t * wlc_hw, struct bcmstrbuf *b,
+extern void wlc_bmac_dump(wlc_hw_info_t *wlc_hw, struct bcmstrbuf *b,
 			  wlc_bmac_dump_id_t dump_id);
-extern void wlc_gpio_fast_deinit(wlc_hw_info_t * wlc_hw);
+extern void wlc_gpio_fast_deinit(wlc_hw_info_t *wlc_hw);
 
-extern bool wlc_bmac_radio_hw(wlc_hw_info_t * wlc_hw, bool enable);
-extern uint16 wlc_bmac_rate_shm_offset(wlc_hw_info_t * wlc_hw, uint8 rate);
+extern bool wlc_bmac_radio_hw(wlc_hw_info_t *wlc_hw, bool enable);
+extern u16 wlc_bmac_rate_shm_offset(wlc_hw_info_t *wlc_hw, u8 rate);
 
-extern void wlc_bmac_assert_type_set(wlc_hw_info_t * wlc_hw, uint32 type);
-extern void wlc_bmac_set_txpwr_percent(wlc_hw_info_t * wlc_hw, uint8 val);
-extern void wlc_bmac_blink_sync(wlc_hw_info_t * wlc_hw, uint32 led_pins);
-extern void wlc_bmac_ifsctl_edcrs_set(wlc_hw_info_t * wlc_hw, bool abie,
+extern void wlc_bmac_assert_type_set(wlc_hw_info_t *wlc_hw, u32 type);
+extern void wlc_bmac_set_txpwr_percent(wlc_hw_info_t *wlc_hw, u8 val);
+extern void wlc_bmac_blink_sync(wlc_hw_info_t *wlc_hw, u32 led_pins);
+extern void wlc_bmac_ifsctl_edcrs_set(wlc_hw_info_t *wlc_hw, bool abie,
 				      bool isht);
 
-extern void wlc_bmac_antsel_set(wlc_hw_info_t * wlc_hw, uint32 antsel_avail);
+extern void wlc_bmac_antsel_set(wlc_hw_info_t *wlc_hw, u32 antsel_avail);
diff --git a/drivers/staging/brcm80211/sys/wlc_bsscfg.h b/drivers/staging/brcm80211/sys/wlc_bsscfg.h
index af0886d..ae5542a 100644
--- a/drivers/staging/brcm80211/sys/wlc_bsscfg.h
+++ b/drivers/staging/brcm80211/sys/wlc_bsscfg.h
@@ -56,15 +56,15 @@ struct wlc_bsscfg {
 	bool _ap;		/* is this configuration an AP */
 	struct wlc_if *wlcif;	/* virtual interface, NULL for primary bsscfg */
 	void *sup;		/* pointer to supplicant state */
-	int8 sup_type;		/* type of supplicant */
+	s8 sup_type;		/* type of supplicant */
 	bool sup_enable_wpa;	/* supplicant WPA on/off */
 	void *authenticator;	/* pointer to authenticator state */
 	bool sup_auth_pending;	/* flag for auth timeout */
 #endif
-	uint8 SSID_len;		/* the length of SSID */
-	uint8 SSID[DOT11_MAX_SSID_LEN];	/* SSID string */
+	u8 SSID_len;		/* the length of SSID */
+	u8 SSID[DOT11_MAX_SSID_LEN];	/* SSID string */
 	struct scb *bcmc_scb[MAXBANDS];	/* one bcmc_scb per band */
-	int8 _idx;		/* the index of this bsscfg,
+	s8 _idx;		/* the index of this bsscfg,
 				 * assigned at wlc_bsscfg_alloc()
 				 */
 	/* MAC filter */
@@ -73,13 +73,13 @@ struct wlc_bsscfg {
 	struct ether_addr *maclist;	/* list of source MAC addrs to match */
 
 	/* security */
-	uint32 wsec;		/* wireless security bitvec */
-	int16 auth;		/* 802.11 authentication: Open, Shared Key, WPA */
-	int16 openshared;	/* try Open auth first, then Shared Key */
+	u32 wsec;		/* wireless security bitvec */
+	s16 auth;		/* 802.11 authentication: Open, Shared Key, WPA */
+	s16 openshared;	/* try Open auth first, then Shared Key */
 	bool wsec_restrict;	/* drop unencrypted packets if wsec is enabled */
 	bool eap_restrict;	/* restrict data until 802.1X auth succeeds */
-	uint16 WPA_auth;	/* WPA: authenticated key management */
-	bool wpa2_preauth;	/* default is TRUE, wpa_cap sets value */
+	u16 WPA_auth;	/* WPA: authenticated key management */
+	bool wpa2_preauth;	/* default is true, wpa_cap sets value */
 	bool wsec_portopen;	/* indicates keys are plumbed */
 	wsec_iv_t wpa_none_txiv;	/* global txiv for WPA_NONE, tkip and aes */
 	int wsec_index;		/* 0-3: default tx key, -1: not set */
@@ -87,19 +87,19 @@ struct wlc_bsscfg {
 
 	/* TKIP countermeasures */
 	bool tkip_countermeasures;	/* flags TKIP no-assoc period */
-	uint32 tk_cm_dt;	/* detect timer */
-	uint32 tk_cm_bt;	/* blocking timer */
-	uint32 tk_cm_bt_tmstmp;	/* Timestamp when TKIP BT is activated */
+	u32 tk_cm_dt;	/* detect timer */
+	u32 tk_cm_bt;	/* blocking timer */
+	u32 tk_cm_bt_tmstmp;	/* Timestamp when TKIP BT is activated */
 	bool tk_cm_activate;	/* activate countermeasures after EAPOL-Key sent */
 
 	struct ether_addr BSSID;	/* BSSID (associated) */
 	struct ether_addr cur_etheraddr;	/* h/w address */
-	uint16 bcmc_fid;	/* the last BCMC FID queued to TX_BCMC_FIFO */
-	uint16 bcmc_fid_shm;	/* the last BCMC FID written to shared mem */
+	u16 bcmc_fid;	/* the last BCMC FID queued to TX_BCMC_FIFO */
+	u16 bcmc_fid_shm;	/* the last BCMC FID written to shared mem */
 
-	uint32 flags;		/* WLC_BSSCFG flags; see below */
+	u32 flags;		/* WLC_BSSCFG flags; see below */
 
-	uint8 *bcn;		/* AP beacon */
+	u8 *bcn;		/* AP beacon */
 	uint bcn_len;		/* AP beacon length */
 	bool ar_disassoc;	/* disassociated in associated recreation */
 
@@ -125,7 +125,7 @@ struct wlc_bsscfg {
 	wsec_key_t *rcmta;
 
 	/* 'unique' ID of this bsscfg, assigned at bsscfg allocation */
-	uint16 ID;
+	u16 ID;
 
 	uint txrspecidx;	/* index into tx rate circular buffer */
 	ratespec_t txrspec[NTXRATE][2];	/* circular buffer of prev MPDUs tx rates */
diff --git a/drivers/staging/brcm80211/sys/wlc_channel.c b/drivers/staging/brcm80211/sys/wlc_channel.c
index 271c246..5092803 100644
--- a/drivers/staging/brcm80211/sys/wlc_channel.c
+++ b/drivers/staging/brcm80211/sys/wlc_channel.c
@@ -14,10 +14,12 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <wlc_cfg.h>
-#include <typedefs.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
 #include <bcmdefs.h>
+#include <wlc_cfg.h>
 #include <osl.h>
+#include <linuxver.h>
 #include <bcmutils.h>
 #include <siutils.h>
 #include <wlioctl.h>
@@ -29,11 +31,11 @@
 #include <wlc_channel.h>
 
 typedef struct wlc_cm_band {
-	uint8 locale_flags;	/* locale_info_t flags */
+	u8 locale_flags;	/* locale_info_t flags */
 	chanvec_t valid_channels;	/* List of valid channels in the country */
 	const chanvec_t *restricted_channels;	/* List of restricted use channels */
 	const chanvec_t *radar_channels;	/* List of radar sensitive channels */
-	uint8 PAD[8];
+	u8 PAD[8];
 } wlc_cm_band_t;
 
 struct wlc_cm_info {
@@ -50,32 +52,32 @@ struct wlc_cm_info {
 	chanvec_t quiet_channels;	/* channels on which we cannot transmit */
 };
 
-static int wlc_channels_init(wlc_cm_info_t * wlc_cm,
-			     const country_info_t * country);
-static void wlc_set_country_common(wlc_cm_info_t * wlc_cm,
+static int wlc_channels_init(wlc_cm_info_t *wlc_cm,
+			     const country_info_t *country);
+static void wlc_set_country_common(wlc_cm_info_t *wlc_cm,
 				   const char *country_abbrev,
 				   const char *ccode, uint regrev,
-				   const country_info_t * country);
-static int wlc_country_aggregate_map(wlc_cm_info_t * wlc_cm, const char *ccode,
-				     char *mapped_ccode, uint * mapped_regrev);
+				   const country_info_t *country);
+static int wlc_country_aggregate_map(wlc_cm_info_t *wlc_cm, const char *ccode,
+				     char *mapped_ccode, uint *mapped_regrev);
 static const country_info_t *wlc_country_lookup_direct(const char *ccode,
 						       uint regrev);
-static const country_info_t *wlc_countrycode_map(wlc_cm_info_t * wlc_cm,
+static const country_info_t *wlc_countrycode_map(wlc_cm_info_t *wlc_cm,
 						 const char *ccode,
 						 char *mapped_ccode,
-						 uint * mapped_regrev);
-static void wlc_channels_commit(wlc_cm_info_t * wlc_cm);
+						 uint *mapped_regrev);
+static void wlc_channels_commit(wlc_cm_info_t *wlc_cm);
 static bool wlc_japan_ccode(const char *ccode);
 static void wlc_channel_min_txpower_limits_with_local_constraint(wlc_cm_info_t *
 								 wlc_cm,
 								 struct
 								 txpwr_limits
 								 *txpwr,
-								 uint8
+								 u8
 								 local_constraint_qdbm);
-void wlc_locale_add_channels(chanvec_t * target, const chanvec_t * channels);
-static const locale_mimo_info_t *wlc_get_mimo_2g(uint8 locale_idx);
-static const locale_mimo_info_t *wlc_get_mimo_5g(uint8 locale_idx);
+void wlc_locale_add_channels(chanvec_t *target, const chanvec_t *channels);
+static const locale_mimo_info_t *wlc_get_mimo_2g(u8 locale_idx);
+static const locale_mimo_info_t *wlc_get_mimo_5g(u8 locale_idx);
 
 /* QDB() macro takes a dB value and converts to a quarter dB value */
 #ifdef QDB
@@ -190,12 +192,12 @@ static const chanvec_t restricted_set_12_13_14 = {
 #define  LOCALE_CHAN_52_140_ALL  (1<<14)
 #define  LOCALE_SET_5G_HIGH4     (1<<15)	/* 184-216 */
 
-#define  LOCALE_CHAN_36_64       LOCALE_SET_5G_LOW1 | LOCALE_SET_5G_LOW2 | LOCALE_SET_5G_LOW3
-#define  LOCALE_CHAN_52_64       LOCALE_SET_5G_LOW2 | LOCALE_SET_5G_LOW3
-#define  LOCALE_CHAN_100_124	 LOCALE_SET_5G_MID1 | LOCALE_SET_5G_MID2
+#define  LOCALE_CHAN_36_64       (LOCALE_SET_5G_LOW1 | LOCALE_SET_5G_LOW2 | LOCALE_SET_5G_LOW3)
+#define  LOCALE_CHAN_52_64       (LOCALE_SET_5G_LOW2 | LOCALE_SET_5G_LOW3)
+#define  LOCALE_CHAN_100_124	 (LOCALE_SET_5G_MID1 | LOCALE_SET_5G_MID2)
 #define  LOCALE_CHAN_100_140     \
-	LOCALE_SET_5G_MID1 | LOCALE_SET_5G_MID2 | LOCALE_SET_5G_MID3 | LOCALE_SET_5G_HIGH1
-#define  LOCALE_CHAN_149_165     LOCALE_SET_5G_HIGH2 | LOCALE_SET_5G_HIGH3
+	(LOCALE_SET_5G_MID1 | LOCALE_SET_5G_MID2 | LOCALE_SET_5G_MID3 | LOCALE_SET_5G_HIGH1)
+#define  LOCALE_CHAN_149_165     (LOCALE_SET_5G_HIGH2 | LOCALE_SET_5G_HIGH3)
 #define  LOCALE_CHAN_184_216     LOCALE_SET_5G_HIGH4
 
 #define  LOCALE_CHAN_01_14	(LOCALE_CHAN_01_11 | LOCALE_CHAN_12_13 | LOCALE_CHAN_14)
@@ -363,21 +365,21 @@ static const chanvec_t *g_table_locale_base[] = {
 	&locale_5g_HIGH4
 };
 
-void wlc_locale_add_channels(chanvec_t * target, const chanvec_t * channels)
+void wlc_locale_add_channels(chanvec_t *target, const chanvec_t *channels)
 {
-	uint8 i;
+	u8 i;
 	for (i = 0; i < sizeof(chanvec_t); i++) {
 		target->vec[i] |= channels->vec[i];
 	}
 }
 
-void wlc_locale_get_channels(const locale_info_t * locale, chanvec_t * channels)
+void wlc_locale_get_channels(const locale_info_t *locale, chanvec_t *channels)
 {
-	uint8 i;
+	u8 i;
 
 	bzero(channels, sizeof(chanvec_t));
 
-	for (i = 0; i < ARRAYSIZE(g_table_locale_base); i++) {
+	for (i = 0; i < ARRAY_SIZE(g_table_locale_base); i++) {
 		if (locale->valid_channels & (1 << i)) {
 			wlc_locale_add_channels(channels,
 						g_table_locale_base[i]);
@@ -483,8 +485,8 @@ static const struct {
 #ifdef SUPPORT_40MHZ
 /* 20MHz channel info for 40MHz pairing support */
 struct chan20_info {
-	uint8 sb;
-	uint8 adj_sbs;
+	u8 sb;
+	u8 adj_sbs;
 };
 
 /* indicates adjacent channels that are allowed for a 40 Mhz channel and
@@ -557,31 +559,31 @@ struct chan20_info chan20_info[] = {
 };
 #endif				/* SUPPORT_40MHZ */
 
-const locale_info_t *wlc_get_locale_2g(uint8 locale_idx)
+const locale_info_t *wlc_get_locale_2g(u8 locale_idx)
 {
-	if (locale_idx >= ARRAYSIZE(g_locale_2g_table)) {
+	if (locale_idx >= ARRAY_SIZE(g_locale_2g_table)) {
 		WL_ERROR(("%s: locale 2g index size out of range %d\n",
 			  __func__, locale_idx));
-		ASSERT(locale_idx < ARRAYSIZE(g_locale_2g_table));
+		ASSERT(locale_idx < ARRAY_SIZE(g_locale_2g_table));
 		return NULL;
 	}
 	return g_locale_2g_table[locale_idx];
 }
 
-const locale_info_t *wlc_get_locale_5g(uint8 locale_idx)
+const locale_info_t *wlc_get_locale_5g(u8 locale_idx)
 {
-	if (locale_idx >= ARRAYSIZE(g_locale_5g_table)) {
+	if (locale_idx >= ARRAY_SIZE(g_locale_5g_table)) {
 		WL_ERROR(("%s: locale 5g index size out of range %d\n",
 			  __func__, locale_idx));
-		ASSERT(locale_idx < ARRAYSIZE(g_locale_5g_table));
+		ASSERT(locale_idx < ARRAY_SIZE(g_locale_5g_table));
 		return NULL;
 	}
 	return g_locale_5g_table[locale_idx];
 }
 
-const locale_mimo_info_t *wlc_get_mimo_2g(uint8 locale_idx)
+const locale_mimo_info_t *wlc_get_mimo_2g(u8 locale_idx)
 {
-	if (locale_idx >= ARRAYSIZE(g_mimo_2g_table)) {
+	if (locale_idx >= ARRAY_SIZE(g_mimo_2g_table)) {
 		WL_ERROR(("%s: mimo 2g index size out of range %d\n", __func__,
 			  locale_idx));
 		return NULL;
@@ -589,9 +591,9 @@ const locale_mimo_info_t *wlc_get_mimo_2g(uint8 locale_idx)
 	return g_mimo_2g_table[locale_idx];
 }
 
-const locale_mimo_info_t *wlc_get_mimo_5g(uint8 locale_idx)
+const locale_mimo_info_t *wlc_get_mimo_5g(u8 locale_idx)
 {
-	if (locale_idx >= ARRAYSIZE(g_mimo_5g_table)) {
+	if (locale_idx >= ARRAY_SIZE(g_mimo_5g_table)) {
 		WL_ERROR(("%s: mimo 5g index size out of range %d\n", __func__,
 			  locale_idx));
 		return NULL;
@@ -599,7 +601,8 @@ const locale_mimo_info_t *wlc_get_mimo_5g(uint8 locale_idx)
 	return g_mimo_5g_table[locale_idx];
 }
 
-wlc_cm_info_t *BCMATTACHFN(wlc_channel_mgr_attach) (wlc_info_t * wlc) {
+wlc_cm_info_t *wlc_channel_mgr_attach(wlc_info_t *wlc)
+{
 	wlc_cm_info_t *wlc_cm;
 	char country_abbrev[WLC_CNTRY_BUF_SZ];
 	const country_info_t *country;
@@ -608,14 +611,11 @@ wlc_cm_info_t *BCMATTACHFN(wlc_channel_mgr_attach) (wlc_info_t * wlc) {
 
 	WL_TRACE(("wl%d: wlc_channel_mgr_attach\n", wlc->pub->unit));
 
-	if ((wlc_cm =
-	     (wlc_cm_info_t *) MALLOC(pub->osh,
-				      sizeof(wlc_cm_info_t))) == NULL) {
-		WL_ERROR(("wl%d: %s: out of memory, malloced %d bytes",
-			  pub->unit, __func__, MALLOCED(pub->osh)));
+	wlc_cm = kzalloc(sizeof(wlc_cm_info_t), GFP_ATOMIC);
+	if (wlc_cm == NULL) {
+		WL_ERROR(("wl%d: %s: out of memory", pub->unit, __func__));
 		return NULL;
 	}
-	bzero((char *)wlc_cm, sizeof(wlc_cm_info_t));
 	wlc_cm->pub = pub;
 	wlc_cm->wlc = wlc;
 	wlc->cmi = wlc_cm;
@@ -646,55 +646,56 @@ wlc_cm_info_t *BCMATTACHFN(wlc_channel_mgr_attach) (wlc_info_t * wlc) {
 	return wlc_cm;
 }
 
-void BCMATTACHFN(wlc_channel_mgr_detach) (wlc_cm_info_t * wlc_cm) {
+void wlc_channel_mgr_detach(wlc_cm_info_t *wlc_cm)
+{
 	if (wlc_cm)
-		MFREE(wlc_cm->pub->osh, wlc_cm, sizeof(wlc_cm_info_t));
+		kfree(wlc_cm);
 }
 
-const char *wlc_channel_country_abbrev(wlc_cm_info_t * wlc_cm)
+const char *wlc_channel_country_abbrev(wlc_cm_info_t *wlc_cm)
 {
 	return wlc_cm->country_abbrev;
 }
 
-uint8 wlc_channel_locale_flags(wlc_cm_info_t * wlc_cm)
+u8 wlc_channel_locale_flags(wlc_cm_info_t *wlc_cm)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 
 	return wlc_cm->bandstate[wlc->band->bandunit].locale_flags;
 }
 
-uint8 wlc_channel_locale_flags_in_band(wlc_cm_info_t * wlc_cm, uint bandunit)
+u8 wlc_channel_locale_flags_in_band(wlc_cm_info_t *wlc_cm, uint bandunit)
 {
 	return wlc_cm->bandstate[bandunit].locale_flags;
 }
 
 /* return chanvec for a given country code and band */
 bool
-wlc_channel_get_chanvec(struct wlc_info * wlc, const char *country_abbrev,
-			int bandtype, chanvec_t * channels)
+wlc_channel_get_chanvec(struct wlc_info *wlc, const char *country_abbrev,
+			int bandtype, chanvec_t *channels)
 {
 	const country_info_t *country;
 	const locale_info_t *locale = NULL;
 
 	country = wlc_country_lookup(wlc, country_abbrev);
 	if (country == NULL)
-		return FALSE;
+		return false;
 
 	if (bandtype == WLC_BAND_2G)
 		locale = wlc_get_locale_2g(country->locale_2G);
 	else if (bandtype == WLC_BAND_5G)
 		locale = wlc_get_locale_5g(country->locale_5G);
 	if (locale == NULL)
-		return FALSE;
+		return false;
 
 	wlc_locale_get_channels(locale, channels);
-	return TRUE;
+	return true;
 }
 
 /* set the driver's current country and regulatory information using a country code
  * as the source. Lookup built in country information found with the country code.
  */
-int wlc_set_countrycode(wlc_cm_info_t * wlc_cm, const char *ccode)
+int wlc_set_countrycode(wlc_cm_info_t *wlc_cm, const char *ccode)
 {
 	char country_abbrev[WLC_CNTRY_BUF_SZ];
 	strncpy(country_abbrev, ccode, WLC_CNTRY_BUF_SZ);
@@ -702,7 +703,7 @@ int wlc_set_countrycode(wlc_cm_info_t * wlc_cm, const char *ccode)
 }
 
 int
-wlc_set_countrycode_rev(wlc_cm_info_t * wlc_cm,
+wlc_set_countrycode_rev(wlc_cm_info_t *wlc_cm,
 			const char *country_abbrev,
 			const char *ccode, int regrev)
 {
@@ -742,10 +743,10 @@ wlc_set_countrycode_rev(wlc_cm_info_t * wlc_cm,
  * as the source. Look up built in country information found with the country code.
  */
 static void
-wlc_set_country_common(wlc_cm_info_t * wlc_cm,
+wlc_set_country_common(wlc_cm_info_t *wlc_cm,
 		       const char *country_abbrev,
 		       const char *ccode, uint regrev,
-		       const country_info_t * country)
+		       const country_info_t *country)
 {
 	const locale_mimo_info_t *li_mimo;
 	const locale_info_t *locale;
@@ -769,9 +770,9 @@ wlc_set_country_common(wlc_cm_info_t * wlc_cm,
 	li_mimo = wlc_get_mimo_2g(country->locale_mimo_2G);
 	if (li_mimo && (li_mimo->flags & WLC_NO_MIMO)) {
 		wlc_set_nmode(wlc, OFF);
-		wlc->stf->no_cddstbc = TRUE;
+		wlc->stf->no_cddstbc = true;
 	} else {
-		wlc->stf->no_cddstbc = FALSE;
+		wlc->stf->no_cddstbc = false;
 		if (N_ENAB(wlc->pub) != wlc->protection->nmode_user)
 			wlc_set_nmode(wlc, wlc->protection->nmode_user);
 	}
@@ -781,9 +782,9 @@ wlc_set_country_common(wlc_cm_info_t * wlc_cm,
 	/* set or restore gmode as required by regulatory */
 	locale = wlc_get_locale_2g(country->locale_2G);
 	if (locale && (locale->flags & WLC_NO_OFDM)) {
-		wlc_set_gmode(wlc, GMODE_LEGACY_B, FALSE);
+		wlc_set_gmode(wlc, GMODE_LEGACY_B, false);
 	} else {
-		wlc_set_gmode(wlc, wlc->protection->gmode_user, FALSE);
+		wlc_set_gmode(wlc, wlc->protection->gmode_user, false);
 	}
 
 	wlc_channels_init(wlc_cm, country);
@@ -808,10 +809,10 @@ const country_info_t *wlc_country_lookup(struct wlc_info *wlc,
 	return country;
 }
 
-static const country_info_t *wlc_countrycode_map(wlc_cm_info_t * wlc_cm,
+static const country_info_t *wlc_countrycode_map(wlc_cm_info_t *wlc_cm,
 						 const char *ccode,
 						 char *mapped_ccode,
-						 uint * mapped_regrev)
+						 uint *mapped_regrev)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 	const country_info_t *country;
@@ -860,10 +861,10 @@ static const country_info_t *wlc_countrycode_map(wlc_cm_info_t * wlc_cm,
 }
 
 static int
-wlc_country_aggregate_map(wlc_cm_info_t * wlc_cm, const char *ccode,
-			  char *mapped_ccode, uint * mapped_regrev)
+wlc_country_aggregate_map(wlc_cm_info_t *wlc_cm, const char *ccode,
+			  char *mapped_ccode, uint *mapped_regrev)
 {
-	return FALSE;
+	return false;
 }
 
 /* Lookup a country info structure from a null terminated country
@@ -882,7 +883,7 @@ static const country_info_t *wlc_country_lookup_direct(const char *ccode,
 		return NULL;
 
 	/* find matched table entry from country code */
-	size = ARRAYSIZE(cntry_locales);
+	size = ARRAY_SIZE(cntry_locales);
 	for (i = 0; i < size; i++) {
 		if (strcmp(ccode, cntry_locales[i].abbrev) == 0) {
 			return &cntry_locales[i].country;
@@ -895,7 +896,7 @@ static const country_info_t *wlc_country_lookup_direct(const char *ccode,
 }
 
 static int
-wlc_channels_init(wlc_cm_info_t * wlc_cm, const country_info_t * country)
+wlc_channels_init(wlc_cm_info_t *wlc_cm, const country_info_t *country)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 	uint i, j;
@@ -943,13 +944,13 @@ wlc_channels_init(wlc_cm_info_t * wlc_cm, const country_info_t * country)
 	wlc_quiet_channels_reset(wlc_cm);
 	wlc_channels_commit(wlc_cm);
 
-	return (0);
+	return 0;
 }
 
 /* Update the radio state (enable/disable) and tx power targets
  * based on a new set of channel/regulatory information
  */
-static void wlc_channels_commit(wlc_cm_info_t * wlc_cm)
+static void wlc_channels_commit(wlc_cm_info_t *wlc_cm)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 	uint chan;
@@ -970,8 +971,8 @@ static void wlc_channels_commit(wlc_cm_info_t * wlc_cm)
 		mboolset(wlc->pub->radio_disabled, WL_RADIO_COUNTRY_DISABLE);
 		WL_ERROR(("wl%d: %s: no valid channel for \"%s\" nbands %d bandlocked %d\n", wlc->pub->unit, __func__, wlc_cm->country_abbrev, NBANDS(wlc), wlc->bandlocked));
 	} else
-	    if (mboolisset(wlc->pub->radio_disabled, WL_RADIO_COUNTRY_DISABLE))
-	{
+	    if (mboolisset(wlc->pub->radio_disabled,
+		WL_RADIO_COUNTRY_DISABLE)) {
 		/* country/locale with valid channel, clear the radio disable bit */
 		mboolclr(wlc->pub->radio_disabled, WL_RADIO_COUNTRY_DISABLE);
 	}
@@ -981,8 +982,8 @@ static void wlc_channels_commit(wlc_cm_info_t * wlc_cm)
 	 */
 	if (NBANDS(wlc) > 1 || BAND_2G(wlc->band->bandtype)) {
 		wlc_phy_chanspec_ch14_widefilter_set(wlc->band->pi,
-						     wlc_japan(wlc) ? TRUE :
-						     FALSE);
+						     wlc_japan(wlc) ? true :
+						     false);
 	}
 
 	if (wlc->pub->up && chan != INVCHANNEL) {
@@ -995,7 +996,7 @@ static void wlc_channels_commit(wlc_cm_info_t * wlc_cm)
 }
 
 /* reset the quiet channels vector to the union of the restricted and radar channel sets */
-void wlc_quiet_channels_reset(wlc_cm_info_t * wlc_cm)
+void wlc_quiet_channels_reset(wlc_cm_info_t *wlc_cm)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 	uint i, j;
@@ -1016,9 +1017,9 @@ void wlc_quiet_channels_reset(wlc_cm_info_t * wlc_cm)
 	}
 }
 
-bool wlc_quiet_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chspec)
+bool wlc_quiet_chanspec(wlc_cm_info_t *wlc_cm, chanspec_t chspec)
 {
-	return (N_ENAB(wlc_cm->wlc->pub) && CHSPEC_IS40(chspec) ?
+	return N_ENAB(wlc_cm->wlc->pub) && CHSPEC_IS40(chspec) ?
 		(isset
 		 (wlc_cm->quiet_channels.vec,
 		  LOWER_20_SB(CHSPEC_CHANNEL(chspec)))
@@ -1027,31 +1028,31 @@ bool wlc_quiet_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chspec)
 									quiet_channels.
 									vec,
 									CHSPEC_CHANNEL
-									(chspec)));
+									(chspec));
 }
 
 /* Is the channel valid for the current locale? (but don't consider channels not
  *   available due to bandlocking)
  */
-bool wlc_valid_channel20_db(wlc_cm_info_t * wlc_cm, uint val)
+bool wlc_valid_channel20_db(wlc_cm_info_t *wlc_cm, uint val)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 
-	return (VALID_CHANNEL20(wlc, val) ||
+	return VALID_CHANNEL20(wlc, val) ||
 		(!wlc->bandlocked
-		 && VALID_CHANNEL20_IN_BAND(wlc, OTHERBANDUNIT(wlc), val)));
+		 && VALID_CHANNEL20_IN_BAND(wlc, OTHERBANDUNIT(wlc), val));
 }
 
 /* Is the channel valid for the current locale and specified band? */
 bool
-wlc_valid_channel20_in_band(wlc_cm_info_t * wlc_cm, uint bandunit, uint val)
+wlc_valid_channel20_in_band(wlc_cm_info_t *wlc_cm, uint bandunit, uint val)
 {
 	return ((val < MAXCHANNEL)
 		&& isset(wlc_cm->bandstate[bandunit].valid_channels.vec, val));
 }
 
 /* Is the channel valid for the current locale and current band? */
-bool wlc_valid_channel20(wlc_cm_info_t * wlc_cm, uint val)
+bool wlc_valid_channel20(wlc_cm_info_t *wlc_cm, uint val)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 
@@ -1061,7 +1062,7 @@ bool wlc_valid_channel20(wlc_cm_info_t * wlc_cm, uint val)
 }
 
 /* Is the 40 MHz allowed for the current locale and specified band? */
-bool wlc_valid_40chanspec_in_band(wlc_cm_info_t * wlc_cm, uint bandunit)
+bool wlc_valid_40chanspec_in_band(wlc_cm_info_t *wlc_cm, uint bandunit)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 
@@ -1071,95 +1072,95 @@ bool wlc_valid_40chanspec_in_band(wlc_cm_info_t * wlc_cm, uint bandunit)
 }
 
 static void
-wlc_channel_min_txpower_limits_with_local_constraint(wlc_cm_info_t * wlc_cm,
+wlc_channel_min_txpower_limits_with_local_constraint(wlc_cm_info_t *wlc_cm,
 						     struct txpwr_limits *txpwr,
-						     uint8
+						     u8
 						     local_constraint_qdbm)
 {
 	int j;
 
 	/* CCK Rates */
 	for (j = 0; j < WL_TX_POWER_CCK_NUM; j++) {
-		txpwr->cck[j] = MIN(txpwr->cck[j], local_constraint_qdbm);
+		txpwr->cck[j] = min(txpwr->cck[j], local_constraint_qdbm);
 	}
 
 	/* 20 MHz Legacy OFDM SISO */
 	for (j = 0; j < WL_TX_POWER_OFDM_NUM; j++) {
-		txpwr->ofdm[j] = MIN(txpwr->ofdm[j], local_constraint_qdbm);
+		txpwr->ofdm[j] = min(txpwr->ofdm[j], local_constraint_qdbm);
 	}
 
 	/* 20 MHz Legacy OFDM CDD */
 	for (j = 0; j < WLC_NUM_RATES_OFDM; j++) {
 		txpwr->ofdm_cdd[j] =
-		    MIN(txpwr->ofdm_cdd[j], local_constraint_qdbm);
+		    min(txpwr->ofdm_cdd[j], local_constraint_qdbm);
 	}
 
 	/* 40 MHz Legacy OFDM SISO */
 	for (j = 0; j < WLC_NUM_RATES_OFDM; j++) {
 		txpwr->ofdm_40_siso[j] =
-		    MIN(txpwr->ofdm_40_siso[j], local_constraint_qdbm);
+		    min(txpwr->ofdm_40_siso[j], local_constraint_qdbm);
 	}
 
 	/* 40 MHz Legacy OFDM CDD */
 	for (j = 0; j < WLC_NUM_RATES_OFDM; j++) {
 		txpwr->ofdm_40_cdd[j] =
-		    MIN(txpwr->ofdm_40_cdd[j], local_constraint_qdbm);
+		    min(txpwr->ofdm_40_cdd[j], local_constraint_qdbm);
 	}
 
 	/* 20MHz MCS 0-7 SISO */
 	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
 		txpwr->mcs_20_siso[j] =
-		    MIN(txpwr->mcs_20_siso[j], local_constraint_qdbm);
+		    min(txpwr->mcs_20_siso[j], local_constraint_qdbm);
 	}
 
 	/* 20MHz MCS 0-7 CDD */
 	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
 		txpwr->mcs_20_cdd[j] =
-		    MIN(txpwr->mcs_20_cdd[j], local_constraint_qdbm);
+		    min(txpwr->mcs_20_cdd[j], local_constraint_qdbm);
 	}
 
 	/* 20MHz MCS 0-7 STBC */
 	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
 		txpwr->mcs_20_stbc[j] =
-		    MIN(txpwr->mcs_20_stbc[j], local_constraint_qdbm);
+		    min(txpwr->mcs_20_stbc[j], local_constraint_qdbm);
 	}
 
 	/* 20MHz MCS 8-15 MIMO */
 	for (j = 0; j < WLC_NUM_RATES_MCS_2_STREAM; j++)
 		txpwr->mcs_20_mimo[j] =
-		    MIN(txpwr->mcs_20_mimo[j], local_constraint_qdbm);
+		    min(txpwr->mcs_20_mimo[j], local_constraint_qdbm);
 
 	/* 40MHz MCS 0-7 SISO */
 	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
 		txpwr->mcs_40_siso[j] =
-		    MIN(txpwr->mcs_40_siso[j], local_constraint_qdbm);
+		    min(txpwr->mcs_40_siso[j], local_constraint_qdbm);
 	}
 
 	/* 40MHz MCS 0-7 CDD */
 	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
 		txpwr->mcs_40_cdd[j] =
-		    MIN(txpwr->mcs_40_cdd[j], local_constraint_qdbm);
+		    min(txpwr->mcs_40_cdd[j], local_constraint_qdbm);
 	}
 
 	/* 40MHz MCS 0-7 STBC */
 	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
 		txpwr->mcs_40_stbc[j] =
-		    MIN(txpwr->mcs_40_stbc[j], local_constraint_qdbm);
+		    min(txpwr->mcs_40_stbc[j], local_constraint_qdbm);
 	}
 
 	/* 40MHz MCS 8-15 MIMO */
 	for (j = 0; j < WLC_NUM_RATES_MCS_2_STREAM; j++)
 		txpwr->mcs_40_mimo[j] =
-		    MIN(txpwr->mcs_40_mimo[j], local_constraint_qdbm);
+		    min(txpwr->mcs_40_mimo[j], local_constraint_qdbm);
 
 	/* 40MHz MCS 32 */
-	txpwr->mcs32 = MIN(txpwr->mcs32, local_constraint_qdbm);
+	txpwr->mcs32 = min(txpwr->mcs32, local_constraint_qdbm);
 
 }
 
 void
-wlc_channel_set_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chanspec,
-			 uint8 local_constraint_qdbm)
+wlc_channel_set_chanspec(wlc_cm_info_t *wlc_cm, chanspec_t chanspec,
+			 u8 local_constraint_qdbm)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 	struct txpwr_limits txpwr;
@@ -1175,8 +1176,8 @@ wlc_channel_set_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chanspec,
 }
 
 int
-wlc_channel_set_txpower_limit(wlc_cm_info_t * wlc_cm,
-			      uint8 local_constraint_qdbm)
+wlc_channel_set_txpower_limit(wlc_cm_info_t *wlc_cm,
+			      u8 local_constraint_qdbm)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 	struct txpwr_limits txpwr;
@@ -1192,7 +1193,7 @@ wlc_channel_set_txpower_limit(wlc_cm_info_t * wlc_cm,
 }
 
 #ifdef POWER_DBG
-static void wlc_phy_txpower_limits_dump(txpwr_limits_t * txpwr)
+static void wlc_phy_txpower_limits_dump(txpwr_limits_t *txpwr)
 {
 	int i;
 	char fraction[4][4] = { "   ", ".25", ".5 ", ".75" };
@@ -1295,8 +1296,8 @@ static void wlc_phy_txpower_limits_dump(txpwr_limits_t * txpwr)
 #endif				/* POWER_DBG */
 
 void
-wlc_channel_reg_limits(wlc_cm_info_t * wlc_cm, chanspec_t chanspec,
-		       txpwr_limits_t * txpwr)
+wlc_channel_reg_limits(wlc_cm_info_t *wlc_cm, chanspec_t chanspec,
+		       txpwr_limits_t *txpwr)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 	uint i;
@@ -1351,11 +1352,11 @@ wlc_channel_reg_limits(wlc_cm_info_t * wlc_cm, chanspec_t chanspec,
 		maxpwr = li->maxpwr[CHANNEL_POWER_IDX_2G_CCK(chan)];
 
 		maxpwr = maxpwr - delta;
-		maxpwr = MAX(maxpwr, 0);
-		maxpwr = MIN(maxpwr, conducted_max);
+		maxpwr = max(maxpwr, 0);
+		maxpwr = min(maxpwr, conducted_max);
 
 		for (i = 0; i < WLC_NUM_RATES_CCK; i++)
-			txpwr->cck[i] = (uint8) maxpwr;
+			txpwr->cck[i] = (u8) maxpwr;
 	}
 
 	/* OFDM txpwr limits for 2.4G or 5G bands */
@@ -1367,15 +1368,15 @@ wlc_channel_reg_limits(wlc_cm_info_t * wlc_cm, chanspec_t chanspec,
 	}
 
 	maxpwr = maxpwr - delta;
-	maxpwr = MAX(maxpwr, 0);
-	maxpwr = MIN(maxpwr, conducted_ofdm_max);
+	maxpwr = max(maxpwr, 0);
+	maxpwr = min(maxpwr, conducted_ofdm_max);
 
 	/* Keep OFDM lmit below CCK limit */
 	if (BAND_2G(band->bandtype))
-		maxpwr = MIN(maxpwr, txpwr->cck[0]);
+		maxpwr = min_t(int, maxpwr, txpwr->cck[0]);
 
 	for (i = 0; i < WLC_NUM_RATES_OFDM; i++) {
-		txpwr->ofdm[i] = (uint8) maxpwr;
+		txpwr->ofdm[i] = (u8) maxpwr;
 	}
 
 	for (i = 0; i < WLC_NUM_RATES_OFDM; i++) {
@@ -1386,7 +1387,7 @@ wlc_channel_reg_limits(wlc_cm_info_t * wlc_cm, chanspec_t chanspec,
 		 */
 		txpwr->ofdm_40_siso[i] = 0;
 
-		txpwr->ofdm_cdd[i] = (uint8) maxpwr;
+		txpwr->ofdm_cdd[i] = (u8) maxpwr;
 
 		txpwr->ofdm_40_cdd[i] = 0;
 	}
@@ -1409,9 +1410,9 @@ wlc_channel_reg_limits(wlc_cm_info_t * wlc_cm, chanspec_t chanspec,
 	maxpwr40 = li_mimo->maxpwr40[maxpwr_idx];
 
 	maxpwr20 = maxpwr20 - delta;
-	maxpwr20 = MAX(maxpwr20, 0);
+	maxpwr20 = max(maxpwr20, 0);
 	maxpwr40 = maxpwr40 - delta;
-	maxpwr40 = MAX(maxpwr40, 0);
+	maxpwr40 = max(maxpwr40, 0);
 
 	/* Fill in the MCS 0-7 (SISO) rates */
 	for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
@@ -1425,8 +1426,8 @@ wlc_channel_reg_limits(wlc_cm_info_t * wlc_cm, chanspec_t chanspec,
 
 	/* Fill in the MCS 0-7 CDD rates */
 	for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
-		txpwr->mcs_20_cdd[i] = (uint8) maxpwr20;
-		txpwr->mcs_40_cdd[i] = (uint8) maxpwr40;
+		txpwr->mcs_20_cdd[i] = (u8) maxpwr20;
+		txpwr->mcs_40_cdd[i] = (u8) maxpwr40;
 	}
 
 	/* These locales have SISO expressed in the table and override CDD later */
@@ -1441,8 +1442,8 @@ wlc_channel_reg_limits(wlc_cm_info_t * wlc_cm, chanspec_t chanspec,
 		}
 
 		for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
-			txpwr->mcs_20_siso[i] = (uint8) maxpwr20;
-			txpwr->mcs_40_siso[i] = (uint8) maxpwr40;
+			txpwr->mcs_20_siso[i] = (u8) maxpwr20;
+			txpwr->mcs_40_siso[i] = (u8) maxpwr40;
 		}
 	}
 
@@ -1454,12 +1455,12 @@ wlc_channel_reg_limits(wlc_cm_info_t * wlc_cm, chanspec_t chanspec,
 
 	/* Fill in the MCS 8-15 SDM rates */
 	for (i = 0; i < WLC_NUM_RATES_MCS_2_STREAM; i++) {
-		txpwr->mcs_20_mimo[i] = (uint8) maxpwr20;
-		txpwr->mcs_40_mimo[i] = (uint8) maxpwr40;
+		txpwr->mcs_20_mimo[i] = (u8) maxpwr20;
+		txpwr->mcs_40_mimo[i] = (u8) maxpwr40;
 	}
 
 	/* Fill in MCS32 */
-	txpwr->mcs32 = (uint8) maxpwr40;
+	txpwr->mcs32 = (u8) maxpwr40;
 
 	for (i = 0, j = 0; i < WLC_NUM_RATES_OFDM; i++, j++) {
 		if (txpwr->ofdm_40_cdd[i] == 0)
@@ -1472,7 +1473,7 @@ wlc_channel_reg_limits(wlc_cm_info_t * wlc_cm, chanspec_t chanspec,
 	}
 
 	/* Copy the 40 MHZ MCS 0-7 CDD value to the 40 MHZ MCS 0-7 SISO value if it wasn't
-	 * provided explicitly. 
+	 * provided explicitly.
 	 */
 
 	for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
@@ -1507,8 +1508,8 @@ wlc_channel_reg_limits(wlc_cm_info_t * wlc_cm, chanspec_t chanspec,
 	return;
 }
 
-/* Returns TRUE if currently set country is Japan or variant */
-bool wlc_japan(struct wlc_info * wlc)
+/* Returns true if currently set country is Japan or variant */
+bool wlc_japan(struct wlc_info *wlc)
 {
 	return wlc_japan_ccode(wlc->cmi->country_abbrev);
 }
@@ -1525,50 +1526,50 @@ static bool wlc_japan_ccode(const char *ccode)
  * are valid 20MZH channels in this locale and they are also a legal HT combination
  */
 static bool
-wlc_valid_chanspec_ext(wlc_cm_info_t * wlc_cm, chanspec_t chspec, bool dualband)
+wlc_valid_chanspec_ext(wlc_cm_info_t *wlc_cm, chanspec_t chspec, bool dualband)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
-	uint8 channel = CHSPEC_CHANNEL(chspec);
+	u8 channel = CHSPEC_CHANNEL(chspec);
 
 	/* check the chanspec */
 	if (wf_chspec_malformed(chspec)) {
 		WL_ERROR(("wl%d: malformed chanspec 0x%x\n", wlc->pub->unit,
 			  chspec));
 		ASSERT(0);
-		return FALSE;
+		return false;
 	}
 
 	if (CHANNEL_BANDUNIT(wlc_cm->wlc, channel) !=
 	    CHSPEC_WLCBANDUNIT(chspec))
-		return FALSE;
+		return false;
 
 	/* Check a 20Mhz channel */
 	if (CHSPEC_IS20(chspec)) {
 		if (dualband)
-			return (VALID_CHANNEL20_DB(wlc_cm->wlc, channel));
+			return VALID_CHANNEL20_DB(wlc_cm->wlc, channel);
 		else
-			return (VALID_CHANNEL20(wlc_cm->wlc, channel));
+			return VALID_CHANNEL20(wlc_cm->wlc, channel);
 	}
 #ifdef SUPPORT_40MHZ
 	/* We know we are now checking a 40MHZ channel, so we should only be here
 	 * for NPHYS
 	 */
 	if (WLCISNPHY(wlc->band) || WLCISSSLPNPHY(wlc->band)) {
-		uint8 upper_sideband = 0, idx;
-		uint8 num_ch20_entries =
+		u8 upper_sideband = 0, idx;
+		u8 num_ch20_entries =
 		    sizeof(chan20_info) / sizeof(struct chan20_info);
 
 		if (!VALID_40CHANSPEC_IN_BAND(wlc, CHSPEC_WLCBANDUNIT(chspec)))
-			return FALSE;
+			return false;
 
 		if (dualband) {
 			if (!VALID_CHANNEL20_DB(wlc, LOWER_20_SB(channel)) ||
 			    !VALID_CHANNEL20_DB(wlc, UPPER_20_SB(channel)))
-				return FALSE;
+				return false;
 		} else {
 			if (!VALID_CHANNEL20(wlc, LOWER_20_SB(channel)) ||
 			    !VALID_CHANNEL20(wlc, UPPER_20_SB(channel)))
-				return FALSE;
+				return false;
 		}
 
 		/* find the lower sideband info in the sideband array */
@@ -1579,20 +1580,20 @@ wlc_valid_chanspec_ext(wlc_cm_info_t * wlc_cm, chanspec_t chspec, bool dualband)
 		/* check that the lower sideband allows an upper sideband */
 		if ((upper_sideband & (CH_UPPER_SB | CH_EWA_VALID)) ==
 		    (CH_UPPER_SB | CH_EWA_VALID))
-			return TRUE;
-		return FALSE;
+			return true;
+		return false;
 	}
 #endif				/* 40 MHZ */
 
-	return FALSE;
+	return false;
 }
 
-bool wlc_valid_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chspec)
+bool wlc_valid_chanspec(wlc_cm_info_t *wlc_cm, chanspec_t chspec)
 {
-	return wlc_valid_chanspec_ext(wlc_cm, chspec, FALSE);
+	return wlc_valid_chanspec_ext(wlc_cm, chspec, false);
 }
 
-bool wlc_valid_chanspec_db(wlc_cm_info_t * wlc_cm, chanspec_t chspec)
+bool wlc_valid_chanspec_db(wlc_cm_info_t *wlc_cm, chanspec_t chspec)
 {
-	return wlc_valid_chanspec_ext(wlc_cm, chspec, TRUE);
+	return wlc_valid_chanspec_ext(wlc_cm, chspec, true);
 }
diff --git a/drivers/staging/brcm80211/sys/wlc_channel.h b/drivers/staging/brcm80211/sys/wlc_channel.h
index 9bc708d..1f170af 100644
--- a/drivers/staging/brcm80211/sys/wlc_channel.h
+++ b/drivers/staging/brcm80211/sys/wlc_channel.h
@@ -47,21 +47,21 @@ struct wlc_info;
 
 /* macro to get 5 GHz channel group index for tx power */
 #define CHANNEL_POWER_IDX_5G(c) \
-	(((c) < 52) ? 0 : (((c) < 62) ? 1 :(((c) < 100) ? 2 : (((c) < 149) ? 3 : 4))))
+	(((c) < 52) ? 0 : (((c) < 62) ? 1 : (((c) < 100) ? 2 : (((c) < 149) ? 3 : 4))))
 
 #define WLC_MAXPWR_TBL_SIZE		6	/* max of BAND_5G_PWR_LVLS and 6 for 2.4 GHz */
 #define WLC_MAXPWR_MIMO_TBL_SIZE	14	/* max of BAND_5G_PWR_LVLS and 14 for 2.4 GHz */
 
 /* locale channel and power info. */
 typedef struct {
-	uint32 valid_channels;
-	uint8 radar_channels;	/* List of radar sensitive channels */
-	uint8 restricted_channels;	/* List of channels used only if APs are detected */
-	int8 maxpwr[WLC_MAXPWR_TBL_SIZE];	/* Max tx pwr in qdBm for each sub-band */
-	int8 pub_maxpwr[BAND_5G_PWR_LVLS];	/* Country IE advertised max tx pwr in dBm
+	u32 valid_channels;
+	u8 radar_channels;	/* List of radar sensitive channels */
+	u8 restricted_channels;	/* List of channels used only if APs are detected */
+	s8 maxpwr[WLC_MAXPWR_TBL_SIZE];	/* Max tx pwr in qdBm for each sub-band */
+	s8 pub_maxpwr[BAND_5G_PWR_LVLS];	/* Country IE advertised max tx pwr in dBm
 						 * per sub-band
 						 */
-	uint8 flags;
+	u8 flags;
 } locale_info_t;
 
 /* bits for locale_info flags */
@@ -82,9 +82,9 @@ typedef struct {
  * by sub-band for 5 GHz limits using CHANNEL_POWER_IDX_5G(channel)
  */
 typedef struct {
-	int8 maxpwr20[WLC_MAXPWR_MIMO_TBL_SIZE];	/* tx 20 MHz power limits, qdBm units */
-	int8 maxpwr40[WLC_MAXPWR_MIMO_TBL_SIZE];	/* tx 40 MHz power limits, qdBm units */
-	uint8 flags;
+	s8 maxpwr20[WLC_MAXPWR_MIMO_TBL_SIZE];	/* tx 20 MHz power limits, qdBm units */
+	s8 maxpwr40[WLC_MAXPWR_MIMO_TBL_SIZE];	/* tx 40 MHz power limits, qdBm units */
+	u8 flags;
 } locale_mimo_info_t;
 
 extern const chanvec_t chanvec_all_2G;
@@ -94,10 +94,10 @@ extern const chanvec_t chanvec_all_5G;
  * Country names and abbreviations with locale defined from ISO 3166
  */
 struct country_info {
-	const uint8 locale_2G;	/* 2.4G band locale */
-	const uint8 locale_5G;	/* 5G band locale */
-	const uint8 locale_mimo_2G;	/* 2.4G mimo info */
-	const uint8 locale_mimo_5G;	/* 5G mimo info */
+	const u8 locale_2G;	/* 2.4G band locale */
+	const u8 locale_5G;	/* 5G band locale */
+	const u8 locale_mimo_2G;	/* 2.4G mimo info */
+	const u8 locale_mimo_5G;	/* 5G mimo info */
 };
 
 typedef struct country_info country_info_t;
@@ -105,20 +105,20 @@ typedef struct country_info country_info_t;
 typedef struct wlc_cm_info wlc_cm_info_t;
 
 extern wlc_cm_info_t *wlc_channel_mgr_attach(struct wlc_info *wlc);
-extern void wlc_channel_mgr_detach(wlc_cm_info_t * wlc_cm);
+extern void wlc_channel_mgr_detach(wlc_cm_info_t *wlc_cm);
 
-extern int wlc_set_countrycode(wlc_cm_info_t * wlc_cm, const char *ccode);
-extern int wlc_set_countrycode_rev(wlc_cm_info_t * wlc_cm,
+extern int wlc_set_countrycode(wlc_cm_info_t *wlc_cm, const char *ccode);
+extern int wlc_set_countrycode_rev(wlc_cm_info_t *wlc_cm,
 				   const char *country_abbrev,
 				   const char *ccode, int regrev);
 
-extern const char *wlc_channel_country_abbrev(wlc_cm_info_t * wlc_cm);
-extern uint8 wlc_channel_locale_flags(wlc_cm_info_t * wlc_cm);
-extern uint8 wlc_channel_locale_flags_in_band(wlc_cm_info_t * wlc_cm,
+extern const char *wlc_channel_country_abbrev(wlc_cm_info_t *wlc_cm);
+extern u8 wlc_channel_locale_flags(wlc_cm_info_t *wlc_cm);
+extern u8 wlc_channel_locale_flags_in_band(wlc_cm_info_t *wlc_cm,
 					      uint bandunit);
 
-extern void wlc_quiet_channels_reset(wlc_cm_info_t * wlc_cm);
-extern bool wlc_quiet_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chspec);
+extern void wlc_quiet_channels_reset(wlc_cm_info_t *wlc_cm);
+extern bool wlc_quiet_chanspec(wlc_cm_info_t *wlc_cm, chanspec_t chspec);
 
 #define	VALID_CHANNEL20_DB(wlc, val) wlc_valid_channel20_db((wlc)->cmi, val)
 #define	VALID_CHANNEL20_IN_BAND(wlc, bandunit, val) \
@@ -126,34 +126,34 @@ extern bool wlc_quiet_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chspec);
 #define	VALID_CHANNEL20(wlc, val) wlc_valid_channel20((wlc)->cmi, val)
 #define VALID_40CHANSPEC_IN_BAND(wlc, bandunit) wlc_valid_40chanspec_in_band((wlc)->cmi, bandunit)
 
-extern bool wlc_valid_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chspec);
-extern bool wlc_valid_chanspec_db(wlc_cm_info_t * wlc_cm, chanspec_t chspec);
-extern bool wlc_valid_channel20_db(wlc_cm_info_t * wlc_cm, uint val);
-extern bool wlc_valid_channel20_in_band(wlc_cm_info_t * wlc_cm, uint bandunit,
+extern bool wlc_valid_chanspec(wlc_cm_info_t *wlc_cm, chanspec_t chspec);
+extern bool wlc_valid_chanspec_db(wlc_cm_info_t *wlc_cm, chanspec_t chspec);
+extern bool wlc_valid_channel20_db(wlc_cm_info_t *wlc_cm, uint val);
+extern bool wlc_valid_channel20_in_band(wlc_cm_info_t *wlc_cm, uint bandunit,
 					uint val);
-extern bool wlc_valid_channel20(wlc_cm_info_t * wlc_cm, uint val);
-extern bool wlc_valid_40chanspec_in_band(wlc_cm_info_t * wlc_cm, uint bandunit);
+extern bool wlc_valid_channel20(wlc_cm_info_t *wlc_cm, uint val);
+extern bool wlc_valid_40chanspec_in_band(wlc_cm_info_t *wlc_cm, uint bandunit);
 
-extern void wlc_channel_reg_limits(wlc_cm_info_t * wlc_cm,
+extern void wlc_channel_reg_limits(wlc_cm_info_t *wlc_cm,
 				   chanspec_t chanspec,
 				   struct txpwr_limits *txpwr);
-extern void wlc_channel_set_chanspec(wlc_cm_info_t * wlc_cm,
+extern void wlc_channel_set_chanspec(wlc_cm_info_t *wlc_cm,
 				     chanspec_t chanspec,
-				     uint8 local_constraint_qdbm);
-extern int wlc_channel_set_txpower_limit(wlc_cm_info_t * wlc_cm,
-					 uint8 local_constraint_qdbm);
+				     u8 local_constraint_qdbm);
+extern int wlc_channel_set_txpower_limit(wlc_cm_info_t *wlc_cm,
+					 u8 local_constraint_qdbm);
 
 extern const country_info_t *wlc_country_lookup(struct wlc_info *wlc,
 						const char *ccode);
-extern void wlc_locale_get_channels(const locale_info_t * locale,
-				    chanvec_t * valid_channels);
-extern const locale_info_t *wlc_get_locale_2g(uint8 locale_idx);
-extern const locale_info_t *wlc_get_locale_5g(uint8 locale_idx);
+extern void wlc_locale_get_channels(const locale_info_t *locale,
+				    chanvec_t *valid_channels);
+extern const locale_info_t *wlc_get_locale_2g(u8 locale_idx);
+extern const locale_info_t *wlc_get_locale_5g(u8 locale_idx);
 extern bool wlc_japan(struct wlc_info *wlc);
 
-extern uint8 wlc_get_regclass(wlc_cm_info_t * wlc_cm, chanspec_t chanspec);
+extern u8 wlc_get_regclass(wlc_cm_info_t *wlc_cm, chanspec_t chanspec);
 extern bool wlc_channel_get_chanvec(struct wlc_info *wlc,
 				    const char *country_abbrev, int bandtype,
-				    chanvec_t * channels);
+				    chanvec_t *channels);
 
 #endif				/* _WLC_CHANNEL_H */
diff --git a/drivers/staging/brcm80211/sys/wlc_event.c b/drivers/staging/brcm80211/sys/wlc_event.c
index 74aae63..7e1bf0e 100644
--- a/drivers/staging/brcm80211/sys/wlc_event.c
+++ b/drivers/staging/brcm80211/sys/wlc_event.c
@@ -14,12 +14,12 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <typedefs.h>
+#include <linux/kernel.h>
+#include <bcmdefs.h>
+#include <linuxver.h>
 #include <bcmutils.h>
 #include <siutils.h>
-#include <bcmendian.h>
 #include <wlioctl.h>
-#include <wl_dbg.h>
 #include <wlc_cfg.h>
 #include <wlc_pub.h>
 #include <wlc_key.h>
@@ -47,98 +47,98 @@ struct wlc_eventq {
 	bool workpending;
 	struct wl_timer *timer;
 	wlc_eventq_cb_t cb;
-	uint8 event_inds_mask[ROUNDUP(WLC_E_LAST, NBBY) / NBBY];
+	u8 event_inds_mask[broken_roundup(WLC_E_LAST, NBBY) / NBBY];
 };
 
 /*
  * Export functions
  */
-wlc_eventq_t *BCMATTACHFN(wlc_eventq_attach) (wlc_pub_t * pub,
-					      struct wlc_info * wlc, void *wl,
-					      wlc_eventq_cb_t cb) {
+wlc_eventq_t *wlc_eventq_attach(wlc_pub_t *pub, struct wlc_info *wlc, void *wl,
+				wlc_eventq_cb_t cb)
+{
 	wlc_eventq_t *eq;
 
-	eq = (wlc_eventq_t *) MALLOC(pub->osh, sizeof(wlc_eventq_t));
+	eq = kzalloc(sizeof(wlc_eventq_t), GFP_ATOMIC);
 	if (eq == NULL)
 		return NULL;
 
-	bzero(eq, sizeof(wlc_eventq_t));
-
 	eq->cb = cb;
 	eq->wlc = wlc;
 	eq->wl = wl;
 	eq->pub = pub;
 
-	if (!(eq->timer = wl_init_timer(eq->wl, wlc_timer_cb, eq, "eventq"))) {
+	eq->timer = wl_init_timer(eq->wl, wlc_timer_cb, eq, "eventq");
+	if (!eq->timer) {
 		WL_ERROR(("wl%d: wlc_eventq_attach: timer failed\n",
 			  pub->unit));
-		MFREE(eq->pub->osh, eq, sizeof(wlc_eventq_t));
+		kfree(eq);
 		return NULL;
 	}
 
 	return eq;
 }
 
-int BCMATTACHFN(wlc_eventq_detach) (wlc_eventq_t * eq) {
+int wlc_eventq_detach(wlc_eventq_t *eq)
+{
 	/* Clean up pending events */
 	wlc_eventq_down(eq);
 
 	if (eq->timer) {
 		if (eq->tpending) {
 			wl_del_timer(eq->wl, eq->timer);
-			eq->tpending = FALSE;
+			eq->tpending = false;
 		}
 		wl_free_timer(eq->wl, eq->timer);
 		eq->timer = NULL;
 	}
 
-	ASSERT(wlc_eventq_avail(eq) == FALSE);
-	MFREE(eq->pub->osh, eq, sizeof(wlc_eventq_t));
+	ASSERT(wlc_eventq_avail(eq) == false);
+	kfree(eq);
 	return 0;
 }
 
-int BCMUNINITFN(wlc_eventq_down) (wlc_eventq_t * eq) {
+int wlc_eventq_down(wlc_eventq_t *eq)
+{
 	int callbacks = 0;
 	if (eq->tpending && !eq->workpending) {
 		if (!wl_del_timer(eq->wl, eq->timer))
 			callbacks++;
 
-		ASSERT(wlc_eventq_avail(eq) == TRUE);
-		ASSERT(eq->workpending == FALSE);
-		eq->workpending = TRUE;
+		ASSERT(wlc_eventq_avail(eq) == true);
+		ASSERT(eq->workpending == false);
+		eq->workpending = true;
 		if (eq->cb)
 			eq->cb(eq->wlc);
 
-		ASSERT(eq->workpending == TRUE);
-		eq->workpending = FALSE;
-		eq->tpending = FALSE;
+		ASSERT(eq->workpending == true);
+		eq->workpending = false;
+		eq->tpending = false;
 	} else {
-		ASSERT(eq->workpending || wlc_eventq_avail(eq) == FALSE);
+		ASSERT(eq->workpending || wlc_eventq_avail(eq) == false);
 	}
 	return callbacks;
 }
 
-wlc_event_t *wlc_event_alloc(wlc_eventq_t * eq)
+wlc_event_t *wlc_event_alloc(wlc_eventq_t *eq)
 {
 	wlc_event_t *e;
 
-	e = MALLOC(eq->pub->osh, sizeof(wlc_event_t));
+	e = kzalloc(sizeof(wlc_event_t), GFP_ATOMIC);
 
 	if (e == NULL)
 		return NULL;
 
-	bzero(e, sizeof(wlc_event_t));
 	return e;
 }
 
-void wlc_event_free(wlc_eventq_t * eq, wlc_event_t * e)
+void wlc_event_free(wlc_eventq_t *eq, wlc_event_t *e)
 {
 	ASSERT(e->data == NULL);
 	ASSERT(e->next == NULL);
-	MFREE(eq->pub->osh, e, sizeof(wlc_event_t));
+	kfree(e);
 }
 
-void wlc_eventq_enq(wlc_eventq_t * eq, wlc_event_t * e)
+void wlc_eventq_enq(wlc_eventq_t *eq, wlc_event_t *e)
 {
 	ASSERT(e->next == NULL);
 	e->next = NULL;
@@ -150,7 +150,7 @@ void wlc_eventq_enq(wlc_eventq_t * eq, wlc_event_t * e)
 		eq->head = eq->tail = e;
 
 	if (!eq->tpending) {
-		eq->tpending = TRUE;
+		eq->tpending = true;
 		/* Use a zero-delay timer to trigger
 		 * delayed processing of the event.
 		 */
@@ -158,7 +158,7 @@ void wlc_eventq_enq(wlc_eventq_t * eq, wlc_event_t * e)
 	}
 }
 
-wlc_event_t *wlc_eventq_deq(wlc_eventq_t * eq)
+wlc_event_t *wlc_eventq_deq(wlc_eventq_t *eq)
 {
 	wlc_event_t *e;
 
@@ -173,7 +173,7 @@ wlc_event_t *wlc_eventq_deq(wlc_eventq_t * eq)
 	return e;
 }
 
-wlc_event_t *wlc_eventq_next(wlc_eventq_t * eq, wlc_event_t * e)
+wlc_event_t *wlc_eventq_next(wlc_eventq_t *eq, wlc_event_t *e)
 {
 #ifdef BCMDBG
 	wlc_event_t *etmp;
@@ -188,7 +188,7 @@ wlc_event_t *wlc_eventq_next(wlc_eventq_t * eq, wlc_event_t * e)
 	return e->next;
 }
 
-int wlc_eventq_cnt(wlc_eventq_t * eq)
+int wlc_eventq_cnt(wlc_eventq_t *eq)
 {
 	wlc_event_t *etmp;
 	int cnt = 0;
@@ -199,7 +199,7 @@ int wlc_eventq_cnt(wlc_eventq_t * eq)
 	return cnt;
 }
 
-bool wlc_eventq_avail(wlc_eventq_t * eq)
+bool wlc_eventq_avail(wlc_eventq_t *eq)
 {
 	return (eq->head != NULL);
 }
@@ -211,16 +211,16 @@ static void wlc_timer_cb(void *arg)
 {
 	struct wlc_eventq *eq = (struct wlc_eventq *)arg;
 
-	ASSERT(eq->tpending == TRUE);
-	ASSERT(wlc_eventq_avail(eq) == TRUE);
-	ASSERT(eq->workpending == FALSE);
-	eq->workpending = TRUE;
+	ASSERT(eq->tpending == true);
+	ASSERT(wlc_eventq_avail(eq) == true);
+	ASSERT(eq->workpending == false);
+	eq->workpending = true;
 
 	if (eq->cb)
 		eq->cb(eq->wlc);
 
-	ASSERT(wlc_eventq_avail(eq) == FALSE);
-	ASSERT(eq->tpending == TRUE);
-	eq->workpending = FALSE;
-	eq->tpending = FALSE;
+	ASSERT(wlc_eventq_avail(eq) == false);
+	ASSERT(eq->tpending == true);
+	eq->workpending = false;
+	eq->tpending = false;
 }
diff --git a/drivers/staging/brcm80211/sys/wlc_event.h b/drivers/staging/brcm80211/sys/wlc_event.h
index 48efdbc..e443dae 100644
--- a/drivers/staging/brcm80211/sys/wlc_event.h
+++ b/drivers/staging/brcm80211/sys/wlc_event.h
@@ -21,31 +21,31 @@ typedef struct wlc_eventq wlc_eventq_t;
 
 typedef void (*wlc_eventq_cb_t) (void *arg);
 
-extern wlc_eventq_t *wlc_eventq_attach(wlc_pub_t * pub, struct wlc_info *wlc,
+extern wlc_eventq_t *wlc_eventq_attach(wlc_pub_t *pub, struct wlc_info *wlc,
 				       void *wl, wlc_eventq_cb_t cb);
-extern int wlc_eventq_detach(wlc_eventq_t * eq);
-extern int wlc_eventq_down(wlc_eventq_t * eq);
-extern void wlc_event_free(wlc_eventq_t * eq, wlc_event_t * e);
-extern wlc_event_t *wlc_eventq_next(wlc_eventq_t * eq, wlc_event_t * e);
-extern int wlc_eventq_cnt(wlc_eventq_t * eq);
-extern bool wlc_eventq_avail(wlc_eventq_t * eq);
-extern wlc_event_t *wlc_eventq_deq(wlc_eventq_t * eq);
-extern void wlc_eventq_enq(wlc_eventq_t * eq, wlc_event_t * e);
-extern wlc_event_t *wlc_event_alloc(wlc_eventq_t * eq);
+extern int wlc_eventq_detach(wlc_eventq_t *eq);
+extern int wlc_eventq_down(wlc_eventq_t *eq);
+extern void wlc_event_free(wlc_eventq_t *eq, wlc_event_t *e);
+extern wlc_event_t *wlc_eventq_next(wlc_eventq_t *eq, wlc_event_t *e);
+extern int wlc_eventq_cnt(wlc_eventq_t *eq);
+extern bool wlc_eventq_avail(wlc_eventq_t *eq);
+extern wlc_event_t *wlc_eventq_deq(wlc_eventq_t *eq);
+extern void wlc_eventq_enq(wlc_eventq_t *eq, wlc_event_t *e);
+extern wlc_event_t *wlc_event_alloc(wlc_eventq_t *eq);
 
-extern int wlc_eventq_register_ind(wlc_eventq_t * eq, void *bitvect);
-extern int wlc_eventq_query_ind(wlc_eventq_t * eq, void *bitvect);
-extern int wlc_eventq_test_ind(wlc_eventq_t * eq, int et);
-extern int wlc_eventq_set_ind(wlc_eventq_t * eq, uint et, bool on);
-extern void wlc_eventq_flush(wlc_eventq_t * eq);
-extern void wlc_assign_event_msg(wlc_info_t * wlc, wl_event_msg_t * msg,
-				 const wlc_event_t * e, uint8 * data,
-				 uint32 len);
+extern int wlc_eventq_register_ind(wlc_eventq_t *eq, void *bitvect);
+extern int wlc_eventq_query_ind(wlc_eventq_t *eq, void *bitvect);
+extern int wlc_eventq_test_ind(wlc_eventq_t *eq, int et);
+extern int wlc_eventq_set_ind(wlc_eventq_t *eq, uint et, bool on);
+extern void wlc_eventq_flush(wlc_eventq_t *eq);
+extern void wlc_assign_event_msg(wlc_info_t *wlc, wl_event_msg_t *msg,
+				 const wlc_event_t *e, u8 *data,
+				 u32 len);
 
 #ifdef MSGTRACE
-extern void wlc_event_sendup_trace(struct wlc_info *wlc, hndrte_dev_t * bus,
-				   uint8 * hdr, uint16 hdrlen, uint8 * buf,
-				   uint16 buflen);
+extern void wlc_event_sendup_trace(struct wlc_info *wlc, hndrte_dev_t *bus,
+				   u8 *hdr, u16 hdrlen, u8 *buf,
+				   u16 buflen);
 #endif
 
 #endif				/* _WLC_EVENT_H_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_key.h b/drivers/staging/brcm80211/sys/wlc_key.h
index 9d2ea4e..6678c69 100644
--- a/drivers/staging/brcm80211/sys/wlc_key.h
+++ b/drivers/staging/brcm80211/sys/wlc_key.h
@@ -65,11 +65,11 @@ struct wlc_bsscfg;
 #define WSEC_KEY(wlc, i)	(((wlc)->wsec_keys[i] && (wlc)->wsec_keys[i]->len) ? \
 	(wlc)->wsec_keys[i] : NULL)
 
-#define WSEC_SCB_KEY_VALID(scb)	(((scb)->key && (scb)->key->len) ? TRUE : FALSE)
+#define WSEC_SCB_KEY_VALID(scb)	(((scb)->key && (scb)->key->len) ? true : false)
 
 /* default key */
 #define WSEC_BSS_DEFAULT_KEY(bsscfg) (((bsscfg)->wsec_index == -1) ? \
-	(struct wsec_key*)NULL : (bsscfg)->bss_def_keys[(bsscfg)->wsec_index])
+	(struct wsec_key *)NULL:(bsscfg)->bss_def_keys[(bsscfg)->wsec_index])
 
 /* Macros for key management in IBSS mode */
 #define WSEC_IBSS_MAX_PEERS	16	/* Max # of IBSS Peers */
@@ -80,33 +80,34 @@ struct wlc_bsscfg;
 #define WSEC_BSS_STA_KEY_GROUP_SIZE	5
 
 typedef struct wsec_iv {
-	uint32 hi;		/* upper 32 bits of IV */
-	uint16 lo;		/* lower 16 bits of IV */
+	u32 hi;		/* upper 32 bits of IV */
+	u16 lo;		/* lower 16 bits of IV */
 } wsec_iv_t;
 
 #define WLC_NUMRXIVS	16	/* # rx IVs (one per 802.11e TID) */
 
 typedef struct wsec_key {
 	struct ether_addr ea;	/* per station */
-	uint8 idx;		/* key index in wsec_keys array */
-	uint8 id;		/* key ID [0-3] */
-	uint8 algo;		/* CRYPTO_ALGO_AES_CCM, CRYPTO_ALGO_WEP128, etc */
-	uint8 rcmta;		/* rcmta entry index, same as idx by default */
-	uint16 flags;		/* misc flags */
-	uint8 algo_hw;		/* cache for hw register */
-	uint8 aes_mode;		/* cache for hw register */
-	int8 iv_len;		/* IV length */
-	int8 icv_len;		/* ICV length */
-	uint32 len;		/* key length..don't move this var */
+	u8 idx;		/* key index in wsec_keys array */
+	u8 id;		/* key ID [0-3] */
+	u8 algo;		/* CRYPTO_ALGO_AES_CCM, CRYPTO_ALGO_WEP128, etc */
+	u8 rcmta;		/* rcmta entry index, same as idx by default */
+	u16 flags;		/* misc flags */
+	u8 algo_hw;		/* cache for hw register */
+	u8 aes_mode;		/* cache for hw register */
+	s8 iv_len;		/* IV length */
+	s8 icv_len;		/* ICV length */
+	u32 len;		/* key length..don't move this var */
 	/* data is 4byte aligned */
-	uint8 data[DOT11_MAX_KEY_SIZE];	/* key data */
+	u8 data[DOT11_MAX_KEY_SIZE];	/* key data */
 	wsec_iv_t rxiv[WLC_NUMRXIVS];	/* Rx IV (one per TID) */
 	wsec_iv_t txiv;		/* Tx IV */
 
 } wsec_key_t;
 
+#define broken_roundup(x, y) ((((x) + ((y) - 1)) / (y)) * (y))
 typedef struct {
-	uint8 vec[ROUNDUP(WSEC_MAX_KEYS, NBBY) / NBBY];	/* bitvec of wsec_key indexes */
+	u8 vec[broken_roundup(WSEC_MAX_KEYS, NBBY) / NBBY];	/* bitvec of wsec_key indexes */
 } wsec_key_vec_t;
 
 /* For use with wsec_key_t.flags */
@@ -130,7 +131,7 @@ typedef struct {
 #define wlc_key_hw_wowl_init(a, b, c, d) do {} while (0)
 #define wlc_key_sw_wowl_update(a, b, c, d, e) do {} while (0)
 #define wlc_key_sw_wowl_create(a, b, c) (BCME_ERROR)
-#define wlc_key_iv_update(a, b, c, d, e) do {(void)e;} while (0)
+#define wlc_key_iv_update(a, b, c, d, e) do {(void)e; } while (0)
 #define wlc_key_iv_init(a, b, c) do {} while (0)
 #define wlc_key_set_error(a, b, c) (BCME_ERROR)
 #define wlc_key_dump_hw(a, b) (BCME_ERROR)
diff --git a/drivers/staging/brcm80211/sys/wlc_mac80211.c b/drivers/staging/brcm80211/sys/wlc_mac80211.c
index 414ba49..feaffcc 100644
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -13,27 +13,21 @@
  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
-
-#include <wlc_cfg.h>
-#include <typedefs.h>
+#include <linux/kernel.h>
+#include <linux/ctype.h>
 #include <bcmdefs.h>
+#include <wlc_cfg.h>
+#include <linuxver.h>
 #include <osl.h>
 #include <bcmutils.h>
 #include <bcmwifi.h>
 #include <siutils.h>
 #include <bcmendian.h>
-#include <proto/802.1d.h>
-#include <proto/802.11.h>
-#include <proto/802.11e.h>
 #include <proto/wpa.h>
-#include <hndsoc.h>
-#include <sbchipc.h>
 #include <pcicfg.h>
 #include <bcmsrom.h>
 #include <wlioctl.h>
 #include <epivers.h>
-#include <bcmwpa.h>
-#include <sbhndpio.h>
 #include <sbhnddma.h>
 #include <hnddma.h>
 #include <hndpmu.h>
@@ -117,7 +111,7 @@
 #define WLC_WAR16165(wlc) (BUSTYPE(wlc->pub->sih->bustype) == PCI_BUS && \
 				(!AP_ENAB(wlc->pub)) && (wlc->war16165))
 #else
-#define WLC_WAR16165(wlc) (FALSE)
+#define WLC_WAR16165(wlc) (false)
 #endif				/* WLC_HIGH_ONLY */
 
 /* debug/trace */
@@ -146,14 +140,6 @@ uint wl_msg_level =
 static wlc_info_t *wlc_info_dbg = (wlc_info_t *) (NULL);
 #endif
 
-#if defined(BCMDBG)
-struct wlc_id_name_entry {
-	int id;
-	const char *name;
-};
-typedef struct wlc_id_name_entry wlc_id_name_table_t[];
-#endif
-
 /* IOVar table */
 
 /* Parameter IDs, for use only internally to wlc -- in the wlc_iovars
@@ -175,7 +161,7 @@ const bcm_iovar_t wlc_iovars[] = {
 	{NULL, 0, 0, 0, 0}
 };
 
-const uint8 prio2fifo[NUMPRIO] = {
+const u8 prio2fifo[NUMPRIO] = {
 	TX_AC_BE_FIFO,		/* 0    BE      AC_BE   Best Effort */
 	TX_AC_BK_FIFO,		/* 1    BK      AC_BK   Background */
 	TX_AC_BK_FIFO,		/* 2    --      AC_BK   Background */
@@ -201,7 +187,7 @@ const uint8 prio2fifo[NUMPRIO] = {
 #define	_WLC_PREC_NC		14	/* NC - Network Control */
 
 /* 802.1D Priority to precedence queue mapping */
-const uint8 wlc_prio2prec_map[] = {
+const u8 wlc_prio2prec_map[] = {
 	_WLC_PREC_BE,		/* 0 BE - Best-effort */
 	_WLC_PREC_BK,		/* 1 BK - Background */
 	_WLC_PREC_NONE,		/* 2 None = - */
@@ -222,23 +208,23 @@ const uint8 wlc_prio2prec_map[] = {
 	(wlc)->fifo2prec_map[(fifo)]))
 
 /* TX FIFO number to WME/802.1E Access Category */
-const uint8 wme_fifo2ac[] = { AC_BK, AC_BE, AC_VI, AC_VO, AC_BE, AC_BE };
+const u8 wme_fifo2ac[] = { AC_BK, AC_BE, AC_VI, AC_VO, AC_BE, AC_BE };
 
 /* WME/802.1E Access Category to TX FIFO number */
-static const uint8 wme_ac2fifo[] = { 1, 0, 2, 3 };
+static const u8 wme_ac2fifo[] = { 1, 0, 2, 3 };
 
-static bool in_send_q = FALSE;
+static bool in_send_q = false;
 
 /* Shared memory location index for various AC params */
 #define wme_shmemacindex(ac)	wme_ac2fifo[ac]
 
 #ifdef BCMDBG
-static const char *fifo_names[] =
-    { "AC_BK", "AC_BE", "AC_VI", "AC_VO", "BCMC", "ATIM" };
+static const char *fifo_names[] = {
+	"AC_BK", "AC_BE", "AC_VI", "AC_VO", "BCMC", "ATIM" };
 const char *aci_names[] = { "AC_BE", "AC_BK", "AC_VI", "AC_VO" };
 #endif
 
-static const uint8 acbitmap2maxprio[] = {
+static const u8 acbitmap2maxprio[] = {
 	PRIO_8021D_BE, PRIO_8021D_BE, PRIO_8021D_BK, PRIO_8021D_BK,
 	PRIO_8021D_VI, PRIO_8021D_VI, PRIO_8021D_VI, PRIO_8021D_VI,
 	PRIO_8021D_VO, PRIO_8021D_VO, PRIO_8021D_VO, PRIO_8021D_VO,
@@ -253,92 +239,87 @@ static const uint8 acbitmap2maxprio[] = {
 
 /* local prototypes */
 extern void wlc_txq_enq(void *ctx, struct scb *scb, void *sdu, uint prec);
-static uint16 BCMFASTPATH wlc_d11hdrs_mac80211(wlc_info_t * wlc,
+static u16 BCMFASTPATH wlc_d11hdrs_mac80211(wlc_info_t *wlc,
 					       struct ieee80211_hw *hw, void *p,
 					       struct scb *scb, uint frag,
 					       uint nfrags, uint queue,
 					       uint next_frag_len,
-					       wsec_key_t * key,
+					       wsec_key_t *key,
 					       ratespec_t rspec_override);
-bool wlc_sendpkt_mac80211(wlc_info_t * wlc, void *sdu, struct ieee80211_hw *hw);
-void wlc_wme_setparams(wlc_info_t * wlc, u16 aci, void *arg, bool suspend);
-static void wlc_bss_default_init(wlc_info_t * wlc);
-static void wlc_ucode_mac_upd(wlc_info_t * wlc);
-static ratespec_t mac80211_wlc_set_nrate(wlc_info_t * wlc, wlcband_t * cur_band,
-					 uint32 int_val);
-static void wlc_tx_prec_map_init(wlc_info_t * wlc);
+bool wlc_sendpkt_mac80211(wlc_info_t *wlc, void *sdu, struct ieee80211_hw *hw);
+void wlc_wme_setparams(wlc_info_t *wlc, u16 aci, void *arg, bool suspend);
+static void wlc_bss_default_init(wlc_info_t *wlc);
+static void wlc_ucode_mac_upd(wlc_info_t *wlc);
+static ratespec_t mac80211_wlc_set_nrate(wlc_info_t *wlc, wlcband_t *cur_band,
+					 u32 int_val);
+static void wlc_tx_prec_map_init(wlc_info_t *wlc);
 static void wlc_watchdog(void *arg);
 static void wlc_watchdog_by_timer(void *arg);
-static int wlc_set_rateset(wlc_info_t * wlc, wlc_rateset_t * rs_arg);
-static int wlc_iovar_rangecheck(wlc_info_t * wlc, uint32 val,
-				const bcm_iovar_t * vi);
-static uint8 wlc_local_constraint_qdbm(wlc_info_t * wlc);
-
-#if defined(BCMDBG)
-static void wlc_print_dot11hdr(uint8 * buf, int len);
-#endif
+static int wlc_set_rateset(wlc_info_t *wlc, wlc_rateset_t *rs_arg);
+static int wlc_iovar_rangecheck(wlc_info_t *wlc, u32 val,
+				const bcm_iovar_t *vi);
+static u8 wlc_local_constraint_qdbm(wlc_info_t *wlc);
 
 /* send and receive */
-static wlc_txq_info_t *wlc_txq_alloc(wlc_info_t * wlc, osl_t * osh);
-static void wlc_txq_free(wlc_info_t * wlc, osl_t * osh, wlc_txq_info_t * qi);
-static void wlc_txflowcontrol_signal(wlc_info_t * wlc, wlc_txq_info_t * qi,
+static wlc_txq_info_t *wlc_txq_alloc(wlc_info_t *wlc, osl_t *osh);
+static void wlc_txq_free(wlc_info_t *wlc, osl_t *osh, wlc_txq_info_t *qi);
+static void wlc_txflowcontrol_signal(wlc_info_t *wlc, wlc_txq_info_t *qi,
 				     bool on, int prio);
-static void wlc_txflowcontrol_reset(wlc_info_t * wlc);
-static uint16 wlc_compute_airtime(wlc_info_t * wlc, ratespec_t rspec,
+static void wlc_txflowcontrol_reset(wlc_info_t *wlc);
+static u16 wlc_compute_airtime(wlc_info_t *wlc, ratespec_t rspec,
 				  uint length);
-static void wlc_compute_cck_plcp(ratespec_t rate, uint length, uint8 * plcp);
-static void wlc_compute_ofdm_plcp(ratespec_t rate, uint length, uint8 * plcp);
-static void wlc_compute_mimo_plcp(ratespec_t rate, uint length, uint8 * plcp);
-static uint16 wlc_compute_frame_dur(wlc_info_t * wlc, ratespec_t rate,
-				    uint8 preamble_type, uint next_frag_len);
-static void wlc_recvctl(wlc_info_t * wlc, osl_t * osh, d11rxhdr_t * rxh,
+static void wlc_compute_cck_plcp(ratespec_t rate, uint length, u8 *plcp);
+static void wlc_compute_ofdm_plcp(ratespec_t rate, uint length, u8 *plcp);
+static void wlc_compute_mimo_plcp(ratespec_t rate, uint length, u8 *plcp);
+static u16 wlc_compute_frame_dur(wlc_info_t *wlc, ratespec_t rate,
+				    u8 preamble_type, uint next_frag_len);
+static void wlc_recvctl(wlc_info_t *wlc, osl_t *osh, d11rxhdr_t *rxh,
 			void *p);
-static uint wlc_calc_frame_len(wlc_info_t * wlc, ratespec_t rate,
-			       uint8 preamble_type, uint dur);
-static uint wlc_calc_ack_time(wlc_info_t * wlc, ratespec_t rate,
-			      uint8 preamble_type);
-static uint wlc_calc_cts_time(wlc_info_t * wlc, ratespec_t rate,
-			      uint8 preamble_type);
+static uint wlc_calc_frame_len(wlc_info_t *wlc, ratespec_t rate,
+			       u8 preamble_type, uint dur);
+static uint wlc_calc_ack_time(wlc_info_t *wlc, ratespec_t rate,
+			      u8 preamble_type);
+static uint wlc_calc_cts_time(wlc_info_t *wlc, ratespec_t rate,
+			      u8 preamble_type);
 /* interrupt, up/down, band */
-static void wlc_setband(wlc_info_t * wlc, uint bandunit);
-static chanspec_t wlc_init_chanspec(wlc_info_t * wlc);
-static void wlc_bandinit_ordered(wlc_info_t * wlc, chanspec_t chanspec);
-static void wlc_bsinit(wlc_info_t * wlc);
-static int wlc_duty_cycle_set(wlc_info_t * wlc, int duty_cycle, bool isOFDM,
+static void wlc_setband(wlc_info_t *wlc, uint bandunit);
+static chanspec_t wlc_init_chanspec(wlc_info_t *wlc);
+static void wlc_bandinit_ordered(wlc_info_t *wlc, chanspec_t chanspec);
+static void wlc_bsinit(wlc_info_t *wlc);
+static int wlc_duty_cycle_set(wlc_info_t *wlc, int duty_cycle, bool isOFDM,
 			      bool writeToShm);
-static void wlc_radio_hwdisable_upd(wlc_info_t * wlc);
-static bool wlc_radio_monitor_start(wlc_info_t * wlc);
+static void wlc_radio_hwdisable_upd(wlc_info_t *wlc);
+static bool wlc_radio_monitor_start(wlc_info_t *wlc);
 static void wlc_radio_timer(void *arg);
-static void wlc_radio_enable(wlc_info_t * wlc);
-static void wlc_radio_upd(wlc_info_t * wlc);
+static void wlc_radio_enable(wlc_info_t *wlc);
+static void wlc_radio_upd(wlc_info_t *wlc);
 
 /* scan, association, BSS */
-static uint wlc_calc_ba_time(wlc_info_t * wlc, ratespec_t rate,
-			     uint8 preamble_type);
-static void wlc_update_mimo_band_bwcap(wlc_info_t * wlc, uint8 bwcap);
-static void wlc_ht_update_sgi_rx(wlc_info_t * wlc, int val);
-void wlc_ht_mimops_cap_update(wlc_info_t * wlc, uint8 mimops_mode);
-static void wlc_ht_update_ldpc(wlc_info_t * wlc, int8 val);
-static void wlc_war16165(wlc_info_t * wlc, bool tx);
+static uint wlc_calc_ba_time(wlc_info_t *wlc, ratespec_t rate,
+			     u8 preamble_type);
+static void wlc_update_mimo_band_bwcap(wlc_info_t *wlc, u8 bwcap);
+static void wlc_ht_update_sgi_rx(wlc_info_t *wlc, int val);
+void wlc_ht_mimops_cap_update(wlc_info_t *wlc, u8 mimops_mode);
+static void wlc_ht_update_ldpc(wlc_info_t *wlc, s8 val);
+static void wlc_war16165(wlc_info_t *wlc, bool tx);
 
 static void wlc_process_eventq(void *arg);
-static void wlc_wme_retries_write(wlc_info_t * wlc);
-static bool wlc_attach_stf_ant_init(wlc_info_t * wlc);
-static uint wlc_attach_module(wlc_info_t * wlc);
-static void wlc_detach_module(wlc_info_t * wlc);
-static void wlc_timers_deinit(wlc_info_t * wlc);
-static void wlc_down_led_upd(wlc_info_t * wlc);
-static uint wlc_down_del_timer(wlc_info_t * wlc);
-static void wlc_ofdm_rateset_war(wlc_info_t * wlc);
-static int _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len,
+static void wlc_wme_retries_write(wlc_info_t *wlc);
+static bool wlc_attach_stf_ant_init(wlc_info_t *wlc);
+static uint wlc_attach_module(wlc_info_t *wlc);
+static void wlc_detach_module(wlc_info_t *wlc);
+static void wlc_timers_deinit(wlc_info_t *wlc);
+static void wlc_down_led_upd(wlc_info_t *wlc);
+static uint wlc_down_del_timer(wlc_info_t *wlc);
+static void wlc_ofdm_rateset_war(wlc_info_t *wlc);
+static int _wlc_ioctl(wlc_info_t *wlc, int cmd, void *arg, int len,
 		      struct wlc_if *wlcif);
-char *print_fk(uint16 fk);
 
 #if defined(BCMDBG)
-void wlc_get_rcmta(wlc_info_t * wlc, int idx, struct ether_addr *addr)
+void wlc_get_rcmta(wlc_info_t *wlc, int idx, struct ether_addr *addr)
 {
 	d11regs_t *regs = wlc->regs;
-	uint32 v32;
+	u32 v32;
 	osl_t *osh;
 
 	WL_TRACE(("wl%d: %s\n", WLCWLUNIT(wlc), __func__));
@@ -350,57 +331,58 @@ void wlc_get_rcmta(wlc_info_t * wlc, int idx, struct ether_addr *addr)
 	W_REG(osh, &regs->objaddr, (OBJADDR_RCMTA_SEL | (idx * 2)));
 	(void)R_REG(osh, &regs->objaddr);
 	v32 = R_REG(osh, &regs->objdata);
-	addr->octet[0] = (uint8) v32;
-	addr->octet[1] = (uint8) (v32 >> 8);
-	addr->octet[2] = (uint8) (v32 >> 16);
-	addr->octet[3] = (uint8) (v32 >> 24);
+	addr->octet[0] = (u8) v32;
+	addr->octet[1] = (u8) (v32 >> 8);
+	addr->octet[2] = (u8) (v32 >> 16);
+	addr->octet[3] = (u8) (v32 >> 24);
 	W_REG(osh, &regs->objaddr, (OBJADDR_RCMTA_SEL | ((idx * 2) + 1)));
 	(void)R_REG(osh, &regs->objaddr);
-	v32 = R_REG(osh, (volatile uint16 *)(uintptr) & regs->objdata);
-	addr->octet[4] = (uint8) v32;
-	addr->octet[5] = (uint8) (v32 >> 8);
+	v32 = R_REG(osh, (volatile u16 *)&regs->objdata);
+	addr->octet[4] = (u8) v32;
+	addr->octet[5] = (u8) (v32 >> 8);
 }
 #endif				/* defined(BCMDBG) */
 
 /* keep the chip awake if needed */
-bool wlc_stay_awake(wlc_info_t * wlc)
+bool wlc_stay_awake(wlc_info_t *wlc)
 {
-	return TRUE;
+	return true;
 }
 
 /* conditions under which the PM bit should be set in outgoing frames and STAY_AWAKE is meaningful
  */
-bool wlc_ps_allowed(wlc_info_t * wlc)
+bool wlc_ps_allowed(wlc_info_t *wlc)
 {
 	int idx;
 	wlc_bsscfg_t *cfg;
 
 	/* disallow PS when one of the following global conditions meets */
 	if (!wlc->pub->associated || !wlc->PMenabled || wlc->PM_override)
-		return FALSE;
+		return false;
 
 	/* disallow PS when one of these meets when not scanning */
 	if (!wlc->PMblocked) {
 		if (AP_ACTIVE(wlc) || wlc->monitor)
-			return FALSE;
+			return false;
 	}
 
 	FOREACH_AS_STA(wlc, idx, cfg) {
 		/* disallow PS when one of the following bsscfg specific conditions meets */
 		if (!cfg->BSS || !WLC_PORTOPEN(cfg))
-			return FALSE;
+			return false;
 
 		if (!cfg->dtim_programmed)
-			return FALSE;
+			return false;
 	}
 
-	return TRUE;
+	return true;
 }
 
-void BCMINITFN(wlc_reset) (wlc_info_t * wlc) {
+void wlc_reset(wlc_info_t *wlc)
+{
 	WL_TRACE(("wl%d: wlc_reset\n", wlc->pub->unit));
 
-	wlc->check_for_unaligned_tbtt = FALSE;
+	wlc->check_for_unaligned_tbtt = false;
 
 	/* slurp up hw mac counters before core reset */
 	if (WLC_UPDATE_STATS(wlc)) {
@@ -423,7 +405,7 @@ void BCMINITFN(wlc_reset) (wlc_info_t * wlc) {
 	 *  have been cleared instantly in wlc_bmac_reset() and no txstatus interrupt
 	 *  will come to driver to fetch those flushed dma pkt pointers.
 	 */
-	wlc->reset_bmac_pending = TRUE;
+	wlc->reset_bmac_pending = true;
 
 	wlc_rpctx_txreclaim(wlc->rpctx);
 
@@ -432,7 +414,7 @@ void BCMINITFN(wlc_reset) (wlc_info_t * wlc) {
 #endif
 }
 
-void wlc_fatal_error(wlc_info_t * wlc)
+void wlc_fatal_error(wlc_info_t *wlc)
 {
 	WL_ERROR(("wl%d: fatal error, reinitializing\n", wlc->pub->unit));
 	wl_init(wlc->wl);
@@ -443,7 +425,8 @@ void wlc_fatal_error(wlc_info_t * wlc)
  * if other configurations are in conflict (bandlocked, 11n mode disabled,
  * invalid channel for current country, etc.)
  */
-static chanspec_t BCMINITFN(wlc_init_chanspec) (wlc_info_t * wlc) {
+static chanspec_t wlc_init_chanspec(wlc_info_t *wlc)
+{
 	chanspec_t chanspec =
 	    1 | WL_CHANSPEC_BW_20 | WL_CHANSPEC_CTL_SB_NONE |
 	    WL_CHANSPEC_BAND_2G;
@@ -458,7 +441,7 @@ static chanspec_t BCMINITFN(wlc_init_chanspec) (wlc_info_t * wlc) {
 
 struct scb global_scb;
 
-static void wlc_init_scb(wlc_info_t * wlc, struct scb *scb)
+static void wlc_init_scb(wlc_info_t *wlc, struct scb *scb)
 {
 	int i;
 	scb->flags = SCB_WMECAP | SCB_HTCAP;
@@ -466,12 +449,13 @@ static void wlc_init_scb(wlc_info_t * wlc, struct scb *scb)
 		scb->seqnum[i] = 0;
 }
 
-void BCMINITFN(wlc_init) (wlc_info_t * wlc) {
+void wlc_init(wlc_info_t *wlc)
+{
 	d11regs_t *regs;
 	chanspec_t chanspec;
 	int i;
 	wlc_bsscfg_t *bsscfg;
-	bool mute = FALSE;
+	bool mute = false;
 
 	WL_TRACE(("wl%d: wlc_init\n", wlc->pub->unit));
 
@@ -495,7 +479,7 @@ void BCMINITFN(wlc_init) (wlc_info_t * wlc) {
 	/* update beacon listen interval */
 	wlc_bcn_li_upd(wlc);
 	wlc->bcn_wait_prd =
-	    (uint8) (wlc_bmac_read_shm(wlc->hw, M_NOSLPZNATDTIM) >> 10);
+	    (u8) (wlc_bmac_read_shm(wlc->hw, M_NOSLPZNATDTIM) >> 10);
 	ASSERT(wlc->bcn_wait_prd > 0);
 
 	/* the world is new again, so is our reported rate */
@@ -511,7 +495,7 @@ void BCMINITFN(wlc_init) (wlc_info_t * wlc) {
 	if (wlc->pub->associated) {
 		FOREACH_BSS(wlc, i, bsscfg) {
 			if (bsscfg->up) {
-				uint32 bi;
+				u32 bi;
 
 				/* get beacon period from bsscfg and convert to uS */
 				bi = bsscfg->current_bss->beacon_period << 10;
@@ -543,8 +527,8 @@ void BCMINITFN(wlc_init) (wlc_info_t * wlc) {
 		       _rifs ? (EDCF_AC_VO_TXOP_AP << 5) : MAXFRAMEBURST_TXOP));
 
 	/* initialize maximum allowed duty cycle */
-	wlc_duty_cycle_set(wlc, wlc->tx_duty_cycle_ofdm, TRUE, TRUE);
-	wlc_duty_cycle_set(wlc, wlc->tx_duty_cycle_cck, FALSE, TRUE);
+	wlc_duty_cycle_set(wlc, wlc->tx_duty_cycle_ofdm, true, true);
+	wlc_duty_cycle_set(wlc, wlc->tx_duty_cycle_cck, false, true);
 
 	/* Update some shared memory locations related to max AMPDU size allowed to received */
 	wlc_ampdu_shm_upd(wlc->ampdu);
@@ -555,7 +539,7 @@ void BCMINITFN(wlc_init) (wlc_info_t * wlc) {
 	/* Enable EDCF mode (while the MAC is suspended) */
 	if (EDCF_ENAB(wlc->pub)) {
 		OR_REG(wlc->osh, &regs->ifs_ctl, IFS_USEEDCF);
-		wlc_edcf_setparams(wlc->cfg, FALSE);
+		wlc_edcf_setparams(wlc->cfg, false);
 	}
 
 	/* Init precedence maps for empty FIFOs */
@@ -564,7 +548,7 @@ void BCMINITFN(wlc_init) (wlc_info_t * wlc) {
 	/* read the ucode version if we have not yet done so */
 	if (wlc->ucode_rev == 0) {
 		wlc->ucode_rev =
-		    wlc_read_shm(wlc, M_BOM_REV_MAJOR) << NBITS(uint16);
+		    wlc_read_shm(wlc, M_BOM_REV_MAJOR) << NBITS(u16);
 		wlc->ucode_rev |= wlc_read_shm(wlc, M_BOM_REV_MINOR);
 	}
 
@@ -575,7 +559,7 @@ void BCMINITFN(wlc_init) (wlc_info_t * wlc) {
 	wlc_txflowcontrol_reset(wlc);
 
 	/* clear tx data fifo suspends */
-	wlc->tx_suspended = FALSE;
+	wlc->tx_suspended = false;
 
 	/* enable the RF Disable Delay timer */
 	if (D11REV_GE(wlc->pub->corerev, 10))
@@ -599,13 +583,13 @@ void BCMINITFN(wlc_init) (wlc_info_t * wlc) {
 	}
 }
 
-void wlc_mac_bcn_promisc_change(wlc_info_t * wlc, bool promisc)
+void wlc_mac_bcn_promisc_change(wlc_info_t *wlc, bool promisc)
 {
 	wlc->bcnmisc_monitor = promisc;
 	wlc_mac_bcn_promisc(wlc);
 }
 
-void wlc_mac_bcn_promisc(wlc_info_t * wlc)
+void wlc_mac_bcn_promisc(wlc_info_t *wlc)
 {
 	if ((AP_ENAB(wlc->pub) && (N_ENAB(wlc->pub) || wlc->band->gmode)) ||
 	    wlc->bcnmisc_ibss || wlc->bcnmisc_scan || wlc->bcnmisc_monitor)
@@ -615,9 +599,9 @@ void wlc_mac_bcn_promisc(wlc_info_t * wlc)
 }
 
 /* set or clear maccontrol bits MCTL_PROMISC and MCTL_KEEPCONTROL */
-void wlc_mac_promisc(wlc_info_t * wlc)
+void wlc_mac_promisc(wlc_info_t *wlc)
 {
-	uint32 promisc_bits = 0;
+	u32 promisc_bits = 0;
 
 	/* promiscuous mode just sets MCTL_PROMISC
 	 * Note: APs get all BSS traffic without the need to set the MCTL_PROMISC bit
@@ -637,14 +621,14 @@ void wlc_mac_promisc(wlc_info_t * wlc)
 }
 
 /* check if hps and wake states of sw and hw are in sync */
-bool wlc_ps_check(wlc_info_t * wlc)
+bool wlc_ps_check(wlc_info_t *wlc)
 {
-	bool res = TRUE;
+	bool res = true;
 	bool hps, wake;
 	bool wake_ok;
 
 	if (!AP_ACTIVE(wlc)) {
-		volatile uint32 tmp;
+		volatile u32 tmp;
 		tmp = R_REG(wlc->osh, &wlc->regs->maccontrol);
 
 		/* If deviceremoved is detected, then don't take any action as this can be called
@@ -668,7 +652,7 @@ bool wlc_ps_check(wlc_info_t * wlc)
 					continue;
 			}
 
-			res = FALSE;
+			res = false;
 		}
 #ifdef WLC_LOW
 		/* For a monolithic build the wake check can be exact since it looks at wake
@@ -687,7 +671,7 @@ bool wlc_ps_check(wlc_info_t * wlc)
 #endif
 		if (hps && !wake_ok) {
 			WL_ERROR(("wl%d: wake not sync, sw %d maccontrol 0x%x\n", wlc->pub->unit, wake, tmp));
-			res = FALSE;
+			res = false;
 		}
 	}
 	ASSERT(res);
@@ -695,14 +679,14 @@ bool wlc_ps_check(wlc_info_t * wlc)
 }
 
 /* push sw hps and wake state through hardware */
-void wlc_set_ps_ctrl(wlc_info_t * wlc)
+void wlc_set_ps_ctrl(wlc_info_t *wlc)
 {
-	uint32 v1, v2;
+	u32 v1, v2;
 	bool hps, wake;
 	bool awake_before;
 
 	hps = PS_ALLOWED(wlc);
-	wake = hps ? (STAY_AWAKE(wlc)) : TRUE;
+	wake = hps ? (STAY_AWAKE(wlc)) : true;
 
 	WL_TRACE(("wl%d: wlc_set_ps_ctrl: hps %d wake %d\n", wlc->pub->unit,
 		  hps, wake));
@@ -727,7 +711,7 @@ void wlc_set_ps_ctrl(wlc_info_t * wlc)
  * Write this BSS config's MAC address to core.
  * Updates RXE match engine.
  */
-int wlc_set_mac(wlc_bsscfg_t * cfg)
+int wlc_set_mac(wlc_bsscfg_t *cfg)
 {
 	int err = 0;
 	wlc_info_t *wlc = cfg->wlc;
@@ -745,7 +729,7 @@ int wlc_set_mac(wlc_bsscfg_t * cfg)
 /* Write the BSS config's BSSID address to core (set_bssid in d11procs.tcl).
  * Updates RXE match engine.
  */
-void wlc_set_bssid(wlc_bsscfg_t * cfg)
+void wlc_set_bssid(wlc_bsscfg_t *cfg)
 {
 	wlc_info_t *wlc = cfg->wlc;
 
@@ -764,7 +748,7 @@ void wlc_set_bssid(wlc_bsscfg_t * cfg)
  * Suspend the the MAC and update the slot timing
  * for standard 11b/g (20us slots) or shortslot 11g (9us slots).
  */
-void wlc_switch_shortslot(wlc_info_t * wlc, bool shortslot)
+void wlc_switch_shortslot(wlc_info_t *wlc, bool shortslot)
 {
 	int idx;
 	wlc_bsscfg_t *cfg;
@@ -792,10 +776,10 @@ void wlc_switch_shortslot(wlc_info_t * wlc, bool shortslot)
 	wlc_bmac_set_shortslot(wlc->hw, shortslot);
 }
 
-static uint8 wlc_local_constraint_qdbm(wlc_info_t * wlc)
+static u8 wlc_local_constraint_qdbm(wlc_info_t *wlc)
 {
-	uint8 local;
-	int16 local_max;
+	u8 local;
+	s16 local_max;
 
 	local = WLC_TXPWR_MAX;
 	if (wlc->pub->associated &&
@@ -810,7 +794,7 @@ static uint8 wlc_local_constraint_qdbm(wlc_info_t * wlc)
 		    (wlc->txpwr_local_max -
 		     wlc->txpwr_local_constraint) * WLC_TXPWR_DB_FACTOR;
 		if (local_max > 0 && local_max < WLC_TXPWR_MAX)
-			return (uint8) local_max;
+			return (u8) local_max;
 		if (local_max < 0)
 			return 0;
 	}
@@ -819,7 +803,7 @@ static uint8 wlc_local_constraint_qdbm(wlc_info_t * wlc)
 }
 
 /* propagate home chanspec to all bsscfgs in case bsscfg->current_bss->chanspec is referenced */
-void wlc_set_home_chanspec(wlc_info_t * wlc, chanspec_t chanspec)
+void wlc_set_home_chanspec(wlc_info_t *wlc, chanspec_t chanspec)
 {
 	if (wlc->home_chanspec != chanspec) {
 		int idx;
@@ -837,7 +821,7 @@ void wlc_set_home_chanspec(wlc_info_t * wlc, chanspec_t chanspec)
 	}
 }
 
-static void wlc_set_phy_chanspec(wlc_info_t * wlc, chanspec_t chanspec)
+static void wlc_set_phy_chanspec(wlc_info_t *wlc, chanspec_t chanspec)
 {
 	/* Save our copy of the chanspec */
 	wlc->chanspec = chanspec;
@@ -856,10 +840,10 @@ static void wlc_set_phy_chanspec(wlc_info_t * wlc, chanspec_t chanspec)
 
 }
 
-void wlc_set_chanspec(wlc_info_t * wlc, chanspec_t chanspec)
+void wlc_set_chanspec(wlc_info_t *wlc, chanspec_t chanspec)
 {
 	uint bandunit;
-	bool switchband = FALSE;
+	bool switchband = false;
 	chanspec_t old_chanspec = wlc->chanspec;
 
 	if (!wlc_valid_chanspec_db(wlc->cmi, chanspec)) {
@@ -873,7 +857,7 @@ void wlc_set_chanspec(wlc_info_t * wlc, chanspec_t chanspec)
 	if (NBANDS(wlc) > 1) {
 		bandunit = CHSPEC_WLCBANDUNIT(chanspec);
 		if (wlc->band->bandunit != bandunit || wlc->bandinit_pending) {
-			switchband = TRUE;
+			switchband = true;
 			if (wlc->bandlocked) {
 				WL_ERROR(("wl%d: %s: chspec %d band is locked!\n", wlc->pub->unit, __func__, CHSPEC_CHANNEL(chanspec)));
 				return;
@@ -911,7 +895,7 @@ void wlc_set_chanspec(wlc_info_t * wlc, chanspec_t chanspec)
 }
 
 #if defined(BCMDBG)
-static int wlc_get_current_txpwr(wlc_info_t * wlc, void *pwr, uint len)
+static int wlc_get_current_txpwr(wlc_info_t *wlc, void *pwr, uint len)
 {
 	txpwr_limits_t txpwr;
 	tx_power_t power;
@@ -937,7 +921,7 @@ static int wlc_get_current_txpwr(wlc_info_t * wlc, void *pwr, uint len)
 	 */
 	wlc_phy_txpower_get(wlc->band->pi, &qdbm, &override);
 	for (r = 0; r < WL_TX_POWER_RATES; r++) {
-		power.user_limit[r] = (uint8) qdbm;
+		power.user_limit[r] = (u8) qdbm;
 	}
 
 	power.local_max = wlc->txpwr_local_max * WLC_TXPWR_DB_FACTOR;
@@ -1080,9 +1064,9 @@ static int wlc_get_current_txpwr(wlc_info_t * wlc, void *pwr, uint len)
 }
 #endif				/* defined(BCMDBG) */
 
-static uint32 wlc_watchdog_backup_bi(wlc_info_t * wlc)
+static u32 wlc_watchdog_backup_bi(wlc_info_t *wlc)
 {
-	uint32 bi;
+	u32 bi;
 	bi = 2 * wlc->cfg->current_bss->dtim_period *
 	    wlc->cfg->current_bss->beacon_period;
 	if (wlc->bcn_li_dtim)
@@ -1097,38 +1081,38 @@ static uint32 wlc_watchdog_backup_bi(wlc_info_t * wlc)
 }
 
 /* Change to run the watchdog either from a periodic timer or from tbtt handler.
- * Call watchdog from tbtt handler if tbtt is TRUE, watchdog timer otherwise.
+ * Call watchdog from tbtt handler if tbtt is true, watchdog timer otherwise.
  */
-void wlc_watchdog_upd(wlc_info_t * wlc, bool tbtt)
+void wlc_watchdog_upd(wlc_info_t *wlc, bool tbtt)
 {
 	/* make sure changing watchdog driver is allowed */
 	if (!wlc->pub->up || !wlc->pub->align_wd_tbtt)
 		return;
 	if (!tbtt && wlc->WDarmed) {
 		wl_del_timer(wlc->wl, wlc->wdtimer);
-		wlc->WDarmed = FALSE;
+		wlc->WDarmed = false;
 	}
 
 	/* stop watchdog timer and use tbtt interrupt to drive watchdog */
 	if (tbtt && wlc->WDarmed) {
 		wl_del_timer(wlc->wl, wlc->wdtimer);
-		wlc->WDarmed = FALSE;
+		wlc->WDarmed = false;
 		wlc->WDlast = OSL_SYSUPTIME();
 	}
 	/* arm watchdog timer and drive the watchdog there */
 	else if (!tbtt && !wlc->WDarmed) {
 		wl_add_timer(wlc->wl, wlc->wdtimer, TIMER_INTERVAL_WATCHDOG,
-			     TRUE);
-		wlc->WDarmed = TRUE;
+			     true);
+		wlc->WDarmed = true;
 	}
 	if (tbtt && !wlc->WDarmed) {
 		wl_add_timer(wlc->wl, wlc->wdtimer, wlc_watchdog_backup_bi(wlc),
-			     TRUE);
-		wlc->WDarmed = TRUE;
+			     true);
+		wlc->WDarmed = true;
 	}
 }
 
-ratespec_t wlc_lowest_basic_rspec(wlc_info_t * wlc, wlc_rateset_t * rs)
+ratespec_t wlc_lowest_basic_rspec(wlc_info_t *wlc, wlc_rateset_t *rs)
 {
 	ratespec_t lowest_basic_rspec;
 	uint i;
@@ -1148,7 +1132,7 @@ ratespec_t wlc_lowest_basic_rspec(wlc_info_t * wlc, wlc_rateset_t * rs)
 	}
 #endif
 
-	return (lowest_basic_rspec);
+	return lowest_basic_rspec;
 }
 
 /* This function changes the phytxctl for beacon based on current beacon ratespec AND txant
@@ -1156,11 +1140,11 @@ ratespec_t wlc_lowest_basic_rspec(wlc_info_t * wlc, wlc_rateset_t * rs)
  *  ratespec     CCK		ant = wlc->stf->txant
  *  		OFDM		ant = 3
  */
-void wlc_beacon_phytxctl_txant_upd(wlc_info_t * wlc, ratespec_t bcn_rspec)
+void wlc_beacon_phytxctl_txant_upd(wlc_info_t *wlc, ratespec_t bcn_rspec)
 {
-	uint16 phyctl;
-	uint16 phytxant = wlc->stf->phytxant;
-	uint16 mask = PHY_TXC_ANT_MASK;
+	u16 phyctl;
+	u16 phytxant = wlc->stf->phytxant;
+	u16 mask = PHY_TXC_ANT_MASK;
 
 	/* for non-siso rates or default setting, use the available chains */
 	if (WLC_PHY_11N_CAP(wlc->band)) {
@@ -1175,7 +1159,7 @@ void wlc_beacon_phytxctl_txant_upd(wlc_info_t * wlc, ratespec_t bcn_rspec)
 /* centralized protection config change function to simplify debugging, no consistency checking
  * this should be called only on changes to avoid overhead in periodic function
 */
-void wlc_protection_upd(wlc_info_t * wlc, uint idx, int val)
+void wlc_protection_upd(wlc_info_t *wlc, uint idx, int val)
 {
 	WL_TRACE(("wlc_protection_upd: idx %d, val %d\n", idx, val));
 
@@ -1184,31 +1168,31 @@ void wlc_protection_upd(wlc_info_t * wlc, uint idx, int val)
 		wlc->protection->_g = (bool) val;
 		break;
 	case WLC_PROT_G_OVR:
-		wlc->protection->g_override = (int8) val;
+		wlc->protection->g_override = (s8) val;
 		break;
 	case WLC_PROT_G_USER:
-		wlc->protection->gmode_user = (uint8) val;
+		wlc->protection->gmode_user = (u8) val;
 		break;
 	case WLC_PROT_OVERLAP:
-		wlc->protection->overlap = (int8) val;
+		wlc->protection->overlap = (s8) val;
 		break;
 	case WLC_PROT_N_USER:
-		wlc->protection->nmode_user = (int8) val;
+		wlc->protection->nmode_user = (s8) val;
 		break;
 	case WLC_PROT_N_CFG:
-		wlc->protection->n_cfg = (int8) val;
+		wlc->protection->n_cfg = (s8) val;
 		break;
 	case WLC_PROT_N_CFG_OVR:
-		wlc->protection->n_cfg_override = (int8) val;
+		wlc->protection->n_cfg_override = (s8) val;
 		break;
 	case WLC_PROT_N_NONGF:
 		wlc->protection->nongf = (bool) val;
 		break;
 	case WLC_PROT_N_NONGF_OVR:
-		wlc->protection->nongf_override = (int8) val;
+		wlc->protection->nongf_override = (s8) val;
 		break;
 	case WLC_PROT_N_PAM_OVR:
-		wlc->protection->n_pam_override = (int8) val;
+		wlc->protection->n_pam_override = (s8) val;
 		break;
 	case WLC_PROT_N_OBSS:
 		wlc->protection->n_obss = (bool) val;
@@ -1221,7 +1205,7 @@ void wlc_protection_upd(wlc_info_t * wlc, uint idx, int val)
 
 }
 
-static void wlc_ht_update_sgi_rx(wlc_info_t * wlc, int val)
+static void wlc_ht_update_sgi_rx(wlc_info_t *wlc, int val)
 {
 	wlc->ht_cap.cap &= ~(HT_CAP_SHORT_GI_20 | HT_CAP_SHORT_GI_40);
 	wlc->ht_cap.cap |= (val & WLC_N_SGI_20) ? HT_CAP_SHORT_GI_20 : 0;
@@ -1229,11 +1213,11 @@ static void wlc_ht_update_sgi_rx(wlc_info_t * wlc, int val)
 
 	if (wlc->pub->up) {
 		wlc_update_beacon(wlc);
-		wlc_update_probe_resp(wlc, TRUE);
+		wlc_update_probe_resp(wlc, true);
 	}
 }
 
-static void wlc_ht_update_ldpc(wlc_info_t * wlc, int8 val)
+static void wlc_ht_update_ldpc(wlc_info_t *wlc, s8 val)
 {
 	wlc->stf->ldpc = val;
 
@@ -1243,8 +1227,8 @@ static void wlc_ht_update_ldpc(wlc_info_t * wlc, int8 val)
 
 	if (wlc->pub->up) {
 		wlc_update_beacon(wlc);
-		wlc_update_probe_resp(wlc, TRUE);
-		wlc_phy_ldpc_override_set(wlc->band->pi, (val ? TRUE : FALSE));
+		wlc_update_probe_resp(wlc, true);
+		wlc_phy_ldpc_override_set(wlc->band->pi, (val ? true : false));
 	}
 }
 
@@ -1252,7 +1236,7 @@ static void wlc_ht_update_ldpc(wlc_info_t * wlc, int8 val)
  * ucode, hwmac update
  *    Channel dependent updates for ucode and hw
  */
-static void wlc_ucode_mac_upd(wlc_info_t * wlc)
+static void wlc_ucode_mac_upd(wlc_info_t *wlc)
 {
 	/* enable or disable any active IBSSs depending on whether or not
 	 * we are on the home channel
@@ -1279,7 +1263,7 @@ static void wlc_ucode_mac_upd(wlc_info_t * wlc)
 	wlc_mac_promisc(wlc);
 }
 
-static void wlc_bandinit_ordered(wlc_info_t * wlc, chanspec_t chanspec)
+static void wlc_bandinit_ordered(wlc_info_t *wlc, chanspec_t chanspec)
 {
 	wlc_rateset_t default_rateset;
 	uint parkband;
@@ -1314,7 +1298,7 @@ static void wlc_bandinit_ordered(wlc_info_t * wlc, chanspec_t chanspec)
 
 		/* fill in hw_rate */
 		wlc_rateset_filter(&default_rateset, &wlc->band->hw_rateset,
-				   FALSE, WLC_RATES_CCK_OFDM, RATE_MASK,
+				   false, WLC_RATES_CCK_OFDM, RATE_MASK,
 				   (bool) N_ENAB(wlc->pub));
 
 		/* init basic rate lookup */
@@ -1326,7 +1310,8 @@ static void wlc_bandinit_ordered(wlc_info_t * wlc, chanspec_t chanspec)
 }
 
 /* band-specific init */
-static void WLBANDINITFN(wlc_bsinit) (wlc_info_t * wlc) {
+static void WLBANDINITFN(wlc_bsinit) (wlc_info_t *wlc)
+{
 	WL_TRACE(("wl%d: wlc_bsinit: bandunit %d\n", wlc->pub->unit,
 		  wlc->band->bandunit));
 
@@ -1343,7 +1328,8 @@ static void WLBANDINITFN(wlc_bsinit) (wlc_info_t * wlc) {
 }
 
 /* switch to and initialize new band */
-static void WLBANDINITFN(wlc_setband) (wlc_info_t * wlc, uint bandunit) {
+static void WLBANDINITFN(wlc_setband) (wlc_info_t *wlc, uint bandunit)
+{
 	int idx;
 	wlc_bsscfg_t *cfg;
 
@@ -1357,9 +1343,9 @@ static void WLBANDINITFN(wlc_setband) (wlc_info_t * wlc, uint bandunit) {
 		return;
 
 	/* wait for at least one beacon before entering sleeping state */
-	wlc->PMawakebcn = TRUE;
+	wlc->PMawakebcn = true;
 	FOREACH_AS_STA(wlc, idx, cfg)
-	    cfg->PMawakebcn = TRUE;
+	    cfg->PMawakebcn = true;
 	wlc_set_ps_ctrl(wlc);
 
 	/* band-specific initializations */
@@ -1367,7 +1353,7 @@ static void WLBANDINITFN(wlc_setband) (wlc_info_t * wlc, uint bandunit) {
 }
 
 /* Initialize a WME Parameter Info Element with default STA parameters from WMM Spec, Table 12 */
-void wlc_wme_initparams_sta(wlc_info_t * wlc, wme_param_ie_t * pe)
+void wlc_wme_initparams_sta(wlc_info_t *wlc, wme_param_ie_t *pe)
 {
 	static const wme_param_ie_t stadef = {
 		WME_OUI,
@@ -1392,11 +1378,11 @@ void wlc_wme_initparams_sta(wlc_info_t * wlc, wme_param_ie_t * pe)
 	memcpy(pe, &stadef, sizeof(*pe));
 }
 
-void wlc_wme_setparams(wlc_info_t * wlc, u16 aci, void *arg, bool suspend)
+void wlc_wme_setparams(wlc_info_t *wlc, u16 aci, void *arg, bool suspend)
 {
 	int i;
 	shm_acparams_t acp_shm;
-	uint16 *shm_entry;
+	u16 *shm_entry;
 	struct ieee80211_tx_queue_params *params = arg;
 
 	ASSERT(wlc);
@@ -1454,7 +1440,7 @@ void wlc_wme_setparams(wlc_info_t * wlc, u16 aci, void *arg, bool suspend)
 		acp_shm.status |= WME_STATUS_NEWAC;
 
 		/* Fill in shm acparam table */
-		shm_entry = (uint16 *) & acp_shm;
+		shm_entry = (u16 *) &acp_shm;
 		for (i = 0; i < (int)sizeof(shm_acparams_t); i += 2)
 			wlc_write_shm(wlc,
 				      M_EDCF_QINFO +
@@ -1471,13 +1457,13 @@ void wlc_wme_setparams(wlc_info_t * wlc, u16 aci, void *arg, bool suspend)
 
 }
 
-void wlc_edcf_setparams(wlc_bsscfg_t * cfg, bool suspend)
+void wlc_edcf_setparams(wlc_bsscfg_t *cfg, bool suspend)
 {
 	wlc_info_t *wlc = cfg->wlc;
 	uint aci, i, j;
 	edcf_acparam_t *edcf_acp;
 	shm_acparams_t acp_shm;
-	uint16 *shm_entry;
+	u16 *shm_entry;
 
 	ASSERT(cfg);
 	ASSERT(wlc);
@@ -1492,7 +1478,7 @@ void wlc_edcf_setparams(wlc_bsscfg_t * cfg, bool suspend)
 	 * STA uses AC params from wme_param_ie.
 	 */
 
-	edcf_acp = (edcf_acparam_t *) & wlc->wme_param_ie.acparam[0];
+	edcf_acp = (edcf_acparam_t *) &wlc->wme_param_ie.acparam[0];
 
 	wlc->wme_admctl = 0;
 
@@ -1541,7 +1527,7 @@ void wlc_edcf_setparams(wlc_bsscfg_t * cfg, bool suspend)
 		acp_shm.status |= WME_STATUS_NEWAC;
 
 		/* Fill in shm acparam table */
-		shm_entry = (uint16 *) & acp_shm;
+		shm_entry = (u16 *) &acp_shm;
 		for (j = 0; j < (int)sizeof(shm_acparams_t); j += 2)
 			wlc_write_shm(wlc,
 				      M_EDCF_QINFO +
@@ -1554,7 +1540,7 @@ void wlc_edcf_setparams(wlc_bsscfg_t * cfg, bool suspend)
 
 	if (AP_ENAB(wlc->pub) && WME_ENAB(wlc->pub)) {
 		wlc_update_beacon(wlc);
-		wlc_update_probe_resp(wlc, FALSE);
+		wlc_update_probe_resp(wlc, false);
 	}
 
 	if (suspend)
@@ -1562,36 +1548,38 @@ void wlc_edcf_setparams(wlc_bsscfg_t * cfg, bool suspend)
 
 }
 
-bool BCMATTACHFN(wlc_timers_init) (wlc_info_t * wlc, int unit) {
-	if (!
-	    (wlc->wdtimer =
-	     wl_init_timer(wlc->wl, wlc_watchdog_by_timer, wlc, "watchdog"))) {
+bool wlc_timers_init(wlc_info_t *wlc, int unit)
+{
+	wlc->wdtimer = wl_init_timer(wlc->wl, wlc_watchdog_by_timer,
+		wlc, "watchdog");
+	if (!wlc->wdtimer) {
 		WL_ERROR(("wl%d:  wl_init_timer for wdtimer failed\n", unit));
 		goto fail;
 	}
 
-	if (!
-	    (wlc->radio_timer =
-	     wl_init_timer(wlc->wl, wlc_radio_timer, wlc, "radio"))) {
+	wlc->radio_timer = wl_init_timer(wlc->wl, wlc_radio_timer,
+		wlc, "radio");
+	if (!wlc->radio_timer) {
 		WL_ERROR(("wl%d:  wl_init_timer for radio_timer failed\n",
 			  unit));
 		goto fail;
 	}
 
-	return TRUE;
+	return true;
 
  fail:
-	return FALSE;
+	return false;
 }
 
 /*
  * Initialize wlc_info default values ...
  * may get overrides later in this function
  */
-void BCMATTACHFN(wlc_info_init) (wlc_info_t * wlc, int unit) {
+void wlc_info_init(wlc_info_t *wlc, int unit)
+{
 	int i;
 	/* Assume the device is there until proven otherwise */
-	wlc->device_present = TRUE;
+	wlc->device_present = true;
 
 	/* set default power output percentage to 100 percent */
 	wlc->txpwr_percent = 100;
@@ -1600,31 +1588,31 @@ void BCMATTACHFN(wlc_info_init) (wlc_info_t * wlc, int unit) {
 	wlc->chanspec = CH20MHZ_CHSPEC(1);
 
 	/* initialize CCK preamble mode to unassociated state */
-	wlc->shortpreamble = FALSE;
+	wlc->shortpreamble = false;
 
-	wlc->legacy_probe = TRUE;
+	wlc->legacy_probe = true;
 
 	/* various 802.11g modes */
-	wlc->shortslot = FALSE;
+	wlc->shortslot = false;
 	wlc->shortslot_override = WLC_SHORTSLOT_AUTO;
 
-	wlc->barker_overlap_control = TRUE;
+	wlc->barker_overlap_control = true;
 	wlc->barker_preamble = WLC_BARKER_SHORT_ALLOWED;
 	wlc->txburst_limit_override = AUTO;
 
 	wlc_protection_upd(wlc, WLC_PROT_G_OVR, WLC_PROTECTION_AUTO);
-	wlc_protection_upd(wlc, WLC_PROT_G_SPEC, FALSE);
+	wlc_protection_upd(wlc, WLC_PROT_G_SPEC, false);
 
 	wlc_protection_upd(wlc, WLC_PROT_N_CFG_OVR, WLC_PROTECTION_AUTO);
 	wlc_protection_upd(wlc, WLC_PROT_N_CFG, WLC_N_PROTECTION_OFF);
 	wlc_protection_upd(wlc, WLC_PROT_N_NONGF_OVR, WLC_PROTECTION_AUTO);
-	wlc_protection_upd(wlc, WLC_PROT_N_NONGF, FALSE);
+	wlc_protection_upd(wlc, WLC_PROT_N_NONGF, false);
 	wlc_protection_upd(wlc, WLC_PROT_N_PAM_OVR, AUTO);
 
 	wlc_protection_upd(wlc, WLC_PROT_OVERLAP, WLC_PROTECTION_CTL_OVERLAP);
 
 	/* 802.11g draft 4.0 NonERP elt advertisement */
-	wlc->include_legacy_erp = TRUE;
+	wlc->include_legacy_erp = true;
 
 	wlc->stf->ant_rx_ovr = ANT_RX_DIV_DEF;
 	wlc->stf->txant = ANT_TX_DEF;
@@ -1646,86 +1634,88 @@ void BCMATTACHFN(wlc_info_init) (wlc_info_t * wlc, int unit) {
 
 	/* init PM state */
 	wlc->PM = PM_OFF;	/* User's setting of PM mode through IOCTL */
-	wlc->PM_override = FALSE;	/* Prevents from going to PM if our AP is 'ill' */
-	wlc->PMenabled = FALSE;	/* Current PM state */
-	wlc->PMpending = FALSE;	/* Tracks whether STA indicated PM in the last attempt */
-	wlc->PMblocked = FALSE;	/* To allow blocking going into PM during RM and scans */
+	wlc->PM_override = false;	/* Prevents from going to PM if our AP is 'ill' */
+	wlc->PMenabled = false;	/* Current PM state */
+	wlc->PMpending = false;	/* Tracks whether STA indicated PM in the last attempt */
+	wlc->PMblocked = false;	/* To allow blocking going into PM during RM and scans */
 
 	/* In WMM Auto mode, PM is allowed if association is a UAPSD association */
-	wlc->WME_PM_blocked = FALSE;
+	wlc->WME_PM_blocked = false;
 
 	/* Init wme queuing method */
-	wlc->wme_prec_queuing = FALSE;
+	wlc->wme_prec_queuing = false;
 
 	/* Overrides for the core to stay awake under zillion conditions Look for STAY_AWAKE */
-	wlc->wake = FALSE;
+	wlc->wake = false;
 	/* Are we waiting for a response to PS-Poll that we sent */
-	wlc->PSpoll = FALSE;
+	wlc->PSpoll = false;
 
 	/* APSD defaults */
-	wlc->wme_apsd = TRUE;
-	wlc->apsd_sta_usp = FALSE;
+	wlc->wme_apsd = true;
+	wlc->apsd_sta_usp = false;
 	wlc->apsd_trigger_timeout = 0;	/* disable the trigger timer */
 	wlc->apsd_trigger_ac = AC_BITMAP_ALL;
 
 	/* Set flag to indicate that hw keys should be used when available. */
-	wlc->wsec_swkeys = FALSE;
+	wlc->wsec_swkeys = false;
 
 	/* init the 4 static WEP default keys */
 	for (i = 0; i < WSEC_MAX_DEFAULT_KEYS; i++) {
 		wlc->wsec_keys[i] = wlc->wsec_def_keys[i];
-		wlc->wsec_keys[i]->idx = (uint8) i;
+		wlc->wsec_keys[i]->idx = (u8) i;
 	}
 
-	wlc->_regulatory_domain = FALSE;	/* 802.11d */
+	wlc->_regulatory_domain = false;	/* 802.11d */
 
 	/* WME QoS mode is Auto by default */
 	wlc->pub->_wme = AUTO;
 
 #ifdef BCMSDIODEV_ENABLED
-	wlc->pub->_priofc = TRUE;	/* enable priority flow control for sdio dongle */
+	wlc->pub->_priofc = true;	/* enable priority flow control for sdio dongle */
 #endif
 
 	wlc->pub->_ampdu = AMPDU_AGG_HOST;
 	wlc->pub->bcmerror = 0;
-	wlc->ibss_allowed = TRUE;
-	wlc->ibss_coalesce_allowed = TRUE;
+	wlc->ibss_allowed = true;
+	wlc->ibss_coalesce_allowed = true;
 	wlc->pub->_coex = ON;
 
 	/* intialize mpc delay */
 	wlc->mpc_delay_off = wlc->mpc_dlycnt = WLC_MPC_MIN_DELAYCNT;
 
-	wlc->pr80838_war = TRUE;
+	wlc->pr80838_war = true;
 }
 
-static bool wlc_state_bmac_sync(wlc_info_t * wlc)
+static bool wlc_state_bmac_sync(wlc_info_t *wlc)
 {
 	wlc_bmac_state_t state_bmac;
 
 	if (wlc_bmac_state_get(wlc->hw, &state_bmac) != 0)
-		return FALSE;
+		return false;
 
 	wlc->machwcap = state_bmac.machwcap;
 	wlc_protection_upd(wlc, WLC_PROT_N_PAM_OVR,
-			   (int8) state_bmac.preamble_ovr);
+			   (s8) state_bmac.preamble_ovr);
 
-	return TRUE;
+	return true;
 }
 
-static uint BCMATTACHFN(wlc_attach_module) (wlc_info_t * wlc) {
+static uint wlc_attach_module(wlc_info_t *wlc)
+{
 	uint err = 0;
 	uint unit;
 	unit = wlc->pub->unit;
 
-	if ((wlc->asi =
-	     wlc_antsel_attach(wlc, wlc->osh, wlc->pub, wlc->hw)) == NULL) {
+	wlc->asi = wlc_antsel_attach(wlc, wlc->osh, wlc->pub, wlc->hw);
+	if (wlc->asi == NULL) {
 		WL_ERROR(("wl%d: wlc_attach: wlc_antsel_attach failed\n",
 			  unit));
 		err = 44;
 		goto fail;
 	}
 
-	if ((wlc->ampdu = wlc_ampdu_attach(wlc)) == NULL) {
+	wlc->ampdu = wlc_ampdu_attach(wlc);
+	if (wlc->ampdu == NULL) {
 		WL_ERROR(("wl%d: wlc_attach: wlc_ampdu_attach failed\n", unit));
 		err = 50;
 		goto fail;
@@ -1759,10 +1749,10 @@ wlc_pub_t *wlc_pub(void *wlc)
 /*
  * The common driver entry routine. Error codes should be unique
  */
-void *BCMATTACHFN(wlc_attach) (void *wl, uint16 vendor, uint16 device,
-			       uint unit, bool piomode, osl_t * osh,
-			       void *regsva, uint bustype, void *btparam,
-			       uint * perr) {
+void *wlc_attach(void *wl, u16 vendor, u16 device, uint unit, bool piomode,
+		 osl_t *osh, void *regsva, uint bustype, void *btparam,
+		 uint *perr)
+{
 	wlc_info_t *wlc;
 	uint err = 0;
 	uint j;
@@ -1784,23 +1774,15 @@ void *BCMATTACHFN(wlc_attach) (void *wl, uint16 vendor, uint16 device,
 	ASSERT(sizeof(cck_phy_hdr_t) == D11_PHY_HDR_LEN);
 	ASSERT(sizeof(d11txh_t) == D11_TXH_LEN);
 	ASSERT(sizeof(d11rxhdr_t) == RXHDR_LEN);
-	ASSERT(sizeof(struct dot11_llc_snap_header) == DOT11_LLC_SNAP_HDR_LEN);
 	ASSERT(sizeof(struct dot11_header) == DOT11_A4_HDR_LEN);
 	ASSERT(sizeof(struct dot11_rts_frame) == DOT11_RTS_LEN);
-	ASSERT(sizeof(struct dot11_cts_frame) == DOT11_CTS_LEN);
-	ASSERT(sizeof(struct dot11_ack_frame) == DOT11_ACK_LEN);
-	ASSERT(sizeof(struct dot11_ps_poll_frame) == DOT11_PS_POLL_LEN);
-	ASSERT(sizeof(struct dot11_cf_end_frame) == DOT11_CS_END_LEN);
 	ASSERT(sizeof(struct dot11_management_header) == DOT11_MGMT_HDR_LEN);
-	ASSERT(sizeof(struct dot11_auth) == DOT11_AUTH_FIXED_LEN);
 	ASSERT(sizeof(struct dot11_bcn_prb) == DOT11_BCN_PRB_LEN);
 	ASSERT(sizeof(tx_status_t) == TXSTATUS_LEN);
-	ASSERT(sizeof(ht_add_ie_t) == HT_ADD_IE_LEN);
 	ASSERT(sizeof(ht_cap_ie_t) == HT_CAP_IE_LEN);
-	ASSERT(OFFSETOF(wl_scan_params_t, channel_list) ==
+	ASSERT(offsetof(wl_scan_params_t, channel_list) ==
 	       WL_SCAN_PARAMS_FIXED_SIZE);
-	ASSERT(TKIP_MIC_SIZE == (2 * sizeof(uint32)));
-	ASSERT(ISALIGNED(OFFSETOF(wsec_key_t, data), sizeof(uint32)));
+	ASSERT(IS_ALIGNED(offsetof(wsec_key_t, data), sizeof(u32)));
 	ASSERT(ISPOWEROF2(MA_WINDOW_SZ));
 
 	ASSERT(sizeof(wlc_d11rxhdr_t) <= WL_HWRXOFF);
@@ -1816,8 +1798,8 @@ void *BCMATTACHFN(wlc_attach) (void *wl, uint16 vendor, uint16 device,
 		   && 4 == WLC_NUMRXIVS));
 
 	/* allocate wlc_info_t state and its substructures */
-	if ((wlc =
-	     (wlc_info_t *) wlc_attach_malloc(osh, unit, &err, device)) == NULL)
+	wlc = (wlc_info_t *) wlc_attach_malloc(osh, unit, &err, device);
+	if (wlc == NULL)
 		goto fail;
 	wlc->osh = osh;
 	pub = wlc->pub;
@@ -1833,7 +1815,7 @@ void *BCMATTACHFN(wlc_attach) (void *wl, uint16 vendor, uint16 device,
 	pub->osh = osh;
 	wlc->btparam = btparam;
 	pub->_piomode = piomode;
-	wlc->bandinit_pending = FALSE;
+	wlc->bandinit_pending = false;
 	/* By default restrict TKIP associations from 11n STA's */
 	wlc->ht_wsec_restriction = WLC_HT_TKIP_RESTRICT;
 
@@ -1876,9 +1858,9 @@ void *BCMATTACHFN(wlc_attach) (void *wl, uint16 vendor, uint16 device,
 
 	/* set maximum allowed duty cycle */
 	wlc->tx_duty_cycle_ofdm =
-	    (uint16) getintvar(pub->vars, "tx_duty_cycle_ofdm");
+	    (u16) getintvar(pub->vars, "tx_duty_cycle_ofdm");
 	wlc->tx_duty_cycle_cck =
-	    (uint16) getintvar(pub->vars, "tx_duty_cycle_cck");
+	    (u16) getintvar(pub->vars, "tx_duty_cycle_cck");
 
 	wlc_stf_phy_chain_calc(wlc);
 
@@ -1946,7 +1928,7 @@ void *BCMATTACHFN(wlc_attach) (void *wl, uint16 vendor, uint16 device,
 
 		/* fill in hw_rateset (used early by WLC_SET_RATESET) */
 		wlc_rateset_filter(&wlc->band->defrateset,
-				   &wlc->band->hw_rateset, FALSE,
+				   &wlc->band->hw_rateset, false,
 				   WLC_RATES_CCK_OFDM, RATE_MASK,
 				   (bool) N_ENAB(wlc->pub));
 	}
@@ -2068,7 +2050,7 @@ void *BCMATTACHFN(wlc_attach) (void *wl, uint16 vendor, uint16 device,
 	if (perr)
 		*perr = 0;
 
-	return ((void *)wlc);
+	return (void *)wlc;
 
  fail:
 	WL_ERROR(("wl%d: %s: failed with err %d\n", unit, __func__, err));
@@ -2077,10 +2059,11 @@ void *BCMATTACHFN(wlc_attach) (void *wl, uint16 vendor, uint16 device,
 
 	if (perr)
 		*perr = err;
-	return (NULL);
+	return NULL;
 }
 
-static void BCMNMIATTACHFN(wlc_attach_antgain_init) (wlc_info_t * wlc) {
+static void wlc_attach_antgain_init(wlc_info_t *wlc)
+{
 	uint unit;
 	unit = wlc->pub->unit;
 
@@ -2091,7 +2074,7 @@ static void BCMNMIATTACHFN(wlc_attach_antgain_init) (wlc_info_t * wlc) {
 		WL_ERROR(("wl%d: %s: Invalid antennas available in srom, using 2dB\n", unit, __func__));
 		wlc->band->antgain = 8;
 	} else {
-		int8 gain, fract;
+		s8 gain, fract;
 		/* Older sroms specified gain in whole dbm only.  In order
 		 * be able to specify qdbm granularity and remain backward compatible
 		 * the whole dbms are now encoded in only low 6 bits and remaining qdbms
@@ -2110,7 +2093,8 @@ static void BCMNMIATTACHFN(wlc_attach_antgain_init) (wlc_info_t * wlc) {
 	}
 }
 
-static bool BCMATTACHFN(wlc_attach_stf_ant_init) (wlc_info_t * wlc) {
+static bool wlc_attach_stf_ant_init(wlc_info_t *wlc)
+{
 	int aa;
 	uint unit;
 	char *vars;
@@ -2121,9 +2105,9 @@ static bool BCMATTACHFN(wlc_attach_stf_ant_init) (wlc_info_t * wlc) {
 	bandtype = wlc->band->bandtype;
 
 	/* get antennas available */
-	aa = (int8) getintvar(vars, (BAND_5G(bandtype) ? "aa5g" : "aa2g"));
+	aa = (s8) getintvar(vars, (BAND_5G(bandtype) ? "aa5g" : "aa2g"));
 	if (aa == 0)
-		aa = (int8) getintvar(vars,
+		aa = (s8) getintvar(vars,
 				      (BAND_5G(bandtype) ? "aa1" : "aa0"));
 	if ((aa < 1) || (aa > 15)) {
 		WL_ERROR(("wl%d: %s: Invalid antennas available in srom (0x%x), using 3.\n", unit, __func__, aa));
@@ -2142,18 +2126,18 @@ static bool BCMATTACHFN(wlc_attach_stf_ant_init) (wlc_info_t * wlc) {
 
 	/* Compute Antenna Gain */
 	wlc->band->antgain =
-	    (int8) getintvar(vars, (BAND_5G(bandtype) ? "ag1" : "ag0"));
+	    (s8) getintvar(vars, (BAND_5G(bandtype) ? "ag1" : "ag0"));
 	wlc_attach_antgain_init(wlc);
 
-	return TRUE;
+	return true;
 }
 
 #ifdef WLC_HIGH_ONLY
 /* HIGH_ONLY bmac_attach, which sync over LOW_ONLY bmac_attach states */
-int
-BCMATTACHFN(wlc_bmac_attach) (wlc_info_t * wlc, uint16 vendor, uint16 device,
-			      uint unit, bool piomode, osl_t * osh,
-			      void *regsva, uint bustype, void *btparam) {
+int wlc_bmac_attach(wlc_info_t *wlc, u16 vendor, u16 device, uint unit,
+		    bool piomode, osl_t *osh, void *regsva, uint bustype,
+		    void *btparam)
+{
 	wlc_bmac_revinfo_t revinfo;
 	uint idx = 0;
 	rpc_info_t *rpc = (rpc_info_t *) btparam;
@@ -2167,7 +2151,8 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t * wlc, uint16 vendor, uint16 device,
 
 	wlc->regs = 0;
 
-	if ((wlc->rpctx = wlc_rpctx_attach(wlc->pub, wlc)) == NULL)
+	wlc->rpctx = wlc_rpctx_attach(wlc->pub, wlc);
+	if (wlc->rpctx == NULL)
 		return -1;
 
 	/*
@@ -2196,12 +2181,12 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t * wlc, uint16 vendor, uint16 device,
 	bzero(&revinfo, sizeof(wlc_bmac_revinfo_t));
 	if (wlc_bmac_revinfo_get(wlc->hw, &revinfo) != 0)
 		return -1;
-	wlc->vendorid = (uint16) revinfo.vendorid;
-	wlc->deviceid = (uint16) revinfo.deviceid;
+	wlc->vendorid = (u16) revinfo.vendorid;
+	wlc->deviceid = (u16) revinfo.deviceid;
 
-	wlc->pub->boardrev = (uint16) revinfo.boardrev;
+	wlc->pub->boardrev = (u16) revinfo.boardrev;
 	wlc->pub->corerev = revinfo.corerev;
-	wlc->pub->sromrev = (uint8) revinfo.sromrev;
+	wlc->pub->sromrev = (u8) revinfo.sromrev;
 	wlc->pub->sih->chiprev = revinfo.chiprev;
 	wlc->pub->sih->chip = revinfo.chip;
 	wlc->pub->sih->chippkg = revinfo.chippkg;
@@ -2229,13 +2214,13 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t * wlc, uint16 vendor, uint16 device,
 		bandunit = revinfo.band[idx].bandunit;
 		bandtype = revinfo.band[idx].bandtype;
 		wlc->bandstate[bandunit]->radiorev =
-		    (uint8) revinfo.band[idx].radiorev;
+		    (u8) revinfo.band[idx].radiorev;
 		wlc->bandstate[bandunit]->phytype =
-		    (uint16) revinfo.band[idx].phytype;
+		    (u16) revinfo.band[idx].phytype;
 		wlc->bandstate[bandunit]->phyrev =
-		    (uint16) revinfo.band[idx].phyrev;
+		    (u16) revinfo.band[idx].phyrev;
 		wlc->bandstate[bandunit]->radioid =
-		    (uint16) revinfo.band[idx].radioid;
+		    (u16) revinfo.band[idx].radioid;
 		wlc->bandstate[bandunit]->abgphy_encore =
 		    revinfo.band[idx].abgphy_encore;
 
@@ -2250,7 +2235,7 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t * wlc, uint16 vendor, uint16 device,
 }
 
 /* Free the convenience handles */
-int wlc_bmac_detach(wlc_info_t * wlc)
+int wlc_bmac_detach(wlc_info_t *wlc)
 {
 	uint idx;
 
@@ -2261,8 +2246,7 @@ int wlc_bmac_detach(wlc_info_t * wlc)
 
 	for (idx = 0; idx < MAXBANDS; idx++)
 		if (wlc->bandstate[idx]->pi) {
-			osl_mfree(wlc->osh, wlc->bandstate[idx]->pi,
-				  sizeof(wlc_phy_t));
+			kfree(wlc->bandstate[idx]->pi);
 			wlc->bandstate[idx]->pi = NULL;
 		}
 
@@ -2277,7 +2261,8 @@ int wlc_bmac_detach(wlc_info_t * wlc)
 
 #endif				/* WLC_HIGH_ONLY */
 
-static void BCMATTACHFN(wlc_timers_deinit) (wlc_info_t * wlc) {
+static void wlc_timers_deinit(wlc_info_t *wlc)
+{
 	/* free timer state */
 	if (wlc->wdtimer) {
 		wl_free_timer(wlc->wl, wlc->wdtimer);
@@ -2289,7 +2274,8 @@ static void BCMATTACHFN(wlc_timers_deinit) (wlc_info_t * wlc) {
 	}
 }
 
-static void BCMATTACHFN(wlc_detach_module) (wlc_info_t * wlc) {
+static void wlc_detach_module(wlc_info_t *wlc)
+{
 	if (wlc->asi) {
 		wlc_antsel_detach(wlc->asi);
 		wlc->asi = NULL;
@@ -2311,7 +2297,8 @@ static void BCMATTACHFN(wlc_detach_module) (wlc_info_t * wlc) {
  *    One exception is sb register access, which is possible if crystal is turned on
  * After "down" state, driver should avoid software timer with the exception of radio_monitor.
  */
-uint BCMATTACHFN(wlc_detach) (wlc_info_t * wlc) {
+uint wlc_detach(wlc_info_t *wlc)
+{
 	uint i;
 	uint callbacks = 0;
 
@@ -2346,15 +2333,14 @@ uint BCMATTACHFN(wlc_detach) (wlc_info_t * wlc) {
 	 * references the wlc->hw->vars which is freed in wlc_bmac_detach()
 	 */
 	if (wlc->pub->vars) {
-		osl_mfree(wlc->osh, wlc->pub->vars, wlc->vars_size);
+		kfree(wlc->pub->vars);
 		wlc->pub->vars = NULL;
 	}
 #endif
 
 #ifdef BCMDBG
 	if (wlc->country_ie_override) {
-		osl_mfree(wlc->osh, wlc->country_ie_override,
-			  wlc->country_ie_override->len + TLV_HDR_LEN);
+		kfree(wlc->country_ie_override);
 		wlc->country_ie_override = NULL;
 	}
 #endif				/* BCMDBG */
@@ -2365,7 +2351,7 @@ uint BCMATTACHFN(wlc_detach) (wlc_info_t * wlc) {
 		prev = ptr = wlc->dumpcb_head;
 		while (ptr) {
 			ptr = prev->next;
-			osl_mfree(wlc->osh, prev, sizeof(dumpcb_t));
+			kfree(prev);
 			prev = ptr;
 		}
 		wlc->dumpcb_head = NULL;
@@ -2393,11 +2379,11 @@ uint BCMATTACHFN(wlc_detach) (wlc_info_t * wlc) {
 		ASSERT(wlc->modulecb[i].name[0] == '\0');
 
 	wlc_detach_mfree(wlc, wlc->osh);
-	return (callbacks);
+	return callbacks;
 }
 
 /* update state that depends on the current value of "ap" */
-void wlc_ap_upd(wlc_info_t * wlc)
+void wlc_ap_upd(wlc_info_t *wlc)
 {
 	if (AP_ENAB(wlc->pub))
 		wlc->PLCPHdr_override = WLC_PLCP_AUTO;	/* AP: short not allowed, but not enforced */
@@ -2408,11 +2394,11 @@ void wlc_ap_upd(wlc_info_t * wlc)
 	wlc->vlan_mode = AP_ENAB(wlc->pub) ? OFF : AUTO;
 
 	/* fixup mpc */
-	wlc->mpc = TRUE;
+	wlc->mpc = true;
 }
 
 /* read hwdisable state and propagate to wlc flag */
-static void wlc_radio_hwdisable_upd(wlc_info_t * wlc)
+static void wlc_radio_hwdisable_upd(wlc_info_t *wlc)
 {
 	if (wlc->pub->wlfeatureflag & WL_SWFL_NOHWRADIO || wlc->pub->hw_off)
 		return;
@@ -2424,18 +2410,18 @@ static void wlc_radio_hwdisable_upd(wlc_info_t * wlc)
 	}
 }
 
-/* return TRUE if Minimum Power Consumption should be entered, FALSE otherwise */
-bool wlc_is_non_delay_mpc(wlc_info_t * wlc)
+/* return true if Minimum Power Consumption should be entered, false otherwise */
+bool wlc_is_non_delay_mpc(wlc_info_t *wlc)
 {
-	return (FALSE);
+	return false;
 }
 
-bool wlc_ismpc(wlc_info_t * wlc)
+bool wlc_ismpc(wlc_info_t *wlc)
 {
-	return ((wlc->mpc_delay_off == 0) && (wlc_is_non_delay_mpc(wlc)));
+	return (wlc->mpc_delay_off == 0) && (wlc_is_non_delay_mpc(wlc));
 }
 
-void wlc_radio_mpc_upd(wlc_info_t * wlc)
+void wlc_radio_mpc_upd(wlc_info_t *wlc)
 {
 	bool mpc_radio, radio_state;
 
@@ -2463,7 +2449,7 @@ void wlc_radio_mpc_upd(wlc_info_t * wlc)
 	radio_state =
 	    (mboolisset(wlc->pub->radio_disabled, WL_RADIO_MPC_DISABLE) ? OFF :
 	     ON);
-	mpc_radio = (wlc_ismpc(wlc) == TRUE) ? OFF : ON;
+	mpc_radio = (wlc_ismpc(wlc) == true) ? OFF : ON;
 
 	if (radio_state == ON && mpc_radio == OFF)
 		wlc->mpc_delay_off = wlc->mpc_dlycnt;
@@ -2480,8 +2466,8 @@ void wlc_radio_mpc_upd(wlc_info_t * wlc)
 	 * other than wlc->mpc_delay_off keeping the mpc off. In that case reset
 	 * wlc->mpc_delay_off to wlc->mpc_dlycnt, so that we restart the countdown of mpc_delay_off
 	 */
-	if ((wlc->prev_non_delay_mpc == FALSE) &&
-	    (wlc_is_non_delay_mpc(wlc) == TRUE) && wlc->mpc_delay_off) {
+	if ((wlc->prev_non_delay_mpc == false) &&
+	    (wlc_is_non_delay_mpc(wlc) == true) && wlc->mpc_delay_off) {
 		wlc->mpc_delay_off = wlc->mpc_dlycnt;
 	}
 	wlc->prev_non_delay_mpc = wlc_is_non_delay_mpc(wlc);
@@ -2491,7 +2477,7 @@ void wlc_radio_mpc_upd(wlc_info_t * wlc)
  * centralized radio disable/enable function,
  * invoke radio enable/disable after updating hwradio status
  */
-static void wlc_radio_upd(wlc_info_t * wlc)
+static void wlc_radio_upd(wlc_info_t *wlc)
 {
 	if (wlc->pub->radio_disabled)
 		wlc_radio_disable(wlc);
@@ -2500,20 +2486,20 @@ static void wlc_radio_upd(wlc_info_t * wlc)
 }
 
 /* maintain LED behavior in down state */
-static void wlc_down_led_upd(wlc_info_t * wlc)
+static void wlc_down_led_upd(wlc_info_t *wlc)
 {
 	ASSERT(!wlc->pub->up);
 
 	/* maintain LEDs while in down state, turn on sbclk if not available yet */
 	/* turn on sbclk if necessary */
 	if (!AP_ENAB(wlc->pub)) {
-		wlc_pllreq(wlc, TRUE, WLC_PLLREQ_FLIP);
+		wlc_pllreq(wlc, true, WLC_PLLREQ_FLIP);
 
-		wlc_pllreq(wlc, FALSE, WLC_PLLREQ_FLIP);
+		wlc_pllreq(wlc, false, WLC_PLLREQ_FLIP);
 	}
 }
 
-void wlc_radio_disable(wlc_info_t * wlc)
+void wlc_radio_disable(wlc_info_t *wlc)
 {
 	if (!wlc->pub->up) {
 		wlc_down_led_upd(wlc);
@@ -2524,7 +2510,7 @@ void wlc_radio_disable(wlc_info_t * wlc)
 	wl_down(wlc->wl);
 }
 
-static void wlc_radio_enable(wlc_info_t * wlc)
+static void wlc_radio_enable(wlc_info_t *wlc)
 {
 	if (wlc->pub->up)
 		return;
@@ -2558,46 +2544,46 @@ static void wlc_radio_timer(void *arg)
 	wlc_radio_upd(wlc);
 }
 
-static bool wlc_radio_monitor_start(wlc_info_t * wlc)
+static bool wlc_radio_monitor_start(wlc_info_t *wlc)
 {
 	/* Don't start the timer if HWRADIO feature is disabled */
 	if (wlc->radio_monitor || (wlc->pub->wlfeatureflag & WL_SWFL_NOHWRADIO))
-		return TRUE;
+		return true;
 
-	wlc->radio_monitor = TRUE;
-	wlc_pllreq(wlc, TRUE, WLC_PLLREQ_RADIO_MON);
-	wl_add_timer(wlc->wl, wlc->radio_timer, TIMER_INTERVAL_RADIOCHK, TRUE);
-	return TRUE;
+	wlc->radio_monitor = true;
+	wlc_pllreq(wlc, true, WLC_PLLREQ_RADIO_MON);
+	wl_add_timer(wlc->wl, wlc->radio_timer, TIMER_INTERVAL_RADIOCHK, true);
+	return true;
 }
 
-bool wlc_radio_monitor_stop(wlc_info_t * wlc)
+bool wlc_radio_monitor_stop(wlc_info_t *wlc)
 {
 	if (!wlc->radio_monitor)
-		return TRUE;
+		return true;
 
 	ASSERT((wlc->pub->wlfeatureflag & WL_SWFL_NOHWRADIO) !=
 	       WL_SWFL_NOHWRADIO);
 
-	wlc->radio_monitor = FALSE;
-	wlc_pllreq(wlc, FALSE, WLC_PLLREQ_RADIO_MON);
-	return (wl_del_timer(wlc->wl, wlc->radio_timer));
+	wlc->radio_monitor = false;
+	wlc_pllreq(wlc, false, WLC_PLLREQ_RADIO_MON);
+	return wl_del_timer(wlc->wl, wlc->radio_timer);
 }
 
 /* bring the driver down, but don't reset hardware */
-void wlc_out(wlc_info_t * wlc)
+void wlc_out(wlc_info_t *wlc)
 {
-	wlc_bmac_set_noreset(wlc->hw, TRUE);
+	wlc_bmac_set_noreset(wlc->hw, true);
 	wlc_radio_upd(wlc);
 	wl_down(wlc->wl);
-	wlc_bmac_set_noreset(wlc->hw, FALSE);
+	wlc_bmac_set_noreset(wlc->hw, false);
 
-	/* core clk is TRUE in BMAC driver due to noreset, need to mirror it in HIGH */
-	wlc->clk = TRUE;
+	/* core clk is true in BMAC driver due to noreset, need to mirror it in HIGH */
+	wlc->clk = true;
 
 	/* This will make sure that when 'up' is done
 	 * after 'out' it'll restore hardware (especially gpios)
 	 */
-	wlc->pub->hw_up = FALSE;
+	wlc->pub->hw_up = false;
 }
 
 #if defined(BCMDBG)
@@ -2605,7 +2591,7 @@ void wlc_out(wlc_info_t * wlc)
  * if there is no packet pending for the FIFO, then the corresponding prec bits should be set
  * in prec_map. Of course, ignore this rule when block_datafifo is set
  */
-static bool wlc_tx_prec_map_verify(wlc_info_t * wlc)
+static bool wlc_tx_prec_map_verify(wlc_info_t *wlc)
 {
 	/* For non-WME, both fifos have overlapping prec_map. So it's an error only if both
 	 * fail the check.
@@ -2613,15 +2599,15 @@ static bool wlc_tx_prec_map_verify(wlc_info_t * wlc)
 	if (!EDCF_ENAB(wlc->pub)) {
 		if (!(WLC_TX_FIFO_CHECK(wlc, TX_DATA_FIFO) ||
 		      WLC_TX_FIFO_CHECK(wlc, TX_CTL_FIFO)))
-			return FALSE;
+			return false;
 		else
-			return TRUE;
+			return true;
 	}
 
-	return (WLC_TX_FIFO_CHECK(wlc, TX_AC_BK_FIFO)
+	return WLC_TX_FIFO_CHECK(wlc, TX_AC_BK_FIFO)
 		&& WLC_TX_FIFO_CHECK(wlc, TX_AC_BE_FIFO)
 		&& WLC_TX_FIFO_CHECK(wlc, TX_AC_VI_FIFO)
-		&& WLC_TX_FIFO_CHECK(wlc, TX_AC_VO_FIFO));
+		&& WLC_TX_FIFO_CHECK(wlc, TX_AC_VO_FIFO);
 }
 #endif				/* BCMDBG */
 
@@ -2633,7 +2619,7 @@ static void wlc_watchdog_by_timer(void *arg)
 		/* set to normal osl watchdog period */
 		wl_del_timer(wlc->wl, wlc->wdtimer);
 		wl_add_timer(wlc->wl, wlc->wdtimer, TIMER_INTERVAL_WATCHDOG,
-			     TRUE);
+			     true);
 	}
 }
 
@@ -2718,7 +2704,7 @@ static void wlc_watchdog(void *arg)
 	}
 #ifdef WLC_LOW
 	/* BMAC_NOTE: for HIGH_ONLY driver, this seems being called after RPC bus failed */
-	ASSERT(wlc_bmac_taclear(wlc->hw, TRUE));
+	ASSERT(wlc_bmac_taclear(wlc->hw, true));
 #endif
 
 	/* Verify that tx_prec_map and fifos are in sync to avoid lock ups */
@@ -2728,7 +2714,8 @@ static void wlc_watchdog(void *arg)
 }
 
 /* make interface operational */
-int BCMINITFN(wlc_up) (wlc_info_t * wlc) {
+int wlc_up(wlc_info_t *wlc)
+{
 	WL_TRACE(("wl%d: %s:\n", wlc->pub->unit, __func__));
 
 	/* HW is turned off so don't try to access it */
@@ -2737,7 +2724,7 @@ int BCMINITFN(wlc_up) (wlc_info_t * wlc) {
 
 	if (!wlc->pub->hw_up) {
 		wlc_bmac_hw_up(wlc->hw);
-		wlc->pub->hw_up = TRUE;
+		wlc->pub->hw_up = true;
 	}
 
 	if ((wlc->pub->boardflags & BFL_FEM)
@@ -2787,7 +2774,7 @@ int BCMINITFN(wlc_up) (wlc_info_t * wlc) {
 	}
 
 	/* wlc_bmac_up_prep has done wlc_corereset(). so clk is on, set it */
-	wlc->clk = TRUE;
+	wlc->clk = true;
 
 	wlc_radio_monitor_stop(wlc);
 
@@ -2803,12 +2790,12 @@ int BCMINITFN(wlc_up) (wlc_info_t * wlc) {
 			WLC_BAND_ALL);
 
 	wl_init(wlc->wl);
-	wlc->pub->up = TRUE;
+	wlc->pub->up = true;
 
 	if (wlc->bandinit_pending) {
 		wlc_suspend_mac_and_wait(wlc);
 		wlc_set_chanspec(wlc, wlc->default_bss->chanspec);
-		wlc->bandinit_pending = FALSE;
+		wlc->bandinit_pending = false;
 		wlc_enable_mac(wlc);
 	}
 
@@ -2823,21 +2810,22 @@ int BCMINITFN(wlc_up) (wlc_info_t * wlc) {
 
 	/* start one second watchdog timer */
 	ASSERT(!wlc->WDarmed);
-	wl_add_timer(wlc->wl, wlc->wdtimer, TIMER_INTERVAL_WATCHDOG, TRUE);
-	wlc->WDarmed = TRUE;
+	wl_add_timer(wlc->wl, wlc->wdtimer, TIMER_INTERVAL_WATCHDOG, true);
+	wlc->WDarmed = true;
 
 	/* ensure antenna config is up to date */
 	wlc_stf_phy_txant_upd(wlc);
 	/* ensure LDPC config is in sync */
 	wlc_ht_update_ldpc(wlc, wlc->stf->ldpc);
 
-	return (0);
+	return 0;
 }
 
 /* Initialize the base precedence map for dequeueing from txq based on WME settings */
-static void BCMINITFN(wlc_tx_prec_map_init) (wlc_info_t * wlc) {
+static void wlc_tx_prec_map_init(wlc_info_t *wlc)
+{
 	wlc->tx_prec_map = WLC_PREC_BMP_ALL;
-	bzero(wlc->fifo2prec_map, sizeof(uint16) * NFIFO);
+	bzero(wlc->fifo2prec_map, sizeof(u16) * NFIFO);
 
 	/* For non-WME, both fifos have overlapping MAXPRIO. So just disable all precedences
 	 * if either is full.
@@ -2853,7 +2841,8 @@ static void BCMINITFN(wlc_tx_prec_map_init) (wlc_info_t * wlc) {
 	}
 }
 
-static uint BCMUNINITFN(wlc_down_del_timer) (wlc_info_t * wlc) {
+static uint wlc_down_del_timer(wlc_info_t *wlc)
+{
 	uint callbacks = 0;
 
 	return callbacks;
@@ -2864,11 +2853,12 @@ static uint BCMUNINITFN(wlc_down_del_timer) (wlc_info_t * wlc) {
  * disable the hardware, free any transient buffer state.
  * Return a count of the number of driver callbacks still pending.
  */
-uint BCMUNINITFN(wlc_down) (wlc_info_t * wlc) {
+uint wlc_down(wlc_info_t *wlc)
+{
 
 	uint callbacks = 0;
 	int i;
-	bool dev_gone = FALSE;
+	bool dev_gone = false;
 	wlc_txq_info_t *qi;
 
 	WL_TRACE(("wl%d: %s:\n", wlc->pub->unit, __func__));
@@ -2880,10 +2870,10 @@ uint BCMUNINITFN(wlc_down) (wlc_info_t * wlc) {
 		return 0;
 	}
 	if (!wlc->pub->up)
-		return (callbacks);
+		return callbacks;
 
 	/* in between, mpc could try to bring down again.. */
-	wlc->going_down = TRUE;
+	wlc->going_down = true;
 
 	callbacks += wlc_bmac_down_prep(wlc->hw);
 
@@ -2900,7 +2890,7 @@ uint BCMUNINITFN(wlc_down) (wlc_info_t * wlc) {
 	if (wlc->WDarmed) {
 		if (!wl_del_timer(wlc->wl, wlc->wdtimer))
 			callbacks++;
-		wlc->WDarmed = FALSE;
+		wlc->WDarmed = false;
 	}
 	/* cancel all other timers */
 	callbacks += wlc_down_del_timer(wlc);
@@ -2908,16 +2898,16 @@ uint BCMUNINITFN(wlc_down) (wlc_info_t * wlc) {
 	/* interrupt must have been blocked */
 	ASSERT((wlc->macintmask == 0) || !wlc->pub->up);
 
-	wlc->pub->up = FALSE;
+	wlc->pub->up = false;
 
-	wlc_phy_mute_upd(wlc->band->pi, FALSE, PHY_MUTE_ALL);
+	wlc_phy_mute_upd(wlc->band->pi, false, PHY_MUTE_ALL);
 
 	/* clear txq flow control */
 	wlc_txflowcontrol_reset(wlc);
 
 	/* flush tx queues */
 	for (qi = wlc->tx_queues; qi != NULL; qi = qi->next) {
-		pktq_flush(wlc->osh, &qi->q, TRUE, NULL, 0);
+		pktq_flush(wlc->osh, &qi->q, true, NULL, 0);
 		ASSERT(pktq_empty(&qi->q));
 	}
 
@@ -2930,7 +2920,7 @@ uint BCMUNINITFN(wlc_down) (wlc_info_t * wlc) {
 	callbacks += wlc_bmac_down_finish(wlc->hw);
 
 	/* wlc_bmac_down_finish has done wlc_coredisable(). so clk is off */
-	wlc->clk = FALSE;
+	wlc->clk = false;
 
 #ifdef WLC_HIGH_ONLY
 	wlc_rpctx_txreclaim(wlc->rpctx);
@@ -2948,24 +2938,24 @@ uint BCMUNINITFN(wlc_down) (wlc_info_t * wlc) {
 	for (i = 1; i <= wlc->pub->tunables->maxpktcb; i++)
 		ASSERT(wlc->pkt_callback[i].fn == NULL);
 #endif
-	wlc->going_down = FALSE;
-	return (callbacks);
+	wlc->going_down = false;
+	return callbacks;
 }
 
 /* Set the current gmode configuration */
-int wlc_set_gmode(wlc_info_t * wlc, uint8 gmode, bool config)
+int wlc_set_gmode(wlc_info_t *wlc, u8 gmode, bool config)
 {
 	int ret = 0;
 	uint i;
 	wlc_rateset_t rs;
 	/* Default to 54g Auto */
-	int8 shortslot = WLC_SHORTSLOT_AUTO;	/* Advertise and use shortslot (-1/0/1 Auto/Off/On) */
-	bool shortslot_restrict = FALSE;	/* Restrict association to stations that support shortslot
+	s8 shortslot = WLC_SHORTSLOT_AUTO;	/* Advertise and use shortslot (-1/0/1 Auto/Off/On) */
+	bool shortslot_restrict = false;	/* Restrict association to stations that support shortslot
 						 */
-	bool ignore_bcns = TRUE;	/* Ignore legacy beacons on the same channel */
-	bool ofdm_basic = FALSE;	/* Make 6, 12, and 24 basic rates */
+	bool ignore_bcns = true;	/* Ignore legacy beacons on the same channel */
+	bool ofdm_basic = false;	/* Make 6, 12, and 24 basic rates */
 	int preamble = WLC_PLCP_LONG;	/* Advertise and use short preambles (-1/0/1 Auto/Off/On) */
-	bool preamble_restrict = FALSE;	/* Restrict association to stations that support short
+	bool preamble_restrict = false;	/* Restrict association to stations that support short
 					 * preambles
 					 */
 	wlcband_t *band;
@@ -2991,7 +2981,7 @@ int wlc_set_gmode(wlc_info_t * wlc, uint8 gmode, bool config)
 		return BCME_RANGE;
 
 	/* update configuration value */
-	if (config == TRUE)
+	if (config == true)
 		wlc_protection_upd(wlc, WLC_PROT_G_USER, gmode);
 
 	/* Clear supported rates filter */
@@ -3017,9 +3007,9 @@ int wlc_set_gmode(wlc_info_t * wlc, uint8 gmode, bool config)
 		break;
 
 	case GMODE_ONLY:
-		ofdm_basic = TRUE;
+		ofdm_basic = true;
 		preamble = WLC_PLCP_SHORT;
-		preamble_restrict = TRUE;
+		preamble_restrict = true;
 		break;
 
 	case GMODE_PERFORMANCE:
@@ -3028,10 +3018,10 @@ int wlc_set_gmode(wlc_info_t * wlc, uint8 gmode, bool config)
 					 &wlc->sup_rates_override);
 
 		shortslot = WLC_SHORTSLOT_ON;
-		shortslot_restrict = TRUE;
-		ofdm_basic = TRUE;
+		shortslot_restrict = true;
+		ofdm_basic = true;
 		preamble = WLC_PLCP_SHORT;
-		preamble_restrict = TRUE;
+		preamble_restrict = true;
 		break;
 
 	default:
@@ -3103,7 +3093,7 @@ int wlc_set_gmode(wlc_info_t * wlc, uint8 gmode, bool config)
 	return ret;
 }
 
-static int wlc_nmode_validate(wlc_info_t * wlc, int32 nmode)
+static int wlc_nmode_validate(wlc_info_t *wlc, s32 nmode)
 {
 	int err = 0;
 
@@ -3127,7 +3117,7 @@ static int wlc_nmode_validate(wlc_info_t * wlc, int32 nmode)
 	return err;
 }
 
-int wlc_set_nmode(wlc_info_t * wlc, int32 nmode)
+int wlc_set_nmode(wlc_info_t *wlc, s32 nmode)
 {
 	uint i;
 	int err;
@@ -3164,7 +3154,7 @@ int wlc_set_nmode(wlc_info_t * wlc, int32 nmode)
 	case WL_11N_3x3:
 		ASSERT(WLC_PHY_11N_CAP(wlc->band));
 		/* force GMODE_AUTO if NMODE is ON */
-		wlc_set_gmode(wlc, GMODE_AUTO, TRUE);
+		wlc_set_gmode(wlc, GMODE_AUTO, true);
 		if (nmode == WL_11N_3x3)
 			wlc->pub->_n_enab = SUPPORT_HT;
 		else
@@ -3186,7 +3176,7 @@ int wlc_set_nmode(wlc_info_t * wlc, int32 nmode)
 	return err;
 }
 
-static int wlc_set_rateset(wlc_info_t * wlc, wlc_rateset_t * rs_arg)
+static int wlc_set_rateset(wlc_info_t *wlc, wlc_rateset_t *rs_arg)
 {
 	wlc_rateset_t rs, new;
 	uint bandunit;
@@ -3201,7 +3191,7 @@ static int wlc_set_rateset(wlc_info_t * wlc, wlc_rateset_t * rs_arg)
 	bandunit = wlc->band->bandunit;
 	bcopy((char *)&rs, (char *)&new, sizeof(wlc_rateset_t));
 	if (wlc_rate_hwrs_filter_sort_validate
-	    (&new, &wlc->bandstate[bandunit]->hw_rateset, TRUE,
+	    (&new, &wlc->bandstate[bandunit]->hw_rateset, true,
 	     wlc->stf->txstreams))
 		goto good;
 
@@ -3212,7 +3202,7 @@ static int wlc_set_rateset(wlc_info_t * wlc, wlc_rateset_t * rs_arg)
 		if (wlc_rate_hwrs_filter_sort_validate(&new,
 						       &wlc->
 						       bandstate[bandunit]->
-						       hw_rateset, TRUE,
+						       hw_rateset, true,
 						       wlc->stf->txstreams))
 			goto good;
 	}
@@ -3225,25 +3215,25 @@ static int wlc_set_rateset(wlc_info_t * wlc, wlc_rateset_t * rs_arg)
 	      sizeof(wlc_rateset_t));
 	bcopy((char *)&new, (char *)&wlc->bandstate[bandunit]->defrateset,
 	      sizeof(wlc_rateset_t));
-	return (0);
+	return 0;
 }
 
 /* simplified integer set interface for common ioctl handler */
-int wlc_set(wlc_info_t * wlc, int cmd, int arg)
+int wlc_set(wlc_info_t *wlc, int cmd, int arg)
 {
 	return wlc_ioctl(wlc, cmd, (void *)&arg, sizeof(arg), NULL);
 }
 
 /* simplified integer get interface for common ioctl handler */
-int wlc_get(wlc_info_t * wlc, int cmd, int *arg)
+int wlc_get(wlc_info_t *wlc, int cmd, int *arg)
 {
 	return wlc_ioctl(wlc, cmd, arg, sizeof(int), NULL);
 }
 
-static void wlc_ofdm_rateset_war(wlc_info_t * wlc)
+static void wlc_ofdm_rateset_war(wlc_info_t *wlc)
 {
-	uint8 r;
-	bool war = FALSE;
+	u8 r;
+	bool war = false;
 
 	if (wlc->cfg->associated)
 		r = wlc->cfg->current_bss->rateset.rates[0];
@@ -3256,14 +3246,14 @@ static void wlc_ofdm_rateset_war(wlc_info_t * wlc)
 }
 
 int
-wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
+wlc_ioctl(wlc_info_t *wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 {
-	return (_wlc_ioctl(wlc, cmd, arg, len, wlcif));
+	return _wlc_ioctl(wlc, cmd, arg, len, wlcif);
 }
 
 /* common ioctl handler. return: 0=ok, -1=error, positive=particular error */
 static int
-_wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
+_wlc_ioctl(wlc_info_t *wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 {
 	int val, *pval;
 	bool bool_val;
@@ -3284,7 +3274,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 
 	/* initialize the following to get rid of compiler warning */
 	nextscb = NULL;
-	ta_ok = FALSE;
+	ta_ok = false;
 	band = 0;
 	r = NULL;
 
@@ -3298,10 +3288,10 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 	ASSERT(!(wlc->pub->hw_off && wlc->pub->up));
 
 	/* default argument is generic integer */
-	pval = arg ? (int *)arg : NULL;
+	pval = arg ? (int *)arg:NULL;
 
 	/* This will prevent the misaligned access */
-	if (pval && (uint32) len >= sizeof(val))
+	if (pval && (u32) len >= sizeof(val))
 		bcopy(pval, &val, sizeof(val));
 	else
 		val = 0;
@@ -3384,9 +3374,9 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			if (!wlc->pub->up && IS_MBAND_UNLOCKED(wlc)) {
 				if (wlc->band->bandunit !=
 				    CHSPEC_WLCBANDUNIT(chspec))
-					wlc->bandinit_pending = TRUE;
+					wlc->bandinit_pending = true;
 				else
-					wlc->bandinit_pending = FALSE;
+					wlc->bandinit_pending = false;
 			}
 
 			wlc->default_bss->chanspec = chspec;
@@ -3418,7 +3408,8 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 		     (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : ((int *)arg)[1];
 
 		/* bcmerror checking */
-		if ((bcmerror = wlc_iocregchk(wlc, band)))
+		bcmerror = wlc_iocregchk(wlc, band);
+		if (bcmerror)
 			break;
 
 		if (val >= MHFMAX) {
@@ -3426,7 +3417,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			break;
 		}
 
-		*pval = wlc_bmac_mhf_get(wlc->hw, (uint8) val, WLC_BAND_AUTO);
+		*pval = wlc_bmac_mhf_get(wlc->hw, (u8) val, WLC_BAND_AUTO);
 		break;
 
 	case WLC_SET_UCFLAGS:
@@ -3441,21 +3432,22 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 		     (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : ((int *)arg)[1];
 
 		/* bcmerror checking */
-		if ((bcmerror = wlc_iocregchk(wlc, band)))
+		bcmerror = wlc_iocregchk(wlc, band);
+		if (bcmerror)
 			break;
 
-		i = (uint16) val;
+		i = (u16) val;
 		if (i >= MHFMAX) {
 			bcmerror = BCME_RANGE;
 			break;
 		}
 
-		wlc_mhf(wlc, (uint8) i, 0xffff, (uint16) (val >> NBITS(uint16)),
+		wlc_mhf(wlc, (u8) i, 0xffff, (u16) (val >> NBITS(u16)),
 			WLC_BAND_AUTO);
 		break;
 
 	case WLC_GET_SHMEM:
-		ta_ok = TRUE;
+		ta_ok = true;
 
 		/* optional band is stored in the second integer of incoming buffer */
 		band =
@@ -3463,7 +3455,8 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 		     (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : ((int *)arg)[1];
 
 		/* bcmerror checking */
-		if ((bcmerror = wlc_iocregchk(wlc, band)))
+		bcmerror = wlc_iocregchk(wlc, band);
+		if (bcmerror)
 			break;
 
 		if (val & 1) {
@@ -3471,11 +3464,11 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			break;
 		}
 
-		*pval = wlc_read_shm(wlc, (uint16) val);
+		*pval = wlc_read_shm(wlc, (u16) val);
 		break;
 
 	case WLC_SET_SHMEM:
-		ta_ok = TRUE;
+		ta_ok = true;
 
 		/* optional band is stored in the second integer of incoming buffer */
 		band =
@@ -3483,7 +3476,8 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 		     (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : ((int *)arg)[1];
 
 		/* bcmerror checking */
-		if ((bcmerror = wlc_iocregchk(wlc, band)))
+		bcmerror = wlc_iocregchk(wlc, band);
+		if (bcmerror)
 			break;
 
 		if (val & 1) {
@@ -3491,12 +3485,12 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			break;
 		}
 
-		wlc_write_shm(wlc, (uint16) val,
-			      (uint16) (val >> NBITS(uint16)));
+		wlc_write_shm(wlc, (u16) val,
+			      (u16) (val >> NBITS(u16)));
 		break;
 
 	case WLC_R_REG:	/* MAC registers */
-		ta_ok = TRUE;
+		ta_ok = true;
 		r = (rw_reg_t *) arg;
 		band = WLC_BAND_AUTO;
 
@@ -3509,29 +3503,30 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			band = r->band;
 
 		/* bcmerror checking */
-		if ((bcmerror = wlc_iocregchk(wlc, band)))
+		bcmerror = wlc_iocregchk(wlc, band);
+		if (bcmerror)
 			break;
 
 		if ((r->byteoff + r->size) > sizeof(d11regs_t)) {
 			bcmerror = BCME_BADADDR;
 			break;
 		}
-		if (r->size == sizeof(uint32))
+		if (r->size == sizeof(u32))
 			r->val =
 			    R_REG(osh,
-				  (uint32 *) ((uchar *) (uintptr) regs +
+				  (u32 *)((unsigned char *)(unsigned long)regs +
 					      r->byteoff));
-		else if (r->size == sizeof(uint16))
+		else if (r->size == sizeof(u16))
 			r->val =
 			    R_REG(osh,
-				  (uint16 *) ((uchar *) (uintptr) regs +
+				  (u16 *)((unsigned char *)(unsigned long)regs +
 					      r->byteoff));
 		else
 			bcmerror = BCME_BADADDR;
 		break;
 
 	case WLC_W_REG:
-		ta_ok = TRUE;
+		ta_ok = true;
 		r = (rw_reg_t *) arg;
 		band = WLC_BAND_AUTO;
 
@@ -3544,20 +3539,21 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			band = r->band;
 
 		/* bcmerror checking */
-		if ((bcmerror = wlc_iocregchk(wlc, band)))
+		bcmerror = wlc_iocregchk(wlc, band);
+		if (bcmerror)
 			break;
 
 		if (r->byteoff + r->size > sizeof(d11regs_t)) {
 			bcmerror = BCME_BADADDR;
 			break;
 		}
-		if (r->size == sizeof(uint32))
+		if (r->size == sizeof(u32))
 			W_REG(osh,
-			      (uint32 *) ((uchar *) (uintptr) regs +
+			      (u32 *)((unsigned char *)(unsigned long) regs +
 					  r->byteoff), r->val);
-		else if (r->size == sizeof(uint16))
+		else if (r->size == sizeof(u16))
 			W_REG(osh,
-			      (uint16 *) ((uchar *) (uintptr) regs +
+			      (u16 *)((unsigned char *)(unsigned long) regs +
 					  r->byteoff), r->val);
 		else
 			bcmerror = BCME_BADADDR;
@@ -3569,11 +3565,11 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 		break;
 
 	case WLC_SET_TXANT:
-		bcmerror = wlc_stf_ant_txant_validate(wlc, (int8) val);
+		bcmerror = wlc_stf_ant_txant_validate(wlc, (s8) val);
 		if (bcmerror < 0)
 			break;
 
-		wlc->stf->txant = (int8) val;
+		wlc->stf->txant = (s8) val;
 
 		/* if down, we are done */
 		if (!wlc->pub->up)
@@ -3589,7 +3585,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 		break;
 
 	case WLC_GET_ANTDIV:{
-			uint8 phy_antdiv;
+			u8 phy_antdiv;
 
 			/* return configured value if core is down */
 			if (!wlc->pub->up) {
@@ -3615,12 +3611,12 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 		if (val == -1)
 			val = ANT_RX_DIV_DEF;
 
-		wlc->stf->ant_rx_ovr = (uint8) val;
-		wlc_phy_ant_rxdiv_set(wlc->band->pi, (uint8) val);
+		wlc->stf->ant_rx_ovr = (u8) val;
+		wlc_phy_ant_rxdiv_set(wlc->band->pi, (u8) val);
 		break;
 
 	case WLC_GET_RX_ANT:{	/* get latest used rx antenna */
-			uint16 rxstatus;
+			u16 rxstatus;
 
 			if (!wlc->pub->up) {
 				bcmerror = BCME_NOTUP;
@@ -3628,7 +3624,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			}
 
 			rxstatus = R_REG(wlc->osh, &wlc->regs->phyrxstatus0);
-			if (rxstatus == 0xdead || rxstatus == (uint16) - 1) {
+			if (rxstatus == 0xdead || rxstatus == (u16) -1) {
 				bcmerror = BCME_ERROR;
 				break;
 			}
@@ -3680,7 +3676,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 	case WLC_SET_SRL:
 		if (val >= 1 && val <= RETRY_SHORT_MAX) {
 			int ac;
-			wlc->SRL = (uint16) val;
+			wlc->SRL = (u16) val;
 
 			wlc_bmac_retrylimit_upd(wlc->hw, wlc->SRL, wlc->LRL);
 
@@ -3699,7 +3695,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 	case WLC_SET_LRL:
 		if (val >= 1 && val <= 255) {
 			int ac;
-			wlc->LRL = (uint16) val;
+			wlc->LRL = (u16) val;
 
 			wlc_bmac_retrylimit_upd(wlc->hw, wlc->SRL, wlc->LRL);
 
@@ -3722,7 +3718,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 		}
 
 		if (val >= 1 && val <= 255) {
-			wlc_set_cwmin(wlc, (uint16) val);
+			wlc_set_cwmin(wlc, (u16) val);
 		} else
 			bcmerror = BCME_RANGE;
 		break;
@@ -3738,7 +3734,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 		}
 
 		if (val >= 255 && val <= 2047) {
-			wlc_set_cwmax(wlc, (uint16) val);
+			wlc_set_cwmax(wlc, (u16) val);
 		} else
 			bcmerror = BCME_RANGE;
 		break;
@@ -3750,7 +3746,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 	case WLC_SET_RADIO:{	/* 32 bits input, higher 16 bits are mask, lower 16 bits are value to
 				 * set
 				 */
-			uint16 radiomask, radioval;
+			u16 radiomask, radioval;
 			uint validbits =
 			    WL_RADIO_SW_DISABLE | WL_RADIO_HW_DISABLE;
 			mbool new = 0;
@@ -3832,11 +3828,12 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			 * The format is 8 bytes, with least significant in seq[0].
 			 */
 
+			key = WSEC_KEY(wlc, val);
 			if ((val >= 0) && (val < WLC_MAX_WSEC_KEYS(wlc)) &&
-			    (key = WSEC_KEY(wlc, val)) != NULL) {
-				uint8 seq[DOT11_WPA_KEY_RSC_LEN];
-				uint16 lo;
-				uint32 hi;
+				(key != NULL)) {
+				u8 seq[DOT11_WPA_KEY_RSC_LEN];
+				u16 lo;
+				u32 hi;
 				/* group keys in WPA-NONE (IBSS only, AES and TKIP) use a global TXIV */
 				if ((bsscfg->WPA_auth & WPA_AUTH_NONE)
 				    && ETHER_ISNULLADDR(&key->ea)) {
@@ -3889,7 +3886,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			wl_rateset_t *ret_rs = (wl_rateset_t *) arg;
 
 			bzero(&rs, sizeof(wlc_rateset_t));
-			wlc_default_rateset(wlc, (wlc_rateset_t *) & rs);
+			wlc_default_rateset(wlc, (wlc_rateset_t *) &rs);
 
 			if (len < (int)(rs.count + sizeof(rs.count))) {
 				bcmerror = BCME_BUFTOOSHORT;
@@ -3951,7 +3948,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 		/* range [1, 0xffff] */
 		if (val >= DOT11_MIN_BEACON_PERIOD
 		    && val <= DOT11_MAX_BEACON_PERIOD) {
-			wlc->default_bss->beacon_period = (uint16) val;
+			wlc->default_bss->beacon_period = (u16) val;
 		} else
 			bcmerror = BCME_RANGE;
 		break;
@@ -3967,7 +3964,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 		/* range [1, 0xff] */
 		if (val >= DOT11_MIN_DTIM_PERIOD
 		    && val <= DOT11_MAX_DTIM_PERIOD) {
-			wlc->default_bss->dtim_period = (uint8) val;
+			wlc->default_bss->dtim_period = (u8) val;
 		} else
 			bcmerror = BCME_RANGE;
 		break;
@@ -3979,7 +3976,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 
 	case WLC_SET_PM:
 		if ((val >= PM_OFF) && (val <= PM_MAX)) {
-			wlc->PM = (uint8) val;
+			wlc->PM = (u8) val;
 			if (wlc->pub->up) {
 			}
 			/* Change watchdog driver to align watchdog with tbtt if possible */
@@ -4005,7 +4002,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			break;
 		}
 
-		wlc->wake = val ? TRUE : FALSE;
+		wlc->wake = val ? true : false;
 
 		/* if down, we're done */
 		if (!wlc->pub->up)
@@ -4033,7 +4030,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 		break;
 
 	case WLC_SET_ATIM:
-		wlc->default_bss->atim_window = (uint32) val;
+		wlc->default_bss->atim_window = (u32) val;
 		break;
 
 	case WLC_GET_PKTCNTS:{
@@ -4075,9 +4072,9 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 	case WLC_SET_WPA_AUTH:
 		/* change of WPA_Auth modifies the PS_ALLOWED state */
 		if (BSSCFG_STA(bsscfg)) {
-			bsscfg->WPA_auth = (uint16) val;
+			bsscfg->WPA_auth = (u16) val;
 		} else
-			bsscfg->WPA_auth = (uint16) val;
+			bsscfg->WPA_auth = (u16) val;
 		break;
 #endif				/* SUPPORT_HWKEY */
 
@@ -4095,7 +4092,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 
 	case WLC_GET_PHYLIST:
 		{
-			uchar *cp = arg;
+			unsigned char *cp = arg;
 			if (len < 3) {
 				bcmerror = BCME_BUFTOOSHORT;
 				break;
@@ -4127,7 +4124,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			break;
 		}
 
-		wlc->shortslot_override = (int8) val;
+		wlc->shortslot_override = (s8) val;
 
 		/* shortslot is an 11g feature, so no more work if we are
 		 * currently on the 5G band
@@ -4139,11 +4136,11 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			/* let watchdog or beacon processing update shortslot */
 		} else if (wlc->pub->up) {
 			/* unassociated shortslot is off */
-			wlc_switch_shortslot(wlc, FALSE);
+			wlc_switch_shortslot(wlc, false);
 		} else {
 			/* driver is down, so just update the wlc_info value */
 			if (wlc->shortslot_override == WLC_SHORTSLOT_AUTO) {
-				wlc->shortslot = FALSE;
+				wlc->shortslot = false;
 			} else {
 				wlc->shortslot =
 				    (wlc->shortslot_override ==
@@ -4165,7 +4162,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 
 		if (AP_ENAB(wlc->pub) && wlc->clk) {
 			wlc_update_beacon(wlc);
-			wlc_update_probe_resp(wlc, TRUE);
+			wlc_update_probe_resp(wlc, true);
 		}
 		break;
 
@@ -4178,7 +4175,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 
 	case WLC_SET_GMODE:
 		if (!wlc->pub->associated)
-			bcmerror = wlc_set_gmode(wlc, (uint8) val, TRUE);
+			bcmerror = wlc_set_gmode(wlc, (u8) val, true);
 		else {
 			bcmerror = BCME_ASSOCIATED;
 			break;
@@ -4201,7 +4198,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			break;
 		}
 
-		wlc_protection_upd(wlc, WLC_PROT_OVERLAP, (int8) val);
+		wlc_protection_upd(wlc, WLC_PROT_OVERLAP, (s8) val);
 
 		/* Current g_protection will sync up to the specified control alg in watchdog
 		 * if the driver is up and associated.
@@ -4220,7 +4217,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			break;
 		}
 
-		wlc_protection_upd(wlc, WLC_PROT_G_OVR, (int8) val);
+		wlc_protection_upd(wlc, WLC_PROT_G_OVR, (s8) val);
 
 		break;
 
@@ -4256,11 +4253,11 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			}
 
 			/* validate rateset by comparing pre and post sorted against 11g hw rates */
-			wlc_rateset_filter(&rs, &new, FALSE, WLC_RATES_CCK_OFDM,
+			wlc_rateset_filter(&rs, &new, false, WLC_RATES_CCK_OFDM,
 					   RATE_MASK, BSS_N_ENAB(wlc, bsscfg));
 			wlc_rate_hwrs_filter_sort_validate(&new,
 							   &cck_ofdm_rates,
-							   FALSE,
+							   false,
 							   wlc->stf->txstreams);
 			if (rs.count != new.count) {
 				bcmerror = BCME_BADRATESET;	/* invalid rateset */
@@ -4275,7 +4272,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			if (wlc->pub->up && AP_ENAB(wlc->pub)
 			    && wlc->pub->associated) {
 				wlc_update_beacon(wlc);
-				wlc_update_probe_resp(wlc, TRUE);
+				wlc_update_probe_resp(wlc, true);
 			}
 			break;
 		}
@@ -4310,15 +4307,16 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			bcmerror = BCME_RANGE;	/* bad value */
 			break;
 		}
-		wlc->prb_resp_timeout = (uint16) val;
+		wlc->prb_resp_timeout = (u16) val;
 		break;
 
 	case WLC_GET_KEY_PRIMARY:{
 			wsec_key_t *key;
 
 			/* treat the 'val' parm as the key id */
-			if ((key = WSEC_BSS_DEFAULT_KEY(bsscfg)) != NULL) {
-				*pval = key->id == val ? TRUE : FALSE;
+			key = WSEC_BSS_DEFAULT_KEY(bsscfg);
+			if (key != NULL) {
+				*pval = key->id == val ? true : false;
 			} else {
 				bcmerror = BCME_BADKEYIDX;
 			}
@@ -4332,11 +4330,10 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 
 			/* treat the 'val' parm as the key id */
 			for (i = 0; i < WSEC_MAX_DEFAULT_KEYS; i++) {
-				if ((key = bsscfg->bss_def_keys[i]) != NULL &&
-				    key->id == val) {
-					if ((old_key =
-					     WSEC_BSS_DEFAULT_KEY(bsscfg)) !=
-					    NULL)
+				key = bsscfg->bss_def_keys[i];
+				if (key != NULL && key->id == val) {
+					old_key = WSEC_BSS_DEFAULT_KEY(bsscfg);
+					if (old_key != NULL)
 						old_key->flags &=
 						    ~WSEC_PRIMARY_KEY;
 					key->flags |= WSEC_PRIMARY_KEY;
@@ -4359,7 +4356,8 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			/* validate the name value */
 			name = (char *)arg;
 			for (i = 0; i < (uint) len && *name != '\0';
-			     i++, name++) ;
+			     i++, name++)
+				;
 
 			if (i == (uint) len) {
 				bcmerror = BCME_BUFTOOSHORT;
@@ -4370,13 +4368,13 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 			if (cmd == WLC_GET_VAR) {
 				bcmerror =
 				    wlc_iovar_op(wlc, arg,
-						 (void *)((int8 *) arg + i),
+						 (void *)((s8 *) arg + i),
 						 len - i, arg, len, IOV_GET,
 						 wlcif);
 			} else
 				bcmerror =
 				    wlc_iovar_op(wlc, arg, NULL, 0,
-						 (void *)((int8 *) arg + i),
+						 (void *)((s8 *) arg + i),
 						 len - i, IOV_SET, wlcif);
 
 			break;
@@ -4417,32 +4415,32 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 		ASSERT(wlc_bmac_taclear(wlc->hw, ta_ok) || !ta_ok);
 #endif
 
-	return (bcmerror);
+	return bcmerror;
 }
 
 #if defined(BCMDBG)
 /* consolidated register access ioctl error checking */
-int wlc_iocregchk(wlc_info_t * wlc, uint band)
+int wlc_iocregchk(wlc_info_t *wlc, uint band)
 {
 	/* if band is specified, it must be the current band */
 	if ((band != WLC_BAND_AUTO) && (band != (uint) wlc->band->bandtype))
-		return (BCME_BADBAND);
+		return BCME_BADBAND;
 
 	/* if multiband and band is not specified, band must be locked */
 	if ((band == WLC_BAND_AUTO) && IS_MBAND_UNLOCKED(wlc))
-		return (BCME_NOTBANDLOCKED);
+		return BCME_NOTBANDLOCKED;
 
 	/* must have core clocks */
 	if (!wlc->clk)
-		return (BCME_NOCLK);
+		return BCME_NOCLK;
 
-	return (0);
+	return 0;
 }
 #endif				/* defined(BCMDBG) */
 
 #if defined(BCMDBG)
 /* For some ioctls, make sure that the pi pointer matches the current phy */
-int wlc_iocpichk(wlc_info_t * wlc, uint phytype)
+int wlc_iocpichk(wlc_info_t *wlc, uint phytype)
 {
 	if (wlc->band->phytype != phytype)
 		return BCME_BADBAND;
@@ -4451,7 +4449,7 @@ int wlc_iocpichk(wlc_info_t * wlc, uint phytype)
 #endif
 
 /* Look up the given var name in the given table */
-static const bcm_iovar_t *wlc_iovar_lookup(const bcm_iovar_t * table,
+static const bcm_iovar_t *wlc_iovar_lookup(const bcm_iovar_t *table,
 					   const char *name)
 {
 	const bcm_iovar_t *vi;
@@ -4476,21 +4474,21 @@ static const bcm_iovar_t *wlc_iovar_lookup(const bcm_iovar_t * table,
 }
 
 /* simplified integer get interface for common WLC_GET_VAR ioctl handler */
-int wlc_iovar_getint(wlc_info_t * wlc, const char *name, int *arg)
+int wlc_iovar_getint(wlc_info_t *wlc, const char *name, int *arg)
 {
-	return wlc_iovar_op(wlc, name, NULL, 0, arg, sizeof(int32), IOV_GET,
+	return wlc_iovar_op(wlc, name, NULL, 0, arg, sizeof(s32), IOV_GET,
 			    NULL);
 }
 
 /* simplified integer set interface for common WLC_SET_VAR ioctl handler */
-int wlc_iovar_setint(wlc_info_t * wlc, const char *name, int arg)
+int wlc_iovar_setint(wlc_info_t *wlc, const char *name, int arg)
 {
 	return wlc_iovar_op(wlc, name, NULL, 0, (void *)&arg, sizeof(arg),
 			    IOV_SET, NULL);
 }
 
-/* simplified int8 get interface for common WLC_GET_VAR ioctl handler */
-int wlc_iovar_getint8(wlc_info_t * wlc, const char *name, int8 * arg)
+/* simplified s8 get interface for common WLC_GET_VAR ioctl handler */
+int wlc_iovar_gets8(wlc_info_t *wlc, const char *name, s8 *arg)
 {
 	int iovar_int;
 	int err;
@@ -4499,7 +4497,7 @@ int wlc_iovar_getint8(wlc_info_t * wlc, const char *name, int8 * arg)
 	    wlc_iovar_op(wlc, name, NULL, 0, &iovar_int, sizeof(iovar_int),
 			 IOV_GET, NULL);
 	if (!err)
-		*arg = (int8) iovar_int;
+		*arg = (s8) iovar_int;
 
 	return err;
 }
@@ -4509,10 +4507,10 @@ int wlc_iovar_getint8(wlc_info_t * wlc, const char *name, int8 * arg)
  * calling function must keep 'iovars' until wlc_module_unregister is called.
  * 'iovar' must have the last entry's name field being NULL as terminator.
  */
-int
-BCMATTACHFN(wlc_module_register) (wlc_pub_t * pub, const bcm_iovar_t * iovars,
-				  const char *name, void *hdl, iovar_fn_t i_fn,
-				  watchdog_fn_t w_fn, down_fn_t d_fn) {
+int wlc_module_register(wlc_pub_t *pub, const bcm_iovar_t *iovars,
+			const char *name, void *hdl, iovar_fn_t i_fn,
+			watchdog_fn_t w_fn, down_fn_t d_fn)
+{
 	wlc_info_t *wlc = (wlc_info_t *) pub->wlc;
 	int i;
 
@@ -4539,9 +4537,8 @@ BCMATTACHFN(wlc_module_register) (wlc_pub_t * pub, const bcm_iovar_t * iovars,
 }
 
 /* unregister module callbacks */
-int
-BCMATTACHFN(wlc_module_unregister) (wlc_pub_t * pub, const char *name,
-				    void *hdl) {
+int wlc_module_unregister(wlc_pub_t *pub, const char *name, void *hdl)
+{
 	wlc_info_t *wlc = (wlc_info_t *) pub->wlc;
 	int i;
 
@@ -4563,7 +4560,7 @@ BCMATTACHFN(wlc_module_unregister) (wlc_pub_t * pub, const char *name,
 }
 
 /* Write WME tunable parameters for retransmit/max rate from wlc struct to ucode */
-static void wlc_wme_retries_write(wlc_info_t * wlc)
+static void wlc_wme_retries_write(wlc_info_t *wlc)
 {
 	int ac;
 
@@ -4585,14 +4582,14 @@ static void wlc_wme_retries_write(wlc_info_t * wlc)
  * All pointers may point into the same buffer.
  */
 int
-wlc_iovar_op(wlc_info_t * wlc, const char *name,
+wlc_iovar_op(wlc_info_t *wlc, const char *name,
 	     void *params, int p_len, void *arg, int len,
 	     bool set, struct wlc_if *wlcif)
 {
 	int err = 0;
 	int val_size;
 	const bcm_iovar_t *vi = NULL;
-	uint32 actionid;
+	u32 actionid;
 	int i;
 
 	ASSERT(name != NULL);
@@ -4608,7 +4605,7 @@ wlc_iovar_op(wlc_info_t * wlc, const char *name,
 	ASSERT(!set || (!params && !p_len));
 
 	if (!set && (len == sizeof(int)) &&
-	    !(ISALIGNED((uintptr) (arg), (uint) sizeof(int)))) {
+	    !(IS_ALIGNED((unsigned long)(arg), (uint) sizeof(int)))) {
 		WL_ERROR(("wl%d: %s unaligned get ptr for %s\n",
 			  wlc->pub->unit, __func__, name));
 		ASSERT(0);
@@ -4618,7 +4615,8 @@ wlc_iovar_op(wlc_info_t * wlc, const char *name,
 	for (i = 0; i < WLC_MAXMODULES; i++) {
 		if (!wlc->modulecb[i].iovars)
 			continue;
-		if ((vi = wlc_iovar_lookup(wlc->modulecb[i].iovars, name)))
+		vi = wlc_iovar_lookup(wlc->modulecb[i].iovars, name);
+		if (vi)
 			break;
 	}
 	/* iovar name not found */
@@ -4660,12 +4658,12 @@ wlc_iovar_op(wlc_info_t * wlc, const char *name,
 }
 
 int
-wlc_iovar_check(wlc_pub_t * pub, const bcm_iovar_t * vi, void *arg, int len,
+wlc_iovar_check(wlc_pub_t *pub, const bcm_iovar_t *vi, void *arg, int len,
 		bool set)
 {
 	wlc_info_t *wlc = (wlc_info_t *) pub->wlc;
 	int err = 0;
-	int32 int_val = 0;
+	s32 int_val = 0;
 
 	/* check generic condition flags */
 	if (set) {
@@ -4694,7 +4692,8 @@ wlc_iovar_check(wlc_pub_t * pub, const bcm_iovar_t * vi, void *arg, int len,
 		goto exit;
 
 	/* length check on io buf */
-	if ((err = bcm_iovar_lencheck(vi, arg, len, set)))
+	err = bcm_iovar_lencheck(vi, arg, len, set);
+	if (err)
 		goto exit;
 
 	/* On set, check value ranges for integer types */
@@ -4726,16 +4725,16 @@ wlc_iovar_check(wlc_pub_t * pub, const bcm_iovar_t * vi, void *arg, int len,
  * Please use params for additional qualifying parameters.
  */
 int
-wlc_doiovar(void *hdl, const bcm_iovar_t * vi, uint32 actionid,
+wlc_doiovar(void *hdl, const bcm_iovar_t *vi, u32 actionid,
 	    const char *name, void *params, uint p_len, void *arg, int len,
 	    int val_size, struct wlc_if *wlcif)
 {
 	wlc_info_t *wlc = hdl;
 	wlc_bsscfg_t *bsscfg;
 	int err = 0;
-	int32 int_val = 0;
-	int32 int_val2 = 0;
-	int32 *ret_int_ptr;
+	s32 int_val = 0;
+	s32 int_val2 = 0;
+	s32 *ret_int_ptr;
 	bool bool_val;
 	bool bool_val2;
 	wlc_bss_info_t *current_bss;
@@ -4745,8 +4744,8 @@ wlc_doiovar(void *hdl, const bcm_iovar_t * vi, uint32 actionid,
 	bsscfg = NULL;
 	current_bss = NULL;
 
-	if ((err =
-	     wlc_iovar_check(wlc->pub, vi, arg, len, IOV_ISSET(actionid))) != 0)
+	err = wlc_iovar_check(wlc->pub, vi, arg, len, IOV_ISSET(actionid));
+	if (err != 0)
 		return err;
 
 	/* convenience int and bool vals for first 8 bytes of buffer */
@@ -4754,14 +4753,14 @@ wlc_doiovar(void *hdl, const bcm_iovar_t * vi, uint32 actionid,
 		bcopy(params, &int_val, sizeof(int_val));
 
 	if (p_len >= (int)sizeof(int_val) * 2)
-		bcopy((void *)((uintptr) params + sizeof(int_val)), &int_val2,
+		bcopy((void *)((unsigned long)params + sizeof(int_val)), &int_val2,
 		      sizeof(int_val));
 
 	/* convenience int ptr for 4-byte gets (requires int aligned arg) */
-	ret_int_ptr = (int32 *) arg;
+	ret_int_ptr = (s32 *) arg;
 
-	bool_val = (int_val != 0) ? TRUE : FALSE;
-	bool_val2 = (int_val2 != 0) ? TRUE : FALSE;
+	bool_val = (int_val != 0) ? true : false;
+	bool_val2 = (int_val2 != 0) ? true : false;
 
 	WL_TRACE(("wl%d: %s: id %d\n", wlc->pub->unit, __func__,
 		  IOV_ID(actionid)));
@@ -4772,9 +4771,9 @@ wlc_doiovar(void *hdl, const bcm_iovar_t * vi, uint32 actionid,
 			uint qdbm;
 			bool override;
 
-			if ((err =
-			     wlc_phy_txpower_get(wlc->band->pi, &qdbm,
-						 &override)) != BCME_OK)
+			err = wlc_phy_txpower_get(wlc->band->pi, &qdbm,
+				&override);
+			if (err != BCME_OK)
 				return err;
 
 			/* Return qdbm units */
@@ -4789,21 +4788,20 @@ wlc_doiovar(void *hdl, const bcm_iovar_t * vi, uint32 actionid,
 		   not internal or test.
 		 */
 	case IOV_SVAL(IOV_QTXPOWER):{
-			uint8 qdbm;
+			u8 qdbm;
 			bool override;
 
 			/* Remove override bit and clip to max qdbm value */
-			qdbm =
-			    (uint8) MIN((int_val & ~WL_TXPWR_OVERRIDE), 0xff);
+			qdbm = (u8)min_t(u32, (int_val & ~WL_TXPWR_OVERRIDE), 0xff);
 			/* Extract override setting */
-			override = (int_val & WL_TXPWR_OVERRIDE) ? TRUE : FALSE;
+			override = (int_val & WL_TXPWR_OVERRIDE) ? true : false;
 			err =
 			    wlc_phy_txpower_set(wlc->band->pi, qdbm, override);
 			break;
 		}
 
 	case IOV_GVAL(IOV_MPC):
-		*ret_int_ptr = (int32) wlc->mpc;
+		*ret_int_ptr = (s32) wlc->mpc;
 		break;
 
 	case IOV_SVAL(IOV_MPC):
@@ -4817,7 +4815,7 @@ wlc_doiovar(void *hdl, const bcm_iovar_t * vi, uint32 actionid,
 		break;
 
 	case IOV_SVAL(IOV_BCN_LI_BCN):
-		wlc->bcn_li_bcn = (uint8) int_val;
+		wlc->bcn_li_bcn = (u8) int_val;
 		if (wlc->pub->up)
 			wlc_bcn_li_upd(wlc);
 		break;
@@ -4835,11 +4833,11 @@ wlc_doiovar(void *hdl, const bcm_iovar_t * vi, uint32 actionid,
 }
 
 static int
-wlc_iovar_rangecheck(wlc_info_t * wlc, uint32 val, const bcm_iovar_t * vi)
+wlc_iovar_rangecheck(wlc_info_t *wlc, u32 val, const bcm_iovar_t *vi)
 {
 	int err = 0;
-	uint32 min_val = 0;
-	uint32 max_val = 0;
+	u32 min_val = 0;
+	u32 max_val = 0;
 
 	/* Only ranged integers are checked */
 	switch (vi->type) {
@@ -4857,8 +4855,8 @@ wlc_iovar_rangecheck(wlc_info_t * wlc, uint32 val, const bcm_iovar_t * vi)
 		else if (vi->flags & IOVF_WHL)
 			min_val = 0;
 		/* Signed values are checked against max_val and min_val */
-		if ((int32) val < (int32) min_val
-		    || (int32) val > (int32) max_val)
+		if ((s32) val < (s32) min_val
+		    || (s32) val > (s32) max_val)
 			err = BCME_RANGE;
 		break;
 
@@ -4880,44 +4878,6 @@ wlc_iovar_rangecheck(wlc_info_t * wlc, uint32 val, const bcm_iovar_t * vi)
 	return err;
 }
 
-#if defined(BCMDBG)
-static const struct wlc_id_name_entry dot11_ie_names[] = {
-	{DOT11_MNG_SSID_ID, "SSID"},
-	{DOT11_MNG_RATES_ID, "Rates"},
-	{DOT11_MNG_FH_PARMS_ID, "FH Parms"},
-	{DOT11_MNG_DS_PARMS_ID, "DS Parms"},
-	{DOT11_MNG_CF_PARMS_ID, "CF Parms"},
-	{DOT11_MNG_TIM_ID, "TIM"},
-	{DOT11_MNG_IBSS_PARMS_ID, "IBSS Parms"},
-	{DOT11_MNG_COUNTRY_ID, "Country"},
-	{DOT11_MNG_HOPPING_PARMS_ID, "Hopping Parms"},
-	{DOT11_MNG_HOPPING_TABLE_ID, "Hopping Table"},
-	{DOT11_MNG_REQUEST_ID, "Request"},
-	{DOT11_MNG_QBSS_LOAD_ID, "QBSS LOAD"},
-	{DOT11_MNG_CHALLENGE_ID, "Challenge"},
-	{DOT11_MNG_PWR_CONSTRAINT_ID, "Pwr Constraint"},
-	{DOT11_MNG_PWR_CAP_ID, "Pwr Capability"},
-	{DOT11_MNG_TPC_REQUEST_ID, "TPC Request"},
-	{DOT11_MNG_TPC_REPORT_ID, "TPC Report"},
-	{DOT11_MNG_SUPP_CHANNELS_ID, "Supported Channels"},
-	{DOT11_MNG_CHANNEL_SWITCH_ID, "Channel Switch"},
-	{DOT11_MNG_MEASURE_REQUEST_ID, "Measure Request"},
-	{DOT11_MNG_MEASURE_REPORT_ID, "Measure Report"},
-	{DOT11_MNG_QUIET_ID, "Quiet"},
-	{DOT11_MNG_IBSS_DFS_ID, "IBSS DFS"},
-	{DOT11_MNG_ERP_ID, "ERP Info"},
-	{DOT11_MNG_TS_DELAY_ID, "TS Delay"},
-	{DOT11_MNG_HT_CAP, "HT Capability"},
-	{DOT11_MNG_NONERP_ID, "Legacy ERP Info"},
-	{DOT11_MNG_RSN_ID, "RSN"},
-	{DOT11_MNG_EXT_RATES_ID, "Ext Rates"},
-	{DOT11_MNG_HT_ADD, "HT Additional"},
-	{DOT11_MNG_EXT_CHANNEL_OFFSET, "Ext Channel Offset"},
-	{DOT11_MNG_VS_ID, "Vendor Specific"},
-	{0, NULL}
-};
-#endif				/* defined(BCMDBG) */
-
 #ifdef BCMDBG
 static const char *supr_reason[] = {
 	"None", "PMQ Entry", "Flush request",
@@ -4925,7 +4885,7 @@ static const char *supr_reason[] = {
 	"Lifetime Expiry", "Underflow"
 };
 
-static void wlc_print_txs_status(uint16 s)
+static void wlc_print_txs_status(u16 s)
 {
 	printf("[15:12]  %d  frame attempts\n", (s & TX_STATUS_FRM_RTX_MASK) >>
 	       TX_STATUS_FRM_RTX_SHIFT);
@@ -4943,11 +4903,11 @@ static void wlc_print_txs_status(uint16 s)
 }
 #endif				/* BCMDBG */
 
-void wlc_print_txstatus(tx_status_t * txs)
+void wlc_print_txstatus(tx_status_t *txs)
 {
 #if defined(BCMDBG)
-	uint16 s = txs->status;
-	uint16 ackphyrxsh = txs->ackphyrxsh;
+	u16 s = txs->status;
+	u16 ackphyrxsh = txs->ackphyrxsh;
 
 	printf("\ntxpkt (MPDU) Complete\n");
 
@@ -4970,13 +4930,13 @@ void wlc_print_txstatus(tx_status_t * txs)
 #define MACSTATUPD(name) \
 	wlc_ctrupd_cache(macstats.name, &wlc->core->macstat_snapshot->name, &wlc->pub->_cnt->name)
 
-void wlc_statsupd(wlc_info_t * wlc)
+void wlc_statsupd(wlc_info_t *wlc)
 {
 	int i;
 #ifdef BCMDBG
-	uint16 delta;
-	uint16 rxf0ovfl;
-	uint16 txfunfl[NFIFO];
+	u16 delta;
+	u16 rxf0ovfl;
+	u16 txfunfl[NFIFO];
 #endif				/* BCMDBG */
 
 	/* if driver down, make no sense to update stats */
@@ -4994,7 +4954,7 @@ void wlc_statsupd(wlc_info_t * wlc)
 
 #ifdef BCMDBG
 	/* check for rx fifo 0 overflow */
-	delta = (uint16) (wlc->core->macstat_snapshot->rxf0ovfl - rxf0ovfl);
+	delta = (u16) (wlc->core->macstat_snapshot->rxf0ovfl - rxf0ovfl);
 	if (delta)
 		WL_ERROR(("wl%d: %u rx fifo 0 overflows!\n", wlc->pub->unit,
 			  delta));
@@ -5002,7 +4962,7 @@ void wlc_statsupd(wlc_info_t * wlc)
 	/* check for tx fifo underflows */
 	for (i = 0; i < NFIFO; i++) {
 		delta =
-		    (uint16) (wlc->core->macstat_snapshot->txfunfl[i] -
+		    (u16) (wlc->core->macstat_snapshot->txfunfl[i] -
 			      txfunfl[i]);
 		if (delta)
 			WL_ERROR(("wl%d: %u tx fifo %d underflows!\n",
@@ -5052,285 +5012,61 @@ void wlc_statsupd(wlc_info_t * wlc)
 		WLCNTADD(wlc->pub->_cnt->rxerror, wlc->pub->_cnt->rxuflo[i]);
 }
 
-bool wlc_chipmatch(uint16 vendor, uint16 device)
+bool wlc_chipmatch(u16 vendor, u16 device)
 {
 	if (vendor != VENDOR_BROADCOM) {
 		WL_ERROR(("wlc_chipmatch: unknown vendor id %04x\n", vendor));
-		return (FALSE);
+		return false;
 	}
 
 	if ((device == BCM43224_D11N_ID) || (device == BCM43225_D11N2G_ID))
-		return (TRUE);
+		return true;
 
 	if (device == BCM4313_D11N2G_ID)
-		return (TRUE);
+		return true;
 	if ((device == BCM43236_D11N_ID) || (device == BCM43236_D11N2G_ID))
-		return (TRUE);
+		return true;
 
 	WL_ERROR(("wlc_chipmatch: unknown device id %04x\n", device));
-	return (FALSE);
-}
-
-#if defined(BCMDBG)
-static const char *errstr = "802.11 Header INCOMPLETE\n";
-static const char *fillstr = "------------";
-static void wlc_print_dot11hdr(uint8 * buf, int len)
-{
-	char hexbuf[(2 * D11B_PHY_HDR_LEN) + 1];
-
-	if (len == 0) {
-		printf("802.11 Header MISSING\n");
-		return;
-	}
-
-	if (len < D11B_PHY_HDR_LEN) {
-		bcm_format_hex(hexbuf, buf, len);
-		strncpy(hexbuf + (2 * len), fillstr,
-			2 * (D11B_PHY_HDR_LEN - len));
-		hexbuf[sizeof(hexbuf) - 1] = '\0';
-	} else {
-		bcm_format_hex(hexbuf, buf, D11B_PHY_HDR_LEN);
-	}
-
-	printf("PLCPHdr: %s ", hexbuf);
-	if (len < D11B_PHY_HDR_LEN) {
-		printf("%s\n", errstr);
-		return;
-	}
-
-	len -= D11B_PHY_HDR_LEN;
-	buf += D11B_PHY_HDR_LEN;
-
-	wlc_print_dot11_mac_hdr(buf, len);
-}
-
-void wlc_print_dot11_mac_hdr(uint8 * buf, int len)
-{
-	char hexbuf[(2 * D11B_PHY_HDR_LEN) + 1];
-	char a1[(2 * ETHER_ADDR_LEN) + 1], a2[(2 * ETHER_ADDR_LEN) + 1];
-	char a3[(2 * ETHER_ADDR_LEN) + 1];
-	char flagstr[64];
-	uint16 fc, kind, toDS, fromDS;
-	uint16 v;
-	int fill_len = 0;
-	static const bcm_bit_desc_t fc_flags[] = {
-		{FC_TODS, "ToDS"},
-		{FC_FROMDS, "FromDS"},
-		{FC_MOREFRAG, "MoreFrag"},
-		{FC_RETRY, "Retry"},
-		{FC_PM, "PM"},
-		{FC_MOREDATA, "MoreData"},
-		{FC_WEP, "WEP"},
-		{FC_ORDER, "Order"},
-		{0, NULL}
-	};
-
-	if (len < 2) {
-		printf("FC: ------ ");
-		printf("%s\n", errstr);
-		return;
-	}
-
-	fc = buf[0] | (buf[1] << 8);
-	kind = fc & FC_KIND_MASK;
-	toDS = (fc & FC_TODS) != 0;
-	fromDS = (fc & FC_FROMDS) != 0;
-
-	bcm_format_flags(fc_flags, fc, flagstr, 64);
-
-	printf("FC: 0x%04x ", fc);
-	if (flagstr[0] != '\0')
-		printf("(%s) ", flagstr);
-
-	len -= 2;
-	buf += 2;
-
-	if (len < 2) {
-		printf("Dur/AID: ----- ");
-		printf("%s\n", errstr);
-		return;
-	}
-
-	v = buf[0] | (buf[1] << 8);
-	if (kind == FC_PS_POLL) {
-		printf("AID: 0x%04x", v);
-	} else {
-		printf("Dur: 0x%04x", v);
-	}
-	printf("\n");
-	len -= 2;
-	buf += 2;
-
-	strncpy(a1, fillstr, sizeof(a1));
-	strncpy(a2, fillstr, sizeof(a2));
-	strncpy(a3, fillstr, sizeof(a3));
-
-	if (len < ETHER_ADDR_LEN) {
-		bcm_format_hex(a1, buf, len);
-		strncpy(a1 + (2 * len), fillstr, 2 * (ETHER_ADDR_LEN - len));
-	} else if (len < 2 * ETHER_ADDR_LEN) {
-		bcm_format_hex(a1, buf, ETHER_ADDR_LEN);
-		bcm_format_hex(a2, buf + ETHER_ADDR_LEN, len - ETHER_ADDR_LEN);
-		fill_len = len - ETHER_ADDR_LEN;
-		strncpy(a2 + (2 * fill_len), fillstr,
-			2 * (ETHER_ADDR_LEN - fill_len));
-	} else if (len < 3 * ETHER_ADDR_LEN) {
-		bcm_format_hex(a1, buf, ETHER_ADDR_LEN);
-		bcm_format_hex(a2, buf + ETHER_ADDR_LEN, ETHER_ADDR_LEN);
-		bcm_format_hex(a3, buf + (2 * ETHER_ADDR_LEN),
-			       len - (2 * ETHER_ADDR_LEN));
-		fill_len = len - (2 * ETHER_ADDR_LEN);
-		strncpy(a3 + (2 * fill_len), fillstr,
-			2 * (ETHER_ADDR_LEN - fill_len));
-	} else {
-		bcm_format_hex(a1, buf, ETHER_ADDR_LEN);
-		bcm_format_hex(a2, buf + ETHER_ADDR_LEN, ETHER_ADDR_LEN);
-		bcm_format_hex(a3, buf + (2 * ETHER_ADDR_LEN), ETHER_ADDR_LEN);
-	}
-
-	if (kind == FC_RTS) {
-		printf("RA: %s ", a1);
-		printf("TA: %s ", a2);
-		if (len < 2 * ETHER_ADDR_LEN)
-			printf("%s ", errstr);
-	} else if (kind == FC_CTS || kind == FC_ACK) {
-		printf("RA: %s ", a1);
-		if (len < ETHER_ADDR_LEN)
-			printf("%s ", errstr);
-	} else if (kind == FC_PS_POLL) {
-		printf("BSSID: %s", a1);
-		printf("TA: %s ", a2);
-		if (len < 2 * ETHER_ADDR_LEN)
-			printf("%s ", errstr);
-	} else if (kind == FC_CF_END || kind == FC_CF_END_ACK) {
-		printf("RA: %s ", a1);
-		printf("BSSID: %s ", a2);
-		if (len < 2 * ETHER_ADDR_LEN)
-			printf("%s ", errstr);
-	} else if (FC_TYPE(fc) == FC_TYPE_DATA) {
-		if (!toDS) {
-			printf("DA: %s ", a1);
-			if (!fromDS) {
-				printf("SA: %s ", a2);
-				printf("BSSID: %s ", a3);
-			} else {
-				printf("BSSID: %s ", a2);
-				printf("SA: %s ", a3);
-			}
-		} else if (!fromDS) {
-			printf("BSSID: %s ", a1);
-			printf("SA: %s ", a2);
-			printf("DA: %s ", a3);
-		} else {
-			printf("RA: %s ", a1);
-			printf("TA: %s ", a2);
-			printf("DA: %s ", a3);
-		}
-		if (len < 3 * ETHER_ADDR_LEN) {
-			printf("%s ", errstr);
-		} else if (len < 20) {
-			printf("SeqCtl: ------ ");
-			printf("%s ", errstr);
-		} else {
-			len -= 3 * ETHER_ADDR_LEN;
-			buf += 3 * ETHER_ADDR_LEN;
-			v = buf[0] | (buf[1] << 8);
-			printf("SeqCtl: 0x%04x ", v);
-			len -= 2;
-			buf += 2;
-		}
-	} else if (FC_TYPE(fc) == FC_TYPE_MNG) {
-		printf("DA: %s ", a1);
-		printf("SA: %s ", a2);
-		printf("BSSID: %s ", a3);
-		if (len < 3 * ETHER_ADDR_LEN) {
-			printf("%s ", errstr);
-		} else if (len < 20) {
-			printf("SeqCtl: ------ ");
-			printf("%s ", errstr);
-		} else {
-			len -= 3 * ETHER_ADDR_LEN;
-			buf += 3 * ETHER_ADDR_LEN;
-			v = buf[0] | (buf[1] << 8);
-			printf("SeqCtl: 0x%04x ", v);
-			len -= 2;
-			buf += 2;
-		}
-	}
-
-	if ((FC_TYPE(fc) == FC_TYPE_DATA) && toDS && fromDS) {
-
-		if (len < ETHER_ADDR_LEN) {
-			bcm_format_hex(hexbuf, buf, len);
-			strncpy(hexbuf + (2 * len), fillstr,
-				2 * (ETHER_ADDR_LEN - len));
-		} else {
-			bcm_format_hex(hexbuf, buf, ETHER_ADDR_LEN);
-		}
-
-		printf("SA: %s ", hexbuf);
-
-		if (len < ETHER_ADDR_LEN) {
-			printf("%s ", errstr);
-		} else {
-			len -= ETHER_ADDR_LEN;
-			buf += ETHER_ADDR_LEN;
-		}
-	}
-
-	if ((FC_TYPE(fc) == FC_TYPE_DATA) && (kind == FC_QOS_DATA)) {
-		if (len < 2) {
-			printf("QoS: ------");
-			printf("%s ", errstr);
-		} else {
-			v = buf[0] | (buf[1] << 8);
-			printf("QoS: 0x%04x ", v);
-			len -= 2;
-			buf += 2;
-		}
-	}
-
-	printf("\n");
-	return;
+	return false;
 }
-#endif				/* defined(BCMDBG) */
 
 #if defined(BCMDBG)
-void wlc_print_txdesc(d11txh_t * txh)
-{
-	uint16 mtcl = ltoh16(txh->MacTxControlLow);
-	uint16 mtch = ltoh16(txh->MacTxControlHigh);
-	uint16 mfc = ltoh16(txh->MacFrameControl);
-	uint16 tfest = ltoh16(txh->TxFesTimeNormal);
-	uint16 ptcw = ltoh16(txh->PhyTxControlWord);
-	uint16 ptcw_1 = ltoh16(txh->PhyTxControlWord_1);
-	uint16 ptcw_1_Fbr = ltoh16(txh->PhyTxControlWord_1_Fbr);
-	uint16 ptcw_1_Rts = ltoh16(txh->PhyTxControlWord_1_Rts);
-	uint16 ptcw_1_FbrRts = ltoh16(txh->PhyTxControlWord_1_FbrRts);
-	uint16 mainrates = ltoh16(txh->MainRates);
-	uint16 xtraft = ltoh16(txh->XtraFrameTypes);
-	uint8 *iv = txh->IV;
-	uint8 *ra = txh->TxFrameRA;
-	uint16 tfestfb = ltoh16(txh->TxFesTimeFallback);
-	uint8 *rtspfb = txh->RTSPLCPFallback;
-	uint16 rtsdfb = ltoh16(txh->RTSDurFallback);
-	uint8 *fragpfb = txh->FragPLCPFallback;
-	uint16 fragdfb = ltoh16(txh->FragDurFallback);
-	uint16 mmodelen = ltoh16(txh->MModeLen);
-	uint16 mmodefbrlen = ltoh16(txh->MModeFbrLen);
-	uint16 tfid = ltoh16(txh->TxFrameID);
-	uint16 txs = ltoh16(txh->TxStatus);
-	uint16 mnmpdu = ltoh16(txh->MaxNMpdus);
-	uint16 mabyte = ltoh16(txh->MaxABytes_MRT);
-	uint16 mabyte_f = ltoh16(txh->MaxABytes_FBR);
-	uint16 mmbyte = ltoh16(txh->MinMBytes);
-
-	uint8 *rtsph = txh->RTSPhyHeader;
+void wlc_print_txdesc(d11txh_t *txh)
+{
+	u16 mtcl = ltoh16(txh->MacTxControlLow);
+	u16 mtch = ltoh16(txh->MacTxControlHigh);
+	u16 mfc = ltoh16(txh->MacFrameControl);
+	u16 tfest = ltoh16(txh->TxFesTimeNormal);
+	u16 ptcw = ltoh16(txh->PhyTxControlWord);
+	u16 ptcw_1 = ltoh16(txh->PhyTxControlWord_1);
+	u16 ptcw_1_Fbr = ltoh16(txh->PhyTxControlWord_1_Fbr);
+	u16 ptcw_1_Rts = ltoh16(txh->PhyTxControlWord_1_Rts);
+	u16 ptcw_1_FbrRts = ltoh16(txh->PhyTxControlWord_1_FbrRts);
+	u16 mainrates = ltoh16(txh->MainRates);
+	u16 xtraft = ltoh16(txh->XtraFrameTypes);
+	u8 *iv = txh->IV;
+	u8 *ra = txh->TxFrameRA;
+	u16 tfestfb = ltoh16(txh->TxFesTimeFallback);
+	u8 *rtspfb = txh->RTSPLCPFallback;
+	u16 rtsdfb = ltoh16(txh->RTSDurFallback);
+	u8 *fragpfb = txh->FragPLCPFallback;
+	u16 fragdfb = ltoh16(txh->FragDurFallback);
+	u16 mmodelen = ltoh16(txh->MModeLen);
+	u16 mmodefbrlen = ltoh16(txh->MModeFbrLen);
+	u16 tfid = ltoh16(txh->TxFrameID);
+	u16 txs = ltoh16(txh->TxStatus);
+	u16 mnmpdu = ltoh16(txh->MaxNMpdus);
+	u16 mabyte = ltoh16(txh->MaxABytes_MRT);
+	u16 mabyte_f = ltoh16(txh->MaxABytes_FBR);
+	u16 mmbyte = ltoh16(txh->MinMBytes);
+
+	u8 *rtsph = txh->RTSPhyHeader;
 	struct dot11_rts_frame rts = txh->rts_frame;
 	char hexbuf[256];
 
 	/* add plcp header along with txh descriptor */
-	prhex("Raw TxDesc + plcp header", (uchar *) txh, sizeof(d11txh_t) + 48);
+	prhex("Raw TxDesc + plcp header", (unsigned char *) txh, sizeof(d11txh_t) + 48);
 
 	printf("TxCtlLow: %04x ", mtcl);
 	printf("TxCtlHigh: %04x ", mtch);
@@ -5373,27 +5109,23 @@ void wlc_print_txdesc(d11txh_t * txh)
 
 	bcm_format_hex(hexbuf, rtsph, sizeof(txh->RTSPhyHeader));
 	printf("RTS PLCP: %s ", hexbuf);
-	bcm_format_hex(hexbuf, (uint8 *) & rts, sizeof(txh->rts_frame));
+	bcm_format_hex(hexbuf, (u8 *) &rts, sizeof(txh->rts_frame));
 	printf("RTS Frame: %s", hexbuf);
 	printf("\n");
 
-	if (mtcl & TXC_SENDRTS) {
-		wlc_print_dot11_mac_hdr((uint8 *) & rts,
-					sizeof(txh->rts_frame));
-	}
 }
 #endif				/* defined(BCMDBG) */
 
 #if defined(BCMDBG)
-void wlc_print_rxh(d11rxhdr_t * rxh)
-{
-	uint16 len = rxh->RxFrameSize;
-	uint16 phystatus_0 = rxh->PhyRxStatus_0;
-	uint16 phystatus_1 = rxh->PhyRxStatus_1;
-	uint16 phystatus_2 = rxh->PhyRxStatus_2;
-	uint16 phystatus_3 = rxh->PhyRxStatus_3;
-	uint16 macstatus1 = rxh->RxStatus1;
-	uint16 macstatus2 = rxh->RxStatus2;
+void wlc_print_rxh(d11rxhdr_t *rxh)
+{
+	u16 len = rxh->RxFrameSize;
+	u16 phystatus_0 = rxh->PhyRxStatus_0;
+	u16 phystatus_1 = rxh->PhyRxStatus_1;
+	u16 phystatus_2 = rxh->PhyRxStatus_2;
+	u16 phystatus_3 = rxh->PhyRxStatus_3;
+	u16 macstatus1 = rxh->RxStatus1;
+	u16 macstatus2 = rxh->RxStatus2;
 	char flagstr[64];
 	char lenbuf[20];
 	static const bcm_bit_desc_t macstat_flags[] = {
@@ -5406,7 +5138,7 @@ void wlc_print_rxh(d11rxhdr_t * rxh)
 		{0, NULL}
 	};
 
-	prhex("Raw RxDesc", (uchar *) rxh, sizeof(d11rxhdr_t));
+	prhex("Raw RxDesc", (unsigned char *) rxh, sizeof(d11rxhdr_t));
 
 	bcm_format_flags(macstat_flags, macstatus1, flagstr, 64);
 
@@ -5420,30 +5152,10 @@ void wlc_print_rxh(d11rxhdr_t * rxh)
 	printf("RXMACaggtype: %x\n", (macstatus2 & RXS_AGGTYPE_MASK));
 	printf("RxTSFTime:       %04x\n", rxh->RxTSFTime);
 }
-
-void
-wlc_print_hdrs(wlc_info_t * wlc, const char *prefix, uint8 * frame,
-	       d11txh_t * txh, d11rxhdr_t * rxh, uint len)
-{
-	ASSERT(!(txh && rxh));
-
-	printf("\nwl%d: %s:\n", wlc->pub->unit, prefix);
-
-	if (txh) {
-		wlc_print_txdesc(txh);
-	} else if (rxh) {
-		wlc_print_rxh(rxh);
-	}
-
-	if (len > 0) {
-		ASSERT(frame != NULL);
-		wlc_print_dot11hdr(frame, len);
-	}
-}
 #endif				/* defined(BCMDBG) */
 
 #if defined(BCMDBG)
-int wlc_format_ssid(char *buf, const uchar ssid[], uint ssid_len)
+int wlc_format_ssid(char *buf, const unsigned char ssid[], uint ssid_len)
 {
 	uint i, c;
 	char *p = buf;
@@ -5457,7 +5169,7 @@ int wlc_format_ssid(char *buf, const uchar ssid[], uint ssid_len)
 		if (c == '\\') {
 			*p++ = '\\';
 			*p++ = '\\';
-		} else if (bcm_isprint((uchar) c)) {
+		} else if (isprint((unsigned char) c)) {
 			*p++ = (char)c;
 		} else {
 			p += snprintf(p, (endp - p), "\\x%02X", c);
@@ -5470,9 +5182,9 @@ int wlc_format_ssid(char *buf, const uchar ssid[], uint ssid_len)
 }
 #endif				/* defined(BCMDBG) */
 
-uint16 wlc_rate_shm_offset(wlc_info_t * wlc, uint8 rate)
+u16 wlc_rate_shm_offset(wlc_info_t *wlc, u8 rate)
 {
-	return (wlc_bmac_rate_shm_offset(wlc->hw, rate));
+	return wlc_bmac_rate_shm_offset(wlc->hw, rate);
 }
 
 /* Callback for device removed */
@@ -5481,7 +5193,7 @@ void wlc_device_removed(void *arg)
 {
 	wlc_info_t *wlc = (wlc_info_t *) arg;
 
-	wlc->device_present = FALSE;
+	wlc->device_present = false;
 }
 #endif				/* WLC_HIGH_ONLY */
 
@@ -5492,16 +5204,16 @@ void wlc_device_removed(void *arg)
  * 'prec' is the precedence number that has already been mapped
  * from the packet priority.
  *
- * Returns TRUE if packet consumed (queued), FALSE if not.
+ * Returns true if packet consumed (queued), false if not.
  */
 bool BCMFASTPATH
-wlc_prec_enq(wlc_info_t * wlc, struct pktq *q, void *pkt, int prec)
+wlc_prec_enq(wlc_info_t *wlc, struct pktq *q, void *pkt, int prec)
 {
-	return wlc_prec_enq_head(wlc, q, pkt, prec, FALSE);
+	return wlc_prec_enq_head(wlc, q, pkt, prec, false);
 }
 
 bool BCMFASTPATH
-wlc_prec_enq_head(wlc_info_t * wlc, struct pktq * q, void *pkt, int prec,
+wlc_prec_enq_head(wlc_info_t *wlc, struct pktq *q, void *pkt, int prec,
 		  bool head)
 {
 	void *p;
@@ -5516,7 +5228,7 @@ wlc_prec_enq_head(wlc_info_t * wlc, struct pktq * q, void *pkt, int prec,
 		if (eprec > prec) {
 			WL_ERROR(("%s: Failing: eprec %d > prec %d\n", __func__,
 				  eprec, prec));
-			return FALSE;
+			return false;
 		}
 	}
 
@@ -5533,7 +5245,7 @@ wlc_prec_enq_head(wlc_info_t * wlc, struct pktq * q, void *pkt, int prec,
 		if (eprec == prec && !discard_oldest) {
 			WL_ERROR(("%s: No where to go, prec == %d\n", __func__,
 				  prec));
-			return FALSE;
+			return false;
 		}
 
 		/* Evict packet according to discard policy */
@@ -5551,7 +5263,7 @@ wlc_prec_enq_head(wlc_info_t * wlc, struct pktq * q, void *pkt, int prec,
 		}
 
 		ASSERT(0);
-		PKTFREE(wlc->osh, p, TRUE);
+		PKTFREE(wlc->osh, p, true);
 		WLCNTINCR(wlc->pub->_cnt->txnobuf);
 	}
 
@@ -5562,7 +5274,7 @@ wlc_prec_enq_head(wlc_info_t * wlc, struct pktq * q, void *pkt, int prec,
 		p = pktq_penq(q, prec, pkt);
 	ASSERT(p != NULL);
 
-	return TRUE;
+	return true;
 }
 
 void BCMFASTPATH wlc_txq_enq(void *ctx, struct scb *scb, void *sdu, uint prec)
@@ -5583,7 +5295,7 @@ void BCMFASTPATH wlc_txq_enq(void *ctx, struct scb *scb, void *sdu, uint prec)
 				  wlc->pub->unit));
 
 		/* ASSERT(9 == 8); *//* XXX we might hit this condtion in case packet flooding from mac80211 stack */
-		PKTFREE(wlc->osh, sdu, TRUE);
+		PKTFREE(wlc->osh, sdu, true);
 		WLCNTINCR(wlc->pub->_cnt->txnobuf);
 	}
 
@@ -5605,14 +5317,14 @@ void BCMFASTPATH wlc_txq_enq(void *ctx, struct scb *scb, void *sdu, uint prec)
 }
 
 bool BCMFASTPATH
-wlc_sendpkt_mac80211(wlc_info_t * wlc, void *sdu, struct ieee80211_hw *hw)
+wlc_sendpkt_mac80211(wlc_info_t *wlc, void *sdu, struct ieee80211_hw *hw)
 {
-	uint8 prio;
+	u8 prio;
 	uint fifo;
 	void *pkt;
 	struct scb *scb = &global_scb;
 	struct dot11_header *d11_header = (struct dot11_header *)PKTDATA(sdu);
-	uint16 type, fc;
+	u16 type, fc;
 
 	ASSERT(sdu);
 
@@ -5640,11 +5352,11 @@ wlc_sendpkt_mac80211(wlc_info_t * wlc, void *sdu, struct ieee80211_hw *hw)
 	return 0;
 }
 
-void BCMFASTPATH wlc_send_q(wlc_info_t * wlc, wlc_txq_info_t * qi)
+void BCMFASTPATH wlc_send_q(wlc_info_t *wlc, wlc_txq_info_t *qi)
 {
 	void *pkt[DOT11_MAXNUMFRAGS];
 	int prec;
-	uint16 prec_map;
+	u16 prec_map;
 	int err = 0, i, count;
 	uint fifo;
 	struct pktq *q = &qi->q;
@@ -5657,7 +5369,7 @@ void BCMFASTPATH wlc_send_q(wlc_info_t * wlc, wlc_txq_info_t * qi)
 	if (in_send_q)
 		return;
 	else
-		in_send_q = TRUE;
+		in_send_q = true;
 
 	prec_map = wlc->tx_prec_map;
 
@@ -5673,7 +5385,7 @@ void BCMFASTPATH wlc_send_q(wlc_info_t * wlc, wlc_txq_info_t * qi)
 			err = wlc_prep_pdu(wlc, pkt[0], &fifo);
 			if (!err) {
 				for (i = 0; i < count; i++) {
-					wlc_txfifo(wlc, fifo, pkt[i], TRUE, 1);
+					wlc_txfifo(wlc, fifo, pkt[i], true, 1);
 				}
 			}
 		}
@@ -5706,7 +5418,7 @@ void BCMFASTPATH wlc_send_q(wlc_info_t * wlc, wlc_txq_info_t * qi)
 			}
 		}
 	}
-	in_send_q = FALSE;
+	in_send_q = false;
 }
 
 /*
@@ -5714,10 +5426,10 @@ void BCMFASTPATH wlc_send_q(wlc_info_t * wlc, wlc_txq_info_t * qi)
  * Generate frame ID for a BCMC packet.  The frag field is not used
  * for MC frames so is used as part of the sequence number.
  */
-static INLINE uint16
-bcmc_fid_generate(wlc_info_t * wlc, wlc_bsscfg_t * bsscfg, d11txh_t * txh)
+static inline u16
+bcmc_fid_generate(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, d11txh_t *txh)
 {
-	uint16 frameid;
+	u16 frameid;
 
 	frameid = ltoh16(txh->TxFrameID) & ~(TXFID_SEQ_MASK | TXFID_QUEUE_MASK);
 	frameid |=
@@ -5729,9 +5441,9 @@ bcmc_fid_generate(wlc_info_t * wlc, wlc_bsscfg_t * bsscfg, d11txh_t * txh)
 }
 
 void BCMFASTPATH
-wlc_txfifo(wlc_info_t * wlc, uint fifo, void *p, bool commit, int8 txpktpend)
+wlc_txfifo(wlc_info_t *wlc, uint fifo, void *p, bool commit, s8 txpktpend)
 {
-	uint16 frameid = INVALIDFID;
+	u16 frameid = INVALIDFID;
 	d11txh_t *txh;
 
 	ASSERT(fifo < NFIFO);
@@ -5746,7 +5458,7 @@ wlc_txfifo(wlc_info_t * wlc, uint fifo, void *p, bool commit, int8 txpktpend)
 	}
 
 	if (WLC_WAR16165(wlc))
-		wlc_war16165(wlc, TRUE);
+		wlc_war16165(wlc, true);
 
 #ifdef WLC_HIGH_ONLY
 	if (RPCTX_ENAB(wlc->pub)) {
@@ -5775,10 +5487,10 @@ wlc_txfifo(wlc_info_t * wlc, uint fifo, void *p, bool commit, int8 txpktpend)
 #endif				/* WLC_HIGH_ONLY */
 }
 
-static uint16
-wlc_compute_airtime(wlc_info_t * wlc, ratespec_t rspec, uint length)
+static u16
+wlc_compute_airtime(wlc_info_t *wlc, ratespec_t rspec, uint length)
 {
-	uint16 usec = 0;
+	u16 usec = 0;
 	uint mac_rate = RSPEC2RATE(rspec);
 	uint nsyms;
 
@@ -5794,8 +5506,8 @@ wlc_compute_airtime(wlc_info_t * wlc, ratespec_t rspec, uint length)
 		nsyms = CEIL((length * 8), (mac_rate * 2));
 
 		/* usec = symbols * usec/symbol */
-		usec = (uint16) (nsyms * APHY_SYMBOL_TIME);
-		return (usec);
+		usec = (u16) (nsyms * APHY_SYMBOL_TIME);
+		return usec;
 	} else {
 		switch (mac_rate) {
 		case WLC_RATE_1M:
@@ -5817,11 +5529,11 @@ wlc_compute_airtime(wlc_info_t * wlc, ratespec_t rspec, uint length)
 		}
 	}
 
-	return (usec);
+	return usec;
 }
 
 void BCMFASTPATH
-wlc_compute_plcp(wlc_info_t * wlc, ratespec_t rspec, uint length, uint8 * plcp)
+wlc_compute_plcp(wlc_info_t *wlc, ratespec_t rspec, uint length, u8 *plcp)
 {
 	if (IS_MCS(rspec)) {
 		wlc_compute_mimo_plcp(rspec, length, plcp);
@@ -5834,9 +5546,9 @@ wlc_compute_plcp(wlc_info_t * wlc, ratespec_t rspec, uint length, uint8 * plcp)
 }
 
 /* Rate: 802.11 rate code, length: PSDU length in octets */
-static void wlc_compute_mimo_plcp(ratespec_t rspec, uint length, uint8 * plcp)
+static void wlc_compute_mimo_plcp(ratespec_t rspec, uint length, u8 *plcp)
 {
-	uint8 mcs = (uint8) (rspec & RSPEC_RATE_MASK);
+	u8 mcs = (u8) (rspec & RSPEC_RATE_MASK);
 	ASSERT(IS_MCS(rspec));
 	plcp[0] = mcs;
 	if (RSPEC_IS40MHZ(rspec) || (mcs == 32))
@@ -5850,10 +5562,10 @@ static void wlc_compute_mimo_plcp(ratespec_t rspec, uint length, uint8 * plcp)
 
 /* Rate: 802.11 rate code, length: PSDU length in octets */
 static void BCMFASTPATH
-wlc_compute_ofdm_plcp(ratespec_t rspec, uint32 length, uint8 * plcp)
+wlc_compute_ofdm_plcp(ratespec_t rspec, u32 length, u8 *plcp)
 {
-	uint8 rate_signal;
-	uint32 tmp = 0;
+	u8 rate_signal;
+	u32 tmp = 0;
 	int rate = RSPEC2RATE(rspec);
 
 	ASSERT(IS_OFDM(rspec));
@@ -5880,10 +5592,10 @@ wlc_compute_ofdm_plcp(ratespec_t rspec, uint32 length, uint8 * plcp)
  * Broken out for PRQ.
  */
 
-static void wlc_cck_plcp_set(int rate_500, uint length, uint8 * plcp)
+static void wlc_cck_plcp_set(int rate_500, uint length, u8 *plcp)
 {
-	uint16 usec = 0;
-	uint8 le = 0;
+	u16 usec = 0;
+	u8 le = 0;
 
 	switch (rate_500) {
 	case WLC_RATE_1M:
@@ -5915,8 +5627,8 @@ static void wlc_cck_plcp_set(int rate_500, uint length, uint8 * plcp)
 	/* PLCP signal byte */
 	plcp[0] = rate_500 * 5;	/* r (500kbps) * 5 == r (100kbps) */
 	/* PLCP service byte */
-	plcp[1] = (uint8) (le | D11B_PLCP_SIGNAL_LOCKED);
-	/* PLCP length uint16, little endian */
+	plcp[1] = (u8) (le | D11B_PLCP_SIGNAL_LOCKED);
+	/* PLCP length u16, little endian */
 	plcp[2] = usec & 0xff;
 	plcp[3] = (usec >> 8) & 0xff;
 	/* PLCP CRC16 */
@@ -5925,7 +5637,7 @@ static void wlc_cck_plcp_set(int rate_500, uint length, uint8 * plcp)
 }
 
 /* Rate: 802.11 rate code, length: PSDU length in octets */
-static void wlc_compute_cck_plcp(ratespec_t rspec, uint length, uint8 * plcp)
+static void wlc_compute_cck_plcp(ratespec_t rspec, uint length, u8 *plcp)
 {
 	int rate = RSPEC2RATE(rspec);
 
@@ -5944,16 +5656,16 @@ static void wlc_compute_cck_plcp(ratespec_t rspec, uint length, uint8 * plcp)
  * next_frag_len	next MPDU length in bytes
  * preamble_type	use short/GF or long/MM PLCP header
  */
-static uint16 BCMFASTPATH
-wlc_compute_frame_dur(wlc_info_t * wlc, ratespec_t rate, uint8 preamble_type,
+static u16 BCMFASTPATH
+wlc_compute_frame_dur(wlc_info_t *wlc, ratespec_t rate, u8 preamble_type,
 		      uint next_frag_len)
 {
-	uint16 dur, sifs;
+	u16 dur, sifs;
 
 	sifs = SIFS(wlc->band);
 
 	dur = sifs;
-	dur += (uint16) wlc_calc_ack_time(wlc, rate, preamble_type);
+	dur += (u16) wlc_calc_ack_time(wlc, rate, preamble_type);
 
 	if (next_frag_len) {
 		/* Double the current DUR to get 2 SIFS + 2 ACKs */
@@ -5961,10 +5673,10 @@ wlc_compute_frame_dur(wlc_info_t * wlc, ratespec_t rate, uint8 preamble_type,
 		/* add another SIFS and the frag time */
 		dur += sifs;
 		dur +=
-		    (uint16) wlc_calc_frame_time(wlc, rate, preamble_type,
+		    (u16) wlc_calc_frame_time(wlc, rate, preamble_type,
 						 next_frag_len);
 	}
-	return (dur);
+	return dur;
 }
 
 /* wlc_compute_rtscts_dur()
@@ -5978,39 +5690,39 @@ wlc_compute_frame_dur(wlc_info_t * wlc, ratespec_t rate, uint8 preamble_type,
  * rate			next MPDU rate in unit of 500kbps
  * frame_len		next MPDU frame length in bytes
  */
-uint16 BCMFASTPATH
-wlc_compute_rtscts_dur(wlc_info_t * wlc, bool cts_only, ratespec_t rts_rate,
-		       ratespec_t frame_rate, uint8 rts_preamble_type,
-		       uint8 frame_preamble_type, uint frame_len, bool ba)
+u16 BCMFASTPATH
+wlc_compute_rtscts_dur(wlc_info_t *wlc, bool cts_only, ratespec_t rts_rate,
+		       ratespec_t frame_rate, u8 rts_preamble_type,
+		       u8 frame_preamble_type, uint frame_len, bool ba)
 {
-	uint16 dur, sifs;
+	u16 dur, sifs;
 
 	sifs = SIFS(wlc->band);
 
 	if (!cts_only) {	/* RTS/CTS */
 		dur = 3 * sifs;
 		dur +=
-		    (uint16) wlc_calc_cts_time(wlc, rts_rate,
+		    (u16) wlc_calc_cts_time(wlc, rts_rate,
 					       rts_preamble_type);
 	} else {		/* CTS-TO-SELF */
 		dur = 2 * sifs;
 	}
 
 	dur +=
-	    (uint16) wlc_calc_frame_time(wlc, frame_rate, frame_preamble_type,
+	    (u16) wlc_calc_frame_time(wlc, frame_rate, frame_preamble_type,
 					 frame_len);
 	if (ba)
 		dur +=
-		    (uint16) wlc_calc_ba_time(wlc, frame_rate,
+		    (u16) wlc_calc_ba_time(wlc, frame_rate,
 					      WLC_SHORT_PREAMBLE);
 	else
 		dur +=
-		    (uint16) wlc_calc_ack_time(wlc, frame_rate,
+		    (u16) wlc_calc_ack_time(wlc, frame_rate,
 					       frame_preamble_type);
-	return (dur);
+	return dur;
 }
 
-static bool wlc_phy_rspec_check(wlc_info_t * wlc, uint16 bw, ratespec_t rspec)
+static bool wlc_phy_rspec_check(wlc_info_t *wlc, u16 bw, ratespec_t rspec)
 {
 	if (IS_MCS(rspec)) {
 		uint mcs = rspec & RSPEC_RATE_MASK;
@@ -6033,13 +5745,13 @@ static bool wlc_phy_rspec_check(wlc_info_t * wlc, uint16 bw, ratespec_t rspec)
 		ASSERT(RSPEC_STF(rspec) == PHY_TXC1_MODE_SISO);
 	}
 
-	return TRUE;
+	return true;
 }
 
-uint16 BCMFASTPATH wlc_phytxctl1_calc(wlc_info_t * wlc, ratespec_t rspec)
+u16 BCMFASTPATH wlc_phytxctl1_calc(wlc_info_t *wlc, ratespec_t rspec)
 {
-	uint16 phyctl1 = 0;
-	uint16 bw;
+	u16 phyctl1 = 0;
+	u16 bw;
 
 	if (WLCISLCNPHY(wlc->band)) {
 		bw = PHY_TXC1_BW_20MHZ;
@@ -6068,9 +5780,10 @@ uint16 BCMFASTPATH wlc_phytxctl1_calc(wlc_info_t * wlc, ratespec_t rspec)
 		/* 0 = 1Mbps; 1 = 2Mbps; 2 = 5.5Mbps; 3 = 11Mbps */
 		phyctl1 = (bw | (RSPEC_STF(rspec) << PHY_TXC1_MODE_SHIFT));
 	} else {		/* legacy OFDM/CCK */
-		int16 phycfg;
+		s16 phycfg;
 		/* get the phyctl byte from rate phycfg table */
-		if ((phycfg = wlc_rate_legacy_phyctl(RSPEC2RATE(rspec))) == -1) {
+		phycfg = wlc_rate_legacy_phyctl(RSPEC2RATE(rspec));
+		if (phycfg == -1) {
 			WL_ERROR(("wlc_phytxctl1_calc: wrong legacy OFDM/CCK rate\n"));
 			ASSERT(0);
 			phycfg = 0;
@@ -6094,8 +5807,8 @@ uint16 BCMFASTPATH wlc_phytxctl1_calc(wlc_info_t * wlc, ratespec_t rspec)
 }
 
 ratespec_t BCMFASTPATH
-wlc_rspec_to_rts_rspec(wlc_info_t * wlc, ratespec_t rspec, bool use_rspec,
-		       uint16 mimo_ctlchbw)
+wlc_rspec_to_rts_rspec(wlc_info_t *wlc, ratespec_t rspec, bool use_rspec,
+		       u16 mimo_ctlchbw)
 {
 	ratespec_t rts_rspec = 0;
 
@@ -6149,47 +5862,47 @@ wlc_rspec_to_rts_rspec(wlc_info_t * wlc, ratespec_t rspec, bool use_rspec,
  * headroom == D11_PHY_HDR_LEN + D11_TXH_LEN (D11_TXH_LEN is now 104 bytes)
  *
  */
-static uint16 BCMFASTPATH
-wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
+static u16 BCMFASTPATH
+wlc_d11hdrs_mac80211(wlc_info_t *wlc, struct ieee80211_hw *hw,
 		     void *p, struct scb *scb, uint frag,
 		     uint nfrags, uint queue, uint next_frag_len,
-		     wsec_key_t * key, ratespec_t rspec_override)
+		     wsec_key_t *key, ratespec_t rspec_override)
 {
 	struct dot11_header *h;
 	d11txh_t *txh;
-	uint8 *plcp, plcp_fallback[D11_PHY_HDR_LEN];
+	u8 *plcp, plcp_fallback[D11_PHY_HDR_LEN];
 	osl_t *osh;
 	int len, phylen, rts_phylen;
-	uint16 fc, type, frameid, mch, phyctl, xfts, mainrates;
-	uint16 seq = 0, mcl = 0, status = 0;
+	u16 fc, type, frameid, mch, phyctl, xfts, mainrates;
+	u16 seq = 0, mcl = 0, status = 0;
 	ratespec_t rspec[2] = { WLC_RATE_1M, WLC_RATE_1M }, rts_rspec[2] = {
 	WLC_RATE_1M, WLC_RATE_1M};
-	bool use_rts = FALSE;
-	bool use_cts = FALSE;
-	bool use_rifs = FALSE;
-	bool short_preamble[2] = { FALSE, FALSE };
-	uint8 preamble_type[2] = { WLC_LONG_PREAMBLE, WLC_LONG_PREAMBLE };
-	uint8 rts_preamble_type[2] = { WLC_LONG_PREAMBLE, WLC_LONG_PREAMBLE };
-	uint8 *rts_plcp, rts_plcp_fallback[D11_PHY_HDR_LEN];
+	bool use_rts = false;
+	bool use_cts = false;
+	bool use_rifs = false;
+	bool short_preamble[2] = { false, false };
+	u8 preamble_type[2] = { WLC_LONG_PREAMBLE, WLC_LONG_PREAMBLE };
+	u8 rts_preamble_type[2] = { WLC_LONG_PREAMBLE, WLC_LONG_PREAMBLE };
+	u8 *rts_plcp, rts_plcp_fallback[D11_PHY_HDR_LEN];
 	struct dot11_rts_frame *rts = NULL;
 	bool qos;
 	uint ac;
-	uint32 rate_val[2];
-	bool hwtkmic = FALSE;
-	uint16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;
+	u32 rate_val[2];
+	bool hwtkmic = false;
+	u16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;
 #ifdef WLANTSEL
 #define ANTCFG_NONE 0xFF
-	uint8 antcfg = ANTCFG_NONE;
-	uint8 fbantcfg = ANTCFG_NONE;
+	u8 antcfg = ANTCFG_NONE;
+	u8 fbantcfg = ANTCFG_NONE;
 #endif
 	uint phyctl1_stf = 0;
-	uint16 durid = 0;
+	u16 durid = 0;
 	struct ieee80211_tx_rate *txrate[2];
 	int k;
 	struct ieee80211_tx_info *tx_info;
 	bool is_mcs[2];
-	uint16 mimo_txbw;
-	uint8 mimo_preamble_type;
+	u16 mimo_txbw;
+	u8 mimo_preamble_type;
 
 	frameid = 0;
 
@@ -6278,7 +5991,7 @@ wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
 
 	for (k = 0; k < hw->max_rates; k++) {
 		is_mcs[k] =
-		    txrate[k]->flags & IEEE80211_TX_RC_MCS ? TRUE : FALSE;
+		    txrate[k]->flags & IEEE80211_TX_RC_MCS ? true : false;
 		if (!is_mcs[k]) {
 			ASSERT(!(tx_info->flags & IEEE80211_TX_CTL_AMPDU));
 			if ((txrate[k]->idx >= 0)
@@ -6290,7 +6003,7 @@ wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
 				short_preamble[k] =
 				    txrate[k]->
 				    flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE ?
-				    TRUE : FALSE;
+				    true : false;
 			} else {
 				ASSERT((txrate[k]->idx >= 0) &&
 				       (txrate[k]->idx <
@@ -6306,10 +6019,10 @@ wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
 		 */
 		use_rts |=
 		    txrate[k]->
-		    flags & IEEE80211_TX_RC_USE_RTS_CTS ? TRUE : FALSE;
+		    flags & IEEE80211_TX_RC_USE_RTS_CTS ? true : false;
 		use_cts |=
 		    txrate[k]->
-		    flags & IEEE80211_TX_RC_USE_CTS_PROTECT ? TRUE : FALSE;
+		    flags & IEEE80211_TX_RC_USE_CTS_PROTECT ? true : false;
 
 		if (is_mcs[k])
 			rate_val[k] |= NRATE_MCS_INUSE;
@@ -6323,7 +6036,7 @@ wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
 		} else {
 			if (WLANTSEL_ENAB(wlc) && !ETHER_ISMULTI(&h->a1)) {
 				/* set tx antenna config */
-				wlc_antsel_antcfg_get(wlc->asi, FALSE, FALSE, 0,
+				wlc_antsel_antcfg_get(wlc->asi, false, false, 0,
 						      0, &antcfg, &fbantcfg);
 			}
 		}
@@ -6344,7 +6057,7 @@ wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
 				/* For SISO MCS use STBC if possible */
 				if (IS_MCS(rspec[k])
 				    && WLC_STF_SS_STBC_TX(wlc, scb)) {
-					uint8 stc;
+					u8 stc;
 
 					ASSERT(WLC_STBC_CAP_PHY(wlc));
 					stc = 1;	/* Nss for single stream is always 1 */
@@ -6490,7 +6203,7 @@ wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
 	} else if (use_rifs) {
 		/* NAV protect to end of next max packet size */
 		durid =
-		    (uint16) wlc_calc_frame_time(wlc, rspec[0],
+		    (u16) wlc_calc_frame_time(wlc, rspec[0],
 						 preamble_type[0],
 						 DOT11_MAX_FRAG_LEN);
 		durid += RIFS_11N_TIME;
@@ -6540,7 +6253,7 @@ wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
 	}
 
 	/* MacFrameControl */
-	bcopy((char *)&h->fc, (char *)&txh->MacFrameControl, sizeof(uint16));
+	bcopy((char *)&h->fc, (char *)&txh->MacFrameControl, sizeof(u16));
 
 	txh->TxFesTimeNormal = htol16(0);
 
@@ -6572,11 +6285,11 @@ wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
 	/* RTS PLCP header and RTS frame */
 	if (use_rts || use_cts) {
 		if (use_rts && use_cts)
-			use_cts = FALSE;
+			use_cts = false;
 
 		for (k = 0; k < 2; k++) {
 			rts_rspec[k] = wlc_rspec_to_rts_rspec(wlc, rspec[k],
-							      FALSE,
+							      false,
 							      mimo_ctlchbw);
 		}
 
@@ -6603,7 +6316,7 @@ wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
 		}
 
 		/* RTS PLCP header */
-		ASSERT(ISALIGNED((uintptr) txh->RTSPhyHeader, sizeof(uint16)));
+		ASSERT(IS_ALIGNED((unsigned long)txh->RTSPhyHeader, sizeof(u16)));
 		rts_plcp = txh->RTSPhyHeader;
 		if (use_cts)
 			rts_phylen = DOT11_CTS_LEN + DOT11_FCS_LEN;
@@ -6623,20 +6336,20 @@ wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
 
 		durid = wlc_compute_rtscts_dur(wlc, use_cts, rts_rspec[0],
 					       rspec[0], rts_preamble_type[0],
-					       preamble_type[0], phylen, FALSE);
+					       preamble_type[0], phylen, false);
 		rts->durid = htol16(durid);
 		/* fallback rate version of RTS DUR field */
 		durid = wlc_compute_rtscts_dur(wlc, use_cts,
 					       rts_rspec[1], rspec[1],
 					       rts_preamble_type[1],
-					       preamble_type[1], phylen, FALSE);
+					       preamble_type[1], phylen, false);
 		txh->RTSDurFallback = htol16(durid);
 
 		if (use_cts) {
 			rts->fc = htol16(FC_CTS);
 			bcopy((char *)&h->a2, (char *)&rts->ra, ETHER_ADDR_LEN);
 		} else {
-			rts->fc = htol16((uint16) FC_RTS);
+			rts->fc = htol16((u16) FC_RTS);
 			bcopy((char *)&h->a1, (char *)&rts->ra,
 			      2 * ETHER_ADDR_LEN);
 		}
@@ -6695,7 +6408,7 @@ wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
 
 	/* PhyTxControlWord_1 */
 	if (WLC_PHY_11N_CAP(wlc->band)) {
-		uint16 phyctl1 = 0;
+		u16 phyctl1 = 0;
 
 		phyctl1 = wlc_phytxctl1_calc(wlc, rspec[0]);
 		txh->PhyTxControlWord_1 = htol16(phyctl1);
@@ -6715,13 +6428,13 @@ wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
 		 *  it will be unnecessary if they are separated
 		 */
 		if (IS_MCS(rspec[0]) && (preamble_type[0] == WLC_MM_PREAMBLE)) {
-			uint16 mmodelen =
+			u16 mmodelen =
 			    wlc_calc_lsig_len(wlc, rspec[0], phylen);
 			txh->MModeLen = htol16(mmodelen);
 		}
 
 		if (IS_MCS(rspec[1]) && (preamble_type[1] == WLC_MM_PREAMBLE)) {
-			uint16 mmodefbrlen =
+			u16 mmodefbrlen =
 			    wlc_calc_lsig_len(wlc, rspec[1], phylen);
 			txh->MModeFbrLen = htol16(mmodefbrlen);
 		}
@@ -6736,7 +6449,8 @@ wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
 	       ((preamble_type[1] == WLC_MM_PREAMBLE) ==
 		(txh->MModeFbrLen != 0)));
 
-	if (SCB_WME(scb) && qos && wlc->edcf_txop[(ac = wme_fifo2ac[queue])]) {
+	ac = wme_fifo2ac[queue];
+	if (SCB_WME(scb) && qos && wlc->edcf_txop[ac]) {
 		uint frag_dur, dur, dur_fallback;
 
 		ASSERT(!ETHER_ISMULTI(&h->a1));
@@ -6777,9 +6491,9 @@ wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
 							  preamble_type[1], 0);
 			}
 			/* NEED to set TxFesTimeNormal (hard) */
-			txh->TxFesTimeNormal = htol16((uint16) dur);
+			txh->TxFesTimeNormal = htol16((u16) dur);
 			/* NEED to set fallback rate version of TxFesTimeNormal (hard) */
-			txh->TxFesTimeFallback = htol16((uint16) dur_fallback);
+			txh->TxFesTimeFallback = htol16((u16) dur_fallback);
 
 			/* update txop byte threshold (txop minus intraframe overhead) */
 			if (wlc->edcf_txop[ac] >= (dur - frag_dur)) {
@@ -6803,9 +6517,9 @@ wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
 						    wlc->usr_fragthresh;
 					/* update the fragthresh and do txc update */
 					if (wlc->fragthresh[queue] !=
-					    (uint16) newfragthresh) {
+					    (u16) newfragthresh) {
 						wlc->fragthresh[queue] =
-						    (uint16) newfragthresh;
+						    (u16) newfragthresh;
 					}
 				}
 			} else
@@ -6821,7 +6535,7 @@ wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
 	return 0;
 }
 
-void wlc_tbtt(wlc_info_t * wlc, d11regs_t * regs)
+void wlc_tbtt(wlc_info_t *wlc, d11regs_t *regs)
 {
 	wlc_bsscfg_t *cfg = wlc->cfg;
 
@@ -6830,23 +6544,23 @@ void wlc_tbtt(wlc_info_t * wlc, d11regs_t * regs)
 	if (BSSCFG_STA(cfg)) {
 		/* run watchdog here if the watchdog timer is not armed */
 		if (WLC_WATCHDOG_TBTT(wlc)) {
-			uint32 cur, delta;
+			u32 cur, delta;
 			if (wlc->WDarmed) {
 				wl_del_timer(wlc->wl, wlc->wdtimer);
-				wlc->WDarmed = FALSE;
+				wlc->WDarmed = false;
 			}
 
 			cur = OSL_SYSUPTIME();
 			delta = cur > wlc->WDlast ? cur - wlc->WDlast :
-			    (uint32) ~ 0 - wlc->WDlast + cur + 1;
+			    (u32) ~0 - wlc->WDlast + cur + 1;
 			if (delta >= TIMER_INTERVAL_WATCHDOG) {
 				wlc_watchdog((void *)wlc);
 				wlc->WDlast = cur;
 			}
 
 			wl_add_timer(wlc->wl, wlc->wdtimer,
-				     wlc_watchdog_backup_bi(wlc), TRUE);
-			wlc->WDarmed = TRUE;
+				     wlc_watchdog_backup_bi(wlc), true);
+			wlc->WDarmed = true;
 		}
 	}
 
@@ -6857,19 +6571,19 @@ void wlc_tbtt(wlc_info_t * wlc, d11regs_t * regs)
 }
 
 /* GP timer is a freerunning 32 bit counter, decrements at 1 us rate */
-void wlc_hwtimer_gptimer_set(wlc_info_t * wlc, uint us)
+void wlc_hwtimer_gptimer_set(wlc_info_t *wlc, uint us)
 {
 	ASSERT(wlc->pub->corerev >= 3);	/* no gptimer in earlier revs */
 	W_REG(wlc->osh, &wlc->regs->gptimer, us);
 }
 
-void wlc_hwtimer_gptimer_abort(wlc_info_t * wlc)
+void wlc_hwtimer_gptimer_abort(wlc_info_t *wlc)
 {
 	ASSERT(wlc->pub->corerev >= 3);
 	W_REG(wlc->osh, &wlc->regs->gptimer, 0);
 }
 
-static void wlc_hwtimer_gptimer_cb(wlc_info_t * wlc)
+static void wlc_hwtimer_gptimer_cb(wlc_info_t *wlc)
 {
 	/* when interrupt is generated, the counter is loaded with last value
 	 * written and continue to decrement. So it has to be cleaned first
@@ -6882,7 +6596,7 @@ static void wlc_hwtimer_gptimer_cb(wlc_info_t * wlc)
  * POLICY: no macinstatus change, no bounding loop.
  *         All dpc bounding should be handled in BMAC dpc, like txstatus and rxint
  */
-void wlc_high_dpc(wlc_info_t * wlc, uint32 macintstatus)
+void wlc_high_dpc(wlc_info_t *wlc, u32 macintstatus)
 {
 	d11regs_t *regs = wlc->regs;
 #ifdef BCMDBG
@@ -6977,7 +6691,7 @@ void wlc_high_dpc(wlc_info_t * wlc, uint32 macintstatus)
 #endif
 }
 
-static void *wlc_15420war(wlc_info_t * wlc, uint queue)
+static void *wlc_15420war(wlc_info_t *wlc, uint queue)
 {
 	hnddma_t *di;
 	void *p;
@@ -6986,7 +6700,7 @@ static void *wlc_15420war(wlc_info_t * wlc, uint queue)
 
 	if ((D11REV_IS(wlc->pub->corerev, 4))
 	    || (D11REV_GT(wlc->pub->corerev, 6)))
-		return (NULL);
+		return NULL;
 
 	di = wlc->hw->di[queue];
 	ASSERT(di != NULL);
@@ -7004,10 +6718,10 @@ static void *wlc_15420war(wlc_info_t * wlc, uint queue)
 			WL_ERROR(("wl%d: %s: dma_txreset[%d]: cannot stop dma\n", wlc->pub->unit, __func__, queue));
 		dma_txinit(di);
 	}
-	return (p);
+	return p;
 }
 
-static void wlc_war16165(wlc_info_t * wlc, bool tx)
+static void wlc_war16165(wlc_info_t *wlc, bool tx)
 {
 	if (tx) {
 		/* the post-increment is used in STAY_AWAKE macro */
@@ -7023,7 +6737,7 @@ static void wlc_war16165(wlc_info_t * wlc, bool tx)
 /* process an individual tx_status_t */
 /* WLC_HIGH_API */
 bool BCMFASTPATH
-wlc_dotxstatus(wlc_info_t * wlc, tx_status_t * txs, uint32 frm_tx2)
+wlc_dotxstatus(wlc_info_t *wlc, tx_status_t *txs, u32 frm_tx2)
 {
 	void *p;
 	uint queue;
@@ -7035,8 +6749,8 @@ wlc_dotxstatus(wlc_info_t * wlc, tx_status_t * txs, uint32 frm_tx2)
 	uint totlen, supr_status;
 	bool lastframe;
 	struct dot11_header *h;
-	uint16 fc;
-	uint16 mcl;
+	u16 fc;
+	u16 mcl;
 	struct ieee80211_tx_info *tx_info;
 	struct ieee80211_tx_rate *txrate;
 	int i;
@@ -7055,7 +6769,7 @@ wlc_dotxstatus(wlc_info_t * wlc, tx_status_t * txs, uint32 frm_tx2)
 			   status & TX_STATUS_FRM_RTX_MASK) >>
 			  TX_STATUS_FRM_RTX_SHIFT));
 		WL_ERROR(("%s: INTERMEDIATE but not AMPDU\n", __func__));
-		return FALSE;
+		return false;
 	}
 
 	osh = wlc->osh;
@@ -7068,7 +6782,7 @@ wlc_dotxstatus(wlc_info_t * wlc, tx_status_t * txs, uint32 frm_tx2)
 
 	p = GETNEXTTXP(wlc, queue);
 	if (WLC_WAR16165(wlc))
-		wlc_war16165(wlc, FALSE);
+		wlc_war16165(wlc, false);
 	if (p == NULL)
 		p = wlc_15420war(wlc, queue);
 	ASSERT(p != NULL);
@@ -7090,13 +6804,13 @@ wlc_dotxstatus(wlc_info_t * wlc, tx_status_t * txs, uint32 frm_tx2)
 		goto fatal;
 
 	tx_info = IEEE80211_SKB_CB(p);
-	h = (struct dot11_header *)((uint8 *) (txh + 1) + D11_PHY_HDR_LEN);
+	h = (struct dot11_header *)((u8 *) (txh + 1) + D11_PHY_HDR_LEN);
 	fc = ltoh16(h->fc);
 
 	scb = (struct scb *)tx_info->control.sta->drv_priv;
 
 	if (N_ENAB(wlc->pub)) {
-		uint8 *plcp = (uint8 *) (txh + 1);
+		u8 *plcp = (u8 *) (txh + 1);
 		if (PLCP3_ISSGI(plcp[3]))
 			WLCNTINCR(wlc->pub->_cnt->txmpdu_sgi);
 		if (PLCP3_ISSTBC(plcp[3]))
@@ -7106,7 +6820,7 @@ wlc_dotxstatus(wlc_info_t * wlc, tx_status_t * txs, uint32 frm_tx2)
 	if (tx_info->flags & IEEE80211_TX_CTL_AMPDU) {
 		ASSERT((mcl & TXC_AMPDU_MASK) != TXC_AMPDU_NONE);
 		wlc_ampdu_dotxstatus(wlc->ampdu, scb, p, txs);
-		return FALSE;
+		return false;
 	}
 
 	supr_status = txs->status & TX_STATUS_SUPR_MASK;
@@ -7125,7 +6839,7 @@ wlc_dotxstatus(wlc_info_t * wlc, tx_status_t * txs, uint32 frm_tx2)
 	if (!lastframe) {
 		WL_ERROR(("Not last frame!\n"));
 	} else {
-		uint16 sfbl, lfbl;
+		u16 sfbl, lfbl;
 		ieee80211_tx_info_clear_status(tx_info);
 		if (queue < AC_COUNT) {
 			sfbl = WLC_WME_RETRY_SFB_GET(wlc, wme_fifo2ac[queue]);
@@ -7160,7 +6874,7 @@ wlc_dotxstatus(wlc_info_t * wlc, tx_status_t * txs, uint32 frm_tx2)
 	}
 
 	totlen = pkttotlen(osh, p);
-	free_pdu = TRUE;
+	free_pdu = true;
 
 	wlc_txfifo_complete(wlc, queue, 1);
 
@@ -7178,12 +6892,12 @@ wlc_dotxstatus(wlc_info_t * wlc, tx_status_t * txs, uint32 frm_tx2)
 			  __func__));
 	}
 
-	return FALSE;
+	return false;
 
  fatal:
 	ASSERT(0);
 	if (p)
-		PKTFREE(osh, p, TRUE);
+		PKTFREE(osh, p, true);
 
 #ifdef WLC_HIGH_ONLY
 	/* If this is a split driver, do the big-hammer here.
@@ -7191,12 +6905,12 @@ wlc_dotxstatus(wlc_info_t * wlc, tx_status_t * txs, uint32 frm_tx2)
 	 */
 	wl_init(wlc->wl);
 #endif
-	return TRUE;
+	return true;
 
 }
 
 void BCMFASTPATH
-wlc_txfifo_complete(wlc_info_t * wlc, uint fifo, int8 txpktpend)
+wlc_txfifo_complete(wlc_info_t *wlc, uint fifo, s8 txpktpend)
 {
 	TXPKTPENDDEC(wlc, fifo, txpktpend);
 	WL_TRACE(("wlc_txfifo_complete, pktpend dec %d to %d\n", txpktpend,
@@ -7214,7 +6928,7 @@ wlc_txfifo_complete(wlc_info_t * wlc, uint fifo, int8 txpktpend)
 	/* Clear MHF2_TXBCMC_NOW flag if BCMC fifo has drained */
 	if (AP_ENAB(wlc->pub) &&
 	    wlc->bcmcfifo_drain && !TXPKTPENDGET(wlc, TX_BCMC_FIFO)) {
-		wlc->bcmcfifo_drain = FALSE;
+		wlc->bcmcfifo_drain = false;
 		wlc_mhf(wlc, MHF2, MHF2_TXBCMC_NOW, 0, WLC_BAND_AUTO);
 	}
 
@@ -7224,9 +6938,9 @@ wlc_txfifo_complete(wlc_info_t * wlc, uint fifo, int8 txpktpend)
 /* Given the beacon interval in kus, and a 64 bit TSF in us,
  * return the offset (in us) of the TSF from the last TBTT
  */
-uint32 wlc_calc_tbtt_offset(uint32 bp, uint32 tsf_h, uint32 tsf_l)
+u32 wlc_calc_tbtt_offset(u32 bp, u32 tsf_h, u32 tsf_l)
 {
-	uint32 k, btklo, btkhi, offset;
+	u32 k, btklo, btkhi, offset;
 
 	/* TBTT is always an even multiple of the beacon_interval,
 	 * so the TBTT less than or equal to the beacon timestamp is
@@ -7241,14 +6955,14 @@ uint32 wlc_calc_tbtt_offset(uint32 bp, uint32 tsf_h, uint32 tsf_l)
 	 * BP = beacon interval (Kusec, 16bits)
 	 * BIu = BP * 2^10 = beacon interval (usec, 26bits)
 	 *
-	 * To keep the calculations in uint32s, the modulo operation
+	 * To keep the calculations in u32s, the modulo operation
 	 * on the high part of BT needs to be done in parts using the
 	 * relations:
 	 * X*Y mod Z = ((X mod Z) * (Y mod Z)) mod Z
 	 * and
 	 * (X + Y) mod Z = ((X mod Z) + (Y mod Z)) mod Z
 	 *
-	 * So, if BTk[n] = uint16 n [0,3] of BTk.
+	 * So, if BTk[n] = u16 n [0,3] of BTk.
 	 * BTk % BP = SUM((BTk[n] * 2^16n) % BP , 0<=n<4) % BP
 	 * and the SUM term can be broken down:
 	 * (BTk[n] *     2^16n)    % BP
@@ -7274,8 +6988,8 @@ uint32 wlc_calc_tbtt_offset(uint32 bp, uint32 tsf_h, uint32 tsf_l)
 	offset = btklo % bp;
 
 	/* K[2] = ((2^16 % BP) * 2^16) % BP */
-	k = (uint32) (1 << 16) % bp;
-	k = (uint32) (k * 1 << 16) % (uint32) bp;
+	k = (u32) (1 << 16) % bp;
+	k = (u32) (k * 1 << 16) % (u32) bp;
 
 	/* offset += (BTk[2] * K[2]) % BP */
 	offset += ((btkhi & 0xffff) * k) % bp;
@@ -7300,7 +7014,7 @@ uint32 wlc_calc_tbtt_offset(uint32 bp, uint32 tsf_h, uint32 tsf_l)
 }
 
 /* Update beacon listen interval in shared memory */
-void wlc_bcn_li_upd(wlc_info_t * wlc)
+void wlc_bcn_li_upd(wlc_info_t *wlc)
 {
 	if (AP_ENAB(wlc->pub))
 		return;
@@ -7314,15 +7028,15 @@ void wlc_bcn_li_upd(wlc_info_t * wlc)
 }
 
 static void
-prep_mac80211_status(wlc_info_t * wlc, d11rxhdr_t * rxh, void *p,
+prep_mac80211_status(wlc_info_t *wlc, d11rxhdr_t *rxh, void *p,
 		     struct ieee80211_rx_status *rx_status)
 {
-	uint32 tsf_l, tsf_h;
+	u32 tsf_l, tsf_h;
 	wlc_d11rxhdr_t *wlc_rxh = (wlc_d11rxhdr_t *) rxh;
 	int preamble;
 	int channel;
 	ratespec_t rspec;
-	uchar *plcp;
+	unsigned char *plcp;
 
 	wlc_read_tsf(wlc, &tsf_l, &tsf_h);	/* mactime */
 	rx_status->mactime = tsf_h;
@@ -7423,97 +7137,8 @@ prep_mac80211_status(wlc_info_t * wlc, d11rxhdr_t * rxh, void *p,
 	}
 }
 
-char *print_fk(uint16 fk)
-{
-	char *str;
-	switch (fk) {
-	case FC_ASSOC_REQ:
-		str = "FC_ASSOC_REQ";
-		break;
-	case FC_ASSOC_RESP:
-		str = "FC_ASSOC_RESP";
-		break;
-	case FC_REASSOC_REQ:
-		str = "FC_REASSOC_REQ";
-		break;
-	case FC_REASSOC_RESP:
-		str = "FC_REASSOC_RESP";
-		break;
-	case FC_PROBE_REQ:
-		str = "FC_PROBE_REQ";
-		break;
-	case FC_PROBE_RESP:
-		str = "FC_PROBE_RESP";
-		break;
-	case FC_BEACON:
-		str = "FC_BEACON";
-		break;
-	case FC_DISASSOC:
-		str = "FC_DISASSOC";
-		break;
-	case FC_AUTH:
-		str = "FC_AUTH";
-		break;
-	case FC_DEAUTH:
-		str = "FC_DEAUTH";
-		break;
-	case FC_ACTION:
-		str = "FC_ACTION";
-		break;
-	case FC_ACTION_NOACK:
-		str = "FC_ACTION_NOACK";
-		break;
-	case FC_CTL_WRAPPER:
-		str = "FC_CTL_WRAPPER";
-		break;
-	case FC_BLOCKACK_REQ:
-		str = "FC_BLOCKACK_REQ";
-		break;
-	case FC_BLOCKACK:
-		str = "FC_BLOCKACK";
-		break;
-	case FC_PS_POLL:
-		str = "FC_PS_POLL";
-		break;
-	case FC_RTS:
-		str = "FC_RTS";
-		break;
-	case FC_CTS:
-		str = "FC_CTS";
-		break;
-	case FC_ACK:
-		str = "FC_ACK";
-		break;
-	case FC_CF_END:
-		str = "FC_CF_END";
-		break;
-	case FC_CF_END_ACK:
-		str = "FC_CF_END_ACK";
-		break;
-	case FC_DATA:
-		str = "FC_DATA";
-		break;
-	case FC_NULL_DATA:
-		str = "FC_NULL_DATA";
-		break;
-	case FC_DATA_CF_ACK:
-		str = "FC_DATA_CF_ACK";
-		break;
-	case FC_QOS_DATA:
-		str = "FC_QOS_DATA";
-		break;
-	case FC_QOS_NULL:
-		str = "FC_QOS_NULL";
-		break;
-	default:
-		str = "Unknown!!";
-		break;
-	}
-	return (str);
-}
-
 static void
-wlc_recvctl(wlc_info_t * wlc, osl_t * osh, d11rxhdr_t * rxh, void *p)
+wlc_recvctl(wlc_info_t *wlc, osl_t *osh, d11rxhdr_t *rxh, void *p)
 {
 	int len_mpdu;
 	struct ieee80211_rx_status rx_status;
@@ -7537,7 +7162,7 @@ wlc_recvctl(wlc_info_t * wlc, osl_t * osh, d11rxhdr_t * rxh, void *p)
 	ASSERT(!PKTNEXT(p));
 	ASSERT(!PKTLINK(p));
 
-	ASSERT(ISALIGNED((uintptr) skb->data, 2));
+	ASSERT(IS_ALIGNED((unsigned long)skb->data, 2));
 
 	memcpy(IEEE80211_SKB_RXCB(p), &rx_status, sizeof(rx_status));
 	ieee80211_rx_irqsafe(wlc->pub->ieee_hw, p);
@@ -7547,7 +7172,7 @@ wlc_recvctl(wlc_info_t * wlc, osl_t * osh, d11rxhdr_t * rxh, void *p)
 	return;
 }
 
-void wlc_bss_list_free(wlc_info_t * wlc, wlc_bss_list_t * bss_list)
+void wlc_bss_list_free(wlc_info_t *wlc, wlc_bss_list_t *bss_list)
 {
 	uint index;
 	wlc_bss_info_t *bi;
@@ -7561,10 +7186,9 @@ void wlc_bss_list_free(wlc_info_t * wlc, wlc_bss_list_t * bss_list)
 		bi = bss_list->ptrs[index];
 		if (bi) {
 			if (bi->bcn_prb) {
-				osl_mfree(wlc->osh, bi->bcn_prb,
-					  bi->bcn_prb_len);
+				kfree(bi->bcn_prb);
 			}
-			osl_mfree(wlc->osh, bi, sizeof(wlc_bss_info_t));
+			kfree(bi);
 			bss_list->ptrs[index] = NULL;
 		}
 	}
@@ -7573,21 +7197,18 @@ void wlc_bss_list_free(wlc_info_t * wlc, wlc_bss_list_t * bss_list)
 
 /* Process received frames */
 /*
- * Return TRUE if more frames need to be processed. FALSE otherwise.
+ * Return true if more frames need to be processed. false otherwise.
  * Param 'bound' indicates max. # frames to process before break out.
  */
 /* WLC_HIGH_API */
-void BCMFASTPATH wlc_recv(wlc_info_t * wlc, void *p)
+void BCMFASTPATH wlc_recv(wlc_info_t *wlc, void *p)
 {
 	d11rxhdr_t *rxh;
 	struct dot11_header *h;
 	osl_t *osh;
-	uint16 fc;
+	u16 fc;
 	uint len;
 	bool is_amsdu;
-#ifdef BCMDBG
-	char eabuf[ETHER_ADDR_STR_LEN];
-#endif
 
 	WL_TRACE(("wl%d: wlc_recv\n", wlc->pub->unit));
 
@@ -7641,7 +7262,9 @@ void BCMFASTPATH wlc_recv(wlc_info_t * wlc, void *p)
 		/* CTS and ACK CTL frames are w/o a2 */
 		if (FC_TYPE(fc) == FC_TYPE_DATA || FC_TYPE(fc) == FC_TYPE_MNG) {
 			if ((ETHER_ISNULLADDR(&h->a2) || ETHER_ISMULTI(&h->a2))) {
-				WL_ERROR(("wl%d: %s: dropping a frame with invalid" " src mac address, a2: %s\n", wlc->pub->unit, __func__, bcm_ether_ntoa(&h->a2, eabuf)));
+				WL_ERROR(("wl%d: %s: dropping a frame with "
+					"invalid src mac address, a2: %pM\n",
+					wlc->pub->unit, __func__, &h->a2));
 				WLCNTINCR(wlc->pub->_cnt->rxbadsrcmac);
 				goto toss;
 			}
@@ -7664,7 +7287,7 @@ void BCMFASTPATH wlc_recv(wlc_info_t * wlc, void *p)
 	return;
 
  toss:
-	PKTFREE(osh, p, FALSE);
+	PKTFREE(osh, p, false);
 }
 
 /* calculate frame duration for Mixed-mode L-SIG spoofing, return
@@ -7673,8 +7296,8 @@ void BCMFASTPATH wlc_recv(wlc_info_t * wlc, void *p)
  * Formula given by HT PHY Spec v 1.13
  *   len = 3(nsyms + nstream + 3) - 3
  */
-uint16 BCMFASTPATH
-wlc_calc_lsig_len(wlc_info_t * wlc, ratespec_t ratespec, uint mac_len)
+u16 BCMFASTPATH
+wlc_calc_lsig_len(wlc_info_t *wlc, ratespec_t ratespec, uint mac_len)
 {
 	uint nsyms, len = 0, kNdps;
 
@@ -7710,12 +7333,12 @@ wlc_calc_lsig_len(wlc_info_t * wlc, ratespec_t ratespec, uint mac_len)
 		len = (3 * nsyms) - 3;	/* (-3) excluding service bits and tail bits */
 	}
 
-	return (uint16) len;
+	return (u16) len;
 }
 
 /* calculate frame duration of a given rate and length, return time in usec unit */
 uint BCMFASTPATH
-wlc_calc_frame_time(wlc_info_t * wlc, ratespec_t ratespec, uint8 preamble_type,
+wlc_calc_frame_time(wlc_info_t *wlc, ratespec_t ratespec, u8 preamble_type,
 		    uint mac_len)
 {
 	uint nsyms, dur = 0, Ndps, kNdps;
@@ -7785,7 +7408,7 @@ wlc_calc_frame_time(wlc_info_t * wlc, ratespec_t ratespec, uint8 preamble_type,
 
 /* The opposite of wlc_calc_frame_time */
 static uint
-wlc_calc_frame_len(wlc_info_t * wlc, ratespec_t ratespec, uint8 preamble_type,
+wlc_calc_frame_len(wlc_info_t *wlc, ratespec_t ratespec, u8 preamble_type,
 		   uint dur)
 {
 	uint nsyms, mac_len, Ndps, kNdps;
@@ -7831,7 +7454,7 @@ wlc_calc_frame_len(wlc_info_t * wlc, ratespec_t ratespec, uint8 preamble_type,
 }
 
 static uint
-wlc_calc_ba_time(wlc_info_t * wlc, ratespec_t rspec, uint8 preamble_type)
+wlc_calc_ba_time(wlc_info_t *wlc, ratespec_t rspec, u8 preamble_type)
 {
 	WL_TRACE(("wl%d: wlc_calc_ba_time: rspec 0x%x, preamble_type %d\n",
 		  wlc->pub->unit, rspec, preamble_type));
@@ -7848,7 +7471,7 @@ wlc_calc_ba_time(wlc_info_t * wlc, ratespec_t rspec, uint8 preamble_type)
 }
 
 static uint BCMFASTPATH
-wlc_calc_ack_time(wlc_info_t * wlc, ratespec_t rspec, uint8 preamble_type)
+wlc_calc_ack_time(wlc_info_t *wlc, ratespec_t rspec, u8 preamble_type)
 {
 	uint dur = 0;
 
@@ -7868,7 +7491,7 @@ wlc_calc_ack_time(wlc_info_t * wlc, ratespec_t rspec, uint8 preamble_type)
 }
 
 static uint
-wlc_calc_cts_time(wlc_info_t * wlc, ratespec_t rspec, uint8 preamble_type)
+wlc_calc_cts_time(wlc_info_t *wlc, ratespec_t rspec, u8 preamble_type)
 {
 	WL_TRACE(("wl%d: wlc_calc_cts_time: ratespec 0x%x, preamble_type %d\n",
 		  wlc->pub->unit, rspec, preamble_type));
@@ -7876,13 +7499,13 @@ wlc_calc_cts_time(wlc_info_t * wlc, ratespec_t rspec, uint8 preamble_type)
 }
 
 /* derive wlc->band->basic_rate[] table from 'rateset' */
-void wlc_rate_lookup_init(wlc_info_t * wlc, wlc_rateset_t * rateset)
+void wlc_rate_lookup_init(wlc_info_t *wlc, wlc_rateset_t *rateset)
 {
-	uint8 rate;
-	uint8 mandatory;
-	uint8 cck_basic = 0;
-	uint8 ofdm_basic = 0;
-	uint8 *br = wlc->band->basic_rate;
+	u8 rate;
+	u8 mandatory;
+	u8 cck_basic = 0;
+	u8 ofdm_basic = 0;
+	u8 *br = wlc->band->basic_rate;
 	uint i;
 
 	/* incoming rates are in 500kbps units as in 802.11 Supported Rates */
@@ -7965,12 +7588,12 @@ void wlc_rate_lookup_init(wlc_info_t * wlc, wlc_rateset_t * rateset)
 	}
 }
 
-static void wlc_write_rate_shm(wlc_info_t * wlc, uint8 rate, uint8 basic_rate)
+static void wlc_write_rate_shm(wlc_info_t *wlc, u8 rate, u8 basic_rate)
 {
-	uint8 phy_rate, index;
-	uint8 basic_phy_rate, basic_index;
-	uint16 dir_table, basic_table;
-	uint16 basic_ptr;
+	u8 phy_rate, index;
+	u8 basic_phy_rate, basic_index;
+	u16 dir_table, basic_table;
+	u16 basic_ptr;
 
 	/* Shared memory address for the table we are reading */
 	dir_table = IS_OFDM(basic_rate) ? M_RT_DIRMAP_A : M_RT_DIRMAP_B;
@@ -7998,7 +7621,7 @@ static void wlc_write_rate_shm(wlc_info_t * wlc, uint8 rate, uint8 basic_rate)
 	wlc_write_shm(wlc, (basic_table + index * 2), basic_ptr);
 }
 
-static const wlc_rateset_t *wlc_rateset_get_hwrs(wlc_info_t * wlc)
+static const wlc_rateset_t *wlc_rateset_get_hwrs(wlc_info_t *wlc)
 {
 	const wlc_rateset_t *rs_dflt;
 
@@ -8015,11 +7638,11 @@ static const wlc_rateset_t *wlc_rateset_get_hwrs(wlc_info_t * wlc)
 	return rs_dflt;
 }
 
-void wlc_set_ratetable(wlc_info_t * wlc)
+void wlc_set_ratetable(wlc_info_t *wlc)
 {
 	const wlc_rateset_t *rs_dflt;
 	wlc_rateset_t rs;
-	uint8 rate, basic_rate;
+	u8 rate, basic_rate;
 	uint i;
 
 	rs_dflt = wlc_rateset_get_hwrs(wlc);
@@ -8051,7 +7674,7 @@ void wlc_set_ratetable(wlc_info_t * wlc)
  * Return true if the specified rate is supported by the specified band.
  * WLC_BAND_AUTO indicates the current band.
  */
-bool wlc_valid_rate(wlc_info_t * wlc, ratespec_t rspec, int band, bool verbose)
+bool wlc_valid_rate(wlc_info_t *wlc, ratespec_t rspec, int band, bool verbose)
 {
 	wlc_rateset_t *hw_rateset;
 	uint i;
@@ -8062,7 +7685,7 @@ bool wlc_valid_rate(wlc_info_t * wlc, ratespec_t rspec, int band, bool verbose)
 		hw_rateset = &wlc->bandstate[OTHERBANDUNIT(wlc)]->hw_rateset;
 	} else {
 		/* other band specified and we are a single band device */
-		return (FALSE);
+		return false;
 	}
 
 	/* check if this is a mimo rate */
@@ -8075,16 +7698,16 @@ bool wlc_valid_rate(wlc_info_t * wlc, ratespec_t rspec, int band, bool verbose)
 
 	for (i = 0; i < hw_rateset->count; i++)
 		if (hw_rateset->rates[i] == RSPEC2RATE(rspec))
-			return (TRUE);
+			return true;
  error:
 	if (verbose) {
 		WL_ERROR(("wl%d: wlc_valid_rate: rate spec 0x%x not in hw_rateset\n", wlc->pub->unit, rspec));
 	}
 
-	return (FALSE);
+	return false;
 }
 
-static void wlc_update_mimo_band_bwcap(wlc_info_t * wlc, uint8 bwcap)
+static void wlc_update_mimo_band_bwcap(wlc_info_t *wlc, u8 bwcap)
 {
 	uint i;
 	wlcband_t *band;
@@ -8096,29 +7719,29 @@ static void wlc_update_mimo_band_bwcap(wlc_info_t * wlc, uint8 bwcap)
 		if (band->bandtype == WLC_BAND_5G) {
 			if ((bwcap == WLC_N_BW_40ALL)
 			    || (bwcap == WLC_N_BW_20IN2G_40IN5G))
-				band->mimo_cap_40 = TRUE;
+				band->mimo_cap_40 = true;
 			else
-				band->mimo_cap_40 = FALSE;
+				band->mimo_cap_40 = false;
 		} else {
 			ASSERT(band->bandtype == WLC_BAND_2G);
 			if (bwcap == WLC_N_BW_40ALL)
-				band->mimo_cap_40 = TRUE;
+				band->mimo_cap_40 = true;
 			else
-				band->mimo_cap_40 = FALSE;
+				band->mimo_cap_40 = false;
 		}
 	}
 
 	wlc->mimo_band_bwcap = bwcap;
 }
 
-void wlc_mod_prb_rsp_rate_table(wlc_info_t * wlc, uint frame_len)
+void wlc_mod_prb_rsp_rate_table(wlc_info_t *wlc, uint frame_len)
 {
 	const wlc_rateset_t *rs_dflt;
 	wlc_rateset_t rs;
-	uint8 rate;
-	uint16 entry_ptr;
-	uint8 plcp[D11_PHY_HDR_LEN];
-	uint16 dur, sifs;
+	u8 rate;
+	u16 entry_ptr;
+	u8 plcp[D11_PHY_HDR_LEN];
+	u16 dur, sifs;
 	uint i;
 
 	sifs = SIFS(wlc->band);
@@ -8140,21 +7763,21 @@ void wlc_mod_prb_rsp_rate_table(wlc_info_t * wlc, uint frame_len)
 
 		/* Calculate the duration of the Probe Response frame plus SIFS for the MAC */
 		dur =
-		    (uint16) wlc_calc_frame_time(wlc, rate, WLC_LONG_PREAMBLE,
+		    (u16) wlc_calc_frame_time(wlc, rate, WLC_LONG_PREAMBLE,
 						 frame_len);
 		dur += sifs;
 
 		/* Update the SHM Rate Table entry Probe Response values */
 		wlc_write_shm(wlc, entry_ptr + M_RT_PRS_PLCP_POS,
-			      (uint16) (plcp[0] + (plcp[1] << 8)));
+			      (u16) (plcp[0] + (plcp[1] << 8)));
 		wlc_write_shm(wlc, entry_ptr + M_RT_PRS_PLCP_POS + 2,
-			      (uint16) (plcp[2] + (plcp[3] << 8)));
+			      (u16) (plcp[2] + (plcp[3] << 8)));
 		wlc_write_shm(wlc, entry_ptr + M_RT_PRS_DUR_POS, dur);
 	}
 }
 
-uint16
-wlc_compute_bcntsfoff(wlc_info_t * wlc, ratespec_t rspec, bool short_preamble,
+u16
+wlc_compute_bcntsfoff(wlc_info_t *wlc, ratespec_t rspec, bool short_preamble,
 		      bool phydelay)
 {
 	uint bcntsfoff = 0;
@@ -8185,7 +7808,7 @@ wlc_compute_bcntsfoff(wlc_info_t * wlc, ratespec_t rspec, bool short_preamble,
 		    D11B_PHY_LPREHDR_TIME;
 		bcntsfoff += wlc_compute_airtime(wlc, rspec, DOT11_MAC_HDR_LEN);
 	}
-	return (uint16) (bcntsfoff);
+	return (u16) (bcntsfoff);
 }
 
 /*	Max buffering needed for beacon template/prb resp template is 142 bytes.
@@ -8201,8 +7824,8 @@ wlc_compute_bcntsfoff(wlc_info_t * wlc, ratespec_t rspec, bool short_preamble,
  *	and included up to, but not including, the 4 byte FCS.
  */
 static void
-wlc_bcn_prb_template(wlc_info_t * wlc, uint type, ratespec_t bcn_rspec,
-		     wlc_bsscfg_t * cfg, uint16 * buf, int *len)
+wlc_bcn_prb_template(wlc_info_t *wlc, uint type, ratespec_t bcn_rspec,
+		     wlc_bsscfg_t *cfg, u16 *buf, int *len)
 {
 	cck_phy_hdr_t *plcp;
 	struct dot11_management_header *h;
@@ -8229,7 +7852,7 @@ wlc_bcn_prb_template(wlc_info_t * wlc, uint type, ratespec_t bcn_rspec,
 		/* fill in PLCP */
 		wlc_compute_plcp(wlc, bcn_rspec,
 				 (DOT11_MAC_HDR_LEN + body_len + DOT11_FCS_LEN),
-				 (uint8 *) plcp);
+				 (u8 *) plcp);
 
 	}
 	/* "Regular" and 16 MBSS but not for 4 MBSS */
@@ -8243,7 +7866,7 @@ wlc_bcn_prb_template(wlc_info_t * wlc, uint type, ratespec_t bcn_rspec,
 		h = (struct dot11_management_header *)&plcp[1];
 
 	/* fill in 802.11 header */
-	h->fc = htol16((uint16) type);
+	h->fc = htol16((u16) type);
 
 	/* DUR is 0 for multicast bcn, or filled in by MAC for prb resp */
 	/* A1 filled in by MAC for prb resp, broadcast for bcn */
@@ -8268,7 +7891,7 @@ int wlc_get_header_len()
  * template updated.
  * Otherwise, it updates the hardware template.
  */
-void wlc_bss_update_beacon(wlc_info_t * wlc, wlc_bsscfg_t * cfg)
+void wlc_bss_update_beacon(wlc_info_t *wlc, wlc_bsscfg_t *cfg)
 {
 	int len = BCN_TMPL_LEN;
 
@@ -8281,8 +7904,8 @@ void wlc_bss_update_beacon(wlc_info_t * wlc, wlc_bsscfg_t * cfg)
 
 	if (MBSS_BCN_ENAB(cfg)) {	/* Optimize:  Some of if/else could be combined */
 	} else if (HWBCN_ENAB(cfg)) {	/* Hardware beaconing for this config */
-		uint16 bcn[BCN_TMPL_LEN / 2];
-		uint32 both_valid = MCMD_BCN0VLD | MCMD_BCN1VLD;
+		u16 bcn[BCN_TMPL_LEN / 2];
+		u32 both_valid = MCMD_BCN0VLD | MCMD_BCN1VLD;
 		d11regs_t *regs = wlc->regs;
 		osl_t *osh = NULL;
 
@@ -8309,19 +7932,19 @@ void wlc_bss_update_beacon(wlc_info_t * wlc, wlc_bsscfg_t * cfg)
 		       (wlc, wlc->bcn_rspec,
 			CHSPEC_IS2G(cfg->current_bss->
 				    chanspec) ? WLC_BAND_2G : WLC_BAND_5G,
-			TRUE));
+			true));
 
 		/* update the template and ucode shm */
 		wlc_bcn_prb_template(wlc, FC_BEACON, wlc->bcn_rspec, cfg, bcn,
 				     &len);
-		wlc_write_hw_bcntemplates(wlc, bcn, len, FALSE);
+		wlc_write_hw_bcntemplates(wlc, bcn, len, false);
 	}
 }
 
 /*
  * Update all beacons for the system.
  */
-void wlc_update_beacon(wlc_info_t * wlc)
+void wlc_update_beacon(wlc_info_t *wlc)
 {
 	int idx;
 	wlc_bsscfg_t *bsscfg;
@@ -8334,11 +7957,11 @@ void wlc_update_beacon(wlc_info_t * wlc)
 }
 
 /* Write ssid into shared memory */
-void wlc_shm_ssid_upd(wlc_info_t * wlc, wlc_bsscfg_t * cfg)
+void wlc_shm_ssid_upd(wlc_info_t *wlc, wlc_bsscfg_t *cfg)
 {
-	uint8 *ssidptr = cfg->SSID;
-	uint16 base = M_SSID;
-	uint8 ssidbuf[DOT11_MAX_SSID_LEN];
+	u8 *ssidptr = cfg->SSID;
+	u16 base = M_SSID;
+	u8 ssidbuf[DOT11_MAX_SSID_LEN];
 
 	/* padding the ssid with zero and copy it into shm */
 	bzero(ssidbuf, DOT11_MAX_SSID_LEN);
@@ -8347,10 +7970,10 @@ void wlc_shm_ssid_upd(wlc_info_t * wlc, wlc_bsscfg_t * cfg)
 	wlc_copyto_shm(wlc, base, ssidbuf, DOT11_MAX_SSID_LEN);
 
 	if (!MBSS_BCN_ENAB(cfg))
-		wlc_write_shm(wlc, M_SSIDLEN, (uint16) cfg->SSID_len);
+		wlc_write_shm(wlc, M_SSIDLEN, (u16) cfg->SSID_len);
 }
 
-void wlc_update_probe_resp(wlc_info_t * wlc, bool suspend)
+void wlc_update_probe_resp(wlc_info_t *wlc, bool suspend)
 {
 	int idx;
 	wlc_bsscfg_t *bsscfg;
@@ -8363,9 +7986,9 @@ void wlc_update_probe_resp(wlc_info_t * wlc, bool suspend)
 }
 
 void
-wlc_bss_update_probe_resp(wlc_info_t * wlc, wlc_bsscfg_t * cfg, bool suspend)
+wlc_bss_update_probe_resp(wlc_info_t *wlc, wlc_bsscfg_t *cfg, bool suspend)
 {
-	uint16 prb_resp[BCN_TMPL_LEN / 2];
+	u16 prb_resp[BCN_TMPL_LEN / 2];
 	int len = BCN_TMPL_LEN;
 
 	/* write the probe response to hardware, or save in the config structure */
@@ -8383,7 +8006,7 @@ wlc_bss_update_probe_resp(wlc_info_t * wlc, wlc_bsscfg_t * cfg, bool suspend)
 					    (len + 3) & ~3, prb_resp);
 
 		/* write the length of the probe response frame (+PLCP/-FCS) */
-		wlc_write_shm(wlc, M_PRB_RESP_FRM_LEN, (uint16) len);
+		wlc_write_shm(wlc, M_PRB_RESP_FRM_LEN, (u16) len);
 
 		/* write the SSID and SSID length */
 		wlc_shm_ssid_upd(wlc, cfg);
@@ -8394,7 +8017,7 @@ wlc_bss_update_probe_resp(wlc_info_t * wlc, wlc_bsscfg_t * cfg, bool suspend)
 		 * wlc_mod_prb_rsp_rate_table() by subtracting the PLCP len and adding the FCS.
 		 */
 		len += (-D11_PHY_HDR_LEN + DOT11_FCS_LEN);
-		wlc_mod_prb_rsp_rate_table(wlc, (uint16) len);
+		wlc_mod_prb_rsp_rate_table(wlc, (u16) len);
 
 		if (suspend)
 			wlc_enable_mac(wlc);
@@ -8404,21 +8027,21 @@ wlc_bss_update_probe_resp(wlc_info_t * wlc, wlc_bsscfg_t * cfg, bool suspend)
 }
 
 /* prepares pdu for transmission. returns BCM error codes */
-int wlc_prep_pdu(wlc_info_t * wlc, void *pdu, uint * fifop)
+int wlc_prep_pdu(wlc_info_t *wlc, void *pdu, uint *fifop)
 {
 	osl_t *osh;
 	uint fifo;
 	d11txh_t *txh;
 	struct dot11_header *h;
 	struct scb *scb;
-	uint16 fc;
+	u16 fc;
 
 	osh = wlc->osh;
 
 	ASSERT(pdu);
 	txh = (d11txh_t *) PKTDATA(pdu);
 	ASSERT(txh);
-	h = (struct dot11_header *)((uint8 *) (txh + 1) + D11_PHY_HDR_LEN);
+	h = (struct dot11_header *)((u8 *) (txh + 1) + D11_PHY_HDR_LEN);
 	ASSERT(h);
 	fc = ltoh16(h->fc);
 
@@ -8443,7 +8066,7 @@ int wlc_prep_pdu(wlc_info_t * wlc, void *pdu, uint * fifop)
 }
 
 /* init tx reported rate mechanism */
-void wlc_reprate_init(wlc_info_t * wlc)
+void wlc_reprate_init(wlc_info_t *wlc)
 {
 	int i;
 	wlc_bsscfg_t *bsscfg;
@@ -8454,7 +8077,7 @@ void wlc_reprate_init(wlc_info_t * wlc)
 }
 
 /* per bsscfg init tx reported rate mechanism */
-void wlc_bsscfg_reprate_init(wlc_bsscfg_t * bsscfg)
+void wlc_bsscfg_reprate_init(wlc_bsscfg_t *bsscfg)
 {
 	bsscfg->txrspecidx = 0;
 	bzero((char *)bsscfg->txrspec, sizeof(bsscfg->txrspec));
@@ -8463,7 +8086,7 @@ void wlc_bsscfg_reprate_init(wlc_bsscfg_t * bsscfg)
 /* Retrieve a consolidated set of revision information,
  * typically for the WLC_GET_REVINFO ioctl
  */
-int wlc_get_revision_info(wlc_info_t * wlc, void *buf, uint len)
+int wlc_get_revision_info(wlc_info_t *wlc, void *buf, uint len)
 {
 	wlc_rev_info_t *rinfo = (wlc_rev_info_t *) buf;
 
@@ -8484,7 +8107,7 @@ int wlc_get_revision_info(wlc_info_t * wlc, void *buf, uint len)
 	rinfo->bus = wlc->pub->sih->bustype;
 	rinfo->chipnum = wlc->pub->sih->chip;
 
-	if (len >= (OFFSETOF(wlc_rev_info_t, chippkg))) {
+	if (len >= (offsetof(wlc_rev_info_t, chippkg))) {
 		rinfo->phytype = wlc->band->phytype;
 		rinfo->phyrev = wlc->band->phyrev;
 		rinfo->anarev = 0;	/* obsolete stuff, suppress */
@@ -8497,15 +8120,16 @@ int wlc_get_revision_info(wlc_info_t * wlc, void *buf, uint len)
 	return BCME_OK;
 }
 
-void wlc_default_rateset(wlc_info_t * wlc, wlc_rateset_t * rs)
+void wlc_default_rateset(wlc_info_t *wlc, wlc_rateset_t *rs)
 {
 	wlc_rateset_default(rs, NULL, wlc->band->phytype, wlc->band->bandtype,
-			    FALSE, RATE_MASK_FULL, (bool) N_ENAB(wlc->pub),
+			    false, RATE_MASK_FULL, (bool) N_ENAB(wlc->pub),
 			    CHSPEC_WLC_BW(wlc->default_bss->chanspec),
 			    wlc->stf->txstreams);
 }
 
-static void BCMATTACHFN(wlc_bss_default_init) (wlc_info_t * wlc) {
+static void wlc_bss_default_init(wlc_info_t *wlc)
+{
 	chanspec_t chanspec;
 	wlcband_t *band;
 	wlc_bss_info_t *bi = wlc->default_bss;
@@ -8532,7 +8156,7 @@ static void BCMATTACHFN(wlc_bss_default_init) (wlc_info_t * wlc) {
 
 	/* init bss rates to the band specific default rate set */
 	wlc_rateset_default(&bi->rateset, NULL, band->phytype, band->bandtype,
-			    FALSE, RATE_MASK_FULL, (bool) N_ENAB(wlc->pub),
+			    false, RATE_MASK_FULL, (bool) N_ENAB(wlc->pub),
 			    CHSPEC_WLC_BW(chanspec), wlc->stf->txstreams);
 
 	if (N_ENAB(wlc->pub))
@@ -8549,7 +8173,7 @@ static void wlc_process_eventq(void *arg)
 		/* Perform OS specific event processing */
 		wl_event(wlc->wl, etmp->event.ifname, etmp);
 		if (etmp->data) {
-			osl_mfree(wlc->osh, etmp->data, etmp->event.datalen);
+			kfree(etmp->data);
 			etmp->data = NULL;
 		}
 		wlc_event_free(wlc->eventq, etmp);
@@ -8557,7 +8181,7 @@ static void wlc_process_eventq(void *arg)
 }
 
 void
-wlc_uint64_sub(uint32 * a_high, uint32 * a_low, uint32 b_high, uint32 b_low)
+wlc_uint64_sub(u32 *a_high, u32 *a_low, u32 b_high, u32 b_low)
 {
 	if (b_low > *a_low) {
 		/* low half needs a carry */
@@ -8568,10 +8192,10 @@ wlc_uint64_sub(uint32 * a_high, uint32 * a_low, uint32 b_high, uint32 b_low)
 }
 
 static ratespec_t
-mac80211_wlc_set_nrate(wlc_info_t * wlc, wlcband_t * cur_band, uint32 int_val)
+mac80211_wlc_set_nrate(wlc_info_t *wlc, wlcband_t *cur_band, u32 int_val)
 {
-	uint8 stf = (int_val & NRATE_STF_MASK) >> NRATE_STF_SHIFT;
-	uint8 rate = int_val & NRATE_RATE_MASK;
+	u8 stf = (int_val & NRATE_STF_MASK) >> NRATE_STF_SHIFT;
+	u8 rate = int_val & NRATE_RATE_MASK;
 	ratespec_t rspec;
 	bool ismcs = ((int_val & NRATE_MCS_INUSE) == NRATE_MCS_INUSE);
 	bool issgi = ((int_val & NRATE_SGI_MASK) >> NRATE_SGI_SHIFT);
@@ -8655,7 +8279,7 @@ mac80211_wlc_set_nrate(wlc_info_t * wlc, wlcband_t * cur_band, uint32 int_val)
 		rspec |= RSPEC_MIMORATE;
 		/* For STBC populate the STC field of the ratespec */
 		if (stf == PHY_TXC1_MODE_STBC) {
-			uint8 stc;
+			u8 stc;
 			stc = 1;	/* Nss for single stream is always 1 */
 			rspec |= (stc << RSPEC_STC_SHIFT);
 		}
@@ -8670,7 +8294,7 @@ mac80211_wlc_set_nrate(wlc_info_t * wlc, wlcband_t * cur_band, uint32 int_val)
 		rspec |= RSPEC_SHORT_GI;
 
 	if ((rate != 0)
-	    && !wlc_valid_rate(wlc, rspec, cur_band->bandtype, TRUE)) {
+	    && !wlc_valid_rate(wlc, rspec, cur_band->bandtype, true)) {
 		return rate;
 	}
 
@@ -8682,7 +8306,7 @@ mac80211_wlc_set_nrate(wlc_info_t * wlc, wlcband_t * cur_band, uint32 int_val)
 
 /* formula:  IDLE_BUSY_RATIO_X_16 = (100-duty_cycle)/duty_cycle*16 */
 static int
-wlc_duty_cycle_set(wlc_info_t * wlc, int duty_cycle, bool isOFDM,
+wlc_duty_cycle_set(wlc_info_t *wlc, int duty_cycle, bool isOFDM,
 		   bool writeToShm)
 {
 	int idle_busy_ratio_x_16 = 0;
@@ -8698,88 +8322,28 @@ wlc_duty_cycle_set(wlc_info_t * wlc, int duty_cycle, bool isOFDM,
 		idle_busy_ratio_x_16 = (100 - duty_cycle) * 16 / duty_cycle;
 	/* Only write to shared memory  when wl is up */
 	if (writeToShm)
-		wlc_write_shm(wlc, offset, (uint16) idle_busy_ratio_x_16);
+		wlc_write_shm(wlc, offset, (u16) idle_busy_ratio_x_16);
 
 	if (isOFDM)
-		wlc->tx_duty_cycle_ofdm = (uint16) duty_cycle;
+		wlc->tx_duty_cycle_ofdm = (u16) duty_cycle;
 	else
-		wlc->tx_duty_cycle_cck = (uint16) duty_cycle;
+		wlc->tx_duty_cycle_cck = (u16) duty_cycle;
 
 	return BCME_OK;
 }
 
-void
-wlc_pktengtx(wlc_info_t * wlc, wl_pkteng_t * pkteng, uint8 rate,
-	     struct ether_addr *sa, uint32 wait_delay)
-{
-	bool suspend;
-	uint16 val = M_PKTENG_MODE_TX;
-	volatile uint16 frame_cnt_check;
-	uint8 counter = 0;
-
-	wlc_bmac_set_deaf(wlc->hw, TRUE);
-
-	suspend =
-	    (0 == (R_REG(wlc->hw->osh, &wlc->regs->maccontrol) & MCTL_EN_MAC));
-	if (suspend)
-		wlc_enable_mac(wlc);
-
-	/* set nframes */
-	if (pkteng->nframes) {
-		/* retry counter is used to replay the packet */
-		wlc_bmac_write_shm(wlc->hw, M_PKTENG_FRMCNT_LO,
-				   (pkteng->nframes & 0xffff));
-		wlc_bmac_write_shm(wlc->hw, M_PKTENG_FRMCNT_HI,
-				   ((pkteng->nframes >> 16) & 0xffff));
-		val |= M_PKTENG_FRMCNT_VLD;
-	}
-
-	if (pkteng->length) {
-		/* DATA frame */
-		wlc_bmac_write_shm(wlc->hw, M_PKTENG_CTRL, val);
-		/* we write to M_MFGTEST_IFS the IFS required in 1/8us factor */
-		/* 10 : for factoring difference b/w Tx.crs and energy in air */
-		/* 44 : amount of time spent after TX_RRSP to frame start */
-		/* IFS */
-		wlc_bmac_write_shm(wlc->hw, M_PKTENG_IFS,
-				   (pkteng->delay - 10) * 8 - 44);
-	} else {
-		/* CTS frame */
-		val |= M_PKTENG_MODE_TX_CTS;
-		wlc_bmac_write_shm(wlc->hw, M_PKTENG_IFS,
-				   (uint16) pkteng->delay);
-		wlc_bmac_write_shm(wlc->hw, M_PKTENG_CTRL, val);
-	}
-
-	/* Wait for packets to finish */
-	frame_cnt_check = wlc_bmac_read_shm(wlc->hw, M_PKTENG_FRMCNT_LO);
-	while ((counter < 100) && (frame_cnt_check != 0)) {
-		OSL_DELAY(100);
-		frame_cnt_check =
-		    wlc_bmac_read_shm(wlc->hw, M_PKTENG_FRMCNT_LO);
-		counter++;
-	}
-
-	wlc_bmac_write_shm(wlc->hw, M_PKTENG_CTRL, 0);
-
-	if (suspend)
-		wlc_suspend_mac_and_wait(wlc);
-
-	wlc_bmac_set_deaf(wlc->hw, FALSE);
-}
-
-/* Read a single uint16 from shared memory.
+/* Read a single u16 from shared memory.
  * SHM 'offset' needs to be an even address
  */
-uint16 wlc_read_shm(wlc_info_t * wlc, uint offset)
+u16 wlc_read_shm(wlc_info_t *wlc, uint offset)
 {
 	return wlc_bmac_read_shm(wlc->hw, offset);
 }
 
-/* Write a single uint16 to shared memory.
+/* Write a single u16 to shared memory.
  * SHM 'offset' needs to be an even address
  */
-void wlc_write_shm(wlc_info_t * wlc, uint offset, uint16 v)
+void wlc_write_shm(wlc_info_t *wlc, uint offset, u16 v)
 {
 	wlc_bmac_write_shm(wlc->hw, offset, v);
 }
@@ -8788,7 +8352,7 @@ void wlc_write_shm(wlc_info_t * wlc, uint offset, uint16 v)
  * SHM 'offset' needs to be an even address and
  * Range length 'len' must be an even number of bytes
  */
-void wlc_set_shm(wlc_info_t * wlc, uint offset, uint16 v, int len)
+void wlc_set_shm(wlc_info_t *wlc, uint offset, u16 v, int len)
 {
 	/* offset and len need to be even */
 	ASSERT((offset & 1) == 0);
@@ -8804,7 +8368,7 @@ void wlc_set_shm(wlc_info_t * wlc, uint offset, uint16 v, int len)
  * SHM 'offset' needs to be an even address and
  * Buffer length 'len' must be an even number of bytes
  */
-void wlc_copyto_shm(wlc_info_t * wlc, uint offset, const void *buf, int len)
+void wlc_copyto_shm(wlc_info_t *wlc, uint offset, const void *buf, int len)
 {
 	/* offset and len need to be even */
 	ASSERT((offset & 1) == 0);
@@ -8820,7 +8384,7 @@ void wlc_copyto_shm(wlc_info_t * wlc, uint offset, const void *buf, int len)
  * SHM 'offset' needs to be an even address and
  * Buffer length 'len' must be an even number of bytes
  */
-void wlc_copyfrom_shm(wlc_info_t * wlc, uint offset, void *buf, int len)
+void wlc_copyfrom_shm(wlc_info_t *wlc, uint offset, void *buf, int len)
 {
 	/* offset and len need to be even */
 	ASSERT((offset & 1) == 0);
@@ -8833,71 +8397,71 @@ void wlc_copyfrom_shm(wlc_info_t * wlc, uint offset, void *buf, int len)
 }
 
 /* wrapper BMAC functions to for HIGH driver access */
-void wlc_mctrl(wlc_info_t * wlc, uint32 mask, uint32 val)
+void wlc_mctrl(wlc_info_t *wlc, u32 mask, u32 val)
 {
 	wlc_bmac_mctrl(wlc->hw, mask, val);
 }
 
-void wlc_corereset(wlc_info_t * wlc, uint32 flags)
+void wlc_corereset(wlc_info_t *wlc, u32 flags)
 {
 	wlc_bmac_corereset(wlc->hw, flags);
 }
 
-void wlc_mhf(wlc_info_t * wlc, uint8 idx, uint16 mask, uint16 val, int bands)
+void wlc_mhf(wlc_info_t *wlc, u8 idx, u16 mask, u16 val, int bands)
 {
 	wlc_bmac_mhf(wlc->hw, idx, mask, val, bands);
 }
 
-uint16 wlc_mhf_get(wlc_info_t * wlc, uint8 idx, int bands)
+u16 wlc_mhf_get(wlc_info_t *wlc, u8 idx, int bands)
 {
 	return wlc_bmac_mhf_get(wlc->hw, idx, bands);
 }
 
-int wlc_xmtfifo_sz_get(wlc_info_t * wlc, uint fifo, uint * blocks)
+int wlc_xmtfifo_sz_get(wlc_info_t *wlc, uint fifo, uint *blocks)
 {
 	return wlc_bmac_xmtfifo_sz_get(wlc->hw, fifo, blocks);
 }
 
-void wlc_write_template_ram(wlc_info_t * wlc, int offset, int len, void *buf)
+void wlc_write_template_ram(wlc_info_t *wlc, int offset, int len, void *buf)
 {
 	wlc_bmac_write_template_ram(wlc->hw, offset, len, buf);
 }
 
-void wlc_write_hw_bcntemplates(wlc_info_t * wlc, void *bcn, int len, bool both)
+void wlc_write_hw_bcntemplates(wlc_info_t *wlc, void *bcn, int len, bool both)
 {
 	wlc_bmac_write_hw_bcntemplates(wlc->hw, bcn, len, both);
 }
 
 void
-wlc_set_addrmatch(wlc_info_t * wlc, int match_reg_offset,
+wlc_set_addrmatch(wlc_info_t *wlc, int match_reg_offset,
 		  const struct ether_addr *addr)
 {
 	wlc_bmac_set_addrmatch(wlc->hw, match_reg_offset, addr);
 }
 
-void wlc_set_rcmta(wlc_info_t * wlc, int idx, const struct ether_addr *addr)
+void wlc_set_rcmta(wlc_info_t *wlc, int idx, const struct ether_addr *addr)
 {
 	wlc_bmac_set_rcmta(wlc->hw, idx, addr);
 }
 
-void wlc_read_tsf(wlc_info_t * wlc, uint32 * tsf_l_ptr, uint32 * tsf_h_ptr)
+void wlc_read_tsf(wlc_info_t *wlc, u32 *tsf_l_ptr, u32 *tsf_h_ptr)
 {
 	wlc_bmac_read_tsf(wlc->hw, tsf_l_ptr, tsf_h_ptr);
 }
 
-void wlc_set_cwmin(wlc_info_t * wlc, uint16 newmin)
+void wlc_set_cwmin(wlc_info_t *wlc, u16 newmin)
 {
 	wlc->band->CWmin = newmin;
 	wlc_bmac_set_cwmin(wlc->hw, newmin);
 }
 
-void wlc_set_cwmax(wlc_info_t * wlc, uint16 newmax)
+void wlc_set_cwmax(wlc_info_t *wlc, u16 newmax)
 {
 	wlc->band->CWmax = newmax;
 	wlc_bmac_set_cwmax(wlc->hw, newmax);
 }
 
-void wlc_fifoerrors(wlc_info_t * wlc)
+void wlc_fifoerrors(wlc_info_t *wlc)
 {
 
 	wlc_bmac_fifoerrors(wlc->hw);
@@ -8905,32 +8469,32 @@ void wlc_fifoerrors(wlc_info_t * wlc)
 
 /* Search mem rw utilities */
 
-void wlc_pllreq(wlc_info_t * wlc, bool set, mbool req_bit)
+void wlc_pllreq(wlc_info_t *wlc, bool set, mbool req_bit)
 {
 	wlc_bmac_pllreq(wlc->hw, set, req_bit);
 }
 
-void wlc_reset_bmac_done(wlc_info_t * wlc)
+void wlc_reset_bmac_done(wlc_info_t *wlc)
 {
 #ifdef WLC_HIGH_ONLY
-	wlc->reset_bmac_pending = FALSE;
+	wlc->reset_bmac_pending = false;
 #endif
 }
 
-void wlc_ht_mimops_cap_update(wlc_info_t * wlc, uint8 mimops_mode)
+void wlc_ht_mimops_cap_update(wlc_info_t *wlc, u8 mimops_mode)
 {
 	wlc->ht_cap.cap &= ~HT_CAP_MIMO_PS_MASK;
 	wlc->ht_cap.cap |= (mimops_mode << HT_CAP_MIMO_PS_SHIFT);
 
 	if (AP_ENAB(wlc->pub) && wlc->clk) {
 		wlc_update_beacon(wlc);
-		wlc_update_probe_resp(wlc, TRUE);
+		wlc_update_probe_resp(wlc, true);
 	}
 }
 
 /* check for the particular priority flow control bit being set */
 bool
-wlc_txflowcontrol_prio_isset(wlc_info_t * wlc, wlc_txq_info_t * q, int prio)
+wlc_txflowcontrol_prio_isset(wlc_info_t *wlc, wlc_txq_info_t *q, int prio)
 {
 	uint prio_mask;
 
@@ -8945,7 +8509,7 @@ wlc_txflowcontrol_prio_isset(wlc_info_t * wlc, wlc_txq_info_t * q, int prio)
 }
 
 /* propogate the flow control to all interfaces using the given tx queue */
-void wlc_txflowcontrol(wlc_info_t * wlc, wlc_txq_info_t * qi, bool on, int prio)
+void wlc_txflowcontrol(wlc_info_t *wlc, wlc_txq_info_t *qi, bool on, int prio)
 {
 	uint prio_bits;
 	uint cur_bits;
@@ -8987,7 +8551,7 @@ void wlc_txflowcontrol(wlc_info_t * wlc, wlc_txq_info_t * qi, bool on, int prio)
 }
 
 void
-wlc_txflowcontrol_override(wlc_info_t * wlc, wlc_txq_info_t * qi, bool on,
+wlc_txflowcontrol_override(wlc_info_t *wlc, wlc_txq_info_t *qi, bool on,
 			   uint override)
 {
 	uint prev_override;
@@ -9034,7 +8598,7 @@ wlc_txflowcontrol_override(wlc_info_t * wlc, wlc_txq_info_t * qi, bool on,
 	}
 }
 
-static void wlc_txflowcontrol_reset(wlc_info_t * wlc)
+static void wlc_txflowcontrol_reset(wlc_info_t *wlc)
 {
 	wlc_txq_info_t *qi;
 
@@ -9047,7 +8611,7 @@ static void wlc_txflowcontrol_reset(wlc_info_t * wlc)
 }
 
 static void
-wlc_txflowcontrol_signal(wlc_info_t * wlc, wlc_txq_info_t * qi, bool on,
+wlc_txflowcontrol_signal(wlc_info_t *wlc, wlc_txq_info_t *qi, bool on,
 			 int prio)
 {
 	wlc_if_t *wlcif;
@@ -9058,7 +8622,7 @@ wlc_txflowcontrol_signal(wlc_info_t * wlc, wlc_txq_info_t * qi, bool on,
 	}
 }
 
-static wlc_txq_info_t *wlc_txq_alloc(wlc_info_t * wlc, osl_t * osh)
+static wlc_txq_info_t *wlc_txq_alloc(wlc_info_t *wlc, osl_t *osh)
 {
 	wlc_txq_info_t *qi, *p;
 
@@ -9088,7 +8652,7 @@ static wlc_txq_info_t *wlc_txq_alloc(wlc_info_t * wlc, osl_t * osh)
 	return qi;
 }
 
-static void wlc_txq_free(wlc_info_t * wlc, osl_t * osh, wlc_txq_info_t * qi)
+static void wlc_txq_free(wlc_info_t *wlc, osl_t *osh, wlc_txq_info_t *qi)
 {
 	wlc_txq_info_t *p;
 
@@ -9107,5 +8671,5 @@ static void wlc_txq_free(wlc_info_t * wlc, osl_t * osh, wlc_txq_info_t * qi)
 			p->next = p->next->next;
 	}
 
-	osl_mfree(osh, qi, sizeof(wlc_txq_info_t));
+	kfree(qi);
 }
diff --git a/drivers/staging/brcm80211/sys/wlc_mac80211.h b/drivers/staging/brcm80211/sys/wlc_mac80211.h
index 2d03272..6a77591 100644
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.h
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.h
@@ -51,7 +51,7 @@
 #define	WLC_PROT_N_PAM_OVR	15	/* n preamble override */
 #define	WLC_PROT_N_OBSS		16	/* non-HT OBSS present */
 
-#define WLC_BITSCNT(x)	bcm_bitcount((uint8 *)&(x), sizeof(uint8))
+#define WLC_BITSCNT(x)	bcm_bitcount((u8 *)&(x), sizeof(u8))
 
 /* Maximum wait time for a MAC suspend */
 #define	WLC_MAX_MAC_SUSPEND	83000	/* uS: 83mS is max packet time (64KB ampdu @ 6Mbps) */
@@ -117,9 +117,13 @@ typedef struct wlc_bss_list {
 
 /* if wpa is in use then portopen is true when the group key is plumbed otherwise it is always true
  */
+#define WSEC_ENABLED(wsec) ((wsec) & (WEP_ENABLED | TKIP_ENABLED | AES_ENABLED))
+#define WLC_SW_KEYS(wlc, bsscfg) ((((wlc)->wsec_swkeys) || \
+	((bsscfg)->wsec & WSEC_SWFLAG)))
+
 #define WLC_PORTOPEN(cfg) \
 	(((cfg)->WPA_auth != WPA_AUTH_DISABLED && WSEC_ENABLED((cfg)->wsec)) ? \
-	(cfg)->wsec_portopen : TRUE)
+	(cfg)->wsec_portopen : true)
 
 #define PS_ALLOWED(wlc)	wlc_ps_allowed(wlc)
 #define STAY_AWAKE(wlc) wlc_stay_awake(wlc)
@@ -127,7 +131,7 @@ typedef struct wlc_bss_list {
 #define DATA_BLOCK_TX_SUPR	(1 << 4)
 
 /* 802.1D Priority to TX FIFO number for wme */
-extern const uint8 prio2fifo[];
+extern const u8 prio2fifo[];
 
 /* Ucode MCTL_WAKE override bits */
 #define WLC_WAKE_OVERRIDE_CLKCTL	0x01
@@ -177,13 +181,13 @@ extern const uint8 prio2fifo[];
 #define WLC_WME_RETRY_LFB_GET(wlc, ac)      GFIELD(wlc->wme_retries[ac], EDCF_LFB)
 
 #define WLC_WME_RETRY_SHORT_SET(wlc, ac, val) \
-	wlc->wme_retries[ac] = SFIELD(wlc->wme_retries[ac], EDCF_SHORT, val)
+	(wlc->wme_retries[ac] = SFIELD(wlc->wme_retries[ac], EDCF_SHORT, val))
 #define WLC_WME_RETRY_SFB_SET(wlc, ac, val) \
-	wlc->wme_retries[ac] = SFIELD(wlc->wme_retries[ac], EDCF_SFB, val)
+	(wlc->wme_retries[ac] = SFIELD(wlc->wme_retries[ac], EDCF_SFB, val))
 #define WLC_WME_RETRY_LONG_SET(wlc, ac, val) \
-	wlc->wme_retries[ac] = SFIELD(wlc->wme_retries[ac], EDCF_LONG, val)
+	(wlc->wme_retries[ac] = SFIELD(wlc->wme_retries[ac], EDCF_LONG, val))
 #define WLC_WME_RETRY_LFB_SET(wlc, ac, val) \
-	wlc->wme_retries[ac] = SFIELD(wlc->wme_retries[ac], EDCF_LFB, val)
+	(wlc->wme_retries[ac] = SFIELD(wlc->wme_retries[ac], EDCF_LFB, val))
 
 /* PLL requests */
 #define WLC_PLLREQ_SHARED	0x1	/* pll is shared on old chips */
@@ -191,7 +195,7 @@ extern const uint8 prio2fifo[];
 #define WLC_PLLREQ_FLIP		0x4	/* hold/release pll for some short operation */
 
 /* Do we support this rate? */
-#define VALID_RATE_DBG(wlc, rspec) wlc_valid_rate(wlc, rspec, WLC_BAND_AUTO, TRUE)
+#define VALID_RATE_DBG(wlc, rspec) wlc_valid_rate(wlc, rspec, WLC_BAND_AUTO, true)
 
 /*
  * Macros to check if AP or STA is active.
@@ -230,15 +234,15 @@ extern const uint8 prio2fifo[];
 
 typedef struct wlc_protection {
 	bool _g;		/* use g spec protection, driver internal */
-	int8 g_override;	/* override for use of g spec protection */
-	uint8 gmode_user;	/* user config gmode, operating band->gmode is different */
-	int8 overlap;		/* Overlap BSS/IBSS protection for both 11g and 11n */
-	int8 nmode_user;	/* user config nmode, operating pub->nmode is different */
-	int8 n_cfg;		/* use OFDM protection on MIMO frames */
-	int8 n_cfg_override;	/* override for use of N protection */
+	s8 g_override;	/* override for use of g spec protection */
+	u8 gmode_user;	/* user config gmode, operating band->gmode is different */
+	s8 overlap;		/* Overlap BSS/IBSS protection for both 11g and 11n */
+	s8 nmode_user;	/* user config nmode, operating pub->nmode is different */
+	s8 n_cfg;		/* use OFDM protection on MIMO frames */
+	s8 n_cfg_override;	/* override for use of N protection */
 	bool nongf;		/* non-GF present protection */
-	int8 nongf_override;	/* override for use of GF protection */
-	int8 n_pam_override;	/* override for preamble: MM or GF */
+	s8 nongf_override;	/* override for use of GF protection */
+	s8 n_pam_override;	/* override for preamble: MM or GF */
 	bool n_obss;		/* indicated OBSS Non-HT STA present */
 
 	uint longpre_detect_timeout;	/* #sec until long preamble bcns gone */
@@ -257,29 +261,29 @@ typedef struct wlc_protection {
 
 /* anything affects the single/dual streams/antenna operation */
 typedef struct wlc_stf {
-	uint8 hw_txchain;	/* HW txchain bitmap cfg */
-	uint8 txchain;		/* txchain bitmap being used */
-	uint8 txstreams;	/* number of txchains being used */
+	u8 hw_txchain;	/* HW txchain bitmap cfg */
+	u8 txchain;		/* txchain bitmap being used */
+	u8 txstreams;	/* number of txchains being used */
 
-	uint8 hw_rxchain;	/* HW rxchain bitmap cfg */
-	uint8 rxchain;		/* rxchain bitmap being used */
-	uint8 rxstreams;	/* number of rxchains being used */
+	u8 hw_rxchain;	/* HW rxchain bitmap cfg */
+	u8 rxchain;		/* rxchain bitmap being used */
+	u8 rxstreams;	/* number of rxchains being used */
 
-	uint8 ant_rx_ovr;	/* rx antenna override */
-	int8 txant;		/* userTx antenna setting */
-	uint16 phytxant;	/* phyTx antenna setting in txheader */
+	u8 ant_rx_ovr;	/* rx antenna override */
+	s8 txant;		/* userTx antenna setting */
+	u16 phytxant;	/* phyTx antenna setting in txheader */
 
-	uint8 ss_opmode;	/* singlestream Operational mode, 0:siso; 1:cdd */
-	bool ss_algosel_auto;	/* if TRUE, use wlc->stf->ss_algo_channel; */
+	u8 ss_opmode;	/* singlestream Operational mode, 0:siso; 1:cdd */
+	bool ss_algosel_auto;	/* if true, use wlc->stf->ss_algo_channel; */
 	/* else use wlc->band->stf->ss_mode_band; */
-	uint16 ss_algo_channel;	/* ss based on per-channel algo: 0: SISO, 1: CDD 2: STBC */
-	uint8 no_cddstbc;	/* stf override, 1: no CDD (or STBC) allowed */
+	u16 ss_algo_channel;	/* ss based on per-channel algo: 0: SISO, 1: CDD 2: STBC */
+	u8 no_cddstbc;	/* stf override, 1: no CDD (or STBC) allowed */
 
-	uint8 rxchain_restore_delay;	/* delay time to restore default rxchain */
+	u8 rxchain_restore_delay;	/* delay time to restore default rxchain */
 
-	int8 ldpc;		/* AUTO/ON/OFF ldpc cap supported */
-	uint8 txcore[MAX_STREAMS_SUPPORTED + 1];	/* bitmap of selected core for each Nsts */
-	int8 spatial_policy;
+	s8 ldpc;		/* AUTO/ON/OFF ldpc cap supported */
+	u8 txcore[MAX_STREAMS_SUPPORTED + 1];	/* bitmap of selected core for each Nsts */
+	s8 spatial_policy;
 } wlc_stf_t;
 
 #define WLC_STF_SS_STBC_TX(wlc, scb) \
@@ -317,7 +321,7 @@ typedef struct wlccore {
 
 	/* fifo */
 	uint *txavail[NFIFO];	/* # tx descriptors available */
-	int16 txpktpend[NFIFO];	/* tx admission control */
+	s16 txpktpend[NFIFO];	/* tx admission control */
 #endif				/* WLC_LOW */
 
 	macstat_t *macstat_snapshot;	/* mac hw prev read values */
@@ -330,14 +334,14 @@ typedef struct wlcband {
 	int bandtype;		/* WLC_BAND_2G, WLC_BAND_5G */
 	uint bandunit;		/* bandstate[] index */
 
-	uint16 phytype;		/* phytype */
-	uint16 phyrev;
-	uint16 radioid;
-	uint16 radiorev;
+	u16 phytype;		/* phytype */
+	u16 phyrev;
+	u16 radioid;
+	u16 radiorev;
 	wlc_phy_t *pi;		/* pointer to phy specific information */
 	bool abgphy_encore;
 
-	uint8 gmode;		/* currently active gmode (see wlioctl.h) */
+	u8 gmode;		/* currently active gmode (see wlioctl.h) */
 
 	struct scb *hwrs_scb;	/* permanent scb for hw rateset */
 
@@ -345,28 +349,28 @@ typedef struct wlcband {
 
 	ratespec_t rspec_override;	/* 802.11 rate override */
 	ratespec_t mrspec_override;	/* multicast rate override */
-	uint8 band_stf_ss_mode;	/* Configured STF type, 0:siso; 1:cdd */
-	int8 band_stf_stbc_tx;	/* STBC TX 0:off; 1:force on; -1:auto */
+	u8 band_stf_ss_mode;	/* Configured STF type, 0:siso; 1:cdd */
+	s8 band_stf_stbc_tx;	/* STBC TX 0:off; 1:force on; -1:auto */
 	wlc_rateset_t hw_rateset;	/* rates supported by chip (phy-specific) */
-	uint8 basic_rate[WLC_MAXRATE + 1];	/* basic rates indexed by rate */
+	u8 basic_rate[WLC_MAXRATE + 1];	/* basic rates indexed by rate */
 	bool mimo_cap_40;	/* 40 MHz cap enabled on this band */
-	int8 antgain;		/* antenna gain from srom */
+	s8 antgain;		/* antenna gain from srom */
 
-	uint16 CWmin;		/* The minimum size of contention window, in unit of aSlotTime */
-	uint16 CWmax;		/* The maximum size of contention window, in unit of aSlotTime */
-	uint16 bcntsfoff;	/* beacon tsf offset */
+	u16 CWmin;		/* The minimum size of contention window, in unit of aSlotTime */
+	u16 CWmax;		/* The maximum size of contention window, in unit of aSlotTime */
+	u16 bcntsfoff;	/* beacon tsf offset */
 } wlcband_t;
 
 /* generic function callback takes just one arg */
 typedef void (*cb_fn_t) (void *);
 
 /* tx completion callback takes 3 args */
-typedef void (*pkcb_fn_t) (wlc_info_t * wlc, uint txstatus, void *arg);
+typedef void (*pkcb_fn_t) (wlc_info_t *wlc, uint txstatus, void *arg);
 
 typedef struct pkt_cb {
 	pkcb_fn_t fn;		/* function to call when tx frame completes */
 	void *arg;		/* void arg for fn */
-	uint8 nextidx;		/* index of next call back if threading */
+	u8 nextidx;		/* index of next call back if threading */
 	bool entered;		/* recursion check */
 } pkt_cb_t;
 
@@ -395,12 +399,12 @@ typedef struct dumpcb_s {
 /* virtual interface */
 struct wlc_if {
 	wlc_if_t *next;
-	uint8 type;		/* WLC_IFTYPE_BSS or WLC_IFTYPE_WDS */
-	uint8 index;		/* assigned in wl_add_if(), index of the wlif if any,
+	u8 type;		/* WLC_IFTYPE_BSS or WLC_IFTYPE_WDS */
+	u8 index;		/* assigned in wl_add_if(), index of the wlif if any,
 				 * not necessarily corresponding to bsscfg._idx or
 				 * AID2PVBMAP(scb).
 				 */
-	uint8 flags;		/* flags for the interface */
+	u8 flags;		/* flags for the interface */
 	wl_if_t *wlif;		/* pointer to wlif */
 	struct wlc_txq_info *qi;	/* pointer to associated tx queue */
 	union {
@@ -416,16 +420,16 @@ struct wlc_if {
 typedef struct wlc_hwband {
 	int bandtype;		/* WLC_BAND_2G, WLC_BAND_5G */
 	uint bandunit;		/* bandstate[] index */
-	uint16 mhfs[MHFMAX];	/* MHF array shadow */
-	uint8 bandhw_stf_ss_mode;	/* HW configured STF type, 0:siso; 1:cdd */
-	uint16 CWmin;
-	uint16 CWmax;
-	uint32 core_flags;
-
-	uint16 phytype;		/* phytype */
-	uint16 phyrev;
-	uint16 radioid;
-	uint16 radiorev;
+	u16 mhfs[MHFMAX];	/* MHF array shadow */
+	u8 bandhw_stf_ss_mode;	/* HW configured STF type, 0:siso; 1:cdd */
+	u16 CWmin;
+	u16 CWmax;
+	u32 core_flags;
+
+	u16 phytype;		/* phytype */
+	u16 phyrev;
+	u16 radioid;
+	u16 radiorev;
 	wlc_phy_t *pi;		/* pointer to phy specific information */
 	bool abgphy_encore;
 } wlc_hwband_t;
@@ -446,16 +450,16 @@ struct wlc_hw_info {
 	uint unit;		/* device instance number */
 
 	/* version info */
-	uint16 vendorid;	/* PCI vendor id */
-	uint16 deviceid;	/* PCI device id */
+	u16 vendorid;	/* PCI vendor id */
+	u16 deviceid;	/* PCI device id */
 	uint corerev;		/* core revision */
-	uint8 sromrev;		/* version # of the srom */
-	uint16 boardrev;	/* version # of particular board */
-	uint32 boardflags;	/* Board specific flags from srom */
-	uint32 boardflags2;	/* More board flags if sromrev >= 4 */
-	uint32 machwcap;	/* MAC capabilities (corerev >= 13) */
-	uint32 machwcap_backup;	/* backup of machwcap (corerev >= 13) */
-	uint16 ucode_dbgsel;	/* dbgsel for ucode debug(config gpio) */
+	u8 sromrev;		/* version # of the srom */
+	u16 boardrev;	/* version # of particular board */
+	u32 boardflags;	/* Board specific flags from srom */
+	u32 boardflags2;	/* More board flags if sromrev >= 4 */
+	u32 machwcap;	/* MAC capabilities (corerev >= 13) */
+	u32 machwcap_backup;	/* backup of machwcap (corerev >= 13) */
+	u16 ucode_dbgsel;	/* dbgsel for ucode debug(config gpio) */
 
 	si_t *sih;		/* SB handle (cookie for siutils calls) */
 	char *vars;		/* "environment" name=value */
@@ -465,12 +469,12 @@ struct wlc_hw_info {
 	void *phy_sh;		/* pointer to shared phy state */
 	wlc_hwband_t *band;	/* pointer to active per-band state */
 	wlc_hwband_t *bandstate[MAXBANDS];	/* per-band state (one per phy/radio) */
-	uint16 bmac_phytxant;	/* cache of high phytxant state */
+	u16 bmac_phytxant;	/* cache of high phytxant state */
 	bool shortslot;		/* currently using 11g ShortSlot timing */
-	uint16 SRL;		/* 802.11 dot11ShortRetryLimit */
-	uint16 LRL;		/* 802.11 dot11LongRetryLimit */
-	uint16 SFBL;		/* Short Frame Rate Fallback Limit */
-	uint16 LFBL;		/* Long Frame Rate Fallback Limit */
+	u16 SRL;		/* 802.11 dot11ShortRetryLimit */
+	u16 LRL;		/* 802.11 dot11LongRetryLimit */
+	u16 SFBL;		/* Short Frame Rate Fallback Limit */
+	u16 LFBL;		/* Long Frame Rate Fallback Limit */
 
 	bool up;		/* d11 hardware up and running */
 	uint now;		/* # elapsed seconds */
@@ -478,17 +482,17 @@ struct wlc_hw_info {
 	chanspec_t chanspec;	/* bmac chanspec shadow */
 
 	uint *txavail[NFIFO];	/* # tx descriptors available */
-	uint16 *xmtfifo_sz;	/* fifo size in 256B for each xmt fifo */
+	u16 *xmtfifo_sz;	/* fifo size in 256B for each xmt fifo */
 
 	mbool pllreq;		/* pll requests to keep PLL on */
 
-	uint8 suspended_fifos;	/* Which TX fifo to remain awake for */
-	uint32 maccontrol;	/* Cached value of maccontrol */
+	u8 suspended_fifos;	/* Which TX fifo to remain awake for */
+	u32 maccontrol;	/* Cached value of maccontrol */
 	uint mac_suspend_depth;	/* current depth of mac_suspend levels */
-	uint32 wake_override;	/* Various conditions to force MAC to WAKE mode */
-	uint32 mute_override;	/* Prevent ucode from sending beacons */
+	u32 wake_override;	/* Various conditions to force MAC to WAKE mode */
+	u32 mute_override;	/* Prevent ucode from sending beacons */
 	struct ether_addr etheraddr;	/* currently configured ethernet address */
-	uint32 led_gpio_mask;	/* LED GPIO Mask */
+	u32 led_gpio_mask;	/* LED GPIO Mask */
 	bool noreset;		/* true= do not reset hw, used by WLC_OUT */
 	bool forcefastclk;	/* true if the h/w is forcing the use of fast clk */
 	bool clk;		/* core is out of reset and has clock */
@@ -500,23 +504,23 @@ struct wlc_hw_info {
 #ifdef BCMSDIO
 	void *sdh;
 #endif
-	bool ucode_loaded;	/* TRUE after ucode downloaded */
+	bool ucode_loaded;	/* true after ucode downloaded */
 
 #ifdef WLC_LOW_ONLY
 	struct wl_timer *wdtimer;	/* timer for watchdog routine */
 	struct ether_addr orig_etheraddr;	/* original hw ethernet address */
-	uint16 rpc_dngl_agg;	/* rpc agg control for dongle */
-	uint32 mem_required_def;	/* memory required to replenish RX DMA ring */
-	uint32 mem_required_lower;	/* memory required with lower RX bound */
-	uint32 mem_required_least;	/* minimum memory requirement to handle RX */
+	u16 rpc_dngl_agg;	/* rpc agg control for dongle */
+	u32 mem_required_def;	/* memory required to replenish RX DMA ring */
+	u32 mem_required_lower;	/* memory required with lower RX bound */
+	u32 mem_required_least;	/* minimum memory requirement to handle RX */
 
 #endif				/* WLC_LOW_ONLY */
 
-	uint8 hw_stf_ss_opmode;	/* STF single stream operation mode */
-	uint8 antsel_type;	/* Type of boardlevel mimo antenna switch-logic
+	u8 hw_stf_ss_opmode;	/* STF single stream operation mode */
+	u8 antsel_type;	/* Type of boardlevel mimo antenna switch-logic
 				 * 0 = N/A, 1 = 2x4 board, 2 = 2x3 CB2 board
 				 */
-	uint32 antsel_avail;	/* put antsel_info_t here if more info is needed */
+	u32 antsel_avail;	/* put antsel_info_t here if more info is needed */
 #endif				/* WLC_LOW */
 };
 
@@ -549,12 +553,12 @@ struct wlc_info {
 
 	/* clock */
 	int clkreq_override;	/* setting for clkreq for PCIE : Auto, 0, 1 */
-	uint16 fastpwrup_dly;	/* time in us needed to bring up d11 fast clock */
+	u16 fastpwrup_dly;	/* time in us needed to bring up d11 fast clock */
 
 	/* interrupt */
-	uint32 macintstatus;	/* bit channel between isr and dpc */
-	uint32 macintmask;	/* sw runtime master macintmask value */
-	uint32 defmacintmask;	/* default "on" macintmask value */
+	u32 macintstatus;	/* bit channel between isr and dpc */
+	u32 macintmask;	/* sw runtime master macintmask value */
+	u32 defmacintmask;	/* default "on" macintmask value */
 
 	/* up and down */
 	bool device_present;	/* (removable) device is present */
@@ -577,14 +581,14 @@ struct wlc_info {
 	uint qvalid;		/* DirFrmQValid and BcMcFrmQValid */
 
 	/* Regulatory power limits */
-	int8 txpwr_local_max;	/* regulatory local txpwr max */
-	uint8 txpwr_local_constraint;	/* local power contraint in dB */
+	s8 txpwr_local_max;	/* regulatory local txpwr max */
+	u8 txpwr_local_constraint;	/* local power contraint in dB */
 
 #ifdef WLC_HIGH_ONLY
 	rpctx_info_t *rpctx;	/* RPC TX module */
 	bool reset_bmac_pending;	/* bmac reset is in progressing */
-	uint32 rpc_agg;		/* host agg: bit 16-31, bmac agg: bit 0-15 */
-	uint32 rpc_msglevel;	/* host rpc: bit 16-31, bmac rpc: bit 0-15 */
+	u32 rpc_agg;		/* host agg: bit 16-31, bmac agg: bit 0-15 */
+	u32 rpc_msglevel;	/* host rpc: bit 16-31, bmac rpc: bit 0-15 */
 #endif
 
 	ampdu_info_t *ampdu;	/* ampdu module handler */
@@ -595,11 +599,11 @@ struct wlc_info {
 
 	uint vars_size;		/* size of vars, free vars on detach */
 
-	uint16 vendorid;	/* PCI vendor id */
-	uint16 deviceid;	/* PCI device id */
+	u16 vendorid;	/* PCI vendor id */
+	u16 deviceid;	/* PCI device id */
 	uint ucode_rev;		/* microcode revision */
 
-	uint32 machwcap;	/* MAC capabilities, BMAC shadow */
+	u32 machwcap;	/* MAC capabilities, BMAC shadow */
 
 	struct ether_addr perm_etheraddr;	/* original sprom local ethernet address */
 
@@ -611,10 +615,10 @@ struct wlc_info {
 	bool going_down;	/* down path intermediate variable */
 
 	bool mpc;		/* enable minimum power consumption */
-	uint8 mpc_dlycnt;	/* # of watchdog cnt before turn disable radio */
-	uint8 mpc_offcnt;	/* # of watchdog cnt that radio is disabled */
-	uint8 mpc_delay_off;	/* delay radio disable by # of watchdog cnt */
-	uint8 prev_non_delay_mpc;	/* prev state wlc_is_non_delay_mpc */
+	u8 mpc_dlycnt;	/* # of watchdog cnt before turn disable radio */
+	u8 mpc_offcnt;	/* # of watchdog cnt that radio is disabled */
+	u8 mpc_delay_off;	/* delay radio disable by # of watchdog cnt */
+	u8 prev_non_delay_mpc;	/* prev state wlc_is_non_delay_mpc */
 
 	/* timer */
 	struct wl_timer *wdtimer;	/* timer for watchdog routine */
@@ -633,12 +637,12 @@ struct wlc_info {
 	bool bcnmisc_scan;	/* bcns promisc mode override for scan */
 	bool bcnmisc_monitor;	/* bcns promisc mode override for monitor */
 
-	uint8 bcn_wait_prd;	/* max waiting period (for beacon) in 1024TU */
+	u8 bcn_wait_prd;	/* max waiting period (for beacon) in 1024TU */
 
 	/* driver feature */
 	bool _rifs;		/* enable per-packet rifs */
-	int32 rifs_advert;	/* RIFS mode advertisement */
-	int8 sgi_tx;		/* sgi tx */
+	s32 rifs_advert;	/* RIFS mode advertisement */
+	s8 sgi_tx;		/* sgi tx */
 	bool wet;		/* true if wireless ethernet bridging mode */
 
 	/* AP-STA synchronization, power save */
@@ -651,43 +655,43 @@ struct wlc_info {
 				 * of scan, rm, etc. off home channel activity.
 				 */
 	bool PSpoll;		/* whether there is an outstanding PS-Poll frame */
-	uint8 PM;		/* power-management mode (CAM, PS or FASTPS) */
+	u8 PM;		/* power-management mode (CAM, PS or FASTPS) */
 	bool PMawakebcn;	/* bcn recvd during current waking state */
 
 	bool WME_PM_blocked;	/* Can STA go to PM when in WME Auto mode */
 	bool wake;		/* host-specified PS-mode sleep state */
-	uint8 pspoll_prd;	/* pspoll interval in milliseconds */
-	uint8 bcn_li_bcn;	/* beacon listen interval in # beacons */
-	uint8 bcn_li_dtim;	/* beacon listen interval in # dtims */
+	u8 pspoll_prd;	/* pspoll interval in milliseconds */
+	u8 bcn_li_bcn;	/* beacon listen interval in # beacons */
+	u8 bcn_li_dtim;	/* beacon listen interval in # dtims */
 
 	bool WDarmed;		/* watchdog timer is armed */
-	uint32 WDlast;		/* last time wlc_watchdog() was called */
+	u32 WDlast;		/* last time wlc_watchdog() was called */
 
 	/* WME */
 	ac_bitmap_t wme_dp;	/* Discard (oldest first) policy per AC */
 	bool wme_apsd;		/* enable Advanced Power Save Delivery */
 	ac_bitmap_t wme_admctl;	/* bit i set if AC i under admission control */
-	uint16 edcf_txop[AC_COUNT];	/* current txop for each ac */
+	u16 edcf_txop[AC_COUNT];	/* current txop for each ac */
 	wme_param_ie_t wme_param_ie;	/* WME parameter info element, which on STA
 					 * contains parameters in use locally, and on
 					 * AP contains parameters advertised to STA
 					 * in beacons and assoc responses.
 					 */
 	bool wme_prec_queuing;	/* enable/disable non-wme STA prec queuing */
-	uint16 wme_retries[AC_COUNT];	/* per-AC retry limits */
+	u16 wme_retries[AC_COUNT];	/* per-AC retry limits */
 
 	int vlan_mode;		/* OK to use 802.1Q Tags (ON, OFF, AUTO) */
-	uint16 tx_prec_map;	/* Precedence map based on HW FIFO space */
-	uint16 fifo2prec_map[NFIFO];	/* pointer to fifo2_prec map based on WME */
+	u16 tx_prec_map;	/* Precedence map based on HW FIFO space */
+	u16 fifo2prec_map[NFIFO];	/* pointer to fifo2_prec map based on WME */
 
 	/* BSS Configurations */
 	wlc_bsscfg_t *bsscfg[WLC_MAXBSSCFG];	/* set of BSS configurations, idx 0 is default and
 						 * always valid
 						 */
 	wlc_bsscfg_t *cfg;	/* the primary bsscfg (can be AP or STA) */
-	uint8 stas_associated;	/* count of ASSOCIATED STA bsscfgs */
-	uint8 aps_associated;	/* count of UP AP bsscfgs */
-	uint8 block_datafifo;	/* prohibit posting frames to data fifos */
+	u8 stas_associated;	/* count of ASSOCIATED STA bsscfgs */
+	u8 aps_associated;	/* count of UP AP bsscfgs */
+	u8 block_datafifo;	/* prohibit posting frames to data fifos */
 	bool bcmcfifo_drain;	/* TX_BCMC_FIFO is set to drain */
 
 	/* tx queue */
@@ -705,26 +709,25 @@ struct wlc_info {
 	modulecb_t *modulecb;
 	dumpcb_t *dumpcb_head;
 
-	uint8 mimoft;		/* SIGN or 11N */
-	uint8 mimo_band_bwcap;	/* bw cap per band type */
-	int8 txburst_limit_override;	/* tx burst limit override */
-	uint16 txburst_limit;	/* tx burst limit value */
-	int8 cck_40txbw;	/* 11N, cck tx b/w override when in 40MHZ mode */
-	int8 ofdm_40txbw;	/* 11N, ofdm tx b/w override when in 40MHZ mode */
-	int8 mimo_40txbw;	/* 11N, mimo tx b/w override when in 40MHZ mode */
+	u8 mimoft;		/* SIGN or 11N */
+	u8 mimo_band_bwcap;	/* bw cap per band type */
+	s8 txburst_limit_override;	/* tx burst limit override */
+	u16 txburst_limit;	/* tx burst limit value */
+	s8 cck_40txbw;	/* 11N, cck tx b/w override when in 40MHZ mode */
+	s8 ofdm_40txbw;	/* 11N, ofdm tx b/w override when in 40MHZ mode */
+	s8 mimo_40txbw;	/* 11N, mimo tx b/w override when in 40MHZ mode */
 	ht_cap_ie_t ht_cap;	/* HT CAP IE being advertised by this node */
-	ht_add_ie_t ht_add;	/* HT ADD IE being used by this node */
 
 	uint seckeys;		/* 54 key table shm address */
 	uint tkmickeys;		/* 12 TKIP MIC key table shm address */
 
 	wlc_bss_info_t *default_bss;	/* configured BSS parameters */
 
-	uint16 AID;		/* association ID */
-	uint16 counter;		/* per-sdu monotonically increasing counter */
-	uint16 mc_fid_counter;	/* BC/MC FIFO frame ID counter */
+	u16 AID;		/* association ID */
+	u16 counter;		/* per-sdu monotonically increasing counter */
+	u16 mc_fid_counter;	/* BC/MC FIFO frame ID counter */
 
-	bool ibss_allowed;	/* FALSE, all IBSS will be ignored during a scan
+	bool ibss_allowed;	/* false, all IBSS will be ignored during a scan
 				 * and the driver will not allow the creation of
 				 * an IBSS network
 				 */
@@ -740,7 +743,7 @@ struct wlc_info {
 	bcm_tlv_t *country_ie_override;	/* debug override of announced Country IE */
 #endif
 
-	uint16 prb_resp_timeout;	/* do not send prb resp if request older than this,
+	u16 prb_resp_timeout;	/* do not send prb resp if request older than this,
 					 * 0 = disable
 					 */
 
@@ -752,38 +755,38 @@ struct wlc_info {
 
 	/* PHY parameters */
 	chanspec_t chanspec;	/* target operational channel */
-	uint16 usr_fragthresh;	/* user configured fragmentation threshold */
-	uint16 fragthresh[NFIFO];	/* per-fifo fragmentation thresholds */
-	uint16 RTSThresh;	/* 802.11 dot11RTSThreshold */
-	uint16 SRL;		/* 802.11 dot11ShortRetryLimit */
-	uint16 LRL;		/* 802.11 dot11LongRetryLimit */
-	uint16 SFBL;		/* Short Frame Rate Fallback Limit */
-	uint16 LFBL;		/* Long Frame Rate Fallback Limit */
+	u16 usr_fragthresh;	/* user configured fragmentation threshold */
+	u16 fragthresh[NFIFO];	/* per-fifo fragmentation thresholds */
+	u16 RTSThresh;	/* 802.11 dot11RTSThreshold */
+	u16 SRL;		/* 802.11 dot11ShortRetryLimit */
+	u16 LRL;		/* 802.11 dot11LongRetryLimit */
+	u16 SFBL;		/* Short Frame Rate Fallback Limit */
+	u16 LFBL;		/* Long Frame Rate Fallback Limit */
 
 	/* network config */
 	bool shortpreamble;	/* currently operating with CCK ShortPreambles */
 	bool shortslot;		/* currently using 11g ShortSlot timing */
-	int8 barker_preamble;	/* current Barker Preamble Mode */
-	int8 shortslot_override;	/* 11g ShortSlot override */
+	s8 barker_preamble;	/* current Barker Preamble Mode */
+	s8 shortslot_override;	/* 11g ShortSlot override */
 	bool include_legacy_erp;	/* include Legacy ERP info elt ID 47 as well as g ID 42 */
-	bool barker_overlap_control;	/* TRUE: be aware of overlapping BSSs for barker */
+	bool barker_overlap_control;	/* true: be aware of overlapping BSSs for barker */
 	bool ignore_bcns;	/* override: ignore non shortslot bcns in a 11g network */
 	bool legacy_probe;	/* restricts probe requests to CCK rates */
 
 	wlc_protection_t *protection;
-	int8 PLCPHdr_override;	/* 802.11b Preamble Type override */
+	s8 PLCPHdr_override;	/* 802.11b Preamble Type override */
 
 	wlc_stf_t *stf;
 
 	pkt_cb_t *pkt_callback;	/* tx completion callback handlers */
 
-	uint32 txretried;	/* tx retried number in one msdu */
+	u32 txretried;	/* tx retried number in one msdu */
 
 	ratespec_t bcn_rspec;	/* save bcn ratespec purpose */
 
 	bool apsd_sta_usp;	/* Unscheduled Service Period in progress on STA */
 	struct wl_timer *apsd_trigger_timer;	/* timer for wme apsd trigger frames */
-	uint32 apsd_trigger_timeout;	/* timeout value for apsd_trigger_timer (in ms)
+	u32 apsd_trigger_timeout;	/* timeout value for apsd_trigger_timer (in ms)
 					 * 0 == disable
 					 */
 	ac_bitmap_t apsd_trigger_ac;	/* Permissible Acess Category in which APSD Null
@@ -791,29 +794,29 @@ struct wlc_info {
 					 */
 	wlc_ap_info_t *ap;
 
-	uint8 htphy_membership;	/* HT PHY membership */
+	u8 htphy_membership;	/* HT PHY membership */
 
 	bool _regulatory_domain;	/* 802.11d enabled? */
 
-	uint8 mimops_PM;
+	u8 mimops_PM;
 
-	uint8 txpwr_percent;	/* power output percentage */
+	u8 txpwr_percent;	/* power output percentage */
 
-	uint8 ht_wsec_restriction;	/* the restriction of HT with TKIP or WEP */
+	u8 ht_wsec_restriction;	/* the restriction of HT with TKIP or WEP */
 
 	uint tempsense_lasttime;
 
-	uint16 tx_duty_cycle_ofdm;	/* maximum allowed duty cycle for OFDM */
-	uint16 tx_duty_cycle_cck;	/* maximum allowed duty cycle for CCK */
+	u16 tx_duty_cycle_ofdm;	/* maximum allowed duty cycle for OFDM */
+	u16 tx_duty_cycle_cck;	/* maximum allowed duty cycle for CCK */
 
-	uint16 next_bsscfg_ID;
+	u16 next_bsscfg_ID;
 
 	wlc_if_t *wlcif_list;	/* linked list of wlc_if structs */
 	wlc_txq_info_t *active_queue;	/* txq for the currently active transmit context */
-	uint32 mpc_dur;		/* total time (ms) in mpc mode except for the
+	u32 mpc_dur;		/* total time (ms) in mpc mode except for the
 				 * portion since radio is turned off last time
 				 */
-	uint32 mpc_laston_ts;	/* timestamp (ms) when radio is turned off last
+	u32 mpc_laston_ts;	/* timestamp (ms) when radio is turned off last
 				 * time
 				 */
 	bool pr80838_war;
@@ -824,17 +827,17 @@ struct wlc_info {
 struct antsel_info {
 	wlc_info_t *wlc;	/* pointer to main wlc structure */
 	wlc_pub_t *pub;		/* pointer to public fn */
-	uint8 antsel_type;	/* Type of boardlevel mimo antenna switch-logic
+	u8 antsel_type;	/* Type of boardlevel mimo antenna switch-logic
 				 * 0 = N/A, 1 = 2x4 board, 2 = 2x3 CB2 board
 				 */
-	uint8 antsel_antswitch;	/* board level antenna switch type */
+	u8 antsel_antswitch;	/* board level antenna switch type */
 	bool antsel_avail;	/* Ant selection availability (SROM based) */
 	wlc_antselcfg_t antcfg_11n;	/* antenna configuration */
 	wlc_antselcfg_t antcfg_cur;	/* current antenna config (auto) */
 };
 
 #define	CHANNEL_BANDUNIT(wlc, ch) (((ch) <= CH_MAX_2G_CHANNEL) ? BAND_2G_INDEX : BAND_5G_INDEX)
-#define	OTHERBANDUNIT(wlc)	((uint)((wlc)->band->bandunit? BAND_2G_INDEX : BAND_5G_INDEX))
+#define	OTHERBANDUNIT(wlc)	((uint)((wlc)->band->bandunit ? BAND_2G_INDEX : BAND_5G_INDEX))
 
 #define IS_MBAND_UNLOCKED(wlc) \
 	((NBANDS(wlc) > 1) && !(wlc)->bandlocked)
@@ -847,8 +850,8 @@ struct antsel_info {
 
 /* sum the individual fifo tx pending packet counts */
 #if defined(WLC_HIGH_ONLY)
-#define TXPKTPENDTOT(wlc)		(wlc_rpctx_txpktpend((wlc)->rpctx, 0, TRUE))
-#define TXPKTPENDGET(wlc, fifo)		(wlc_rpctx_txpktpend((wlc)->rpctx, (fifo), FALSE))
+#define TXPKTPENDTOT(wlc)		(wlc_rpctx_txpktpend((wlc)->rpctx, 0, true))
+#define TXPKTPENDGET(wlc, fifo)		(wlc_rpctx_txpktpend((wlc)->rpctx, (fifo), false))
 #define TXPKTPENDINC(wlc, fifo, val)	(wlc_rpctx_txpktpendinc((wlc)->rpctx, (fifo), (val)))
 #define TXPKTPENDDEC(wlc, fifo, val)	(wlc_rpctx_txpktpenddec((wlc)->rpctx, (fifo), (val)))
 #define TXPKTPENDCLR(wlc, fifo)		(wlc_rpctx_txpktpendclr((wlc)->rpctx, (fifo)))
@@ -871,169 +874,167 @@ struct antsel_info {
 	((len1 == len2) && !bcmp(ssid1, ssid2, len1))
 
 /* API shared by both WLC_HIGH and WLC_LOW driver */
-extern void wlc_high_dpc(wlc_info_t * wlc, uint32 macintstatus);
-extern void wlc_fatal_error(wlc_info_t * wlc);
-extern void wlc_bmac_rpc_watchdog(wlc_info_t * wlc);
-extern void wlc_recv(wlc_info_t * wlc, void *p);
-extern bool wlc_dotxstatus(wlc_info_t * wlc, tx_status_t * txs, uint32 frm_tx2);
-extern void wlc_txfifo(wlc_info_t * wlc, uint fifo, void *p, bool commit,
-		       int8 txpktpend);
-extern void wlc_txfifo_complete(wlc_info_t * wlc, uint fifo, int8 txpktpend);
-extern void wlc_info_init(wlc_info_t * wlc, int unit);
-extern void wlc_print_txstatus(tx_status_t * txs);
-extern int wlc_xmtfifo_sz_get(wlc_info_t * wlc, uint fifo, uint * blocks);
-extern void wlc_write_template_ram(wlc_info_t * wlc, int offset, int len,
+extern void wlc_high_dpc(wlc_info_t *wlc, u32 macintstatus);
+extern void wlc_fatal_error(wlc_info_t *wlc);
+extern void wlc_bmac_rpc_watchdog(wlc_info_t *wlc);
+extern void wlc_recv(wlc_info_t *wlc, void *p);
+extern bool wlc_dotxstatus(wlc_info_t *wlc, tx_status_t *txs, u32 frm_tx2);
+extern void wlc_txfifo(wlc_info_t *wlc, uint fifo, void *p, bool commit,
+		       s8 txpktpend);
+extern void wlc_txfifo_complete(wlc_info_t *wlc, uint fifo, s8 txpktpend);
+extern void wlc_info_init(wlc_info_t *wlc, int unit);
+extern void wlc_print_txstatus(tx_status_t *txs);
+extern int wlc_xmtfifo_sz_get(wlc_info_t *wlc, uint fifo, uint *blocks);
+extern void wlc_write_template_ram(wlc_info_t *wlc, int offset, int len,
 				   void *buf);
-extern void wlc_write_hw_bcntemplates(wlc_info_t * wlc, void *bcn, int len,
+extern void wlc_write_hw_bcntemplates(wlc_info_t *wlc, void *bcn, int len,
 				      bool both);
 #if defined(BCMDBG)
-extern void wlc_get_rcmta(wlc_info_t * wlc, int idx, struct ether_addr *addr);
+extern void wlc_get_rcmta(wlc_info_t *wlc, int idx, struct ether_addr *addr);
 #endif
-extern void wlc_set_rcmta(wlc_info_t * wlc, int idx,
+extern void wlc_set_rcmta(wlc_info_t *wlc, int idx,
 			  const struct ether_addr *addr);
-extern void wlc_set_addrmatch(wlc_info_t * wlc, int match_reg_offset,
+extern void wlc_set_addrmatch(wlc_info_t *wlc, int match_reg_offset,
 			      const struct ether_addr *addr);
-extern void wlc_read_tsf(wlc_info_t * wlc, uint32 * tsf_l_ptr,
-			 uint32 * tsf_h_ptr);
-extern void wlc_set_cwmin(wlc_info_t * wlc, uint16 newmin);
-extern void wlc_set_cwmax(wlc_info_t * wlc, uint16 newmax);
-extern void wlc_fifoerrors(wlc_info_t * wlc);
-extern void wlc_pllreq(wlc_info_t * wlc, bool set, mbool req_bit);
-extern void wlc_reset_bmac_done(wlc_info_t * wlc);
-extern void wlc_protection_upd(wlc_info_t * wlc, uint idx, int val);
-extern void wlc_hwtimer_gptimer_set(wlc_info_t * wlc, uint us);
-extern void wlc_hwtimer_gptimer_abort(wlc_info_t * wlc);
-extern void wlc_pktengtx(wlc_info_t * wlc, wl_pkteng_t * pkteng, uint8 rate,
-			 struct ether_addr *sa, uint32 wait_delay);
+extern void wlc_read_tsf(wlc_info_t *wlc, u32 *tsf_l_ptr,
+			 u32 *tsf_h_ptr);
+extern void wlc_set_cwmin(wlc_info_t *wlc, u16 newmin);
+extern void wlc_set_cwmax(wlc_info_t *wlc, u16 newmax);
+extern void wlc_fifoerrors(wlc_info_t *wlc);
+extern void wlc_pllreq(wlc_info_t *wlc, bool set, mbool req_bit);
+extern void wlc_reset_bmac_done(wlc_info_t *wlc);
+extern void wlc_protection_upd(wlc_info_t *wlc, uint idx, int val);
+extern void wlc_hwtimer_gptimer_set(wlc_info_t *wlc, uint us);
+extern void wlc_hwtimer_gptimer_abort(wlc_info_t *wlc);
 
 #if defined(BCMDBG)
-extern void wlc_print_rxh(d11rxhdr_t * rxh);
-extern void wlc_print_hdrs(wlc_info_t * wlc, const char *prefix, uint8 * frame,
-			   d11txh_t * txh, d11rxhdr_t * rxh, uint len);
-extern void wlc_print_txdesc(d11txh_t * txh);
+extern void wlc_print_rxh(d11rxhdr_t *rxh);
+extern void wlc_print_hdrs(wlc_info_t *wlc, const char *prefix, u8 *frame,
+			   d11txh_t *txh, d11rxhdr_t *rxh, uint len);
+extern void wlc_print_txdesc(d11txh_t *txh);
 #endif
 #if defined(BCMDBG)
-extern void wlc_print_dot11_mac_hdr(uint8 * buf, int len);
+extern void wlc_print_dot11_mac_hdr(u8 *buf, int len);
 #endif
 
 #ifdef WLC_LOW
-extern void wlc_setxband(wlc_hw_info_t * wlc_hw, uint bandunit);
-extern void wlc_coredisable(wlc_hw_info_t * wlc_hw);
+extern void wlc_setxband(wlc_hw_info_t *wlc_hw, uint bandunit);
+extern void wlc_coredisable(wlc_hw_info_t *wlc_hw);
 #endif
 
-extern bool wlc_valid_rate(wlc_info_t * wlc, ratespec_t rate, int band,
+extern bool wlc_valid_rate(wlc_info_t *wlc, ratespec_t rate, int band,
 			   bool verbose);
-extern void wlc_ap_upd(wlc_info_t * wlc);
+extern void wlc_ap_upd(wlc_info_t *wlc);
 
 /* helper functions */
-extern void wlc_shm_ssid_upd(wlc_info_t * wlc, wlc_bsscfg_t * cfg);
-extern int wlc_set_gmode(wlc_info_t * wlc, uint8 gmode, bool config);
+extern void wlc_shm_ssid_upd(wlc_info_t *wlc, wlc_bsscfg_t *cfg);
+extern int wlc_set_gmode(wlc_info_t *wlc, u8 gmode, bool config);
 
-extern void wlc_mac_bcn_promisc_change(wlc_info_t * wlc, bool promisc);
-extern void wlc_mac_bcn_promisc(wlc_info_t * wlc);
-extern void wlc_mac_promisc(wlc_info_t * wlc);
-extern void wlc_txflowcontrol(wlc_info_t * wlc, wlc_txq_info_t * qi, bool on,
+extern void wlc_mac_bcn_promisc_change(wlc_info_t *wlc, bool promisc);
+extern void wlc_mac_bcn_promisc(wlc_info_t *wlc);
+extern void wlc_mac_promisc(wlc_info_t *wlc);
+extern void wlc_txflowcontrol(wlc_info_t *wlc, wlc_txq_info_t *qi, bool on,
 			      int prio);
-extern void wlc_txflowcontrol_override(wlc_info_t * wlc, wlc_txq_info_t * qi,
+extern void wlc_txflowcontrol_override(wlc_info_t *wlc, wlc_txq_info_t *qi,
 				       bool on, uint override);
-extern bool wlc_txflowcontrol_prio_isset(wlc_info_t * wlc, wlc_txq_info_t * qi,
+extern bool wlc_txflowcontrol_prio_isset(wlc_info_t *wlc, wlc_txq_info_t *qi,
 					 int prio);
-extern void wlc_send_q(wlc_info_t * wlc, wlc_txq_info_t * qi);
-extern int wlc_prep_pdu(wlc_info_t * wlc, void *pdu, uint * fifo);
+extern void wlc_send_q(wlc_info_t *wlc, wlc_txq_info_t *qi);
+extern int wlc_prep_pdu(wlc_info_t *wlc, void *pdu, uint *fifo);
 
-extern uint16 wlc_calc_lsig_len(wlc_info_t * wlc, ratespec_t ratespec,
+extern u16 wlc_calc_lsig_len(wlc_info_t *wlc, ratespec_t ratespec,
 				uint mac_len);
-extern ratespec_t wlc_rspec_to_rts_rspec(wlc_info_t * wlc, ratespec_t rspec,
-					 bool use_rspec, uint16 mimo_ctlchbw);
-extern uint16 wlc_compute_rtscts_dur(wlc_info_t * wlc, bool cts_only,
+extern ratespec_t wlc_rspec_to_rts_rspec(wlc_info_t *wlc, ratespec_t rspec,
+					 bool use_rspec, u16 mimo_ctlchbw);
+extern u16 wlc_compute_rtscts_dur(wlc_info_t *wlc, bool cts_only,
 				     ratespec_t rts_rate, ratespec_t frame_rate,
-				     uint8 rts_preamble_type,
-				     uint8 frame_preamble_type, uint frame_len,
+				     u8 rts_preamble_type,
+				     u8 frame_preamble_type, uint frame_len,
 				     bool ba);
 
-extern void wlc_tbtt(wlc_info_t * wlc, d11regs_t * regs);
+extern void wlc_tbtt(wlc_info_t *wlc, d11regs_t *regs);
 
 #if defined(BCMDBG)
-extern void wlc_dump_ie(wlc_info_t * wlc, bcm_tlv_t * ie, struct bcmstrbuf *b);
+extern void wlc_dump_ie(wlc_info_t *wlc, bcm_tlv_t *ie, struct bcmstrbuf *b);
 #endif
 
-extern bool wlc_ps_check(wlc_info_t * wlc);
-extern void wlc_reprate_init(wlc_info_t * wlc);
-extern void wlc_bsscfg_reprate_init(wlc_bsscfg_t * bsscfg);
-extern void wlc_uint64_sub(uint32 * a_high, uint32 * a_low, uint32 b_high,
-			   uint32 b_low);
-extern uint32 wlc_calc_tbtt_offset(uint32 bi, uint32 tsf_h, uint32 tsf_l);
+extern bool wlc_ps_check(wlc_info_t *wlc);
+extern void wlc_reprate_init(wlc_info_t *wlc);
+extern void wlc_bsscfg_reprate_init(wlc_bsscfg_t *bsscfg);
+extern void wlc_uint64_sub(u32 *a_high, u32 *a_low, u32 b_high,
+			   u32 b_low);
+extern u32 wlc_calc_tbtt_offset(u32 bi, u32 tsf_h, u32 tsf_l);
 
 /* Shared memory access */
-extern void wlc_write_shm(wlc_info_t * wlc, uint offset, uint16 v);
-extern uint16 wlc_read_shm(wlc_info_t * wlc, uint offset);
-extern void wlc_set_shm(wlc_info_t * wlc, uint offset, uint16 v, int len);
-extern void wlc_copyto_shm(wlc_info_t * wlc, uint offset, const void *buf,
+extern void wlc_write_shm(wlc_info_t *wlc, uint offset, u16 v);
+extern u16 wlc_read_shm(wlc_info_t *wlc, uint offset);
+extern void wlc_set_shm(wlc_info_t *wlc, uint offset, u16 v, int len);
+extern void wlc_copyto_shm(wlc_info_t *wlc, uint offset, const void *buf,
 			   int len);
-extern void wlc_copyfrom_shm(wlc_info_t * wlc, uint offset, void *buf, int len);
+extern void wlc_copyfrom_shm(wlc_info_t *wlc, uint offset, void *buf, int len);
 
-extern void wlc_update_beacon(wlc_info_t * wlc);
-extern void wlc_bss_update_beacon(wlc_info_t * wlc, struct wlc_bsscfg *bsscfg);
+extern void wlc_update_beacon(wlc_info_t *wlc);
+extern void wlc_bss_update_beacon(wlc_info_t *wlc, struct wlc_bsscfg *bsscfg);
 
-extern void wlc_update_probe_resp(wlc_info_t * wlc, bool suspend);
-extern void wlc_bss_update_probe_resp(wlc_info_t * wlc, wlc_bsscfg_t * cfg,
+extern void wlc_update_probe_resp(wlc_info_t *wlc, bool suspend);
+extern void wlc_bss_update_probe_resp(wlc_info_t *wlc, wlc_bsscfg_t *cfg,
 				      bool suspend);
 
-extern bool wlc_ismpc(wlc_info_t * wlc);
-extern bool wlc_is_non_delay_mpc(wlc_info_t * wlc);
-extern void wlc_radio_mpc_upd(wlc_info_t * wlc);
-extern bool wlc_prec_enq(wlc_info_t * wlc, struct pktq *q, void *pkt, int prec);
-extern bool wlc_prec_enq_head(wlc_info_t * wlc, struct pktq *q, void *pkt,
+extern bool wlc_ismpc(wlc_info_t *wlc);
+extern bool wlc_is_non_delay_mpc(wlc_info_t *wlc);
+extern void wlc_radio_mpc_upd(wlc_info_t *wlc);
+extern bool wlc_prec_enq(wlc_info_t *wlc, struct pktq *q, void *pkt, int prec);
+extern bool wlc_prec_enq_head(wlc_info_t *wlc, struct pktq *q, void *pkt,
 			      int prec, bool head);
-extern uint16 wlc_phytxctl1_calc(wlc_info_t * wlc, ratespec_t rspec);
-extern void wlc_compute_plcp(wlc_info_t * wlc, ratespec_t rate, uint length,
-			     uint8 * plcp);
-extern uint wlc_calc_frame_time(wlc_info_t * wlc, ratespec_t ratespec,
-				uint8 preamble_type, uint mac_len);
+extern u16 wlc_phytxctl1_calc(wlc_info_t *wlc, ratespec_t rspec);
+extern void wlc_compute_plcp(wlc_info_t *wlc, ratespec_t rate, uint length,
+			     u8 *plcp);
+extern uint wlc_calc_frame_time(wlc_info_t *wlc, ratespec_t ratespec,
+				u8 preamble_type, uint mac_len);
 
-extern void wlc_set_chanspec(wlc_info_t * wlc, chanspec_t chanspec);
+extern void wlc_set_chanspec(wlc_info_t *wlc, chanspec_t chanspec);
 
-extern bool wlc_timers_init(wlc_info_t * wlc, int unit);
+extern bool wlc_timers_init(wlc_info_t *wlc, int unit);
 
 extern const bcm_iovar_t wlc_iovars[];
 
-extern int wlc_doiovar(void *hdl, const bcm_iovar_t * vi, uint32 actionid,
+extern int wlc_doiovar(void *hdl, const bcm_iovar_t *vi, u32 actionid,
 		       const char *name, void *params, uint p_len, void *arg,
-		       int len, int val_size, wlc_if_t * wlcif);
+		       int len, int val_size, wlc_if_t *wlcif);
 
 #if defined(BCMDBG)
-extern void wlc_print_ies(wlc_info_t * wlc, uint8 * ies, uint ies_len);
+extern void wlc_print_ies(wlc_info_t *wlc, u8 *ies, uint ies_len);
 #endif
 
-extern int wlc_set_nmode(wlc_info_t * wlc, int32 nmode);
-extern void wlc_ht_mimops_cap_update(wlc_info_t * wlc, uint8 mimops_mode);
-extern void wlc_mimops_action_ht_send(wlc_info_t * wlc, wlc_bsscfg_t * bsscfg,
-				      uint8 mimops_mode);
+extern int wlc_set_nmode(wlc_info_t *wlc, s32 nmode);
+extern void wlc_ht_mimops_cap_update(wlc_info_t *wlc, u8 mimops_mode);
+extern void wlc_mimops_action_ht_send(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg,
+				      u8 mimops_mode);
 
-extern void wlc_switch_shortslot(wlc_info_t * wlc, bool shortslot);
-extern void wlc_set_bssid(wlc_bsscfg_t * cfg);
-extern void wlc_edcf_setparams(wlc_bsscfg_t * cfg, bool suspend);
-extern void wlc_wme_setparams(wlc_info_t * wlc, u16 aci, void *arg,
+extern void wlc_switch_shortslot(wlc_info_t *wlc, bool shortslot);
+extern void wlc_set_bssid(wlc_bsscfg_t *cfg);
+extern void wlc_edcf_setparams(wlc_bsscfg_t *cfg, bool suspend);
+extern void wlc_wme_setparams(wlc_info_t *wlc, u16 aci, void *arg,
 			      bool suspend);
 
-extern void wlc_set_ratetable(wlc_info_t * wlc);
-extern int wlc_set_mac(wlc_bsscfg_t * cfg);
-extern void wlc_beacon_phytxctl_txant_upd(wlc_info_t * wlc,
+extern void wlc_set_ratetable(wlc_info_t *wlc);
+extern int wlc_set_mac(wlc_bsscfg_t *cfg);
+extern void wlc_beacon_phytxctl_txant_upd(wlc_info_t *wlc,
 					  ratespec_t bcn_rate);
-extern void wlc_mod_prb_rsp_rate_table(wlc_info_t * wlc, uint frame_len);
-extern ratespec_t wlc_lowest_basic_rspec(wlc_info_t * wlc, wlc_rateset_t * rs);
-extern uint16 wlc_compute_bcntsfoff(wlc_info_t * wlc, ratespec_t rspec,
+extern void wlc_mod_prb_rsp_rate_table(wlc_info_t *wlc, uint frame_len);
+extern ratespec_t wlc_lowest_basic_rspec(wlc_info_t *wlc, wlc_rateset_t *rs);
+extern u16 wlc_compute_bcntsfoff(wlc_info_t *wlc, ratespec_t rspec,
 				    bool short_preamble, bool phydelay);
-extern void wlc_radio_disable(wlc_info_t * wlc);
-extern void wlc_bcn_li_upd(wlc_info_t * wlc);
-
-extern int wlc_get_revision_info(wlc_info_t * wlc, void *buf, uint len);
-extern void wlc_out(wlc_info_t * wlc);
-extern void wlc_set_home_chanspec(wlc_info_t * wlc, chanspec_t chanspec);
-extern void wlc_watchdog_upd(wlc_info_t * wlc, bool tbtt);
-extern bool wlc_ps_allowed(wlc_info_t * wlc);
-extern bool wlc_stay_awake(wlc_info_t * wlc);
-extern void wlc_wme_initparams_sta(wlc_info_t * wlc, wme_param_ie_t * pe);
-
-extern void wlc_bss_list_free(wlc_info_t * wlc, wlc_bss_list_t * bss_list);
+extern void wlc_radio_disable(wlc_info_t *wlc);
+extern void wlc_bcn_li_upd(wlc_info_t *wlc);
+
+extern int wlc_get_revision_info(wlc_info_t *wlc, void *buf, uint len);
+extern void wlc_out(wlc_info_t *wlc);
+extern void wlc_set_home_chanspec(wlc_info_t *wlc, chanspec_t chanspec);
+extern void wlc_watchdog_upd(wlc_info_t *wlc, bool tbtt);
+extern bool wlc_ps_allowed(wlc_info_t *wlc);
+extern bool wlc_stay_awake(wlc_info_t *wlc);
+extern void wlc_wme_initparams_sta(wlc_info_t *wlc, wme_param_ie_t *pe);
+
+extern void wlc_bss_list_free(wlc_info_t *wlc, wlc_bss_list_t *bss_list);
 #endif				/* _wlc_h_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_phy_shim.c b/drivers/staging/brcm80211/sys/wlc_phy_shim.c
index 535ba8c..bf8e2e1 100644
--- a/drivers/staging/brcm80211/sys/wlc_phy_shim.c
+++ b/drivers/staging/brcm80211/sys/wlc_phy_shim.c
@@ -21,10 +21,11 @@
  *   access to wlc_hw pointer.
  */
 
+#include <linux/kernel.h>
+#include <bcmdefs.h>
 #include <wlc_cfg.h>
-#include <typedefs.h>
+#include <linuxver.h>
 #include <bcmutils.h>
-#include <bcmdefs.h>
 #include <osl.h>
 
 #include <proto/802.11.h>
@@ -60,18 +61,15 @@ struct wlc_phy_shim_info {
 	void *wl;		/* pointer to os-specific private state */
 };
 
-wlc_phy_shim_info_t *BCMATTACHFN(wlc_phy_shim_attach) (wlc_hw_info_t * wlc_hw,
+wlc_phy_shim_info_t *wlc_phy_shim_attach(wlc_hw_info_t *wlc_hw,
 						       void *wl, void *wlc) {
 	wlc_phy_shim_info_t *physhim = NULL;
 
-	if (!
-	    (physhim =
-	     (wlc_phy_shim_info_t *) MALLOC(wlc_hw->osh,
-					    sizeof(wlc_phy_shim_info_t)))) {
-		WL_ERROR(("wl%d: wlc_phy_shim_attach: out of mem, malloced %d bytes\n", wlc_hw->unit, MALLOCED(wlc_hw->osh)));
+	physhim = kzalloc(sizeof(wlc_phy_shim_info_t), GFP_ATOMIC);
+	if (!physhim) {
+		WL_ERROR(("wl%d: wlc_phy_shim_attach: out of mem\n", wlc_hw->unit));
 		return NULL;
 	}
-	bzero((char *)physhim, sizeof(wlc_phy_shim_info_t));
 	physhim->wlc_hw = wlc_hw;
 	physhim->wlc = wlc;
 	physhim->wl = wl;
@@ -79,173 +77,167 @@ wlc_phy_shim_info_t *BCMATTACHFN(wlc_phy_shim_attach) (wlc_hw_info_t * wlc_hw,
 	return physhim;
 }
 
-void BCMATTACHFN(wlc_phy_shim_detach) (wlc_phy_shim_info_t * physhim) {
+void wlc_phy_shim_detach(wlc_phy_shim_info_t *physhim)
+{
 	if (!physhim)
 		return;
 
-	MFREE(physhim->wlc_hw->osh, physhim, sizeof(wlc_phy_shim_info_t));
+	kfree(physhim);
 }
 
-struct wlapi_timer *wlapi_init_timer(wlc_phy_shim_info_t * physhim,
+struct wlapi_timer *wlapi_init_timer(wlc_phy_shim_info_t *physhim,
 				     void (*fn) (void *arg), void *arg,
 				     const char *name)
 {
 	return (struct wlapi_timer *)wl_init_timer(physhim->wl, fn, arg, name);
 }
 
-void wlapi_free_timer(wlc_phy_shim_info_t * physhim, struct wlapi_timer *t)
+void wlapi_free_timer(wlc_phy_shim_info_t *physhim, struct wlapi_timer *t)
 {
 	wl_free_timer(physhim->wl, (struct wl_timer *)t);
 }
 
 void
-wlapi_add_timer(wlc_phy_shim_info_t * physhim, struct wlapi_timer *t, uint ms,
+wlapi_add_timer(wlc_phy_shim_info_t *physhim, struct wlapi_timer *t, uint ms,
 		int periodic)
 {
 	wl_add_timer(physhim->wl, (struct wl_timer *)t, ms, periodic);
 }
 
-bool wlapi_del_timer(wlc_phy_shim_info_t * physhim, struct wlapi_timer *t)
+bool wlapi_del_timer(wlc_phy_shim_info_t *physhim, struct wlapi_timer *t)
 {
 	return wl_del_timer(physhim->wl, (struct wl_timer *)t);
 }
 
-void wlapi_intrson(wlc_phy_shim_info_t * physhim)
+void wlapi_intrson(wlc_phy_shim_info_t *physhim)
 {
 	wl_intrson(physhim->wl);
 }
 
-uint32 wlapi_intrsoff(wlc_phy_shim_info_t * physhim)
+u32 wlapi_intrsoff(wlc_phy_shim_info_t *physhim)
 {
 	return wl_intrsoff(physhim->wl);
 }
 
-void wlapi_intrsrestore(wlc_phy_shim_info_t * physhim, uint32 macintmask)
+void wlapi_intrsrestore(wlc_phy_shim_info_t *physhim, u32 macintmask)
 {
 	wl_intrsrestore(physhim->wl, macintmask);
 }
 
-void wlapi_bmac_write_shm(wlc_phy_shim_info_t * physhim, uint offset, uint16 v)
+void wlapi_bmac_write_shm(wlc_phy_shim_info_t *physhim, uint offset, u16 v)
 {
 	wlc_bmac_write_shm(physhim->wlc_hw, offset, v);
 }
 
-uint16 wlapi_bmac_read_shm(wlc_phy_shim_info_t * physhim, uint offset)
+u16 wlapi_bmac_read_shm(wlc_phy_shim_info_t *physhim, uint offset)
 {
 	return wlc_bmac_read_shm(physhim->wlc_hw, offset);
 }
 
 void
-wlapi_bmac_mhf(wlc_phy_shim_info_t * physhim, uint8 idx, uint16 mask,
-	       uint16 val, int bands)
+wlapi_bmac_mhf(wlc_phy_shim_info_t *physhim, u8 idx, u16 mask,
+	       u16 val, int bands)
 {
 	wlc_bmac_mhf(physhim->wlc_hw, idx, mask, val, bands);
 }
 
-void wlapi_bmac_corereset(wlc_phy_shim_info_t * physhim, uint32 flags)
+void wlapi_bmac_corereset(wlc_phy_shim_info_t *physhim, u32 flags)
 {
 	wlc_bmac_corereset(physhim->wlc_hw, flags);
 }
 
-void wlapi_suspend_mac_and_wait(wlc_phy_shim_info_t * physhim)
+void wlapi_suspend_mac_and_wait(wlc_phy_shim_info_t *physhim)
 {
 	wlc_suspend_mac_and_wait(physhim->wlc);
 }
 
-void wlapi_switch_macfreq(wlc_phy_shim_info_t * physhim, uint8 spurmode)
+void wlapi_switch_macfreq(wlc_phy_shim_info_t *physhim, u8 spurmode)
 {
 	wlc_bmac_switch_macfreq(physhim->wlc_hw, spurmode);
 }
 
-void wlapi_enable_mac(wlc_phy_shim_info_t * physhim)
+void wlapi_enable_mac(wlc_phy_shim_info_t *physhim)
 {
 	wlc_enable_mac(physhim->wlc);
 }
 
-void wlapi_bmac_mctrl(wlc_phy_shim_info_t * physhim, uint32 mask, uint32 val)
+void wlapi_bmac_mctrl(wlc_phy_shim_info_t *physhim, u32 mask, u32 val)
 {
 	wlc_bmac_mctrl(physhim->wlc_hw, mask, val);
 }
 
-void wlapi_bmac_phy_reset(wlc_phy_shim_info_t * physhim)
+void wlapi_bmac_phy_reset(wlc_phy_shim_info_t *physhim)
 {
 	wlc_bmac_phy_reset(physhim->wlc_hw);
 }
 
-void wlapi_bmac_bw_set(wlc_phy_shim_info_t * physhim, uint16 bw)
+void wlapi_bmac_bw_set(wlc_phy_shim_info_t *physhim, u16 bw)
 {
 	wlc_bmac_bw_set(physhim->wlc_hw, bw);
 }
 
-uint16 wlapi_bmac_get_txant(wlc_phy_shim_info_t * physhim)
+u16 wlapi_bmac_get_txant(wlc_phy_shim_info_t *physhim)
 {
 	return wlc_bmac_get_txant(physhim->wlc_hw);
 }
 
-void wlapi_bmac_phyclk_fgc(wlc_phy_shim_info_t * physhim, bool clk)
+void wlapi_bmac_phyclk_fgc(wlc_phy_shim_info_t *physhim, bool clk)
 {
 	wlc_bmac_phyclk_fgc(physhim->wlc_hw, clk);
 }
 
-void wlapi_bmac_macphyclk_set(wlc_phy_shim_info_t * physhim, bool clk)
+void wlapi_bmac_macphyclk_set(wlc_phy_shim_info_t *physhim, bool clk)
 {
 	wlc_bmac_macphyclk_set(physhim->wlc_hw, clk);
 }
 
-void wlapi_bmac_core_phypll_ctl(wlc_phy_shim_info_t * physhim, bool on)
+void wlapi_bmac_core_phypll_ctl(wlc_phy_shim_info_t *physhim, bool on)
 {
 	wlc_bmac_core_phypll_ctl(physhim->wlc_hw, on);
 }
 
-void wlapi_bmac_core_phypll_reset(wlc_phy_shim_info_t * physhim)
+void wlapi_bmac_core_phypll_reset(wlc_phy_shim_info_t *physhim)
 {
 	wlc_bmac_core_phypll_reset(physhim->wlc_hw);
 }
 
-void wlapi_bmac_ucode_wake_override_phyreg_set(wlc_phy_shim_info_t * physhim)
+void wlapi_bmac_ucode_wake_override_phyreg_set(wlc_phy_shim_info_t *physhim)
 {
 	wlc_ucode_wake_override_set(physhim->wlc_hw, WLC_WAKE_OVERRIDE_PHYREG);
 }
 
-void wlapi_bmac_ucode_wake_override_phyreg_clear(wlc_phy_shim_info_t * physhim)
+void wlapi_bmac_ucode_wake_override_phyreg_clear(wlc_phy_shim_info_t *physhim)
 {
 	wlc_ucode_wake_override_clear(physhim->wlc_hw,
 				      WLC_WAKE_OVERRIDE_PHYREG);
 }
 
 void
-wlapi_bmac_write_template_ram(wlc_phy_shim_info_t * physhim, int offset,
+wlapi_bmac_write_template_ram(wlc_phy_shim_info_t *physhim, int offset,
 			      int len, void *buf)
 {
 	wlc_bmac_write_template_ram(physhim->wlc_hw, offset, len, buf);
 }
 
-uint16 wlapi_bmac_rate_shm_offset(wlc_phy_shim_info_t * physhim, uint8 rate)
+u16 wlapi_bmac_rate_shm_offset(wlc_phy_shim_info_t *physhim, u8 rate)
 {
 	return wlc_bmac_rate_shm_offset(physhim->wlc_hw, rate);
 }
 
-void wlapi_ucode_sample_init(wlc_phy_shim_info_t * physhim)
+void wlapi_ucode_sample_init(wlc_phy_shim_info_t *physhim)
 {
 }
 
 void
-wlapi_copyfrom_objmem(wlc_phy_shim_info_t * physhim, uint offset, void *buf,
-		      int len, uint32 sel)
+wlapi_copyfrom_objmem(wlc_phy_shim_info_t *physhim, uint offset, void *buf,
+		      int len, u32 sel)
 {
 	wlc_bmac_copyfrom_objmem(physhim->wlc_hw, offset, buf, len, sel);
 }
 
 void
-wlapi_copyto_objmem(wlc_phy_shim_info_t * physhim, uint offset, const void *buf,
-		    int l, uint32 sel)
+wlapi_copyto_objmem(wlc_phy_shim_info_t *physhim, uint offset, const void *buf,
+		    int l, u32 sel)
 {
 	wlc_bmac_copyto_objmem(physhim->wlc_hw, offset, buf, l, sel);
 }
-
-void
-wlapi_bmac_pktengtx(wlc_phy_shim_info_t * physhim, wl_pkteng_t * pkteng,
-		    uint8 rate, struct ether_addr *sa, uint32 wait_delay)
-{
-	wlc_pktengtx(physhim->wlc, pkteng, rate, sa, wait_delay);
-}
diff --git a/drivers/staging/brcm80211/sys/wlc_phy_shim.h b/drivers/staging/brcm80211/sys/wlc_phy_shim.h
index 73c83a4..c151a5d 100644
--- a/drivers/staging/brcm80211/sys/wlc_phy_shim.h
+++ b/drivers/staging/brcm80211/sys/wlc_phy_shim.h
@@ -57,59 +57,56 @@ typedef struct wlc_phy_shim_info wlc_phy_shim_info_t;
 
 extern wlc_phy_shim_info_t *wlc_phy_shim_attach(struct wlc_hw_info *wlc_hw,
 						void *wl, void *wlc);
-extern void wlc_phy_shim_detach(wlc_phy_shim_info_t * physhim);
+extern void wlc_phy_shim_detach(wlc_phy_shim_info_t *physhim);
 
 /* PHY to WL utility functions */
 struct wlapi_timer;
-extern struct wlapi_timer *wlapi_init_timer(wlc_phy_shim_info_t * physhim,
+extern struct wlapi_timer *wlapi_init_timer(wlc_phy_shim_info_t *physhim,
 					    void (*fn) (void *arg), void *arg,
 					    const char *name);
-extern void wlapi_free_timer(wlc_phy_shim_info_t * physhim,
+extern void wlapi_free_timer(wlc_phy_shim_info_t *physhim,
 			     struct wlapi_timer *t);
-extern void wlapi_add_timer(wlc_phy_shim_info_t * physhim,
+extern void wlapi_add_timer(wlc_phy_shim_info_t *physhim,
 			    struct wlapi_timer *t, uint ms, int periodic);
-extern bool wlapi_del_timer(wlc_phy_shim_info_t * physhim,
+extern bool wlapi_del_timer(wlc_phy_shim_info_t *physhim,
 			    struct wlapi_timer *t);
-extern void wlapi_intrson(wlc_phy_shim_info_t * physhim);
-extern uint32 wlapi_intrsoff(wlc_phy_shim_info_t * physhim);
-extern void wlapi_intrsrestore(wlc_phy_shim_info_t * physhim,
-			       uint32 macintmask);
+extern void wlapi_intrson(wlc_phy_shim_info_t *physhim);
+extern u32 wlapi_intrsoff(wlc_phy_shim_info_t *physhim);
+extern void wlapi_intrsrestore(wlc_phy_shim_info_t *physhim,
+			       u32 macintmask);
 
-extern void wlapi_bmac_write_shm(wlc_phy_shim_info_t * physhim, uint offset,
-				 uint16 v);
-extern uint16 wlapi_bmac_read_shm(wlc_phy_shim_info_t * physhim, uint offset);
-extern void wlapi_bmac_mhf(wlc_phy_shim_info_t * physhim, uint8 idx,
-			   uint16 mask, uint16 val, int bands);
-extern void wlapi_bmac_corereset(wlc_phy_shim_info_t * physhim, uint32 flags);
-extern void wlapi_suspend_mac_and_wait(wlc_phy_shim_info_t * physhim);
-extern void wlapi_switch_macfreq(wlc_phy_shim_info_t * physhim, uint8 spurmode);
-extern void wlapi_enable_mac(wlc_phy_shim_info_t * physhim);
-extern void wlapi_bmac_mctrl(wlc_phy_shim_info_t * physhim, uint32 mask,
-			     uint32 val);
-extern void wlapi_bmac_phy_reset(wlc_phy_shim_info_t * physhim);
-extern void wlapi_bmac_bw_set(wlc_phy_shim_info_t * physhim, uint16 bw);
-extern void wlapi_bmac_phyclk_fgc(wlc_phy_shim_info_t * physhim, bool clk);
-extern void wlapi_bmac_macphyclk_set(wlc_phy_shim_info_t * physhim, bool clk);
-extern void wlapi_bmac_core_phypll_ctl(wlc_phy_shim_info_t * physhim, bool on);
-extern void wlapi_bmac_core_phypll_reset(wlc_phy_shim_info_t * physhim);
+extern void wlapi_bmac_write_shm(wlc_phy_shim_info_t *physhim, uint offset,
+				 u16 v);
+extern u16 wlapi_bmac_read_shm(wlc_phy_shim_info_t *physhim, uint offset);
+extern void wlapi_bmac_mhf(wlc_phy_shim_info_t *physhim, u8 idx,
+			   u16 mask, u16 val, int bands);
+extern void wlapi_bmac_corereset(wlc_phy_shim_info_t *physhim, u32 flags);
+extern void wlapi_suspend_mac_and_wait(wlc_phy_shim_info_t *physhim);
+extern void wlapi_switch_macfreq(wlc_phy_shim_info_t *physhim, u8 spurmode);
+extern void wlapi_enable_mac(wlc_phy_shim_info_t *physhim);
+extern void wlapi_bmac_mctrl(wlc_phy_shim_info_t *physhim, u32 mask,
+			     u32 val);
+extern void wlapi_bmac_phy_reset(wlc_phy_shim_info_t *physhim);
+extern void wlapi_bmac_bw_set(wlc_phy_shim_info_t *physhim, u16 bw);
+extern void wlapi_bmac_phyclk_fgc(wlc_phy_shim_info_t *physhim, bool clk);
+extern void wlapi_bmac_macphyclk_set(wlc_phy_shim_info_t *physhim, bool clk);
+extern void wlapi_bmac_core_phypll_ctl(wlc_phy_shim_info_t *physhim, bool on);
+extern void wlapi_bmac_core_phypll_reset(wlc_phy_shim_info_t *physhim);
 extern void wlapi_bmac_ucode_wake_override_phyreg_set(wlc_phy_shim_info_t *
 						      physhim);
 extern void wlapi_bmac_ucode_wake_override_phyreg_clear(wlc_phy_shim_info_t *
 							physhim);
-extern void wlapi_bmac_write_template_ram(wlc_phy_shim_info_t * physhim, int o,
+extern void wlapi_bmac_write_template_ram(wlc_phy_shim_info_t *physhim, int o,
 					  int len, void *buf);
-extern uint16 wlapi_bmac_rate_shm_offset(wlc_phy_shim_info_t * physhim,
-					 uint8 rate);
-extern void wlapi_ucode_sample_init(wlc_phy_shim_info_t * physhim);
-extern void wlapi_copyfrom_objmem(wlc_phy_shim_info_t * physhim, uint,
-				  void *buf, int, uint32 sel);
-extern void wlapi_copyto_objmem(wlc_phy_shim_info_t * physhim, uint,
-				const void *buf, int, uint32);
+extern u16 wlapi_bmac_rate_shm_offset(wlc_phy_shim_info_t *physhim,
+					 u8 rate);
+extern void wlapi_ucode_sample_init(wlc_phy_shim_info_t *physhim);
+extern void wlapi_copyfrom_objmem(wlc_phy_shim_info_t *physhim, uint,
+				  void *buf, int, u32 sel);
+extern void wlapi_copyto_objmem(wlc_phy_shim_info_t *physhim, uint,
+				const void *buf, int, u32);
 
-extern void wlapi_high_update_phy_mode(wlc_phy_shim_info_t * physhim,
-				       uint32 phy_mode);
-extern void wlapi_bmac_pktengtx(wlc_phy_shim_info_t * physhim,
-				wl_pkteng_t * pkteng, uint8 rate,
-				struct ether_addr *sa, uint32 wait_delay);
-extern uint16 wlapi_bmac_get_txant(wlc_phy_shim_info_t * physhim);
+extern void wlapi_high_update_phy_mode(wlc_phy_shim_info_t *physhim,
+				       u32 phy_mode);
+extern u16 wlapi_bmac_get_txant(wlc_phy_shim_info_t *physhim);
 #endif				/* _wlc_phy_shim_h_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_pub.h b/drivers/staging/brcm80211/sys/wlc_pub.h
index fe02081..a6a8c33 100644
--- a/drivers/staging/brcm80211/sys/wlc_pub.h
+++ b/drivers/staging/brcm80211/sys/wlc_pub.h
@@ -57,8 +57,8 @@
 
 #define WLC_SNR_INVALID		0	/* invalid SNR value */
 
-/* a large TX Power as an init value to factor out of MIN() calculations,
- * keep low enough to fit in an int8, units are .25 dBm
+/* a large TX Power as an init value to factor out of min() calculations,
+ * keep low enough to fit in an s8, units are .25 dBm
  */
 #define WLC_TXPWR_MAX		(127)	/* ~32 dBm = 1,500 mW */
 
@@ -92,7 +92,7 @@
 
 #define RXBUFSZ		PKTBUFSZ
 #ifndef AIDMAPSZ
-#define AIDMAPSZ	(ROUNDUP(MAXSCB, NBBY)/NBBY)	/* aid bitmap size in bytes */
+#define AIDMAPSZ	(roundup(MAXSCB, NBBY)/NBBY)	/* aid bitmap size in bytes */
 #endif				/* AIDMAPSZ */
 
 typedef struct wlc_tunables {
@@ -115,19 +115,19 @@ typedef struct wlc_tunables {
 
 typedef struct wlc_rateset {
 	uint count;		/* number of rates in rates[] */
-	uint8 rates[WLC_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
-	uint8 htphy_membership;	/* HT PHY Membership */
-	uint8 mcs[MCSSET_LEN];	/* supported mcs index bit map */
+	u8 rates[WLC_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
+	u8 htphy_membership;	/* HT PHY Membership */
+	u8 mcs[MCSSET_LEN];	/* supported mcs index bit map */
 } wlc_rateset_t;
 
 struct rsn_parms {
-	uint8 flags;		/* misc booleans (e.g., supported) */
-	uint8 multicast;	/* multicast cipher */
-	uint8 ucount;		/* count of unicast ciphers */
-	uint8 unicast[4];	/* unicast ciphers */
-	uint8 acount;		/* count of auth modes */
-	uint8 auth[4];		/* Authentication modes */
-	uint8 PAD[4];		/* padding for future growth */
+	u8 flags;		/* misc booleans (e.g., supported) */
+	u8 multicast;	/* multicast cipher */
+	u8 ucount;		/* count of unicast ciphers */
+	u8 unicast[4];	/* unicast ciphers */
+	u8 acount;		/* count of auth modes */
+	u8 auth[4];		/* Authentication modes */
+	u8 PAD[4];		/* padding for future growth */
 };
 
 /*
@@ -166,29 +166,29 @@ typedef struct wlc_event {
 /* wlc internal bss_info, wl external one is in wlioctl.h */
 typedef struct wlc_bss_info {
 	struct ether_addr BSSID;	/* network BSSID */
-	uint16 flags;		/* flags for internal attributes */
-	uint8 SSID_len;		/* the length of SSID */
-	uint8 SSID[32];		/* SSID string */
-	int16 RSSI;		/* receive signal strength (in dBm) */
-	int16 SNR;		/* receive signal SNR in dB */
-	uint16 beacon_period;	/* units are Kusec */
-	uint16 atim_window;	/* units are Kusec */
+	u16 flags;		/* flags for internal attributes */
+	u8 SSID_len;		/* the length of SSID */
+	u8 SSID[32];		/* SSID string */
+	s16 RSSI;		/* receive signal strength (in dBm) */
+	s16 SNR;		/* receive signal SNR in dB */
+	u16 beacon_period;	/* units are Kusec */
+	u16 atim_window;	/* units are Kusec */
 	chanspec_t chanspec;	/* Channel num, bw, ctrl_sb and band */
-	int8 infra;		/* 0=IBSS, 1=infrastructure, 2=unknown */
+	s8 infra;		/* 0=IBSS, 1=infrastructure, 2=unknown */
 	wlc_rateset_t rateset;	/* supported rates */
-	uint8 dtim_period;	/* DTIM period */
-	int8 phy_noise;		/* noise right after tx (in dBm) */
-	uint16 capability;	/* Capability information */
+	u8 dtim_period;	/* DTIM period */
+	s8 phy_noise;		/* noise right after tx (in dBm) */
+	u16 capability;	/* Capability information */
 	struct dot11_bcn_prb *bcn_prb;	/* beacon/probe response frame (ioctl na) */
-	uint16 bcn_prb_len;	/* beacon/probe response frame length (ioctl na) */
-	uint8 wme_qosinfo;	/* QoS Info from WME IE; valid if WLC_BSS_WME flag set */
+	u16 bcn_prb_len;	/* beacon/probe response frame length (ioctl na) */
+	u8 wme_qosinfo;	/* QoS Info from WME IE; valid if WLC_BSS_WME flag set */
 	struct rsn_parms wpa;
 	struct rsn_parms wpa2;
-	uint16 qbss_load_aac;	/* qbss load available admission capacity */
+	u16 qbss_load_aac;	/* qbss load available admission capacity */
 	/* qbss_load_chan_free <- (0xff - channel_utilization of qbss_load_ie_t) */
-	uint8 qbss_load_chan_free;	/* indicates how free the channel is */
-	uint8 mcipher;		/* multicast cipher */
-	uint8 wpacfg;		/* wpa config index */
+	u8 qbss_load_chan_free;	/* indicates how free the channel is */
+	u8 mcipher;		/* multicast cipher */
+	u8 wpacfg;		/* wpa config index */
 } wlc_bss_info_t;
 
 /* forward declarations */
@@ -224,7 +224,7 @@ struct wlc_if;
 /* watchdog down and dump callback function proto's */
 typedef int (*watchdog_fn_t) (void *handle);
 typedef int (*down_fn_t) (void *handle);
-typedef int (*dump_fn_t) (void *handle, struct bcmstrbuf * b);
+typedef int (*dump_fn_t) (void *handle, struct bcmstrbuf *b);
 
 /* IOVar handler
  *
@@ -239,10 +239,10 @@ typedef int (*dump_fn_t) (void *handle, struct bcmstrbuf * b);
  *
  * All pointers may point into the same buffer.
  */
-typedef int (*iovar_fn_t) (void *handle, const bcm_iovar_t * vi,
-			   uint32 actionid, const char *name, void *params,
+typedef int (*iovar_fn_t) (void *handle, const bcm_iovar_t *vi,
+			   u32 actionid, const char *name, void *params,
 			   uint plen, void *arg, int alen, int vsize,
-			   struct wlc_if * wlcif);
+			   struct wlc_if *wlcif);
 
 #define MAC80211_PROMISC_BCNS	(1 << 0)
 #define MAC80211_SCAN		(1 << 1)
@@ -277,7 +277,7 @@ typedef struct wlc_pub {
 	bool _apsta;		/* simultaneous AP/STA mode enabled */
 	bool _assoc_recreate;	/* association recreation on up transitions */
 	int _wme;		/* WME QoS mode */
-	uint8 _mbss;		/* MBSS mode on */
+	u8 _mbss;		/* MBSS mode on */
 	bool allmulti;		/* enable all multicasts */
 	bool associated;	/* true:part of [I]BSS, false: not */
 	/* (union of stas_associated, aps_associated) */
@@ -285,10 +285,10 @@ typedef struct wlc_pub {
 	bool bf_preempt_4306;	/* True to enable 'darwin' mode */
 	bool _ampdu;		/* ampdu enabled or not */
 	bool _cac;		/* 802.11e CAC enabled */
-	uint8 _n_enab;		/* bitmap of 11N + HT support */
+	u8 _n_enab;		/* bitmap of 11N + HT support */
 	bool _n_reqd;		/* N support required for clients */
 
-	int8 _coex;		/* 20/40 MHz BSS Management AUTO, ENAB, DISABLE */
+	s8 _coex;		/* 20/40 MHz BSS Management AUTO, ENAB, DISABLE */
 	bool _priofc;		/* Priority-based flowcontrol */
 
 	struct ether_addr cur_etheraddr;	/* our local ethernet address */
@@ -296,19 +296,19 @@ typedef struct wlc_pub {
 	struct ether_addr *multicast;	/* ptr to list of multicast addresses */
 	uint nmulticast;	/* # enabled multicast addresses */
 
-	uint32 wlfeatureflag;	/* Flags to control sw features from registry */
+	u32 wlfeatureflag;	/* Flags to control sw features from registry */
 	int psq_pkts_total;	/* total num of ps pkts */
 
-	uint16 txmaxpkts;	/* max number of large pkts allowed to be pending */
+	u16 txmaxpkts;	/* max number of large pkts allowed to be pending */
 
 	/* s/w decryption counters */
-	uint32 swdecrypt;	/* s/w decrypt attempts */
+	u32 swdecrypt;	/* s/w decrypt attempts */
 
 	int bcmerror;		/* last bcm error */
 
 	mbool radio_disabled;	/* bit vector for radio disabled reasons */
 	bool radio_active;	/* radio on/off state */
-	uint16 roam_time_thresh;	/* Max. # secs. of not hearing beacons
+	u16 roam_time_thresh;	/* Max. # secs. of not hearing beacons
 					 * before roaming.
 					 */
 	bool align_wd_tbtt;	/* Align watchdog with tbtt indication
@@ -322,11 +322,11 @@ typedef struct wlc_pub {
 	uint sdiod_drive_strength;	/* SDIO drive strength */
 #endif				/* BCMSDIO */
 
-	uint16 boardrev;	/* version # of particular board */
-	uint8 sromrev;		/* version # of the srom */
+	u16 boardrev;	/* version # of particular board */
+	u8 sromrev;		/* version # of the srom */
 	char srom_ccode[WLC_CNTRY_BUF_SZ];	/* Country Code in SROM */
-	uint32 boardflags;	/* Board specific flags from srom */
-	uint32 boardflags2;	/* More board flags if sromrev >= 4 */
+	u32 boardflags;	/* Board specific flags from srom */
+	u32 boardflags2;	/* More board flags if sromrev >= 4 */
 	bool tempsense_disable;	/* disable periodic tempsense check */
 
 	bool _lmac;		/* lmac module included and enabled */
@@ -343,10 +343,10 @@ typedef struct wl_rxsts {
 	uint datarate;		/* rate in 500kbps */
 	uint antenna;		/* antenna pkts received on */
 	uint pktlength;		/* pkt length minus bcm phy hdr */
-	uint32 mactime;		/* time stamp from mac, count per 1us */
+	u32 mactime;		/* time stamp from mac, count per 1us */
 	uint sq;		/* signal quality */
-	int32 signal;		/* in dbm */
-	int32 noise;		/* in dbm */
+	s32 signal;		/* in dbm */
+	s32 noise;		/* in dbm */
 	uint preamble;		/* Unknown, short, long */
 	uint encoding;		/* Unknown, CCK, PBCC, OFDM */
 	uint nfrmtype;		/* special 802.11n frames(AMPDU, AMSDU) */
@@ -394,81 +394,6 @@ struct wlc_hw_info;
 struct wlc_bsscfg;
 struct wlc_if;
 
-/* Structure for Pkttag area in a packet.
- * CAUTION: Please carefully consider your design before adding any new fields to the pkttag
- * The size is limited to 32 bytes which on 64-bit machine allows only 4 fields.
- * If adding a member, be sure to check if wlc_pkttag_info_move should transfer it.
- */
-typedef struct {
-	uint32 flags;		/* Describe various packet properties */
-	uint16 seq;		/* preassigned seqnum for AMPDU */
-#ifdef BCMDBG
-	uint16 _scb_dbgid;	/* Uniqe debug id for the scb pointed by scb pointer */
-#endif
-	uint8 callbackidx;	/* Index into pkt_callback tables for callback function */
-	int8 _bsscfgidx;	/* Index of bsscfg for this frame */
-	int8 ac_override;	/* fifo on which this frame should go */
-	int8 rssi;		/* RSSI for the recvd. packet */
-	uint32 exptime;		/* Time of expiry for the packet */
-	struct scb *_scb;	/* Pointer to SCB for associated ea */
-	uint32 rspec;		/* Phy rate for received packet */
-	union {
-		uint32 packetid;
-	} shared;
-} wlc_pkttag_t;
-
-#define WLPKTTAG(p) ((wlc_pkttag_t*)PKTTAG(p))
-
-/* Flags used in wlc_pkttag_t.
- * If adding a flag, be sure to check if WLPKTTAG_FLAG_MOVE should transfer it.
- */
-#define WLF_PSMARK		0x00000001	/* PKT marking for PSQ aging */
-#define WLF_PSDONTQ		0x00000002	/* PS-Poll response don't queue flag */
-#define WLF_MPDU		0x00000004	/* Set if pkt is a PDU as opposed to MSDU */
-#define WLF_NON8023		0x00000008	/* original pkt is not 8023 */
-#define WLF_8021X		0x00000010	/* original pkt is 802.1x */
-#define WLF_APSD		0x00000020	/* APSD delivery frame */
-#define WLF_AMSDU		0x00000040	/* pkt is aggregated msdu */
-#define WLF_HWAMSDU		0x00000080	/* Rx: HW/ucode has deaggregated this A-MSDU */
-#define WLF_TXHDR		0x00000080	/* Tx: pkt is 802.11 MPDU with plcp and txhdr */
-#define WLF_BA			0x00000100	/* Used by BA module if pkt is not to be acked */
-#define WLF_EXPTIME		0x00000200	/* pkttag has a valid expiration time for the pkt */
-#define WLF_AMPDU_MPDU		0x00000400	/* mpdu in a ampdu */
-#define WLF_MIMO		0x00000800	/* mpdu has a mimo rate */
-#define WLF_RIFS		0x00001000	/* frameburst with RIFS separated */
-#define WLF_VRATE_PROBE		0x00002000	/* vertical rate probe mpdu */
-#define WLF_BSS_DOWN		0x00004000	/* The BSS associated with the pkt has gone down */
-#define WLF_UMAC_PKT		0x00008000	/* UMAC Packet */
-#define WLF_EXEMPT_MASK		0x00030000	/* mask for encryption exemption (Vista) */
-#define WLF_WME_NOACK		0x00040000	/* pkt use WME No ACK policy */
-#define WLF_USERTS		0x04000000	/* protect the packet with RTS/CTS */
-#define WLF_RATE_AUTO		0x08000000	/* pkt uses rates from the rate selection module */
-
-#define WLF_DATA		0x40000000	/* pkt is pure data */
-
-#define WLPKTFLAG_BA(pkttag)	FALSE
-
-#define WLPKTFLAG_AMPDU(pkttag)	((pkttag)->flags & WLF_AMPDU_MPDU)
-#define WLPKTFLAG_RIFS(pkttag)	((pkttag)->flags & WLF_RIFS)
-
-/* API for accessing BSSCFG index in WLPKTTAG */
-#define BSSCFGIDX_ISVALID(bsscfgidx) (((bsscfgidx >= 0)&&(bsscfgidx < WLC_MAXBSSCFG)) ? 1 : 0)
-
-static INLINE int8 wlc_pkttag_bsscfg_get(void *p)
-{
-	int8 idx = WLPKTTAG(p)->_bsscfgidx;
-#ifdef BCMDBG
-	ASSERT(BSSCFGIDX_ISVALID(idx));
-#endif
-	return idx;
-}
-
-#define WLPKTTAGBSSCFGGET(p) (wlc_pkttag_bsscfg_get(p))
-#define WLPKTTAGBSSCFGSET(p, bsscfgidx) (WLPKTTAG(p)->_bsscfgidx = bsscfgidx)
-
-/* Raw get of bss idx from pkt tag without error checking */
-#define WLPKTTAG_BSSIDX_GET(pkttag) ((pkttag)->_bsscfgidx)
-
 /***********************************************
  * Feature-related macros to optimize out code *
  * *********************************************
@@ -516,7 +441,7 @@ static INLINE int8 wlc_pkttag_bsscfg_get(void *p)
 
 #define PROMISC_ENAB(wlc)	(bcmspace && (wlc)->promisc)
 
-extern void wlc_pkttag_info_move(wlc_pub_t * pub, void *pkt_from, void *pkt_to);
+extern void wlc_pkttag_info_move(wlc_pub_t *pub, void *pkt_from, void *pkt_to);
 
 #define WLPKTTAGSCB(p) (WLPKTTAG(p)->_scb)
 
@@ -525,15 +450,15 @@ extern void wlc_pkttag_info_move(wlc_pub_t * pub, void *pkt_from, void *pkt_to);
 /* pri is PKTPRIO encoded in the packet. This maps the Packet priority to
  * enqueue precedence as defined in wlc_prec_map
  */
-extern const uint8 wlc_prio2prec_map[];
+extern const u8 wlc_prio2prec_map[];
 #define WLC_PRIO_TO_PREC(pri)	wlc_prio2prec_map[(pri) & 7]
 
 /* This maps priority to one precedence higher - Used by PS-Poll response packets to
  * simulate enqueue-at-head operation, but still maintain the order on the queue
  */
-#define WLC_PRIO_TO_HI_PREC(pri)	MIN(WLC_PRIO_TO_PREC(pri) + 1, WLC_PREC_COUNT - 1)
+#define WLC_PRIO_TO_HI_PREC(pri)	min(WLC_PRIO_TO_PREC(pri) + 1, WLC_PREC_COUNT - 1)
 
-extern const uint8 wme_fifo2ac[];
+extern const u8 wme_fifo2ac[];
 #define WME_PRIO2AC(prio)	wme_fifo2ac[prio2fifo[(prio)]]
 
 /* Mask to describe all precedence levels */
@@ -566,14 +491,14 @@ extern const uint8 wme_fifo2ac[];
 #define WLC_UPDATE_STATS(wlc)	0	/* No stats support */
 #define WLCNTINCR(a)		/* No stats support */
 #define WLCNTDECR(a)		/* No stats support */
-#define WLCNTADD(a,delta)	/* No stats support */
-#define WLCNTSET(a,value)	/* No stats support */
+#define WLCNTADD(a, delta)	/* No stats support */
+#define WLCNTSET(a, value)	/* No stats support */
 #define WLCNTVAL(a)		0	/* No stats support */
 
 /* common functions for every port */
-extern void *wlc_attach(void *wl, uint16 vendor, uint16 device, uint unit,
-			bool piomode, osl_t * osh, void *regsva, uint bustype,
-			void *btparam, uint * perr);
+extern void *wlc_attach(void *wl, u16 vendor, u16 device, uint unit,
+			bool piomode, osl_t *osh, void *regsva, uint bustype,
+			void *btparam, uint *perr);
 extern uint wlc_detach(struct wlc_info *wlc);
 extern int wlc_up(struct wlc_info *wlc);
 extern uint wlc_down(struct wlc_info *wlc);
@@ -582,17 +507,17 @@ extern int wlc_set(struct wlc_info *wlc, int cmd, int arg);
 extern int wlc_get(struct wlc_info *wlc, int cmd, int *arg);
 extern int wlc_iovar_getint(struct wlc_info *wlc, const char *name, int *arg);
 extern int wlc_iovar_setint(struct wlc_info *wlc, const char *name, int arg);
-extern bool wlc_chipmatch(uint16 vendor, uint16 device);
+extern bool wlc_chipmatch(u16 vendor, u16 device);
 extern void wlc_init(struct wlc_info *wlc);
 extern void wlc_reset(struct wlc_info *wlc);
 
 extern void wlc_intrson(struct wlc_info *wlc);
-extern uint32 wlc_intrsoff(struct wlc_info *wlc);
-extern void wlc_intrsrestore(struct wlc_info *wlc, uint32 macintmask);
+extern u32 wlc_intrsoff(struct wlc_info *wlc);
+extern void wlc_intrsrestore(struct wlc_info *wlc, u32 macintmask);
 extern bool wlc_intrsupd(struct wlc_info *wlc);
-extern bool wlc_isr(struct wlc_info *wlc, bool * wantdpc);
+extern bool wlc_isr(struct wlc_info *wlc, bool *wantdpc);
 extern bool wlc_dpc(struct wlc_info *wlc, bool bounded);
-extern bool wlc_send80211_raw(struct wlc_info *wlc, wlc_if_t * wlcif, void *p,
+extern bool wlc_send80211_raw(struct wlc_info *wlc, wlc_if_t *wlcif, void *p,
 			      uint ac);
 extern int wlc_iovar_op(struct wlc_info *wlc, const char *name, void *params,
 			int p_len, void *arg, int len, bool set,
@@ -611,64 +536,52 @@ extern int wlc_bmac_up_finish(struct wlc_hw_info *wlc_hw);
 extern int wlc_bmac_down_prep(struct wlc_hw_info *wlc_hw);
 extern int wlc_bmac_down_finish(struct wlc_hw_info *wlc_hw);
 
-extern int wlc_nin_ioctl(struct wlc_info *wlc, int cmd, void *arg, int len,
-			 struct wlc_if *wlcif);
-extern bool wlc_nin_process_sendup(struct wlc_info *wlc, void *p);
-void wlc_nin_create_iapp_ind(struct wlc_info *wlc, void *p, int len);
-
-extern uint32 wlc_reg_read(struct wlc_info *wlc, void *r, uint size);
-extern void wlc_reg_write(struct wlc_info *wlc, void *r, uint32 v, uint size);
-extern void wlc_corereset(struct wlc_info *wlc, uint32 flags);
-extern void wlc_mhf(struct wlc_info *wlc, uint8 idx, uint16 mask, uint16 val,
+extern u32 wlc_reg_read(struct wlc_info *wlc, void *r, uint size);
+extern void wlc_reg_write(struct wlc_info *wlc, void *r, u32 v, uint size);
+extern void wlc_corereset(struct wlc_info *wlc, u32 flags);
+extern void wlc_mhf(struct wlc_info *wlc, u8 idx, u16 mask, u16 val,
 		    int bands);
-extern uint16 wlc_mhf_get(struct wlc_info *wlc, uint8 idx, int bands);
-extern uint32 wlc_delta_txfunfl(struct wlc_info *wlc, int fifo);
-extern void wlc_rate_lookup_init(struct wlc_info *wlc, wlc_rateset_t * rateset);
-extern void wlc_default_rateset(struct wlc_info *wlc, wlc_rateset_t * rs);
-extern void wlc_join_attempt(struct wlc_bsscfg *cfg);
-extern void wlc_join_bss_start(struct wlc_bsscfg *cfg);
-extern void wlc_join_BSS(struct wlc_bsscfg *cfg, wlc_bss_info_t * bi);
+extern u16 wlc_mhf_get(struct wlc_info *wlc, u8 idx, int bands);
+extern u32 wlc_delta_txfunfl(struct wlc_info *wlc, int fifo);
+extern void wlc_rate_lookup_init(struct wlc_info *wlc, wlc_rateset_t *rateset);
+extern void wlc_default_rateset(struct wlc_info *wlc, wlc_rateset_t *rs);
 
 /* wlc_phy.c helper functions */
-extern bool wlc_scan_inprog(struct wlc_info *wlc);
-extern bool wlc_associnprog(struct wlc_info *wlc);
-extern bool wlc_scan_inprog(struct wlc_info *wlc);
-extern void *wlc_cur_phy(struct wlc_info *wlc);
 extern void wlc_set_ps_ctrl(struct wlc_info *wlc);
-extern void wlc_mctrl(struct wlc_info *wlc, uint32 mask, uint32 val);
+extern void wlc_mctrl(struct wlc_info *wlc, u32 mask, u32 val);
 extern void wlc_scb_ratesel_init_all(struct wlc_info *wlc);
 
 /* ioctl */
-extern int wlc_iovar_getint8(struct wlc_info *wlc, const char *name,
-			     int8 * arg);
-extern int wlc_iovar_check(wlc_pub_t * pub, const bcm_iovar_t * vi, void *arg,
+extern int wlc_iovar_gets8(struct wlc_info *wlc, const char *name,
+			     s8 *arg);
+extern int wlc_iovar_check(wlc_pub_t *pub, const bcm_iovar_t *vi, void *arg,
 			   int len, bool set);
 
-extern int wlc_module_register(wlc_pub_t * pub, const bcm_iovar_t * iovars,
+extern int wlc_module_register(wlc_pub_t *pub, const bcm_iovar_t *iovars,
 			       const char *name, void *hdl, iovar_fn_t iovar_fn,
 			       watchdog_fn_t watchdog_fn, down_fn_t down_fn);
-extern int wlc_module_unregister(wlc_pub_t * pub, const char *name, void *hdl);
+extern int wlc_module_unregister(wlc_pub_t *pub, const char *name, void *hdl);
 extern void wlc_event_if(struct wlc_info *wlc, struct wlc_bsscfg *cfg,
-			 wlc_event_t * e, const struct ether_addr *addr);
+			 wlc_event_t *e, const struct ether_addr *addr);
 extern void wlc_suspend_mac_and_wait(struct wlc_info *wlc);
 extern void wlc_enable_mac(struct wlc_info *wlc);
-extern uint16 wlc_rate_shm_offset(struct wlc_info *wlc, uint8 rate);
-extern uint32 wlc_get_rspec_history(struct wlc_bsscfg *cfg);
-extern uint32 wlc_get_current_highest_rate(struct wlc_bsscfg *cfg);
+extern u16 wlc_rate_shm_offset(struct wlc_info *wlc, u8 rate);
+extern u32 wlc_get_rspec_history(struct wlc_bsscfg *cfg);
+extern u32 wlc_get_current_highest_rate(struct wlc_bsscfg *cfg);
 
-static INLINE int wlc_iovar_getuint(struct wlc_info *wlc, const char *name,
-				    uint * arg)
+static inline int wlc_iovar_getuint(struct wlc_info *wlc, const char *name,
+				    uint *arg)
 {
 	return wlc_iovar_getint(wlc, name, (int *)arg);
 }
 
-static INLINE int wlc_iovar_getuint8(struct wlc_info *wlc, const char *name,
-				     uint8 * arg)
+static inline int wlc_iovar_getu8(struct wlc_info *wlc, const char *name,
+				     u8 *arg)
 {
-	return wlc_iovar_getint8(wlc, name, (int8 *) arg);
+	return wlc_iovar_gets8(wlc, name, (s8 *) arg);
 }
 
-static INLINE int wlc_iovar_setuint(struct wlc_info *wlc, const char *name,
+static inline int wlc_iovar_setuint(struct wlc_info *wlc, const char *name,
 				    uint arg)
 {
 	return wlc_iovar_setint(wlc, name, (int)arg);
@@ -682,7 +595,7 @@ extern int wlc_iocpichk(struct wlc_info *wlc, uint phytype);
 #endif
 
 /* helper functions */
-extern void wlc_getrand(struct wlc_info *wlc, uint8 * buf, int len);
+extern void wlc_getrand(struct wlc_info *wlc, u8 *buf, int len);
 
 struct scb;
 extern void wlc_ps_on(struct wlc_info *wlc, struct scb *scb);
@@ -690,7 +603,7 @@ extern void wlc_ps_off(struct wlc_info *wlc, struct scb *scb, bool discard);
 extern bool wlc_radio_monitor_stop(struct wlc_info *wlc);
 
 #if defined(BCMDBG)
-extern int wlc_format_ssid(char *buf, const uchar ssid[], uint ssid_len);
+extern int wlc_format_ssid(char *buf, const unsigned char ssid[], uint ssid_len);
 #endif
 
 extern void wlc_pmkid_build_cand_list(struct wlc_bsscfg *cfg, bool check_SSID);
@@ -708,7 +621,7 @@ extern void wlc_pmkid_event(struct wlc_bsscfg *cfg);
 void wlc_device_removed(void *arg);
 #endif
 
-/* BMAC RPC: 7 uint32 params: pkttotlen, fifo, commit, fid, txpktpend, pktflag, rpc_id */
+/* BMAC RPC: 7 u32 params: pkttotlen, fifo, commit, fid, txpktpend, pktflag, rpc_id */
 #define WLC_RPCTX_PARAMS		32
 
 #endif				/* _wlc_pub_h_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_rate.c b/drivers/staging/brcm80211/sys/wlc_rate.c
index a71e4a5..d2d7256 100644
--- a/drivers/staging/brcm80211/sys/wlc_rate.c
+++ b/drivers/staging/brcm80211/sys/wlc_rate.c
@@ -13,10 +13,11 @@
  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
-
+#include <linux/kernel.h>
+#include <bcmdefs.h>
 #include <wlc_cfg.h>
-#include <typedefs.h>
 #include <osl.h>
+#include <linuxver.h>
 #include <bcmutils.h>
 #include <siutils.h>
 #include <bcmendian.h>
@@ -29,7 +30,7 @@
 #include <wlc_pub.h>
 
 /* Rate info per rate: It tells whether a rate is ofdm or not and its phy_rate value */
-const uint8 rate_info[WLC_MAXRATE + 1] = {
+const u8 rate_info[WLC_MAXRATE + 1] = {
 	/*  0     1     2     3     4     5     6     7     8     9 */
 /*   0 */ 0x00, 0x00, 0x0a, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00,
 /*  10 */ 0x00, 0x37, 0x8b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x00,
@@ -151,8 +152,8 @@ const mcs_info_t mcs_table[MCS_TABLE_SIZE] = {
  *   other fields: refer to table 78 of section 17.3.2.2 of the original .11a standard
  */
 typedef struct legacy_phycfg {
-	uint32 rate_ofdm;	/* ofdm mac rate */
-	uint8 tx_phy_ctl3;	/* phy ctl byte 3, code rate, modulation type, # of streams */
+	u32 rate_ofdm;	/* ofdm mac rate */
+	u8 tx_phy_ctl3;	/* phy ctl byte 3, code rate, modulation type, # of streams */
 } legacy_phycfg_t;
 
 #define LEGACY_PHYCFG_TABLE_SIZE	12	/* Number of legacy_rate_cfg entries in the table */
@@ -253,30 +254,30 @@ const wlc_rateset_t cck_rates = {
 	 0x00, 0x00, 0x00, 0x00}
 };
 
-static bool wlc_rateset_valid(wlc_rateset_t * rs, bool check_brate);
+static bool wlc_rateset_valid(wlc_rateset_t *rs, bool check_brate);
 
 /* check if rateset is valid.
  * if check_brate is true, rateset without a basic rate is considered NOT valid.
  */
-static bool wlc_rateset_valid(wlc_rateset_t * rs, bool check_brate)
+static bool wlc_rateset_valid(wlc_rateset_t *rs, bool check_brate)
 {
 	uint idx;
 
 	if (!rs->count)
-		return FALSE;
+		return false;
 
 	if (!check_brate)
-		return TRUE;
+		return true;
 
 	/* error if no basic rates */
 	for (idx = 0; idx < rs->count; idx++) {
 		if (rs->rates[idx] & WLC_RATE_FLAG)
-			return TRUE;
+			return true;
 	}
-	return FALSE;
+	return false;
 }
 
-void wlc_rateset_mcs_upd(wlc_rateset_t * rs, uint8 txstreams)
+void wlc_rateset_mcs_upd(wlc_rateset_t *rs, u8 txstreams)
 {
 	int i;
 	for (i = txstreams; i < MAX_STREAMS_SUPPORTED; i++)
@@ -287,12 +288,12 @@ void wlc_rateset_mcs_upd(wlc_rateset_t * rs, uint8 txstreams)
  * and check if resulting rateset is valid.
 */
 bool
-wlc_rate_hwrs_filter_sort_validate(wlc_rateset_t * rs,
-				   const wlc_rateset_t * hw_rs,
-				   bool check_brate, uint8 txstreams)
+wlc_rate_hwrs_filter_sort_validate(wlc_rateset_t *rs,
+				   const wlc_rateset_t *hw_rs,
+				   bool check_brate, u8 txstreams)
 {
-	uint8 rateset[WLC_MAXRATE + 1];
-	uint8 r;
+	u8 rateset[WLC_MAXRATE + 1];
+	u8 r;
 	uint count;
 	uint i;
 
@@ -324,13 +325,13 @@ wlc_rate_hwrs_filter_sort_validate(wlc_rateset_t * rs,
 		rs->mcs[i] = (rs->mcs[i] & hw_rs->mcs[i]);
 
 	if (wlc_rateset_valid(rs, check_brate))
-		return TRUE;
+		return true;
 	else
-		return FALSE;
+		return false;
 }
 
 /* caluclate the rate of a rx'd frame and return it as a ratespec */
-ratespec_t BCMFASTPATH wlc_compute_rspec(d11rxhdr_t * rxh, uint8 * plcp)
+ratespec_t BCMFASTPATH wlc_compute_rspec(d11rxhdr_t *rxh, u8 *plcp)
 {
 	int phy_type;
 	ratespec_t rspec = PHY_TXC1_BW_20MHZ << RSPEC_BW_SHIFT;
@@ -377,7 +378,7 @@ ratespec_t BCMFASTPATH wlc_compute_rspec(d11rxhdr_t * rxh, uint8 * plcp)
 }
 
 /* copy rateset src to dst as-is (no masking or sorting) */
-void wlc_rateset_copy(const wlc_rateset_t * src, wlc_rateset_t * dst)
+void wlc_rateset_copy(const wlc_rateset_t *src, wlc_rateset_t *dst)
 {
 	bcopy(src, dst, sizeof(wlc_rateset_t));
 }
@@ -392,8 +393,8 @@ void wlc_rateset_copy(const wlc_rateset_t * src, wlc_rateset_t * dst)
  * 'xmask' is the copy mask (typically 0x7f or 0xff).
  */
 void
-wlc_rateset_filter(wlc_rateset_t * src, wlc_rateset_t * dst, bool basic_only,
-		   uint8 rates, uint xmask, bool mcsallow)
+wlc_rateset_filter(wlc_rateset_t *src, wlc_rateset_t *dst, bool basic_only,
+		   u8 rates, uint xmask, bool mcsallow)
 {
 	uint i;
 	uint r;
@@ -423,9 +424,9 @@ wlc_rateset_filter(wlc_rateset_t * src, wlc_rateset_t * dst, bool basic_only,
  * and fill rs_tgt with result
  */
 void
-wlc_rateset_default(wlc_rateset_t * rs_tgt, const wlc_rateset_t * rs_hw,
+wlc_rateset_default(wlc_rateset_t *rs_tgt, const wlc_rateset_t *rs_hw,
 		    uint phy_type, int bandtype, bool cck_only, uint rate_mask,
-		    bool mcsallow, uint8 bw, uint8 txstreams)
+		    bool mcsallow, u8 bw, u8 txstreams)
 {
 	const wlc_rateset_t *rs_dflt;
 	wlc_rateset_t rs_sel;
@@ -458,14 +459,14 @@ wlc_rateset_default(wlc_rateset_t * rs_tgt, const wlc_rateset_t * rs_hw,
 
 	wlc_rateset_copy(rs_dflt, &rs_sel);
 	wlc_rateset_mcs_upd(&rs_sel, txstreams);
-	wlc_rateset_filter(&rs_sel, rs_tgt, FALSE,
+	wlc_rateset_filter(&rs_sel, rs_tgt, false,
 			   cck_only ? WLC_RATES_CCK : WLC_RATES_CCK_OFDM,
 			   rate_mask, mcsallow);
-	wlc_rate_hwrs_filter_sort_validate(rs_tgt, rs_hw, FALSE,
+	wlc_rate_hwrs_filter_sort_validate(rs_tgt, rs_hw, false,
 					   mcsallow ? txstreams : 1);
 }
 
-int16 BCMFASTPATH wlc_rate_legacy_phyctl(uint rate)
+s16 BCMFASTPATH wlc_rate_legacy_phyctl(uint rate)
 {
 	uint i;
 	for (i = 0; i < LEGACY_PHYCFG_TABLE_SIZE; i++)
@@ -475,21 +476,21 @@ int16 BCMFASTPATH wlc_rate_legacy_phyctl(uint rate)
 	return -1;
 }
 
-void wlc_rateset_mcs_clear(wlc_rateset_t * rateset)
+void wlc_rateset_mcs_clear(wlc_rateset_t *rateset)
 {
 	uint i;
 	for (i = 0; i < MCSSET_LEN; i++)
 		rateset->mcs[i] = 0;
 }
 
-void wlc_rateset_mcs_build(wlc_rateset_t * rateset, uint8 txstreams)
+void wlc_rateset_mcs_build(wlc_rateset_t *rateset, u8 txstreams)
 {
 	bcopy(&cck_ofdm_mimo_rates.mcs[0], &rateset->mcs[0], MCSSET_LEN);
 	wlc_rateset_mcs_upd(rateset, txstreams);
 }
 
 /* Based on bandwidth passed, allow/disallow MCS 32 in the rateset */
-void wlc_rateset_bw_mcs_filter(wlc_rateset_t * rateset, uint8 bw)
+void wlc_rateset_bw_mcs_filter(wlc_rateset_t *rateset, u8 bw)
 {
 	if (bw == WLC_40_MHZ)
 		setbit(rateset->mcs, 32);
diff --git a/drivers/staging/brcm80211/sys/wlc_rate.h b/drivers/staging/brcm80211/sys/wlc_rate.h
index 20db2a7..25ba2a4 100644
--- a/drivers/staging/brcm80211/sys/wlc_rate.h
+++ b/drivers/staging/brcm80211/sys/wlc_rate.h
@@ -17,7 +17,7 @@
 #ifndef _WLC_RATE_H_
 #define _WLC_RATE_H_
 
-extern const uint8 rate_info[];
+extern const u8 rate_info[];
 extern const struct wlc_rateset cck_ofdm_mimo_rates;
 extern const struct wlc_rateset ofdm_mimo_rates;
 extern const struct wlc_rateset cck_ofdm_rates;
@@ -28,12 +28,12 @@ extern const struct wlc_rateset wlc_lrs_rates;
 extern const struct wlc_rateset rate_limit_1_2;
 
 typedef struct mcs_info {
-	uint32 phy_rate_20;	/* phy rate in kbps [20Mhz] */
-	uint32 phy_rate_40;	/* phy rate in kbps [40Mhz] */
-	uint32 phy_rate_20_sgi;	/* phy rate in kbps [20Mhz] with SGI */
-	uint32 phy_rate_40_sgi;	/* phy rate in kbps [40Mhz] with SGI */
-	uint8 tx_phy_ctl3;	/* phy ctl byte 3, code rate, modulation type, # of streams */
-	uint8 leg_ofdm;		/* matching legacy ofdm rate in 500bkps */
+	u32 phy_rate_20;	/* phy rate in kbps [20Mhz] */
+	u32 phy_rate_40;	/* phy rate in kbps [40Mhz] */
+	u32 phy_rate_20_sgi;	/* phy rate in kbps [20Mhz] with SGI */
+	u32 phy_rate_40_sgi;	/* phy rate in kbps [40Mhz] with SGI */
+	u8 tx_phy_ctl3;	/* phy ctl byte 3, code rate, modulation type, # of streams */
+	u8 leg_ofdm;		/* matching legacy ofdm rate in 500bkps */
 } mcs_info_t;
 
 #define WLC_MAXMCS	32	/* max valid mcs index */
@@ -65,7 +65,7 @@ extern const mcs_info_t mcs_table[];
 /* rate spec : holds rate and mode specific information required to generate a tx frame. */
 /* Legacy CCK and OFDM information is held in the same manner as was done in the past    */
 /* (in the lower byte) the upper 3 bytes primarily hold MIMO specific information        */
-typedef uint32 ratespec_t;
+typedef u32 ratespec_t;
 
 /* rate spec bit fields */
 #define RSPEC_RATE_MASK		0x0000007F	/* Either 500Kbps units or MIMO MCS idx */
@@ -129,7 +129,7 @@ typedef uint32 ratespec_t;
 	(PHY_TXC1_MODE_SDM << RSPEC_STF_SHIFT)))
 
 /* Convert encoded rate value in plcp header to numerical rates in 500 KHz increments */
-extern const uint8 ofdm_rate_lookup[];
+extern const u8 ofdm_rate_lookup[];
 #define OFDM_PHY2MAC_RATE(rlpt)		(ofdm_rate_lookup[rlpt & 0x7])
 #define CCK_PHY2MAC_RATE(signal)	(signal/5)
 
@@ -145,26 +145,26 @@ struct wlc_rateset;
 extern bool wlc_rate_hwrs_filter_sort_validate(struct wlc_rateset *rs,
 					       const struct wlc_rateset *hw_rs,
 					       bool check_brate,
-					       uint8 txstreams);
+					       u8 txstreams);
 /* copy rateset src to dst as-is (no masking or sorting) */
 extern void wlc_rateset_copy(const struct wlc_rateset *src,
 			     struct wlc_rateset *dst);
 
 /* would be nice to have these documented ... */
-extern ratespec_t wlc_compute_rspec(d11rxhdr_t * rxh, uint8 * plcp);
+extern ratespec_t wlc_compute_rspec(d11rxhdr_t *rxh, u8 *plcp);
 
 extern void wlc_rateset_filter(struct wlc_rateset *src, struct wlc_rateset *dst,
-			       bool basic_only, uint8 rates, uint xmask,
+			       bool basic_only, u8 rates, uint xmask,
 			       bool mcsallow);
 extern void wlc_rateset_default(struct wlc_rateset *rs_tgt,
 				const struct wlc_rateset *rs_hw, uint phy_type,
 				int bandtype, bool cck_only, uint rate_mask,
-				bool mcsallow, uint8 bw, uint8 txstreams);
-extern int16 wlc_rate_legacy_phyctl(uint rate);
+				bool mcsallow, u8 bw, u8 txstreams);
+extern s16 wlc_rate_legacy_phyctl(uint rate);
 
-extern void wlc_rateset_mcs_upd(struct wlc_rateset *rs, uint8 txstreams);
+extern void wlc_rateset_mcs_upd(struct wlc_rateset *rs, u8 txstreams);
 extern void wlc_rateset_mcs_clear(struct wlc_rateset *rateset);
-extern void wlc_rateset_mcs_build(struct wlc_rateset *rateset, uint8 txstreams);
-extern void wlc_rateset_bw_mcs_filter(struct wlc_rateset *rateset, uint8 bw);
+extern void wlc_rateset_mcs_build(struct wlc_rateset *rateset, u8 txstreams);
+extern void wlc_rateset_bw_mcs_filter(struct wlc_rateset *rateset, u8 bw);
 
 #endif				/* _WLC_RATE_H_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_rpc.h b/drivers/staging/brcm80211/sys/wlc_rpc.h
index dd4547d..db39645 100644
--- a/drivers/staging/brcm80211/sys/wlc_rpc.h
+++ b/drivers/staging/brcm80211/sys/wlc_rpc.h
@@ -362,55 +362,55 @@ static __inline char *_wlc_rpc_id_lookup(const struct name_entry *tbl, int _id)
 #endif				/* BCMDBG */
 
 /* refer to txpwr_limits_t for each elements, mcs32 is the at the end for 1 byte */
-#define TXPOWER_XDR_SZ	(ROUNDUP(WLC_NUM_RATES_CCK, 4) + ROUNDUP(WLC_NUM_RATES_OFDM, 4) * 4 + \
-	ROUNDUP(WLC_NUM_RATES_MCS_1_STREAM, 4) * 6 + ROUNDUP(WLC_NUM_RATES_MCS_2_STREAM, 4) * 2 + \
-	ROUNDUP(1, 4))
+#define TXPOWER_XDR_SZ	(roundup(WLC_NUM_RATES_CCK, 4) + roundup(WLC_NUM_RATES_OFDM, 4) * 4 + \
+	roundup(WLC_NUM_RATES_MCS_1_STREAM, 4) * 6 + roundup(WLC_NUM_RATES_MCS_2_STREAM, 4) * 2 + \
+	roundup(1, 4))
 
 #define wlc_rpc_txpwr_limits(b, txpwr, op, err)	\
 	do {											\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->cck, WLC_NUM_RATES_CCK);		\
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->cck, WLC_NUM_RATES_CCK);		\
 		ASSERT(!(err));									\
 												\
 		/* 20 MHz Legacy OFDM rates with SISO transmission */				\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->ofdm, WLC_NUM_RATES_OFDM);	\
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->ofdm, WLC_NUM_RATES_OFDM);	\
 		ASSERT(!(err));									\
 												\
 		/* 20 MHz Legacy OFDM rates with CDD transmission */				\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->ofdm_cdd, WLC_NUM_RATES_OFDM);   \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->ofdm_cdd, WLC_NUM_RATES_OFDM);   \
 		ASSERT(!(err));									\
 												\
 		/* 40 MHz Legacy OFDM rates with SISO transmission */				\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->ofdm_40_siso, WLC_NUM_RATES_OFDM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->ofdm_40_siso, WLC_NUM_RATES_OFDM); \
 		ASSERT(!(err));									\
 												\
 		/* 40 MHz Legacy OFDM rates with CDD transmission */				\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->ofdm_40_cdd, WLC_NUM_RATES_OFDM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->ofdm_40_cdd, WLC_NUM_RATES_OFDM); \
 		ASSERT(!(err));									\
 												\
 		/* 20MHz MCS rates SISO/CDD/STBC/SDM */							 \
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_20_siso, WLC_NUM_RATES_MCS_1_STREAM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->mcs_20_siso, WLC_NUM_RATES_MCS_1_STREAM); \
 		ASSERT(!(err));									\
 												\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_20_cdd, WLC_NUM_RATES_MCS_1_STREAM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->mcs_20_cdd, WLC_NUM_RATES_MCS_1_STREAM); \
 		ASSERT(!(err));									\
 												\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_20_stbc, WLC_NUM_RATES_MCS_1_STREAM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->mcs_20_stbc, WLC_NUM_RATES_MCS_1_STREAM); \
 		ASSERT(!(err));									\
 												\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_20_mimo, WLC_NUM_RATES_MCS_2_STREAM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->mcs_20_mimo, WLC_NUM_RATES_MCS_2_STREAM); \
 		ASSERT(!(err));									\
 												\
 		/* 40MHz MCS rates SISO/CDD/STBC/SDM */							 \
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_40_siso, WLC_NUM_RATES_MCS_1_STREAM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->mcs_40_siso, WLC_NUM_RATES_MCS_1_STREAM); \
 		ASSERT(!(err));									\
 												\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_40_cdd, WLC_NUM_RATES_MCS_1_STREAM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->mcs_40_cdd, WLC_NUM_RATES_MCS_1_STREAM); \
 		ASSERT(!(err));									\
 												\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_40_stbc, WLC_NUM_RATES_MCS_1_STREAM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->mcs_40_stbc, WLC_NUM_RATES_MCS_1_STREAM); \
 		ASSERT(!(err));									\
 												\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_40_mimo, WLC_NUM_RATES_MCS_2_STREAM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->mcs_40_mimo, WLC_NUM_RATES_MCS_2_STREAM); \
 		ASSERT(!(err));									\
 	} while (0)
 
@@ -420,40 +420,40 @@ typedef struct wlc_rpc_ctx {
 	wlc_hw_info_t *wlc_hw;
 } wlc_rpc_ctx_t;
 
-static INLINE rpc_buf_t *wlc_rpc_buf_alloc(rpc_info_t * rpc, bcm_xdr_buf_t * b,
+static inline rpc_buf_t *wlc_rpc_buf_alloc(rpc_info_t *rpc, bcm_xdr_buf_t *b,
 					   uint len, wlc_rpc_id_t rpc_id)
 {
 	rpc_buf_t *rpc_buf;
 
-	rpc_buf = bcm_rpc_buf_alloc(rpc, len + sizeof(uint32));
+	rpc_buf = bcm_rpc_buf_alloc(rpc, len + sizeof(u32));
 
 	if (!rpc_buf)
 		return NULL;
 
 	bcm_xdr_buf_init(b, bcm_rpc_buf_data(bcm_rpc_tp_get(rpc), rpc_buf),
-			 len + sizeof(uint32));
+			 len + sizeof(u32));
 
-	bcm_xdr_pack_uint32(b, rpc_id);
+	bcm_xdr_pack_u32(b, rpc_id);
 
 	return rpc_buf;
 }
 
 #if defined(BCMDBG)
 static __inline wlc_rpc_id_t
-wlc_rpc_id_get(struct rpc_info *rpc, rpc_buf_t * buf)
+wlc_rpc_id_get(struct rpc_info *rpc, rpc_buf_t *buf)
 {
 	wlc_rpc_id_t rpc_id;
 	bcm_xdr_buf_t b;
 
 	bcm_xdr_buf_init(&b, bcm_rpc_buf_data(bcm_rpc_tp_get(rpc), buf),
-			 sizeof(uint32));
+			 sizeof(u32));
 
-	bcm_xdr_unpack_uint32(&b, (uint32 *) ((uintptr) & rpc_id));
+	bcm_xdr_unpack_u32(&b, (u32 *)((unsigned long) & rpc_id));
 	return rpc_id;
 }
 #endif
 
-static __inline int _wlc_rpc_call(struct rpc_info *rpc, rpc_buf_t * send)
+static __inline int _wlc_rpc_call(struct rpc_info *rpc, rpc_buf_t *send)
 {
 	int _err = 0;
 #if defined(BCMDBG)
@@ -481,24 +481,24 @@ static __inline int _wlc_rpc_call(struct rpc_info *rpc, rpc_buf_t * send)
 #include <d11.h>
 
 #ifdef WLC_LOW
-extern void wlc_rpc_bmac_dispatch(wlc_rpc_ctx_t * rpc_ctx, struct rpc_buf *buf);
-extern void wlc_rpc_bmac_dump_txfifohist(wlc_hw_info_t * wlc_hw,
+extern void wlc_rpc_bmac_dispatch(wlc_rpc_ctx_t *rpc_ctx, struct rpc_buf *buf);
+extern void wlc_rpc_bmac_dump_txfifohist(wlc_hw_info_t *wlc_hw,
 					 bool dump_clear);
 #else
-extern void wlc_rpc_high_dispatch(wlc_rpc_ctx_t * ctx, struct rpc_buf *buf);
+extern void wlc_rpc_high_dispatch(wlc_rpc_ctx_t *ctx, struct rpc_buf *buf);
 #endif
 
-/* Packed structure for ease of transport across RPC bus along uint32 boundary */
+/* Packed structure for ease of transport across RPC bus along u32 boundary */
 typedef struct wlc_rpc_txstatus {
-	uint32 PAD_framelen;
-	uint32 status_frameid;
-	uint32 sequence_lasttxtime;
-	uint32 ackphyrxsh_phyerr;
+	u32 PAD_framelen;
+	u32 status_frameid;
+	u32 sequence_lasttxtime;
+	u32 ackphyrxsh_phyerr;
 } wlc_rpc_txstatus_t;
 
-static INLINE
-    void txstatus2rpc_txstatus(tx_status_t * txstatus,
-			       wlc_rpc_txstatus_t * rpc_txstatus)
+static inline
+    void txstatus2rpc_txstatus(tx_status_t *txstatus,
+			       wlc_rpc_txstatus_t *rpc_txstatus)
 {
 	rpc_txstatus->PAD_framelen = txstatus->framelen;
 	rpc_txstatus->status_frameid =
@@ -509,9 +509,9 @@ static INLINE
 	    (txstatus->ackphyrxsh << 16) | txstatus->phyerr;
 }
 
-static INLINE
-    void rpc_txstatus2txstatus(wlc_rpc_txstatus_t * rpc_txstatus,
-			       tx_status_t * txstatus)
+static inline
+    void rpc_txstatus2txstatus(wlc_rpc_txstatus_t *rpc_txstatus,
+			       tx_status_t *txstatus)
 {
 	txstatus->framelen = rpc_txstatus->PAD_framelen & 0xffff;
 	txstatus->status = (rpc_txstatus->status_frameid >> 16) & 0xffff;
@@ -522,6 +522,6 @@ static INLINE
 	txstatus->phyerr = rpc_txstatus->ackphyrxsh_phyerr & 0xffff;
 }
 
-extern void wlc_bmac_dngl_reboot(rpc_info_t * rpc);
+extern void wlc_bmac_dngl_reboot(rpc_info_t *rpc);
 
 #endif				/* WLC_RPC_H */
diff --git a/drivers/staging/brcm80211/sys/wlc_rpctx.h b/drivers/staging/brcm80211/sys/wlc_rpctx.h
index 5abd35c..7427154 100644
--- a/drivers/staging/brcm80211/sys/wlc_rpctx.h
+++ b/drivers/staging/brcm80211/sys/wlc_rpctx.h
@@ -34,28 +34,28 @@ struct wlc_rpc_phy {
 	struct rpc_info *rpc;
 };
 
-#define RPCTX_ENAB(pub)		(TRUE)
-extern rpctx_info_t *wlc_rpctx_attach(wlc_pub_t * pub, struct wlc_info *wlc);
-extern int wlc_rpctx_fifoinit(rpctx_info_t * rpctx, uint fifo, uint ntxd);
-extern void wlc_rpctx_detach(rpctx_info_t * rpctx);
-extern int wlc_rpctx_dump(rpctx_info_t * rpctx, struct bcmstrbuf *b);
-extern void *wlc_rpctx_getnexttxp(rpctx_info_t * rpctx, uint fifo);
-extern void wlc_rpctx_txreclaim(rpctx_info_t * rpctx);
-extern uint wlc_rpctx_txavail(rpctx_info_t * rpctx, uint fifo);
-extern int wlc_rpctx_pkteng(rpctx_info_t * rpctx, uint fifo, void *p);
-extern int wlc_rpctx_tx(rpctx_info_t * rpctx, uint fifo, void *p, bool commit,
-			uint16 frameid, uint8 txpktpend);
-extern void wlc_rpctx_txpktpendinc(rpctx_info_t * rpctx, uint fifo, uint8 val);
-extern void wlc_rpctx_txpktpenddec(rpctx_info_t * rpctx, uint fifo, uint8 val);
-extern void wlc_rpctx_txpktpendclr(rpctx_info_t * rpctx, uint fifo);
-extern int wlc_rpctx_txpktpend(rpctx_info_t * rpctx, uint fifo, bool all);
+#define RPCTX_ENAB(pub)		(true)
+extern rpctx_info_t *wlc_rpctx_attach(wlc_pub_t *pub, struct wlc_info *wlc);
+extern int wlc_rpctx_fifoinit(rpctx_info_t *rpctx, uint fifo, uint ntxd);
+extern void wlc_rpctx_detach(rpctx_info_t *rpctx);
+extern int wlc_rpctx_dump(rpctx_info_t *rpctx, struct bcmstrbuf *b);
+extern void *wlc_rpctx_getnexttxp(rpctx_info_t *rpctx, uint fifo);
+extern void wlc_rpctx_txreclaim(rpctx_info_t *rpctx);
+extern uint wlc_rpctx_txavail(rpctx_info_t *rpctx, uint fifo);
+extern int wlc_rpctx_pkteng(rpctx_info_t *rpctx, uint fifo, void *p);
+extern int wlc_rpctx_tx(rpctx_info_t *rpctx, uint fifo, void *p, bool commit,
+			u16 frameid, u8 txpktpend);
+extern void wlc_rpctx_txpktpendinc(rpctx_info_t *rpctx, uint fifo, u8 val);
+extern void wlc_rpctx_txpktpenddec(rpctx_info_t *rpctx, uint fifo, u8 val);
+extern void wlc_rpctx_txpktpendclr(rpctx_info_t *rpctx, uint fifo);
+extern int wlc_rpctx_txpktpend(rpctx_info_t *rpctx, uint fifo, bool all);
 
 #else
-#define	RPCTX_ENAB(pub)			(FALSE)
+#define	RPCTX_ENAB(pub)			(false)
 #define	wlc_rpctx_attach(pub, wlc)	(NULL)
 #define	wlc_rpctx_fifoinit(rpctx, fifo, ntxd) (0)
 #define	wlc_rpctx_detach(rpctx)		ASSERT(0)
-#define	wlc_rpctx_txavail(rpctx, f)	(FALSE)
+#define	wlc_rpctx_txavail(rpctx, f)	(false)
 #define	wlc_rpctx_dump(rpctx, b)		(0)
 #define	wlc_rpctx_getnexttxp(rpctx, f)		(NULL)
 #define	wlc_rpctx_txreclaim(rpctx)		ASSERT(0)
diff --git a/drivers/staging/brcm80211/sys/wlc_scb.h b/drivers/staging/brcm80211/sys/wlc_scb.h
index 7c21b1c..ce26c74 100644
--- a/drivers/staging/brcm80211/sys/wlc_scb.h
+++ b/drivers/staging/brcm80211/sys/wlc_scb.h
@@ -19,15 +19,15 @@
 
 #include <proto/802.1d.h>
 
-extern bool wlc_aggregatable(wlc_info_t * wlc, uint8 tid);
+extern bool wlc_aggregatable(wlc_info_t *wlc, u8 tid);
 
 #define AMPDU_TX_BA_MAX_WSIZE	64	/* max Tx ba window size (in pdu) */
 /* structure to store per-tid state for the ampdu initiator */
 typedef struct scb_ampdu_tid_ini {
-	uint32 magic;
-	uint8 tx_in_transit;	/* number of pending mpdus in transit in driver */
-	uint8 tid;		/* initiator tid for easy lookup */
-	uint8 txretry[AMPDU_TX_BA_MAX_WSIZE];	/* tx retry count; indexed by seq modulo */
+	u32 magic;
+	u8 tx_in_transit;	/* number of pending mpdus in transit in driver */
+	u8 tid;		/* initiator tid for easy lookup */
+	u8 txretry[AMPDU_TX_BA_MAX_WSIZE];	/* tx retry count; indexed by seq modulo */
 	struct scb *scb;	/* backptr for easy lookup */
 } scb_ampdu_tid_ini_t;
 
@@ -35,11 +35,11 @@ typedef struct scb_ampdu_tid_ini {
 
 typedef struct scb_ampdu {
 	struct scb *scb;	/* back pointer for easy reference */
-	uint8 mpdu_density;	/* mpdu density */
-	uint8 max_pdu;		/* max pdus allowed in ampdu */
-	uint8 release;		/* # of mpdus released at a time */
-	uint16 min_len;		/* min mpdu len to support the density */
-	uint32 max_rxlen;	/* max ampdu rcv length; 8k, 16k, 32k, 64k */
+	u8 mpdu_density;	/* mpdu density */
+	u8 max_pdu;		/* max pdus allowed in ampdu */
+	u8 release;		/* # of mpdus released at a time */
+	u16 min_len;		/* min mpdu len to support the density */
+	u32 max_rxlen;	/* max ampdu rcv length; 8k, 16k, 32k, 64k */
 	struct pktq txq;	/* sdu transmit queue pending aggregation */
 
 	/* This could easily be a ini[] pointer and we keep this info in wl itself instead
@@ -54,158 +54,31 @@ typedef struct scb_ampdu {
 
 /* station control block - one per remote MAC address */
 struct scb {
-	uint32 magic;
-	uint32 flags;		/* various bit flags as defined below */
-	uint32 flags2;		/* various bit flags2 as defined below */
-	uint8 state;		/* current state bitfield of auth/assoc process */
+	u32 magic;
+	u32 flags;		/* various bit flags as defined below */
+	u32 flags2;		/* various bit flags2 as defined below */
+	u8 state;		/* current state bitfield of auth/assoc process */
 	struct ether_addr ea;	/* station address */
 	void *fragbuf[NUMPRIO];	/* defragmentation buffer per prio */
 	uint fragresid[NUMPRIO];	/* #bytes unused in frag buffer per prio */
 
-	uint16 seqctl[NUMPRIO];	/* seqctl of last received frame (for dups) */
-	uint16 seqctl_nonqos;	/* seqctl of last received frame (for dups) for
+	u16 seqctl[NUMPRIO];	/* seqctl of last received frame (for dups) */
+	u16 seqctl_nonqos;	/* seqctl of last received frame (for dups) for
 				 * non-QoS data and management
 				 */
-	uint16 seqnum[NUMPRIO];	/* WME: driver maintained sw seqnum per priority */
+	u16 seqnum[NUMPRIO];	/* WME: driver maintained sw seqnum per priority */
 
 	scb_ampdu_t scb_ampdu;	/* AMPDU state including per tid info */
 };
 
-/* SCB flags */
-#define SCB_NONERP		0x0001	/* No ERP */
-#define SCB_LONGSLOT		0x0002	/* Long Slot */
-#define SCB_SHORTPREAMBLE	0x0004	/* Short Preamble ok */
-#define SCB_8021XHDR		0x0008	/* 802.1x Header */
-#define SCB_WPA_SUP		0x0010	/* 0 - authenticator, 1 - supplicant */
-#define SCB_DEAUTH		0x0020	/* 0 - ok to deauth, 1 - no (just did) */
-#define SCB_WMECAP		0x0040	/* WME Cap; may ONLY be set if WME_ENAB(wlc) */
-#define SCB_BRCM		0x0100	/* BRCM AP or STA */
-#define SCB_WDS_LINKUP		0x0200	/* WDS link up */
-#define SCB_RESERVED1		0x0400
-#define SCB_RESERVED2		0x0800
-#define SCB_MYAP		0x1000	/* We are associated to this AP */
-#define SCB_PENDING_PROBE	0x2000	/* Probe is pending to this SCB */
-#define SCB_AMSDUCAP		0x4000	/* A-MSDU capable */
-#define SCB_BACAP		0x8000	/* pre-n blockack capable */
+/* scb flags */
+#define SCB_WMECAP		0x0040	/* may ONLY be set if WME_ENAB(wlc) */
 #define SCB_HTCAP		0x10000	/* HT (MIMO) capable device */
-#define SCB_RECV_PM		0x20000	/* state of PM bit in last data frame recv'd */
-#define SCB_AMPDUCAP		0x40000	/* A-MPDU capable */
 #define SCB_IS40		0x80000	/* 40MHz capable */
-#define SCB_NONGF		0x100000	/* Not Green Field capable */
-#define SCB_APSDCAP		0x200000	/* APSD capable */
-#define SCB_PENDING_FREE	0x400000	/* marked for deletion - clip recursion */
-#define SCB_PENDING_PSPOLL	0x800000	/* PS-Poll is pending to this SCB */
-#define SCB_RIFSCAP		0x1000000	/* RIFS capable */
-#define SCB_HT40INTOLERANT	0x2000000	/* 40 Intolerant */
-#define SCB_WMEPS		0x4000000	/* PS + WME w/o APSD capable */
-#define SCB_SENT_APSD_TRIG	0x8000000	/* APSD Trigger Null Frame was recently sent */
-#define SCB_COEX_MGMT		0x10000000	/* Coexistence Management supported */
-#define SCB_IBSS_PEER		0x20000000	/* Station is an IBSS peer */
 #define SCB_STBCCAP		0x40000000	/* STBC Capable */
-
-/* scb flags2 */
-#define SCB2_SGI20_CAP		0x00000001	/* 20MHz SGI Capable */
-#define SCB2_SGI40_CAP		0x00000002	/* 40MHz SGI Capable */
-#define SCB2_RX_LARGE_AGG	0x00000004	/* device can rx large aggs */
-#define SCB2_INTERNAL		0x00000008	/* This scb is an internal scb */
-#define SCB2_IN_ASSOC		0x00000010	/* Incoming assocation in progress */
-#define SCB2_RESERVED1		0x00000040
-#define SCB2_LDPCCAP		0x00000080	/* LDPC Cap */
-
-/* scb association state bitfield */
-#define UNAUTHENTICATED		0	/* unknown */
-#define AUTHENTICATED		1	/* 802.11 authenticated (open or shared key) */
-#define ASSOCIATED		2	/* 802.11 associated */
-#define PENDING_AUTH		4	/* Waiting for 802.11 authentication response */
-#define PENDING_ASSOC		8	/* Waiting for 802.11 association response */
-#define AUTHORIZED		0x10	/* 802.1X authorized */
-#define TAKEN4IBSS		0x80	/* Taken */
-
-/* scb association state helpers */
-#define SCB_ASSOCIATED(a)	((a)->state & ASSOCIATED)
-#define SCB_AUTHENTICATED(a)	((a)->state & AUTHENTICATED)
-#define SCB_AUTHORIZED(a)	((a)->state & AUTHORIZED)
-
-/* flag access */
-#define SCB_ISMYAP(a)           ((a)->flags & SCB_MYAP)
-#define SCB_ISPERMANENT(a)      ((a)->permanent)
-#define	SCB_INTERNAL(a) 	((a)->flags2 & SCB2_INTERNAL)
-/* scb association state helpers w/ respect to ssid (in case of multi ssids)
- * The bit set in the bit field is relative to the current state (i.e. if
- * the current state is "associated", a 1 at the position "i" means the
- * sta is associated to ssid "i"
- */
-#define SCB_ASSOCIATED_BSSCFG(a, i)	\
-	(((a)->state & ASSOCIATED) && isset(&(scb->auth_bsscfg), i))
-
-#define SCB_AUTHENTICATED_BSSCFG(a, i)	\
-	(((a)->state & AUTHENTICATED) && isset(&(scb->auth_bsscfg), i))
-
-#define SCB_AUTHORIZED_BSSCFG(a, i)	\
-	(((a)->state & AUTHORIZED) && isset(&(scb->auth_bsscfg), i))
-
-#define SCB_LONG_TIMEOUT	3600	/* # seconds of idle time after which we proactively
-					 * free an authenticated SCB
-					 */
-#define SCB_SHORT_TIMEOUT	  60	/* # seconds of idle time after which we will reclaim an
-					 * authenticated SCB if we would otherwise fail
-					 * an SCB allocation.
-					 */
-#define SCB_TIMEOUT		  60	/* # seconds: interval to probe idle STAs */
-#define SCB_ACTIVITY_TIME	   5	/* # seconds: skip probe if activity during this time */
-#define SCB_GRACE_ATTEMPTS	   3	/* # attempts to probe sta beyond scb_activity_time */
-
-/* scb_info macros */
+#define SCB_WME(a)		((a)->flags & SCB_WMECAP)/* implies WME_ENAB */
+#define SCB_SEQNUM(scb, prio)	((scb)->seqnum[(prio)])
 #define SCB_PS(a)		NULL
-#define SCB_WDS(a)		NULL
-#define SCB_INTERFACE(a)        ((a)->bsscfg->wlcif->wlif)
-#define SCB_WLCIFP(a)           (((a)->bsscfg->wlcif))
-#define WLC_BCMC_PSMODE(wlc, bsscfg) (TRUE)
-
-#define SCB_WME(a)		((a)->flags & SCB_WMECAP)	/* Also implies WME_ENAB(wlc) */
-
-#define SCB_AMPDU(a)		TRUE
-#define SCB_AMSDU(a)		FALSE
-
-#define SCB_HT_CAP(a)		((a)->flags & SCB_HTCAP)
-#define SCB_ISGF_CAP(a)		(((a)->flags & (SCB_HTCAP | SCB_NONGF)) == SCB_HTCAP)
-#define SCB_NONGF_CAP(a)	(((a)->flags & (SCB_HTCAP | SCB_NONGF)) == \
-					(SCB_HTCAP | SCB_NONGF))
-#define SCB_COEX_CAP(a)		((a)->flags & SCB_COEX_MGMT)
 #define SCB_STBC_CAP(a)		((a)->flags & SCB_STBCCAP)
-#define SCB_LDPC_CAP(a)		(SCB_HT_CAP(a) && ((a)->flags2 & SCB2_LDPCCAP))
-
-#define SCB_IS_IBSS_PEER(a)	((a)->flags & SCB_IBSS_PEER)
-#define SCB_SET_IBSS_PEER(a)	((a)->flags |= SCB_IBSS_PEER)
-#define SCB_UNSET_IBSS_PEER(a)	((a)->flags &= ~SCB_IBSS_PEER)
-
-#define SCB_11E(a)		FALSE
-
-#define SCB_QOS(a)		((a)->flags & (SCB_WMECAP | SCB_HTCAP))
-
-#define SCB_BSSCFG(a)           ((a)->bsscfg)
-
-#define SCB_SEQNUM(scb, prio)	(scb)->seqnum[(prio)]
-
-#define SCB_ISMULTI(a)	ETHER_ISMULTI((a)->ea.octet)
-#define SCB_ISVALID(a, _pkttag_dbgid)	((a) && (a)->_dbgid == (_pkttag_dbgid))
-
-/* API for accessing SCB pointer in WLPKTTAG */
-#ifdef BCMDBG
-#define WLPKTTAGSCBSET(p, scb) { WLPKTTAG(p)->_scb = scb; WLPKTTAG(p)->_scb_dbgid = scb->_dbgid; }
-#define WLPKTTAGSCBCLR(p) { WLPKTTAG(p)->_scb = NULL; WLPKTTAG(p)->_scb_dbgid = 0; }
-#else
-#define WLPKTTAGSCBSET(p, scb) (WLPKTTAG(p)->_scb = scb)
-#define WLPKTTAGSCBCLR(p) (WLPKTTAG(p)->_scb = NULL)
-#endif
-
-#define WLCNTSCBINCR(a)		/* No stats support */
-#define WLCNTSCBDECR(a)		/* No stats support */
-#define WLCNTSCBADD(a,delta)	/* No stats support */
-#define WLCNTSCBSET(a,value)	/* No stats support */
-#define WLCNTSCBVAL(a)		0	/* No stats support */
-#define WLCNTSCB_COND_SET(c, a, v)	/* No stats support */
-#define WLCNTSCB_COND_ADD(c, a, d)	/* No stats support */
-#define WLCNTSCB_COND_INCR(c, a)	/* No stats support */
-
+#define SCB_AMPDU(a)		true
 #endif				/* _wlc_scb_h_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_stf.c b/drivers/staging/brcm80211/sys/wlc_stf.c
index ea3a07c..4728ad9 100644
--- a/drivers/staging/brcm80211/sys/wlc_stf.c
+++ b/drivers/staging/brcm80211/sys/wlc_stf.c
@@ -14,8 +14,9 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#include <linux/kernel.h>
 #include <wlc_cfg.h>
-#include <typedefs.h>
+#include <linuxver.h>
 #include <bcmdefs.h>
 #include <osl.h>
 #include <bcmutils.h>
@@ -23,7 +24,6 @@
 #include <bcmendian.h>
 #include <proto/802.11.h>
 #include <wlioctl.h>
-#include <bcmwpa.h>
 #include <bcmwifi.h>
 #include <d11.h>
 #include <wlc_rate.h>
@@ -40,20 +40,20 @@
 #define WLC_STF_SS_STBC_RX(wlc) (WLCISNPHY(wlc->band) && \
 	NREV_GT(wlc->band->phyrev, 3) && NREV_LE(wlc->band->phyrev, 6))
 
-static int8 wlc_stf_stbc_rx_get(wlc_info_t * wlc);
-static bool wlc_stf_stbc_tx_set(wlc_info_t * wlc, int32 int_val);
-static int wlc_stf_txcore_set(wlc_info_t * wlc, uint8 Nsts, uint8 val);
-static int wlc_stf_spatial_policy_set(wlc_info_t * wlc, int val);
-static void wlc_stf_stbc_rx_ht_update(wlc_info_t * wlc, int val);
+static s8 wlc_stf_stbc_rx_get(wlc_info_t *wlc);
+static bool wlc_stf_stbc_tx_set(wlc_info_t *wlc, s32 int_val);
+static int wlc_stf_txcore_set(wlc_info_t *wlc, u8 Nsts, u8 val);
+static int wlc_stf_spatial_policy_set(wlc_info_t *wlc, int val);
+static void wlc_stf_stbc_rx_ht_update(wlc_info_t *wlc, int val);
 
-static void _wlc_stf_phy_txant_upd(wlc_info_t * wlc);
-static uint16 _wlc_stf_phytxchain_sel(wlc_info_t * wlc, ratespec_t rspec);
+static void _wlc_stf_phy_txant_upd(wlc_info_t *wlc);
+static u16 _wlc_stf_phytxchain_sel(wlc_info_t *wlc, ratespec_t rspec);
 
 #define NSTS_1	1
 #define NSTS_2	2
 #define NSTS_3	3
 #define NSTS_4	4
-const uint8 txcore_default[5] = {
+const u8 txcore_default[5] = {
 	(0),			/* bitmap of the core enabled */
 	(0x01),			/* For Nsts = 1, enable core 1 */
 	(0x03),			/* For Nsts = 2, enable core 1 & 2 */
@@ -61,7 +61,7 @@ const uint8 txcore_default[5] = {
 	(0x0f)			/* For Nsts = 4, enable all cores */
 };
 
-static void wlc_stf_stbc_rx_ht_update(wlc_info_t * wlc, int val)
+static void wlc_stf_stbc_rx_ht_update(wlc_info_t *wlc, int val)
 {
 	ASSERT((val == HT_CAP_RX_STBC_NO)
 	       || (val == HT_CAP_RX_STBC_ONE_STREAM));
@@ -77,12 +77,12 @@ static void wlc_stf_stbc_rx_ht_update(wlc_info_t * wlc, int val)
 
 	if (wlc->pub->up) {
 		wlc_update_beacon(wlc);
-		wlc_update_probe_resp(wlc, TRUE);
+		wlc_update_probe_resp(wlc, true);
 	}
 }
 
 /* every WLC_TEMPSENSE_PERIOD seconds temperature check to decide whether to turn on/off txchain */
-void wlc_tempsense_upd(wlc_info_t * wlc)
+void wlc_tempsense_upd(wlc_info_t *wlc)
 {
 	wlc_phy_t *pi = wlc->band->pi;
 	uint active_chains, txchain;
@@ -95,28 +95,28 @@ void wlc_tempsense_upd(wlc_info_t * wlc)
 	if (wlc->stf->txchain == wlc->stf->hw_txchain) {
 		if (txchain && (txchain < wlc->stf->hw_txchain)) {
 			/* turn off 1 tx chain */
-			wlc_stf_txchain_set(wlc, txchain, TRUE);
+			wlc_stf_txchain_set(wlc, txchain, true);
 		}
 	} else if (wlc->stf->txchain < wlc->stf->hw_txchain) {
 		if (txchain == wlc->stf->hw_txchain) {
 			/* turn back on txchain */
-			wlc_stf_txchain_set(wlc, txchain, TRUE);
+			wlc_stf_txchain_set(wlc, txchain, true);
 		}
 	}
 }
 
 void
-wlc_stf_ss_algo_channel_get(wlc_info_t * wlc, uint16 * ss_algo_channel,
+wlc_stf_ss_algo_channel_get(wlc_info_t *wlc, u16 *ss_algo_channel,
 			    chanspec_t chanspec)
 {
 	tx_power_t power;
-	uint8 siso_mcs_id, cdd_mcs_id, stbc_mcs_id;
+	u8 siso_mcs_id, cdd_mcs_id, stbc_mcs_id;
 
 	/* Clear previous settings */
 	*ss_algo_channel = 0;
 
 	if (!wlc->pub->up) {
-		*ss_algo_channel = (uint16) - 1;
+		*ss_algo_channel = (u16) -1;
 		return;
 	}
 
@@ -147,19 +147,19 @@ wlc_stf_ss_algo_channel_get(wlc_info_t * wlc, uint16 * ss_algo_channel,
 		setbit(ss_algo_channel, PHY_TXC1_MODE_STBC);
 }
 
-static int8 wlc_stf_stbc_rx_get(wlc_info_t * wlc)
+static s8 wlc_stf_stbc_rx_get(wlc_info_t *wlc)
 {
 	return (wlc->ht_cap.cap & HT_CAP_RX_STBC_MASK) >> HT_CAP_RX_STBC_SHIFT;
 }
 
-static bool wlc_stf_stbc_tx_set(wlc_info_t * wlc, int32 int_val)
+static bool wlc_stf_stbc_tx_set(wlc_info_t *wlc, s32 int_val)
 {
 	if ((int_val != AUTO) && (int_val != OFF) && (int_val != ON)) {
-		return FALSE;
+		return false;
 	}
 
 	if ((int_val == ON) && (wlc->stf->txstreams == 1))
-		return FALSE;
+		return false;
 
 	if ((int_val == OFF) || (wlc->stf->txstreams == 1)
 	    || !WLC_STBC_CAP_PHY(wlc))
@@ -167,30 +167,30 @@ static bool wlc_stf_stbc_tx_set(wlc_info_t * wlc, int32 int_val)
 	else
 		wlc->ht_cap.cap |= HT_CAP_TX_STBC;
 
-	wlc->bandstate[BAND_2G_INDEX]->band_stf_stbc_tx = (int8) int_val;
-	wlc->bandstate[BAND_5G_INDEX]->band_stf_stbc_tx = (int8) int_val;
+	wlc->bandstate[BAND_2G_INDEX]->band_stf_stbc_tx = (s8) int_val;
+	wlc->bandstate[BAND_5G_INDEX]->band_stf_stbc_tx = (s8) int_val;
 
-	return TRUE;
+	return true;
 }
 
-bool wlc_stf_stbc_rx_set(wlc_info_t * wlc, int32 int_val)
+bool wlc_stf_stbc_rx_set(wlc_info_t *wlc, s32 int_val)
 {
 	if ((int_val != HT_CAP_RX_STBC_NO)
 	    && (int_val != HT_CAP_RX_STBC_ONE_STREAM)) {
-		return FALSE;
+		return false;
 	}
 
 	if (WLC_STF_SS_STBC_RX(wlc)) {
 		if ((int_val != HT_CAP_RX_STBC_NO)
 		    && (wlc->stf->rxstreams == 1))
-			return FALSE;
+			return false;
 	}
 
 	wlc_stf_stbc_rx_ht_update(wlc, int_val);
-	return TRUE;
+	return true;
 }
 
-static int wlc_stf_txcore_set(wlc_info_t * wlc, uint8 Nsts, uint8 core_mask)
+static int wlc_stf_txcore_set(wlc_info_t *wlc, u8 Nsts, u8 core_mask)
 {
 	WL_TRACE(("wl%d: %s: Nsts %d core_mask %x\n",
 		  wlc->pub->unit, __func__, Nsts, core_mask));
@@ -227,26 +227,26 @@ static int wlc_stf_txcore_set(wlc_info_t * wlc, uint8 Nsts, uint8 core_mask)
 	return BCME_OK;
 }
 
-static int wlc_stf_spatial_policy_set(wlc_info_t * wlc, int val)
+static int wlc_stf_spatial_policy_set(wlc_info_t *wlc, int val)
 {
 	int i;
-	uint8 core_mask = 0;
+	u8 core_mask = 0;
 
 	WL_TRACE(("wl%d: %s: val %x\n", wlc->pub->unit, __func__, val));
 
-	wlc->stf->spatial_policy = (int8) val;
+	wlc->stf->spatial_policy = (s8) val;
 	for (i = 1; i <= MAX_STREAMS_SUPPORTED; i++) {
 		core_mask = (val == MAX_SPATIAL_EXPANSION) ?
 		    wlc->stf->txchain : txcore_default[i];
-		wlc_stf_txcore_set(wlc, (uint8) i, core_mask);
+		wlc_stf_txcore_set(wlc, (u8) i, core_mask);
 	}
 	return BCME_OK;
 }
 
-int wlc_stf_txchain_set(wlc_info_t * wlc, int32 int_val, bool force)
+int wlc_stf_txchain_set(wlc_info_t *wlc, s32 int_val, bool force)
 {
-	uint8 txchain = (uint8) int_val;
-	uint8 txstreams;
+	u8 txchain = (u8) int_val;
+	u8 txstreams;
 	uint i;
 
 	if (wlc->stf->txchain == txchain)
@@ -257,7 +257,7 @@ int wlc_stf_txchain_set(wlc_info_t * wlc, int32 int_val, bool force)
 		return BCME_RANGE;
 
 	/* if nrate override is configured to be non-SISO STF mode, reject reducing txchain to 1 */
-	txstreams = (uint8) WLC_BITSCNT(txchain);
+	txstreams = (u8) WLC_BITSCNT(txchain);
 	if (txstreams > MAX_STREAMS_SUPPORTED)
 		return BCME_RANGE;
 
@@ -298,17 +298,17 @@ int wlc_stf_txchain_set(wlc_info_t * wlc, int32 int_val, bool force)
 			      wlc->stf->rxchain);
 
 	for (i = 1; i <= MAX_STREAMS_SUPPORTED; i++)
-		wlc_stf_txcore_set(wlc, (uint8) i, txcore_default[i]);
+		wlc_stf_txcore_set(wlc, (u8) i, txcore_default[i]);
 
 	return BCME_OK;
 }
 
-int wlc_stf_rxchain_set(wlc_info_t * wlc, int32 int_val)
+int wlc_stf_rxchain_set(wlc_info_t *wlc, s32 int_val)
 {
-	uint8 rxchain_cnt;
-	uint8 rxchain = (uint8) int_val;
-	uint8 mimops_mode;
-	uint8 old_rxchain, old_rxchain_cnt;
+	u8 rxchain_cnt;
+	u8 rxchain = (u8) int_val;
+	u8 mimops_mode;
+	u8 old_rxchain, old_rxchain_cnt;
 
 	if (wlc->stf->rxchain == rxchain)
 		return BCME_OK;
@@ -317,7 +317,7 @@ int wlc_stf_rxchain_set(wlc_info_t * wlc, int32 int_val)
 	    || !(rxchain & wlc->stf->hw_rxchain))
 		return BCME_RANGE;
 
-	rxchain_cnt = (uint8) WLC_BITSCNT(rxchain);
+	rxchain_cnt = (u8) WLC_BITSCNT(rxchain);
 	if (WLC_STF_SS_STBC_RX(wlc)) {
 		if ((rxchain_cnt == 1)
 		    && (wlc_stf_stbc_rx_get(wlc) != HT_CAP_RX_STBC_NO))
@@ -367,18 +367,18 @@ int wlc_stf_rxchain_set(wlc_info_t * wlc, int32 int_val)
 }
 
 /* update wlc->stf->ss_opmode which represents the operational stf_ss mode we're using */
-int wlc_stf_ss_update(wlc_info_t * wlc, wlcband_t * band)
+int wlc_stf_ss_update(wlc_info_t *wlc, wlcband_t *band)
 {
 	int ret_code = 0;
-	uint8 prev_stf_ss;
-	uint8 upd_stf_ss;
+	u8 prev_stf_ss;
+	u8 upd_stf_ss;
 
 	prev_stf_ss = wlc->stf->ss_opmode;
 
 	/* NOTE: opmode can only be SISO or CDD as STBC is decided on a per-packet basis */
 	if (WLC_STBC_CAP_PHY(wlc) &&
 	    wlc->stf->ss_algosel_auto
-	    && (wlc->stf->ss_algo_channel != (uint16) - 1)) {
+	    && (wlc->stf->ss_algo_channel != (u16) -1)) {
 		ASSERT(isset(&wlc->stf->ss_algo_channel, PHY_TXC1_MODE_CDD)
 		       || isset(&wlc->stf->ss_algo_channel,
 				PHY_TXC1_MODE_SISO));
@@ -402,7 +402,8 @@ int wlc_stf_ss_update(wlc_info_t * wlc, wlcband_t * band)
 	return ret_code;
 }
 
-int BCMATTACHFN(wlc_stf_attach) (wlc_info_t * wlc) {
+int wlc_stf_attach(wlc_info_t *wlc)
+{
 	wlc->bandstate[BAND_2G_INDEX]->band_stf_ss_mode = PHY_TXC1_MODE_SISO;
 	wlc->bandstate[BAND_5G_INDEX]->band_stf_ss_mode = PHY_TXC1_MODE_CDD;
 
@@ -418,16 +419,17 @@ int BCMATTACHFN(wlc_stf_attach) (wlc_info_t * wlc) {
 	wlc->bandstate[BAND_5G_INDEX]->band_stf_stbc_tx = OFF;
 
 	if (WLC_STBC_CAP_PHY(wlc)) {
-		wlc->stf->ss_algosel_auto = TRUE;
-		wlc->stf->ss_algo_channel = (uint16) - 1;	/* Init the default value */
+		wlc->stf->ss_algosel_auto = true;
+		wlc->stf->ss_algo_channel = (u16) -1;	/* Init the default value */
 	}
 	return 0;
 }
 
-void BCMATTACHFN(wlc_stf_detach) (wlc_info_t * wlc) {
+void wlc_stf_detach(wlc_info_t *wlc)
+{
 }
 
-int wlc_stf_ant_txant_validate(wlc_info_t * wlc, int8 val)
+int wlc_stf_ant_txant_validate(wlc_info_t *wlc, s8 val)
 {
 	int bcmerror = BCME_OK;
 
@@ -454,7 +456,7 @@ int wlc_stf_ant_txant_validate(wlc_info_t * wlc, int8 val)
 	}
 
 	if (bcmerror == BCME_OK)
-		wlc->stf->txant = (int8) val;
+		wlc->stf->txant = (s8) val;
 
 	return bcmerror;
 
@@ -474,11 +476,11 @@ int wlc_stf_ant_txant_validate(wlc_info_t * wlc, int8 val)
  *    do tx-antenna selection for SISO transmissions
  * for NREV>=7, bit 6 and bit 7 mean antenna 0 and 1 respectively, nit6+bit7 means both cores active
 */
-static void _wlc_stf_phy_txant_upd(wlc_info_t * wlc)
+static void _wlc_stf_phy_txant_upd(wlc_info_t *wlc)
 {
-	int8 txant;
+	s8 txant;
 
-	txant = (int8) wlc->stf->txant;
+	txant = (s8) wlc->stf->txant;
 	ASSERT(txant == ANT_TX_FORCE_0 || txant == ANT_TX_FORCE_1
 	       || txant == ANT_TX_LAST_RX);
 
@@ -515,15 +517,16 @@ static void _wlc_stf_phy_txant_upd(wlc_info_t * wlc)
 	wlc_bmac_txant_set(wlc->hw, wlc->stf->phytxant);
 }
 
-void wlc_stf_phy_txant_upd(wlc_info_t * wlc)
+void wlc_stf_phy_txant_upd(wlc_info_t *wlc)
 {
 	_wlc_stf_phy_txant_upd(wlc);
 }
 
-void BCMATTACHFN(wlc_stf_phy_chain_calc) (wlc_info_t * wlc) {
+void wlc_stf_phy_chain_calc(wlc_info_t *wlc)
+{
 	/* get available rx/tx chains */
-	wlc->stf->hw_txchain = (uint8) getintvar(wlc->pub->vars, "txchain");
-	wlc->stf->hw_rxchain = (uint8) getintvar(wlc->pub->vars, "rxchain");
+	wlc->stf->hw_txchain = (u8) getintvar(wlc->pub->vars, "txchain");
+	wlc->stf->hw_rxchain = (u8) getintvar(wlc->pub->vars, "rxchain");
 
 	/* these parameter are intended to be used for all PHY types */
 	if (wlc->stf->hw_txchain == 0 || wlc->stf->hw_txchain == 0xf) {
@@ -535,7 +538,7 @@ void BCMATTACHFN(wlc_stf_phy_chain_calc) (wlc_info_t * wlc) {
 	}
 
 	wlc->stf->txchain = wlc->stf->hw_txchain;
-	wlc->stf->txstreams = (uint8) WLC_BITSCNT(wlc->stf->hw_txchain);
+	wlc->stf->txstreams = (u8) WLC_BITSCNT(wlc->stf->hw_txchain);
 
 	if (wlc->stf->hw_rxchain == 0 || wlc->stf->hw_rxchain == 0xf) {
 		if (WLCISNPHY(wlc->band)) {
@@ -546,7 +549,7 @@ void BCMATTACHFN(wlc_stf_phy_chain_calc) (wlc_info_t * wlc) {
 	}
 
 	wlc->stf->rxchain = wlc->stf->hw_rxchain;
-	wlc->stf->rxstreams = (uint8) WLC_BITSCNT(wlc->stf->hw_rxchain);
+	wlc->stf->rxstreams = (u8) WLC_BITSCNT(wlc->stf->hw_rxchain);
 
 	/* initialize the txcore table */
 	bcopy(txcore_default, wlc->stf->txcore, sizeof(wlc->stf->txcore));
@@ -556,9 +559,9 @@ void BCMATTACHFN(wlc_stf_phy_chain_calc) (wlc_info_t * wlc) {
 	wlc_stf_spatial_policy_set(wlc, MIN_SPATIAL_EXPANSION);
 }
 
-static uint16 _wlc_stf_phytxchain_sel(wlc_info_t * wlc, ratespec_t rspec)
+static u16 _wlc_stf_phytxchain_sel(wlc_info_t *wlc, ratespec_t rspec)
 {
-	uint16 phytxant = wlc->stf->phytxant;
+	u16 phytxant = wlc->stf->phytxant;
 
 	if (RSPEC_STF(rspec) != PHY_TXC1_MODE_SISO) {
 		ASSERT(wlc->stf->txstreams > 1);
@@ -569,15 +572,15 @@ static uint16 _wlc_stf_phytxchain_sel(wlc_info_t * wlc, ratespec_t rspec)
 	return phytxant;
 }
 
-uint16 wlc_stf_phytxchain_sel(wlc_info_t * wlc, ratespec_t rspec)
+u16 wlc_stf_phytxchain_sel(wlc_info_t *wlc, ratespec_t rspec)
 {
 	return _wlc_stf_phytxchain_sel(wlc, rspec);
 }
 
-uint16 wlc_stf_d11hdrs_phyctl_txant(wlc_info_t * wlc, ratespec_t rspec)
+u16 wlc_stf_d11hdrs_phyctl_txant(wlc_info_t *wlc, ratespec_t rspec)
 {
-	uint16 phytxant = wlc->stf->phytxant;
-	uint16 mask = PHY_TXC_ANT_MASK;
+	u16 phytxant = wlc->stf->phytxant;
+	u16 mask = PHY_TXC_ANT_MASK;
 
 	/* for non-siso rates or default setting, use the available chains */
 	if (WLCISNPHY(wlc->band)) {
diff --git a/drivers/staging/brcm80211/sys/wlc_stf.h b/drivers/staging/brcm80211/sys/wlc_stf.h
index b789ea1..ee9b02a 100644
--- a/drivers/staging/brcm80211/sys/wlc_stf.h
+++ b/drivers/staging/brcm80211/sys/wlc_stf.h
@@ -20,23 +20,23 @@
 #define MIN_SPATIAL_EXPANSION	0
 #define MAX_SPATIAL_EXPANSION	1
 
-extern int wlc_stf_attach(wlc_info_t * wlc);
-extern void wlc_stf_detach(wlc_info_t * wlc);
+extern int wlc_stf_attach(wlc_info_t *wlc);
+extern void wlc_stf_detach(wlc_info_t *wlc);
 
-extern void wlc_tempsense_upd(wlc_info_t * wlc);
-extern void wlc_stf_ss_algo_channel_get(wlc_info_t * wlc,
-					uint16 * ss_algo_channel,
+extern void wlc_tempsense_upd(wlc_info_t *wlc);
+extern void wlc_stf_ss_algo_channel_get(wlc_info_t *wlc,
+					u16 *ss_algo_channel,
 					chanspec_t chanspec);
-extern int wlc_stf_ss_update(wlc_info_t * wlc, struct wlcband *band);
-extern void wlc_stf_phy_txant_upd(wlc_info_t * wlc);
-extern int wlc_stf_txchain_set(wlc_info_t * wlc, int32 int_val, bool force);
-extern int wlc_stf_rxchain_set(wlc_info_t * wlc, int32 int_val);
-extern bool wlc_stf_stbc_rx_set(wlc_info_t * wlc, int32 int_val);
+extern int wlc_stf_ss_update(wlc_info_t *wlc, struct wlcband *band);
+extern void wlc_stf_phy_txant_upd(wlc_info_t *wlc);
+extern int wlc_stf_txchain_set(wlc_info_t *wlc, s32 int_val, bool force);
+extern int wlc_stf_rxchain_set(wlc_info_t *wlc, s32 int_val);
+extern bool wlc_stf_stbc_rx_set(wlc_info_t *wlc, s32 int_val);
 
-extern int wlc_stf_ant_txant_validate(wlc_info_t * wlc, int8 val);
-extern void wlc_stf_phy_txant_upd(wlc_info_t * wlc);
-extern void wlc_stf_phy_chain_calc(wlc_info_t * wlc);
-extern uint16 wlc_stf_phytxchain_sel(wlc_info_t * wlc, ratespec_t rspec);
-extern uint16 wlc_stf_d11hdrs_phyctl_txant(wlc_info_t * wlc, ratespec_t rspec);
-extern uint16 wlc_stf_spatial_expansion_get(wlc_info_t * wlc, ratespec_t rspec);
+extern int wlc_stf_ant_txant_validate(wlc_info_t *wlc, s8 val);
+extern void wlc_stf_phy_txant_upd(wlc_info_t *wlc);
+extern void wlc_stf_phy_chain_calc(wlc_info_t *wlc);
+extern u16 wlc_stf_phytxchain_sel(wlc_info_t *wlc, ratespec_t rspec);
+extern u16 wlc_stf_d11hdrs_phyctl_txant(wlc_info_t *wlc, ratespec_t rspec);
+extern u16 wlc_stf_spatial_expansion_get(wlc_info_t *wlc, ratespec_t rspec);
 #endif				/* _wlc_stf_h_ */
diff --git a/drivers/staging/brcm80211/util/aiutils.c b/drivers/staging/brcm80211/util/aiutils.c
index 8883af0..75a7e3a 100644
--- a/drivers/staging/brcm80211/util/aiutils.c
+++ b/drivers/staging/brcm80211/util/aiutils.c
@@ -14,9 +14,11 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <typedefs.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
 #include <bcmdefs.h>
 #include <osl.h>
+#include <linuxver.h>
 #include <bcmutils.h>
 #include <siutils.h>
 #include <hndsoc.h>
@@ -30,13 +32,13 @@
 
 /* EROM parsing */
 
-static uint32
-get_erom_ent(si_t * sih, uint32 ** eromptr, uint32 mask, uint32 match)
+static u32
+get_erom_ent(si_t *sih, u32 **eromptr, u32 mask, u32 match)
 {
-	uint32 ent;
+	u32 ent;
 	uint inv = 0, nom = 0;
 
-	while (TRUE) {
+	while (true) {
 		ent = R_REG(si_osh(sih), *eromptr);
 		(*eromptr)++;
 
@@ -65,11 +67,11 @@ get_erom_ent(si_t * sih, uint32 ** eromptr, uint32 mask, uint32 match)
 	return ent;
 }
 
-static uint32
-get_asd(si_t * sih, uint32 ** eromptr, uint sp, uint ad, uint st,
-	uint32 * addrl, uint32 * addrh, uint32 * sizel, uint32 * sizeh)
+static u32
+get_asd(si_t *sih, u32 **eromptr, uint sp, uint ad, uint st,
+	u32 *addrl, u32 *addrh, u32 *sizel, u32 *sizeh)
 {
-	uint32 asd, sz, szd;
+	u32 asd, sz, szd;
 
 	asd = get_erom_ent(sih, eromptr, ER_VALID, ER_VALID);
 	if (((asd & ER_TAG1) != ER_ADD) ||
@@ -100,26 +102,27 @@ get_asd(si_t * sih, uint32 ** eromptr, uint sp, uint ad, uint st,
 	return asd;
 }
 
-static void ai_hwfixup(si_info_t * sii)
+static void ai_hwfixup(si_info_t *sii)
 {
 }
 
 /* parse the enumeration rom to identify all cores */
-void BCMATTACHFN(ai_scan) (si_t * sih, void *regs, uint devid) {
+void ai_scan(si_t *sih, void *regs, uint devid)
+{
 	si_info_t *sii = SI_INFO(sih);
 	chipcregs_t *cc = (chipcregs_t *) regs;
-	uint32 erombase, *eromptr, *eromlim;
+	u32 erombase, *eromptr, *eromlim;
 
 	erombase = R_REG(sii->osh, &cc->eromptr);
 
 	switch (BUSTYPE(sih->bustype)) {
 	case SI_BUS:
-		eromptr = (uint32 *) REG_MAP(erombase, SI_CORE_SIZE);
+		eromptr = (u32 *) REG_MAP(erombase, SI_CORE_SIZE);
 		break;
 
 	case PCI_BUS:
 		/* Set wrappers address */
-		sii->curwrap = (void *)((uintptr) regs + SI_CORE_SIZE);
+		sii->curwrap = (void *)((unsigned long)regs + SI_CORE_SIZE);
 
 		/* Now point the window at the erom */
 		OSL_PCI_WRITE_CONFIG(sii->osh, PCI_BAR0_WIN, 4, erombase);
@@ -130,7 +133,7 @@ void BCMATTACHFN(ai_scan) (si_t * sih, void *regs, uint devid) {
 	case SPI_BUS:
 	case SDIO_BUS:
 #endif				/* BCMSDIO */
-		eromptr = (uint32 *) (uintptr) erombase;
+		eromptr = (u32 *)(unsigned long)erombase;
 		break;
 
 	default:
@@ -139,17 +142,17 @@ void BCMATTACHFN(ai_scan) (si_t * sih, void *regs, uint devid) {
 		ASSERT(0);
 		return;
 	}
-	eromlim = eromptr + (ER_REMAPCONTROL / sizeof(uint32));
+	eromlim = eromptr + (ER_REMAPCONTROL / sizeof(u32));
 
 	SI_VMSG(("ai_scan: regs = 0x%p, erombase = 0x%08x, eromptr = 0x%p, eromlim = 0x%p\n", regs, erombase, eromptr, eromlim));
 	while (eromptr < eromlim) {
-		uint32 cia, cib, cid, mfg, crev, nmw, nsw, nmp, nsp;
-		uint32 mpd, asd, addrl, addrh, sizel, sizeh;
-		uint32 *base;
+		u32 cia, cib, cid, mfg, crev, nmw, nsw, nmp, nsp;
+		u32 mpd, asd, addrl, addrh, sizel, sizeh;
+		u32 *base;
 		uint i, j, idx;
 		bool br;
 
-		br = FALSE;
+		br = false;
 
 		/* Grok a component */
 		cia = get_erom_ent(sih, &eromptr, ER_TAG, ER_CI);
@@ -220,7 +223,7 @@ void BCMATTACHFN(ai_scan) (si_t * sih, void *regs, uint devid) {
 			    get_asd(sih, &eromptr, 0, 0, AD_ST_BRIDGE, &addrl,
 				    &addrh, &sizel, &sizeh);
 			if (asd != 0)
-				br = TRUE;
+				br = true;
 			else if ((addrh != 0) || (sizeh != 0)
 				 || (sizel != SI_CORE_SIZE)) {
 				SI_ERROR(("First Slave ASD for core 0x%04x malformed " "(0x%08x)\n", cid, asd));
@@ -310,15 +313,15 @@ void BCMATTACHFN(ai_scan) (si_t * sih, void *regs, uint devid) {
 /* This function changes the logical "focus" to the indicated core.
  * Return the current core's virtual address.
  */
-void *ai_setcoreidx(si_t * sih, uint coreidx)
+void *ai_setcoreidx(si_t *sih, uint coreidx)
 {
 	si_info_t *sii = SI_INFO(sih);
-	uint32 addr = sii->coresba[coreidx];
-	uint32 wrap = sii->wrapba[coreidx];
+	u32 addr = sii->coresba[coreidx];
+	u32 wrap = sii->wrapba[coreidx];
 	void *regs;
 
 	if (coreidx >= sii->numcores)
-		return (NULL);
+		return NULL;
 
 	/*
 	 * If the user has provided an interrupt mask enabled function,
@@ -354,8 +357,8 @@ void *ai_setcoreidx(si_t * sih, uint coreidx)
 	case SPI_BUS:
 	case SDIO_BUS:
 #endif				/* BCMSDIO */
-		sii->curmap = regs = (void *)((uintptr) addr);
-		sii->curwrap = (void *)((uintptr) wrap);
+		sii->curmap = regs = (void *)(unsigned long)addr;
+		sii->curwrap = (void *)(unsigned long)wrap;
 		break;
 
 	default:
@@ -371,13 +374,13 @@ void *ai_setcoreidx(si_t * sih, uint coreidx)
 }
 
 /* Return the number of address spaces in current core */
-int ai_numaddrspaces(si_t * sih)
+int ai_numaddrspaces(si_t *sih)
 {
 	return 2;
 }
 
 /* Return the address of the nth address space in the current core */
-uint32 ai_addrspace(si_t * sih, uint asidx)
+u32 ai_addrspace(si_t *sih, uint asidx)
 {
 	si_info_t *sii;
 	uint cidx;
@@ -396,7 +399,7 @@ uint32 ai_addrspace(si_t * sih, uint asidx)
 }
 
 /* Return the size of the nth address space in the current core */
-uint32 ai_addrspacesize(si_t * sih, uint asidx)
+u32 ai_addrspacesize(si_t *sih, uint asidx)
 {
 	si_info_t *sii;
 	uint cidx;
@@ -414,7 +417,7 @@ uint32 ai_addrspacesize(si_t * sih, uint asidx)
 	}
 }
 
-uint ai_flag(si_t * sih)
+uint ai_flag(si_t *sih)
 {
 	si_info_t *sii;
 	aidmp_t *ai;
@@ -426,42 +429,42 @@ uint ai_flag(si_t * sih)
 	}
 	ai = sii->curwrap;
 
-	return (R_REG(sii->osh, &ai->oobselouta30) & 0x1f);
+	return R_REG(sii->osh, &ai->oobselouta30) & 0x1f;
 }
 
-void ai_setint(si_t * sih, int siflag)
+void ai_setint(si_t *sih, int siflag)
 {
 }
 
-void ai_write_wrap_reg(si_t * sih, uint32 offset, uint32 val)
+void ai_write_wrap_reg(si_t *sih, u32 offset, u32 val)
 {
 	si_info_t *sii = SI_INFO(sih);
-	uint32 *w = (uint32 *) sii->curwrap;
+	u32 *w = (u32 *) sii->curwrap;
 	W_REG(sii->osh, w + (offset / 4), val);
 	return;
 }
 
-uint ai_corevendor(si_t * sih)
+uint ai_corevendor(si_t *sih)
 {
 	si_info_t *sii;
-	uint32 cia;
+	u32 cia;
 
 	sii = SI_INFO(sih);
 	cia = sii->cia[sii->curidx];
-	return ((cia & CIA_MFG_MASK) >> CIA_MFG_SHIFT);
+	return (cia & CIA_MFG_MASK) >> CIA_MFG_SHIFT;
 }
 
-uint ai_corerev(si_t * sih)
+uint ai_corerev(si_t *sih)
 {
 	si_info_t *sii;
-	uint32 cib;
+	u32 cib;
 
 	sii = SI_INFO(sih);
 	cib = sii->cib[sii->curidx];
-	return ((cib & CIB_REV_MASK) >> CIB_REV_SHIFT);
+	return (cib & CIB_REV_MASK) >> CIB_REV_SHIFT;
 }
 
-bool ai_iscoreup(si_t * sih)
+bool ai_iscoreup(si_t *sih)
 {
 	si_info_t *sii;
 	aidmp_t *ai;
@@ -483,13 +486,13 @@ bool ai_iscoreup(si_t * sih)
  * Also, when using pci/pcie, we can optimize away the core switching for pci registers
  * and (on newer pci cores) chipcommon registers.
  */
-uint ai_corereg(si_t * sih, uint coreidx, uint regoff, uint mask, uint val)
+uint ai_corereg(si_t *sih, uint coreidx, uint regoff, uint mask, uint val)
 {
 	uint origidx = 0;
-	uint32 *r = NULL;
+	u32 *r = NULL;
 	uint w;
 	uint intr_val = 0;
-	bool fast = FALSE;
+	bool fast = false;
 	si_info_t *sii;
 
 	sii = SI_INFO(sih);
@@ -503,34 +506,34 @@ uint ai_corereg(si_t * sih, uint coreidx, uint regoff, uint mask, uint val)
 
 	if (BUSTYPE(sih->bustype) == SI_BUS) {
 		/* If internal bus, we can always get at everything */
-		fast = TRUE;
+		fast = true;
 		/* map if does not exist */
 		if (!sii->regs[coreidx]) {
 			sii->regs[coreidx] = REG_MAP(sii->coresba[coreidx],
 						     SI_CORE_SIZE);
 			ASSERT(GOODREGS(sii->regs[coreidx]));
 		}
-		r = (uint32 *) ((uchar *) sii->regs[coreidx] + regoff);
+		r = (u32 *) ((unsigned char *) sii->regs[coreidx] + regoff);
 	} else if (BUSTYPE(sih->bustype) == PCI_BUS) {
 		/* If pci/pcie, we can get at pci/pcie regs and on newer cores to chipc */
 
 		if ((sii->coreid[coreidx] == CC_CORE_ID) && SI_FAST(sii)) {
 			/* Chipc registers are mapped at 12KB */
 
-			fast = TRUE;
-			r = (uint32 *) ((char *)sii->curmap +
+			fast = true;
+			r = (u32 *) ((char *)sii->curmap +
 					PCI_16KB0_CCREGS_OFFSET + regoff);
 		} else if (sii->pub.buscoreidx == coreidx) {
 			/* pci registers are at either in the last 2KB of an 8KB window
 			 * or, in pcie and pci rev 13 at 8KB
 			 */
-			fast = TRUE;
+			fast = true;
 			if (SI_FAST(sii))
-				r = (uint32 *) ((char *)sii->curmap +
+				r = (u32 *) ((char *)sii->curmap +
 						PCI_16KB0_PCIREGS_OFFSET +
 						regoff);
 			else
-				r = (uint32 *) ((char *)sii->curmap +
+				r = (u32 *) ((char *)sii->curmap +
 						((regoff >= SBCONFIGOFF) ?
 						 PCI_BAR0_PCISBR_OFFSET :
 						 PCI_BAR0_PCIREGS_OFFSET) +
@@ -545,7 +548,7 @@ uint ai_corereg(si_t * sih, uint coreidx, uint regoff, uint mask, uint val)
 		origidx = si_coreidx(&sii->pub);
 
 		/* switch core */
-		r = (uint32 *) ((uchar *) ai_setcoreidx(&sii->pub, coreidx) +
+		r = (u32 *) ((unsigned char *) ai_setcoreidx(&sii->pub, coreidx) +
 				regoff);
 	}
 	ASSERT(r != NULL);
@@ -567,13 +570,13 @@ uint ai_corereg(si_t * sih, uint coreidx, uint regoff, uint mask, uint val)
 		INTR_RESTORE(sii, intr_val);
 	}
 
-	return (w);
+	return w;
 }
 
-void ai_core_disable(si_t * sih, uint32 bits)
+void ai_core_disable(si_t *sih, u32 bits)
 {
 	si_info_t *sii;
-	volatile uint32 dummy;
+	volatile u32 dummy;
 	aidmp_t *ai;
 
 	sii = SI_INFO(sih);
@@ -587,10 +590,10 @@ void ai_core_disable(si_t * sih, uint32 bits)
 
 	W_REG(sii->osh, &ai->ioctrl, bits);
 	dummy = R_REG(sii->osh, &ai->ioctrl);
-	OSL_DELAY(10);
+	udelay(10);
 
 	W_REG(sii->osh, &ai->resetctrl, AIRC_RESET);
-	OSL_DELAY(1);
+	udelay(1);
 }
 
 /* reset and re-enable a core
@@ -598,11 +601,11 @@ void ai_core_disable(si_t * sih, uint32 bits)
  * bits - core specific bits that are set during and after reset sequence
  * resetbits - core specific bits that are set only during reset sequence
  */
-void ai_core_reset(si_t * sih, uint32 bits, uint32 resetbits)
+void ai_core_reset(si_t *sih, u32 bits, u32 resetbits)
 {
 	si_info_t *sii;
 	aidmp_t *ai;
-	volatile uint32 dummy;
+	volatile u32 dummy;
 
 	sii = SI_INFO(sih);
 	ASSERT(GOODREGS(sii->curwrap));
@@ -619,18 +622,18 @@ void ai_core_reset(si_t * sih, uint32 bits, uint32 resetbits)
 	W_REG(sii->osh, &ai->ioctrl, (bits | SICF_FGC | SICF_CLOCK_EN));
 	dummy = R_REG(sii->osh, &ai->ioctrl);
 	W_REG(sii->osh, &ai->resetctrl, 0);
-	OSL_DELAY(1);
+	udelay(1);
 
 	W_REG(sii->osh, &ai->ioctrl, (bits | SICF_CLOCK_EN));
 	dummy = R_REG(sii->osh, &ai->ioctrl);
-	OSL_DELAY(1);
+	udelay(1);
 }
 
-void ai_core_cflags_wo(si_t * sih, uint32 mask, uint32 val)
+void ai_core_cflags_wo(si_t *sih, u32 mask, u32 val)
 {
 	si_info_t *sii;
 	aidmp_t *ai;
-	uint32 w;
+	u32 w;
 
 	sii = SI_INFO(sih);
 
@@ -651,11 +654,11 @@ void ai_core_cflags_wo(si_t * sih, uint32 mask, uint32 val)
 	}
 }
 
-uint32 ai_core_cflags(si_t * sih, uint32 mask, uint32 val)
+u32 ai_core_cflags(si_t *sih, u32 mask, u32 val)
 {
 	si_info_t *sii;
 	aidmp_t *ai;
-	uint32 w;
+	u32 w;
 
 	sii = SI_INFO(sih);
 	if (BCM47162_DMP()) {
@@ -677,11 +680,11 @@ uint32 ai_core_cflags(si_t * sih, uint32 mask, uint32 val)
 	return R_REG(sii->osh, &ai->ioctrl);
 }
 
-uint32 ai_core_sflags(si_t * sih, uint32 mask, uint32 val)
+u32 ai_core_sflags(si_t *sih, u32 mask, u32 val)
 {
 	si_info_t *sii;
 	aidmp_t *ai;
-	uint32 w;
+	u32 w;
 
 	sii = SI_INFO(sih);
 	if (BCM47162_DMP()) {
@@ -703,93 +706,3 @@ uint32 ai_core_sflags(si_t * sih, uint32 mask, uint32 val)
 	return R_REG(sii->osh, &ai->iostatus);
 }
 
-#ifdef BCMDBG
-void ai_view(si_t * sih, bool verbose)
-{
-	si_info_t *sii;
-	osl_t *osh;
-	aidmp_t *ai;
-	uint32 config;
-
-	sii = SI_INFO(sih);
-	ai = sii->curwrap;
-	osh = sii->osh;
-	if (BCM47162_DMP()) {
-		SI_ERROR(("Cannot access mips74k DMP in 47162a0\n"));
-		return;
-	}
-
-	config = R_REG(osh, &ai->config);
-	SI_ERROR(("\nCore ID: 0x%x, config 0x%x\n", si_coreid(&sii->pub),
-		  config));
-
-	if (config & AICFG_RST)
-		SI_ERROR(("resetctrl 0x%x, resetstatus 0x%x, resetreadid 0x%x, resetwriteid 0x%x\n", R_REG(osh, &ai->resetctrl), R_REG(osh, &ai->resetstatus), R_REG(osh, &ai->resetreadid), R_REG(osh, &ai->resetwriteid)));
-
-	if (config & AICFG_IOC)
-		SI_ERROR(("ioctrl 0x%x, width %d\n", R_REG(osh, &ai->ioctrl),
-			  R_REG(osh, &ai->ioctrlwidth)));
-
-	if (config & AICFG_IOS)
-		SI_ERROR(("iostatus 0x%x, width %d\n",
-			  R_REG(osh, &ai->iostatus), R_REG(osh,
-							   &ai->
-							   iostatuswidth)));
-
-	if (config & AICFG_ERRL) {
-		SI_ERROR(("errlogctrl 0x%x, errlogdone 0x%x, errlogstatus 0x%x, intstatus 0x%x\n", R_REG(osh, &ai->errlogctrl), R_REG(osh, &ai->errlogdone), R_REG(osh, &ai->errlogstatus), R_REG(osh, &ai->intstatus)));
-		SI_ERROR(("errlogid 0x%x, errloguser 0x%x, errlogflags 0x%x, errlogaddr " "0x%x/0x%x\n", R_REG(osh, &ai->errlogid), R_REG(osh, &ai->errloguser), R_REG(osh, &ai->errlogflags), R_REG(osh, &ai->errlogaddrhi), R_REG(osh, &ai->errlogaddrlo)));
-	}
-
-	if (verbose && (config & AICFG_OOB)) {
-		SI_ERROR(("oobselina30 0x%x, oobselina74 0x%x\n",
-			  R_REG(osh, &ai->oobselina30), R_REG(osh,
-							      &ai->
-							      oobselina74)));
-		SI_ERROR(("oobselinb30 0x%x, oobselinb74 0x%x\n",
-			  R_REG(osh, &ai->oobselinb30), R_REG(osh,
-							      &ai->
-							      oobselinb74)));
-		SI_ERROR(("oobselinc30 0x%x, oobselinc74 0x%x\n",
-			  R_REG(osh, &ai->oobselinc30), R_REG(osh,
-							      &ai->
-							      oobselinc74)));
-		SI_ERROR(("oobselind30 0x%x, oobselind74 0x%x\n",
-			  R_REG(osh, &ai->oobselind30), R_REG(osh,
-							      &ai->
-							      oobselind74)));
-		SI_ERROR(("oobselouta30 0x%x, oobselouta74 0x%x\n",
-			  R_REG(osh, &ai->oobselouta30), R_REG(osh,
-							       &ai->
-							       oobselouta74)));
-		SI_ERROR(("oobseloutb30 0x%x, oobseloutb74 0x%x\n",
-			  R_REG(osh, &ai->oobseloutb30), R_REG(osh,
-							       &ai->
-							       oobseloutb74)));
-		SI_ERROR(("oobseloutc30 0x%x, oobseloutc74 0x%x\n",
-			  R_REG(osh, &ai->oobseloutc30), R_REG(osh,
-							       &ai->
-							       oobseloutc74)));
-		SI_ERROR(("oobseloutd30 0x%x, oobseloutd74 0x%x\n",
-			  R_REG(osh, &ai->oobseloutd30), R_REG(osh,
-							       &ai->
-							       oobseloutd74)));
-		SI_ERROR(("oobsynca 0x%x, oobseloutaen 0x%x\n",
-			  R_REG(osh, &ai->oobsynca), R_REG(osh,
-							   &ai->oobseloutaen)));
-		SI_ERROR(("oobsyncb 0x%x, oobseloutben 0x%x\n",
-			  R_REG(osh, &ai->oobsyncb), R_REG(osh,
-							   &ai->oobseloutben)));
-		SI_ERROR(("oobsyncc 0x%x, oobseloutcen 0x%x\n",
-			  R_REG(osh, &ai->oobsyncc), R_REG(osh,
-							   &ai->oobseloutcen)));
-		SI_ERROR(("oobsyncd 0x%x, oobseloutden 0x%x\n",
-			  R_REG(osh, &ai->oobsyncd), R_REG(osh,
-							   &ai->oobseloutden)));
-		SI_ERROR(("oobaextwidth 0x%x, oobainwidth 0x%x, oobaoutwidth 0x%x\n", R_REG(osh, &ai->oobaextwidth), R_REG(osh, &ai->oobainwidth), R_REG(osh, &ai->oobaoutwidth)));
-		SI_ERROR(("oobbextwidth 0x%x, oobbinwidth 0x%x, oobboutwidth 0x%x\n", R_REG(osh, &ai->oobbextwidth), R_REG(osh, &ai->oobbinwidth), R_REG(osh, &ai->oobboutwidth)));
-		SI_ERROR(("oobcextwidth 0x%x, oobcinwidth 0x%x, oobcoutwidth 0x%x\n", R_REG(osh, &ai->oobcextwidth), R_REG(osh, &ai->oobcinwidth), R_REG(osh, &ai->oobcoutwidth)));
-		SI_ERROR(("oobdextwidth 0x%x, oobdinwidth 0x%x, oobdoutwidth 0x%x\n", R_REG(osh, &ai->oobdextwidth), R_REG(osh, &ai->oobdinwidth), R_REG(osh, &ai->oobdoutwidth)));
-	}
-}
-#endif				/* BCMDBG */
diff --git a/drivers/staging/brcm80211/util/bcmotp.c b/drivers/staging/brcm80211/util/bcmotp.c
index c85cc6a..c909832 100644
--- a/drivers/staging/brcm80211/util/bcmotp.c
+++ b/drivers/staging/brcm80211/util/bcmotp.c
@@ -14,9 +14,11 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <typedefs.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
 #include <bcmdefs.h>
 #include <osl.h>
+#include <linuxver.h>
 #include <bcmdevs.h>
 #include <bcmutils.h>
 #include <siutils.h>
@@ -55,11 +57,11 @@
 /* OTP common function type */
 typedef int (*otp_status_t) (void *oh);
 typedef int (*otp_size_t) (void *oh);
-typedef void *(*otp_init_t) (si_t * sih);
-typedef uint16(*otp_read_bit_t) (void *oh, chipcregs_t * cc, uint off);
-typedef int (*otp_read_region_t) (si_t * sih, int region, uint16 * data,
-				  uint * wlen);
-typedef int (*otp_nvread_t) (void *oh, char *data, uint * len);
+typedef void *(*otp_init_t) (si_t *sih);
+typedef u16(*otp_read_bit_t) (void *oh, chipcregs_t *cc, uint off);
+typedef int (*otp_read_region_t) (si_t *sih, int region, u16 *data,
+				  uint *wlen);
+typedef int (*otp_nvread_t) (void *oh, char *data, uint *len);
 
 /* OTP function struct */
 typedef struct otp_fn_s {
@@ -79,18 +81,18 @@ typedef struct {
 
 #ifdef BCMIPXOTP
 	/* IPX OTP section */
-	uint16 wsize;		/* Size of otp in words */
-	uint16 rows;		/* Geometry */
-	uint16 cols;		/* Geometry */
-	uint32 status;		/* Flag bits (lock/prog/rv).
+	u16 wsize;		/* Size of otp in words */
+	u16 rows;		/* Geometry */
+	u16 cols;		/* Geometry */
+	u32 status;		/* Flag bits (lock/prog/rv).
 				 * (Reflected only when OTP is power cycled)
 				 */
-	uint16 hwbase;		/* hardware subregion offset */
-	uint16 hwlim;		/* hardware subregion boundary */
-	uint16 swbase;		/* software subregion offset */
-	uint16 swlim;		/* software subregion boundary */
-	uint16 fbase;		/* fuse subregion offset */
-	uint16 flim;		/* fuse subregion boundary */
+	u16 hwbase;		/* hardware subregion offset */
+	u16 hwlim;		/* hardware subregion boundary */
+	u16 swbase;		/* software subregion offset */
+	u16 swlim;		/* software subregion boundary */
+	u16 fbase;		/* fuse subregion offset */
+	u16 flim;		/* fuse subregion boundary */
 	int otpgu_base;		/* offset to General Use Region */
 #endif				/* BCMIPXOTP */
 
@@ -149,7 +151,7 @@ static otpinfo_t otpinfo;
 #define OTPGU_P_SHIFT		(OTPGU_HWP_OFF % 16)
 
 /* OTP Size */
-#define OTP_SZ_FU_324		((ROUNDUP(324,8))/8)	/* 324 bits */
+#define OTP_SZ_FU_324		((roundup(324, 8))/8)	/* 324 bits */
 #define OTP_SZ_FU_288		(288/8)	/* 288 bits */
 #define OTP_SZ_FU_216		(216/8)	/* 216 bits */
 #define OTP_SZ_FU_72		(72/8)	/* 72 bits */
@@ -170,7 +172,7 @@ static int ipxotp_size(void *oh)
 	return (int)oi->wsize * 2;
 }
 
-static uint16 ipxotp_otpr(void *oh, chipcregs_t * cc, uint wn)
+static u16 ipxotp_otpr(void *oh, chipcregs_t *cc, uint wn)
 {
 	otpinfo_t *oi;
 
@@ -182,11 +184,11 @@ static uint16 ipxotp_otpr(void *oh, chipcregs_t * cc, uint wn)
 	return R_REG(oi->osh, &cc->sromotp[wn]);
 }
 
-static uint16 ipxotp_read_bit(void *oh, chipcregs_t * cc, uint off)
+static u16 ipxotp_read_bit(void *oh, chipcregs_t *cc, uint off)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	uint k, row, col;
-	uint32 otpp, st;
+	u32 otpp, st;
 
 	row = off / oi->cols;
 	col = off % oi->cols;
@@ -199,7 +201,8 @@ static uint16 ipxotp_read_bit(void *oh, chipcregs_t * cc, uint off)
 
 	for (k = 0;
 	     ((st = R_REG(oi->osh, &cc->otpprog)) & OTPP_START_BUSY)
-	     && (k < OTPP_TRIES); k++) ;
+	     && (k < OTPP_TRIES); k++)
+		;
 	if (k >= OTPP_TRIES) {
 		return 0xffff;
 	}
@@ -214,7 +217,7 @@ static uint16 ipxotp_read_bit(void *oh, chipcregs_t * cc, uint off)
 /* Calculate max HW/SW region byte size by substracting fuse region and checksum size,
  * osizew is oi->wsize (OTP size - GU size) in words
  */
-static int ipxotp_max_rgnsz(si_t * sih, int osizew)
+static int ipxotp_max_rgnsz(si_t *sih, int osizew)
 {
 	int ret = 0;
 
@@ -233,9 +236,10 @@ static int ipxotp_max_rgnsz(si_t * sih, int osizew)
 	return ret;
 }
 
-static void BCMNMIATTACHFN(_ipxotp_init) (otpinfo_t * oi, chipcregs_t * cc) {
+static void _ipxotp_init(otpinfo_t *oi, chipcregs_t *cc)
+{
 	uint k;
-	uint32 otpp, st;
+	u32 otpp, st;
 
 	/* record word offset of General Use Region for various chipcommon revs */
 	if (oi->sih->ccrev == 21 || oi->sih->ccrev == 24
@@ -258,7 +262,8 @@ static void BCMNMIATTACHFN(_ipxotp_init) (otpinfo_t * oi, chipcregs_t * cc) {
 	W_REG(oi->osh, &cc->otpprog, otpp);
 	for (k = 0;
 	     ((st = R_REG(oi->osh, &cc->otpprog)) & OTPP_START_BUSY)
-	     && (k < OTPP_TRIES); k++) ;
+	     && (k < OTPP_TRIES); k++)
+		;
 	if (k >= OTPP_TRIES) {
 		return;
 	}
@@ -268,7 +273,7 @@ static void BCMNMIATTACHFN(_ipxotp_init) (otpinfo_t * oi, chipcregs_t * cc) {
 
 	if ((CHIPID(oi->sih->chip) == BCM43224_CHIP_ID)
 	    || (CHIPID(oi->sih->chip) == BCM43225_CHIP_ID)) {
-		uint32 p_bits;
+		u32 p_bits;
 		p_bits =
 		    (ipxotp_otpr(oi, cc, oi->otpgu_base + OTPGU_P_OFF) &
 		     OTPGU_P_MSK)
@@ -302,7 +307,8 @@ static void BCMNMIATTACHFN(_ipxotp_init) (otpinfo_t * oi, chipcregs_t * cc) {
 	oi->flim = oi->wsize;
 }
 
-static void *BCMNMIATTACHFN(ipxotp_init) (si_t * sih) {
+static void *ipxotp_init(si_t *sih)
+{
 	uint idx;
 	chipcregs_t *cc;
 	otpinfo_t *oi;
@@ -366,7 +372,7 @@ static void *BCMNMIATTACHFN(ipxotp_init) (si_t * sih) {
 	return (void *)oi;
 }
 
-static int ipxotp_read_region(void *oh, int region, uint16 * data, uint * wlen)
+static int ipxotp_read_region(void *oh, int region, u16 *data, uint *wlen)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	uint idx;
@@ -452,7 +458,7 @@ static int ipxotp_read_region(void *oh, int region, uint16 * data, uint * wlen)
 	return 0;
 }
 
-static int ipxotp_nvread(void *oh, char *data, uint * len)
+static int ipxotp_nvread(void *oh, char *data, uint *len)
 {
 	return BCME_UNSUPPORTED;
 }
@@ -551,35 +557,35 @@ static otp_fn_t ipxotp_fn = {
 static int hndotp_status(void *oh)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
-	return ((int)(oi->hwprot | oi->signvalid));
+	return (int)(oi->hwprot | oi->signvalid);
 }
 
 static int hndotp_size(void *oh)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
-	return ((int)(oi->size));
+	return (int)(oi->size);
 }
 
-static uint16 hndotp_otpr(void *oh, chipcregs_t * cc, uint wn)
+static u16 hndotp_otpr(void *oh, chipcregs_t *cc, uint wn)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	osl_t *osh;
-	volatile uint16 *ptr;
+	volatile u16 *ptr;
 
 	ASSERT(wn < ((oi->size / 2) + OTP_RC_LIM_OFF));
 	ASSERT(cc != NULL);
 
 	osh = si_osh(oi->sih);
 
-	ptr = (volatile uint16 *)((volatile char *)cc + CC_SROM_OTP);
-	return (R_REG(osh, &ptr[wn]));
+	ptr = (volatile u16 *)((volatile char *)cc + CC_SROM_OTP);
+	return R_REG(osh, &ptr[wn]);
 }
 
-static uint16 hndotp_otproff(void *oh, chipcregs_t * cc, int woff)
+static u16 hndotp_otproff(void *oh, chipcregs_t *cc, int woff)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	osl_t *osh;
-	volatile uint16 *ptr;
+	volatile u16 *ptr;
 
 	ASSERT(woff >= (-((int)oi->size / 2)));
 	ASSERT(woff < OTP_LIM_OFF);
@@ -587,16 +593,16 @@ static uint16 hndotp_otproff(void *oh, chipcregs_t * cc, int woff)
 
 	osh = si_osh(oi->sih);
 
-	ptr = (volatile uint16 *)((volatile char *)cc + CC_SROM_OTP);
+	ptr = (volatile u16 *)((volatile char *)cc + CC_SROM_OTP);
 
-	return (R_REG(osh, &ptr[(oi->size / 2) + woff]));
+	return R_REG(osh, &ptr[(oi->size / 2) + woff]);
 }
 
-static uint16 hndotp_read_bit(void *oh, chipcregs_t * cc, uint idx)
+static u16 hndotp_read_bit(void *oh, chipcregs_t *cc, uint idx)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	uint k, row, col;
-	uint32 otpp, st;
+	u32 otpp, st;
 	osl_t *osh;
 
 	osh = si_osh(oi->sih);
@@ -620,14 +626,15 @@ static uint16 hndotp_read_bit(void *oh, chipcregs_t * cc, uint idx)
 		return 0xffff;
 	}
 	st = (st & OTPP_VALUE_MASK) >> OTPP_VALUE_SHIFT;
-	return (uint16) st;
+	return (u16) st;
 }
 
-static void *BCMNMIATTACHFN(hndotp_init) (si_t * sih) {
+static void *hndotp_init(si_t *sih)
+{
 	uint idx;
 	chipcregs_t *cc;
 	otpinfo_t *oi;
-	uint32 cap = 0, clkdiv, otpdiv = 0;
+	u32 cap = 0, clkdiv, otpdiv = 0;
 	void *ret = NULL;
 	osl_t *osh;
 
@@ -637,7 +644,8 @@ static void *BCMNMIATTACHFN(hndotp_init) (si_t * sih) {
 	osh = si_osh(oi->sih);
 
 	/* Check for otp */
-	if ((cc = si_setcoreidx(sih, SI_CC_IDX)) != NULL) {
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	if (cc != NULL) {
 		cap = R_REG(osh, &cc->capabilities);
 		if ((cap & CC_CAP_OTPSIZE) == 0) {
 			/* Nothing there */
@@ -686,7 +694,7 @@ static void *BCMNMIATTACHFN(hndotp_init) (si_t * sih) {
 			    (clkdiv & ~CLKD_OTP) | (otpdiv << CLKD_OTP_SHIFT);
 			W_REG(osh, &cc->clkdiv, clkdiv);
 		}
-		OSL_DELAY(10);
+		udelay(10);
 
 		ret = (void *)oi;
 	}
@@ -697,10 +705,10 @@ static void *BCMNMIATTACHFN(hndotp_init) (si_t * sih) {
 	return ret;
 }
 
-static int hndotp_read_region(void *oh, int region, uint16 * data, uint * wlen)
+static int hndotp_read_region(void *oh, int region, u16 *data, uint *wlen)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
-	uint32 idx, st;
+	u32 idx, st;
 	chipcregs_t *cc;
 	int i;
 
@@ -727,16 +735,16 @@ static int hndotp_read_region(void *oh, int region, uint16 * data, uint * wlen)
 	return 0;
 }
 
-static int hndotp_nvread(void *oh, char *data, uint * len)
+static int hndotp_nvread(void *oh, char *data, uint *len)
 {
 	int rc = 0;
 	otpinfo_t *oi = (otpinfo_t *) oh;
-	uint32 base, bound, lim = 0, st;
+	u32 base, bound, lim = 0, st;
 	int i, chunk, gchunks, tsz = 0;
-	uint32 idx;
+	u32 idx;
 	chipcregs_t *cc;
 	uint offset;
-	uint16 *rawotp = NULL;
+	u16 *rawotp = NULL;
 
 	/* save the orig core */
 	idx = si_coreidx(oi->sih);
@@ -751,7 +759,8 @@ static int hndotp_nvread(void *oh, char *data, uint * len)
 
 	/* Read the whole otp so we can easily manipulate it */
 	lim = hndotp_size(oh);
-	if ((rawotp = MALLOC(si_osh(oi->sih), lim)) == NULL) {
+	rawotp = kmalloc(lim, GFP_ATOMIC);
+	if (rawotp == NULL) {
 		rc = -2;
 		goto out;
 	}
@@ -798,7 +807,7 @@ static int hndotp_nvread(void *oh, char *data, uint * len)
 			/* Bad length, try to find another chunk anyway */
 			rsz = 6;
 		}
-		if (hndcrc16((uint8 *) & rawotp[i], rsz,
+		if (hndcrc16((u8 *) &rawotp[i], rsz,
 			     CRC16_INIT_VALUE) == CRC16_GOOD_VALUE) {
 			/* Good crc, copy the vars */
 			gchunks++;
@@ -832,7 +841,7 @@ static int hndotp_nvread(void *oh, char *data, uint * len)
 
  out:
 	if (rawotp)
-		MFREE(si_osh(oi->sih), rawotp, lim);
+		kfree(rawotp);
 	si_setcoreidx(oi->sih, idx);
 
 	return rc;
@@ -875,17 +884,18 @@ int otp_size(void *oh)
 	return oi->fn->size(oh);
 }
 
-uint16 otp_read_bit(void *oh, uint offset)
+u16 otp_read_bit(void *oh, uint offset)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	uint idx = si_coreidx(oi->sih);
 	chipcregs_t *cc = si_setcoreidx(oi->sih, SI_CC_IDX);
-	uint16 readBit = (uint16) oi->fn->read_bit(oh, cc, offset);
+	u16 readBit = (u16) oi->fn->read_bit(oh, cc, offset);
 	si_setcoreidx(oi->sih, idx);
 	return readBit;
 }
 
-void *BCMNMIATTACHFN(otp_init) (si_t * sih) {
+void *otp_init(si_t *sih)
+{
 	otpinfo_t *oi;
 	void *ret = NULL;
 
@@ -917,14 +927,15 @@ void *BCMNMIATTACHFN(otp_init) (si_t * sih) {
 }
 
 int
-BCMNMIATTACHFN(otp_read_region) (si_t * sih, int region, uint16 * data,
-				 uint * wlen) {
-	bool wasup = FALSE;
+otp_read_region(si_t *sih, int region, u16 *data,
+				 uint *wlen) {
+	bool wasup = false;
 	void *oh;
 	int err = 0;
 
-	if (!(wasup = si_is_otp_powered(sih)))
-		si_otp_power(sih, TRUE);
+	wasup = si_is_otp_powered(sih);
+	if (!wasup)
+		si_otp_power(sih, true);
 
 	if (!si_is_otp_powered(sih) || si_is_otp_disabled(sih)) {
 		err = BCME_NOTREADY;
@@ -941,12 +952,12 @@ BCMNMIATTACHFN(otp_read_region) (si_t * sih, int region, uint16 * data,
 
  out:
 	if (!wasup)
-		si_otp_power(sih, FALSE);
+		si_otp_power(sih, false);
 
 	return err;
 }
 
-int otp_nvread(void *oh, char *data, uint * len)
+int otp_nvread(void *oh, char *data, uint *len)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 
diff --git a/drivers/staging/brcm80211/util/bcmsrom.c b/drivers/staging/brcm80211/util/bcmsrom.c
index d5527f7..1282ef7 100644
--- a/drivers/staging/brcm80211/util/bcmsrom.c
+++ b/drivers/staging/brcm80211/util/bcmsrom.c
@@ -13,10 +13,11 @@
  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
-
-#include <typedefs.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
 #include <bcmdefs.h>
 #include <osl.h>
+#include <linuxver.h>
 #include <stdarg.h>
 #include <bcmutils.h>
 #include <hndsoc.h>
@@ -47,8 +48,8 @@
 
 #define SROM_OFFSET(sih) ((sih->ccrev > 31) ? \
 	(((sih->cccaps & CC_CAP_SROM) == 0) ? NULL : \
-	 ((uint8 *)curmap + PCI_16KB0_CCREGS_OFFSET + CC_SROM_OTP)) : \
-	((uint8 *)curmap + PCI_BAR0_SPROM_OFFSET))
+	 ((u8 *)curmap + PCI_16KB0_CCREGS_OFFSET + CC_SROM_OTP)) : \
+	((u8 *)curmap + PCI_BAR0_SPROM_OFFSET))
 
 #if defined(BCMDBG)
 #define WRITE_ENABLE_DELAY	500	/* 500 ms after write enable/disable toggle */
@@ -65,38 +66,40 @@ extern uint _varsz;
 
 #define SROM_CIS_SINGLE	1
 
-static int initvars_srom_si(si_t * sih, osl_t * osh, void *curmap, char **vars,
-			    uint * count);
-static void _initvars_srom_pci(uint8 sromrev, uint16 * srom, uint off,
-			       varbuf_t * b);
-static int initvars_srom_pci(si_t * sih, void *curmap, char **vars,
-			     uint * count);
-static int initvars_flash_si(si_t * sih, char **vars, uint * count);
+static int initvars_srom_si(si_t *sih, osl_t *osh, void *curmap, char **vars,
+			    uint *count);
+static void _initvars_srom_pci(u8 sromrev, u16 *srom, uint off,
+			       varbuf_t *b);
+static int initvars_srom_pci(si_t *sih, void *curmap, char **vars,
+			     uint *count);
+static int initvars_flash_si(si_t *sih, char **vars, uint *count);
 #ifdef BCMSDIO
-static int initvars_cis_sdio(osl_t * osh, char **vars, uint * count);
-static int sprom_cmd_sdio(osl_t * osh, uint8 cmd);
-static int sprom_read_sdio(osl_t * osh, uint16 addr, uint16 * data);
+static int initvars_cis_sdio(osl_t *osh, char **vars, uint *count);
+static int sprom_cmd_sdio(osl_t *osh, u8 cmd);
+static int sprom_read_sdio(osl_t *osh, u16 addr, u16 *data);
 #endif				/* BCMSDIO */
-static int sprom_read_pci(osl_t * osh, si_t * sih, uint16 * sprom, uint wordoff,
-			  uint16 * buf, uint nwords, bool check_crc);
+static int sprom_read_pci(osl_t *osh, si_t *sih, u16 *sprom, uint wordoff,
+			  u16 *buf, uint nwords, bool check_crc);
 #if defined(BCMNVRAMR)
-static int otp_read_pci(osl_t * osh, si_t * sih, uint16 * buf, uint bufsz);
+static int otp_read_pci(osl_t *osh, si_t *sih, u16 *buf, uint bufsz);
 #endif
-static uint16 srom_cc_cmd(si_t * sih, osl_t * osh, void *ccregs, uint32 cmd,
-			  uint wordoff, uint16 data);
+static u16 srom_cc_cmd(si_t *sih, osl_t *osh, void *ccregs, u32 cmd,
+			  uint wordoff, u16 data);
 
-static int initvars_table(osl_t * osh, char *start, char *end, char **vars,
-			  uint * count);
-static int initvars_flash(si_t * sih, osl_t * osh, char **vp, uint len);
+static int initvars_table(osl_t *osh, char *start, char *end, char **vars,
+			  uint *count);
+static int initvars_flash(si_t *sih, osl_t *osh, char **vp, uint len);
 
 /* Initialization of varbuf structure */
-static void BCMATTACHFN(varbuf_init) (varbuf_t * b, char *buf, uint size) {
+static void varbuf_init(varbuf_t *b, char *buf, uint size)
+{
 	b->size = size;
 	b->base = b->buf = buf;
 }
 
 /* append a null terminated var=value string */
-static int BCMATTACHFN(varbuf_append) (varbuf_t * b, const char *fmt, ...) {
+static int varbuf_append(varbuf_t *b, const char *fmt, ...)
+{
 	va_list ap;
 	int r;
 	size_t len;
@@ -122,7 +125,8 @@ static int BCMATTACHFN(varbuf_append) (varbuf_t * b, const char *fmt, ...) {
 	}
 
 	/* Remove any earlier occurrence of the same variable */
-	if ((s = strchr(b->buf, '=')) != NULL) {
+	s = strchr(b->buf, '=');
+	if (s != NULL) {
 		len = (size_t) (s - b->buf);
 		for (s = b->base; s < b->buf;) {
 			if ((bcmp(s, b->buf, len) == 0) && s[len] == '=') {
@@ -134,7 +138,8 @@ static int BCMATTACHFN(varbuf_append) (varbuf_t * b, const char *fmt, ...) {
 				break;
 			}
 
-			while (*s++) ;
+			while (*s++)
+				;
 		}
 	}
 
@@ -150,16 +155,16 @@ static int BCMATTACHFN(varbuf_append) (varbuf_t * b, const char *fmt, ...) {
  * Initialize local vars from the right source for this platform.
  * Return 0 on success, nonzero on error.
  */
-int
-BCMATTACHFN(srom_var_init) (si_t * sih, uint bustype, void *curmap, osl_t * osh,
-			    char **vars, uint * count) {
+int srom_var_init(si_t *sih, uint bustype, void *curmap, osl_t *osh,
+		  char **vars, uint *count)
+{
 	uint len;
 
 	len = 0;
 
 	ASSERT(bustype == BUSTYPE(bustype));
 	if (vars == NULL || count == NULL)
-		return (0);
+		return 0;
 
 	*vars = NULL;
 	*count = 0;
@@ -172,7 +177,7 @@ BCMATTACHFN(srom_var_init) (si_t * sih, uint bustype, void *curmap, osl_t * osh,
 	case PCI_BUS:
 		ASSERT(curmap != NULL);
 		if (curmap == NULL)
-			return (-1);
+			return -1;
 
 		return initvars_srom_pci(sih, curmap, vars, count);
 
@@ -184,13 +189,13 @@ BCMATTACHFN(srom_var_init) (si_t * sih, uint bustype, void *curmap, osl_t * osh,
 	default:
 		ASSERT(0);
 	}
-	return (-1);
+	return -1;
 }
 
 /* support only 16-bit word read from srom */
 int
-srom_read(si_t * sih, uint bustype, void *curmap, osl_t * osh,
-	  uint byteoff, uint nbytes, uint16 * buf, bool check_crc)
+srom_read(si_t *sih, uint bustype, void *curmap, osl_t *osh,
+	  uint byteoff, uint nbytes, u16 *buf, bool check_crc)
 {
 	uint off, nw;
 #ifdef BCMSDIO
@@ -211,9 +216,9 @@ srom_read(si_t * sih, uint bustype, void *curmap, osl_t * osh,
 			return 1;
 
 		if (si_is_sprom_available(sih)) {
-			uint16 *srom;
+			u16 *srom;
 
-			srom = (uint16 *) SROM_OFFSET(sih);
+			srom = (u16 *) SROM_OFFSET(sih);
 			if (srom == NULL)
 				return 1;
 
@@ -233,7 +238,7 @@ srom_read(si_t * sih, uint bustype, void *curmap, osl_t * osh,
 		nw = nbytes / 2;
 		for (i = 0; i < nw; i++) {
 			if (sprom_read_sdio
-			    (osh, (uint16) (off + i), (uint16 *) (buf + i)))
+			    (osh, (u16) (off + i), (u16 *) (buf + i)))
 				return 1;
 		}
 #endif				/* BCMSDIO */
@@ -246,150 +251,143 @@ srom_read(si_t * sih, uint bustype, void *curmap, osl_t * osh,
 	return 0;
 }
 
-static const char BCMATTACHDATA(vstr_manf)[] = "manf=%s";
-static const char BCMATTACHDATA(vstr_productname)[] = "productname=%s";
-static const char BCMATTACHDATA(vstr_manfid)[] = "manfid=0x%x";
-static const char BCMATTACHDATA(vstr_prodid)[] = "prodid=0x%x";
+static const char vstr_manf[] = "manf=%s";
+static const char vstr_productname[] = "productname=%s";
+static const char vstr_manfid[] = "manfid=0x%x";
+static const char vstr_prodid[] = "prodid=0x%x";
 #ifdef BCMSDIO
-static const char BCMATTACHDATA(vstr_sdmaxspeed)[] = "sdmaxspeed=%d";
-static const char BCMATTACHDATA(vstr_sdmaxblk)[][13] =
-{
+static const char vstr_sdmaxspeed[] = "sdmaxspeed=%d";
+static const char vstr_sdmaxblk[][13] = {
 "sdmaxblk0=%d", "sdmaxblk1=%d", "sdmaxblk2=%d"};
 #endif
-static const char BCMATTACHDATA(vstr_regwindowsz)[] = "regwindowsz=%d";
-static const char BCMATTACHDATA(vstr_sromrev)[] = "sromrev=%d";
-static const char BCMATTACHDATA(vstr_chiprev)[] = "chiprev=%d";
-static const char BCMATTACHDATA(vstr_subvendid)[] = "subvendid=0x%x";
-static const char BCMATTACHDATA(vstr_subdevid)[] = "subdevid=0x%x";
-static const char BCMATTACHDATA(vstr_boardrev)[] = "boardrev=0x%x";
-static const char BCMATTACHDATA(vstr_aa2g)[] = "aa2g=0x%x";
-static const char BCMATTACHDATA(vstr_aa5g)[] = "aa5g=0x%x";
-static const char BCMATTACHDATA(vstr_ag)[] = "ag%d=0x%x";
-static const char BCMATTACHDATA(vstr_cc)[] = "cc=%d";
-static const char BCMATTACHDATA(vstr_opo)[] = "opo=%d";
-static const char BCMATTACHDATA(vstr_pa0b)[][9] =
-{
+static const char vstr_regwindowsz[] = "regwindowsz=%d";
+static const char vstr_sromrev[] = "sromrev=%d";
+static const char vstr_chiprev[] = "chiprev=%d";
+static const char vstr_subvendid[] = "subvendid=0x%x";
+static const char vstr_subdevid[] = "subdevid=0x%x";
+static const char vstr_boardrev[] = "boardrev=0x%x";
+static const char vstr_aa2g[] = "aa2g=0x%x";
+static const char vstr_aa5g[] = "aa5g=0x%x";
+static const char vstr_ag[] = "ag%d=0x%x";
+static const char vstr_cc[] = "cc=%d";
+static const char vstr_opo[] = "opo=%d";
+static const char vstr_pa0b[][9] = {
 "pa0b0=%d", "pa0b1=%d", "pa0b2=%d"};
 
-static const char BCMATTACHDATA(vstr_pa0itssit)[] = "pa0itssit=%d";
-static const char BCMATTACHDATA(vstr_pa0maxpwr)[] = "pa0maxpwr=%d";
-static const char BCMATTACHDATA(vstr_pa1b)[][9] =
-{
+static const char vstr_pa0itssit[] = "pa0itssit=%d";
+static const char vstr_pa0maxpwr[] = "pa0maxpwr=%d";
+static const char vstr_pa1b[][9] = {
 "pa1b0=%d", "pa1b1=%d", "pa1b2=%d"};
 
-static const char BCMATTACHDATA(vstr_pa1lob)[][11] =
-{
+static const char vstr_pa1lob[][11] = {
 "pa1lob0=%d", "pa1lob1=%d", "pa1lob2=%d"};
 
-static const char BCMATTACHDATA(vstr_pa1hib)[][11] =
-{
+static const char vstr_pa1hib[][11] = {
 "pa1hib0=%d", "pa1hib1=%d", "pa1hib2=%d"};
 
-static const char BCMATTACHDATA(vstr_pa1itssit)[] = "pa1itssit=%d";
-static const char BCMATTACHDATA(vstr_pa1maxpwr)[] = "pa1maxpwr=%d";
-static const char BCMATTACHDATA(vstr_pa1lomaxpwr)[] = "pa1lomaxpwr=%d";
-static const char BCMATTACHDATA(vstr_pa1himaxpwr)[] = "pa1himaxpwr=%d";
-static const char BCMATTACHDATA(vstr_oem)[] =
+static const char vstr_pa1itssit[] = "pa1itssit=%d";
+static const char vstr_pa1maxpwr[] = "pa1maxpwr=%d";
+static const char vstr_pa1lomaxpwr[] = "pa1lomaxpwr=%d";
+static const char vstr_pa1himaxpwr[] = "pa1himaxpwr=%d";
+static const char vstr_oem[] =
     "oem=%02x%02x%02x%02x%02x%02x%02x%02x";
-static const char BCMATTACHDATA(vstr_boardflags)[] = "boardflags=0x%x";
-static const char BCMATTACHDATA(vstr_boardflags2)[] = "boardflags2=0x%x";
-static const char BCMATTACHDATA(vstr_ledbh)[] = "ledbh%d=0x%x";
-static const char BCMATTACHDATA(vstr_noccode)[] = "ccode=0x0";
-static const char BCMATTACHDATA(vstr_ccode)[] = "ccode=%c%c";
-static const char BCMATTACHDATA(vstr_cctl)[] = "cctl=0x%x";
-static const char BCMATTACHDATA(vstr_cckpo)[] = "cckpo=0x%x";
-static const char BCMATTACHDATA(vstr_ofdmpo)[] = "ofdmpo=0x%x";
-static const char BCMATTACHDATA(vstr_rdlid)[] = "rdlid=0x%x";
-static const char BCMATTACHDATA(vstr_rdlrndis)[] = "rdlrndis=%d";
-static const char BCMATTACHDATA(vstr_rdlrwu)[] = "rdlrwu=%d";
-static const char BCMATTACHDATA(vstr_usbfs)[] = "usbfs=%d";
-static const char BCMATTACHDATA(vstr_wpsgpio)[] = "wpsgpio=%d";
-static const char BCMATTACHDATA(vstr_wpsled)[] = "wpsled=%d";
-static const char BCMATTACHDATA(vstr_rdlsn)[] = "rdlsn=%d";
-static const char BCMATTACHDATA(vstr_rssismf2g)[] = "rssismf2g=%d";
-static const char BCMATTACHDATA(vstr_rssismc2g)[] = "rssismc2g=%d";
-static const char BCMATTACHDATA(vstr_rssisav2g)[] = "rssisav2g=%d";
-static const char BCMATTACHDATA(vstr_bxa2g)[] = "bxa2g=%d";
-static const char BCMATTACHDATA(vstr_rssismf5g)[] = "rssismf5g=%d";
-static const char BCMATTACHDATA(vstr_rssismc5g)[] = "rssismc5g=%d";
-static const char BCMATTACHDATA(vstr_rssisav5g)[] = "rssisav5g=%d";
-static const char BCMATTACHDATA(vstr_bxa5g)[] = "bxa5g=%d";
-static const char BCMATTACHDATA(vstr_tri2g)[] = "tri2g=%d";
-static const char BCMATTACHDATA(vstr_tri5gl)[] = "tri5gl=%d";
-static const char BCMATTACHDATA(vstr_tri5g)[] = "tri5g=%d";
-static const char BCMATTACHDATA(vstr_tri5gh)[] = "tri5gh=%d";
-static const char BCMATTACHDATA(vstr_rxpo2g)[] = "rxpo2g=%d";
-static const char BCMATTACHDATA(vstr_rxpo5g)[] = "rxpo5g=%d";
-static const char BCMATTACHDATA(vstr_boardtype)[] = "boardtype=0x%x";
-static const char BCMATTACHDATA(vstr_leddc)[] = "leddc=0x%04x";
-static const char BCMATTACHDATA(vstr_vendid)[] = "vendid=0x%x";
-static const char BCMATTACHDATA(vstr_devid)[] = "devid=0x%x";
-static const char BCMATTACHDATA(vstr_xtalfreq)[] = "xtalfreq=%d";
-static const char BCMATTACHDATA(vstr_txchain)[] = "txchain=0x%x";
-static const char BCMATTACHDATA(vstr_rxchain)[] = "rxchain=0x%x";
-static const char BCMATTACHDATA(vstr_antswitch)[] = "antswitch=0x%x";
-static const char BCMATTACHDATA(vstr_regrev)[] = "regrev=0x%x";
-static const char BCMATTACHDATA(vstr_antswctl2g)[] = "antswctl2g=0x%x";
-static const char BCMATTACHDATA(vstr_triso2g)[] = "triso2g=0x%x";
-static const char BCMATTACHDATA(vstr_pdetrange2g)[] = "pdetrange2g=0x%x";
-static const char BCMATTACHDATA(vstr_extpagain2g)[] = "extpagain2g=0x%x";
-static const char BCMATTACHDATA(vstr_tssipos2g)[] = "tssipos2g=0x%x";
-static const char BCMATTACHDATA(vstr_antswctl5g)[] = "antswctl5g=0x%x";
-static const char BCMATTACHDATA(vstr_triso5g)[] = "triso5g=0x%x";
-static const char BCMATTACHDATA(vstr_pdetrange5g)[] = "pdetrange5g=0x%x";
-static const char BCMATTACHDATA(vstr_extpagain5g)[] = "extpagain5g=0x%x";
-static const char BCMATTACHDATA(vstr_tssipos5g)[] = "tssipos5g=0x%x";
-static const char BCMATTACHDATA(vstr_maxp2ga0)[] = "maxp2ga0=0x%x";
-static const char BCMATTACHDATA(vstr_itt2ga0)[] = "itt2ga0=0x%x";
-static const char BCMATTACHDATA(vstr_pa)[] = "pa%dgw%da%d=0x%x";
-static const char BCMATTACHDATA(vstr_pahl)[] = "pa%dg%cw%da%d=0x%x";
-static const char BCMATTACHDATA(vstr_maxp5ga0)[] = "maxp5ga0=0x%x";
-static const char BCMATTACHDATA(vstr_itt5ga0)[] = "itt5ga0=0x%x";
-static const char BCMATTACHDATA(vstr_maxp5gha0)[] = "maxp5gha0=0x%x";
-static const char BCMATTACHDATA(vstr_maxp5gla0)[] = "maxp5gla0=0x%x";
-static const char BCMATTACHDATA(vstr_maxp2ga1)[] = "maxp2ga1=0x%x";
-static const char BCMATTACHDATA(vstr_itt2ga1)[] = "itt2ga1=0x%x";
-static const char BCMATTACHDATA(vstr_maxp5ga1)[] = "maxp5ga1=0x%x";
-static const char BCMATTACHDATA(vstr_itt5ga1)[] = "itt5ga1=0x%x";
-static const char BCMATTACHDATA(vstr_maxp5gha1)[] = "maxp5gha1=0x%x";
-static const char BCMATTACHDATA(vstr_maxp5gla1)[] = "maxp5gla1=0x%x";
-static const char BCMATTACHDATA(vstr_cck2gpo)[] = "cck2gpo=0x%x";
-static const char BCMATTACHDATA(vstr_ofdm2gpo)[] = "ofdm2gpo=0x%x";
-static const char BCMATTACHDATA(vstr_ofdm5gpo)[] = "ofdm5gpo=0x%x";
-static const char BCMATTACHDATA(vstr_ofdm5glpo)[] = "ofdm5glpo=0x%x";
-static const char BCMATTACHDATA(vstr_ofdm5ghpo)[] = "ofdm5ghpo=0x%x";
-static const char BCMATTACHDATA(vstr_cddpo)[] = "cddpo=0x%x";
-static const char BCMATTACHDATA(vstr_stbcpo)[] = "stbcpo=0x%x";
-static const char BCMATTACHDATA(vstr_bw40po)[] = "bw40po=0x%x";
-static const char BCMATTACHDATA(vstr_bwduppo)[] = "bwduppo=0x%x";
-static const char BCMATTACHDATA(vstr_mcspo)[] = "mcs%dgpo%d=0x%x";
-static const char BCMATTACHDATA(vstr_mcspohl)[] = "mcs%dg%cpo%d=0x%x";
-static const char BCMATTACHDATA(vstr_custom)[] = "customvar%d=0x%x";
-static const char BCMATTACHDATA(vstr_cckdigfilttype)[] = "cckdigfilttype=%d";
-static const char BCMATTACHDATA(vstr_boardnum)[] = "boardnum=%d";
-static const char BCMATTACHDATA(vstr_macaddr)[] = "macaddr=%s";
-static const char BCMATTACHDATA(vstr_usbepnum)[] = "usbepnum=0x%x";
-static const char BCMATTACHDATA(vstr_end)[] = "END\0";
-
-uint8 patch_pair = 0;
+static const char vstr_boardflags[] = "boardflags=0x%x";
+static const char vstr_boardflags2[] = "boardflags2=0x%x";
+static const char vstr_ledbh[] = "ledbh%d=0x%x";
+static const char vstr_noccode[] = "ccode=0x0";
+static const char vstr_ccode[] = "ccode=%c%c";
+static const char vstr_cctl[] = "cctl=0x%x";
+static const char vstr_cckpo[] = "cckpo=0x%x";
+static const char vstr_ofdmpo[] = "ofdmpo=0x%x";
+static const char vstr_rdlid[] = "rdlid=0x%x";
+static const char vstr_rdlrndis[] = "rdlrndis=%d";
+static const char vstr_rdlrwu[] = "rdlrwu=%d";
+static const char vstr_usbfs[] = "usbfs=%d";
+static const char vstr_wpsgpio[] = "wpsgpio=%d";
+static const char vstr_wpsled[] = "wpsled=%d";
+static const char vstr_rdlsn[] = "rdlsn=%d";
+static const char vstr_rssismf2g[] = "rssismf2g=%d";
+static const char vstr_rssismc2g[] = "rssismc2g=%d";
+static const char vstr_rssisav2g[] = "rssisav2g=%d";
+static const char vstr_bxa2g[] = "bxa2g=%d";
+static const char vstr_rssismf5g[] = "rssismf5g=%d";
+static const char vstr_rssismc5g[] = "rssismc5g=%d";
+static const char vstr_rssisav5g[] = "rssisav5g=%d";
+static const char vstr_bxa5g[] = "bxa5g=%d";
+static const char vstr_tri2g[] = "tri2g=%d";
+static const char vstr_tri5gl[] = "tri5gl=%d";
+static const char vstr_tri5g[] = "tri5g=%d";
+static const char vstr_tri5gh[] = "tri5gh=%d";
+static const char vstr_rxpo2g[] = "rxpo2g=%d";
+static const char vstr_rxpo5g[] = "rxpo5g=%d";
+static const char vstr_boardtype[] = "boardtype=0x%x";
+static const char vstr_leddc[] = "leddc=0x%04x";
+static const char vstr_vendid[] = "vendid=0x%x";
+static const char vstr_devid[] = "devid=0x%x";
+static const char vstr_xtalfreq[] = "xtalfreq=%d";
+static const char vstr_txchain[] = "txchain=0x%x";
+static const char vstr_rxchain[] = "rxchain=0x%x";
+static const char vstr_antswitch[] = "antswitch=0x%x";
+static const char vstr_regrev[] = "regrev=0x%x";
+static const char vstr_antswctl2g[] = "antswctl2g=0x%x";
+static const char vstr_triso2g[] = "triso2g=0x%x";
+static const char vstr_pdetrange2g[] = "pdetrange2g=0x%x";
+static const char vstr_extpagain2g[] = "extpagain2g=0x%x";
+static const char vstr_tssipos2g[] = "tssipos2g=0x%x";
+static const char vstr_antswctl5g[] = "antswctl5g=0x%x";
+static const char vstr_triso5g[] = "triso5g=0x%x";
+static const char vstr_pdetrange5g[] = "pdetrange5g=0x%x";
+static const char vstr_extpagain5g[] = "extpagain5g=0x%x";
+static const char vstr_tssipos5g[] = "tssipos5g=0x%x";
+static const char vstr_maxp2ga0[] = "maxp2ga0=0x%x";
+static const char vstr_itt2ga0[] = "itt2ga0=0x%x";
+static const char vstr_pa[] = "pa%dgw%da%d=0x%x";
+static const char vstr_pahl[] = "pa%dg%cw%da%d=0x%x";
+static const char vstr_maxp5ga0[] = "maxp5ga0=0x%x";
+static const char vstr_itt5ga0[] = "itt5ga0=0x%x";
+static const char vstr_maxp5gha0[] = "maxp5gha0=0x%x";
+static const char vstr_maxp5gla0[] = "maxp5gla0=0x%x";
+static const char vstr_maxp2ga1[] = "maxp2ga1=0x%x";
+static const char vstr_itt2ga1[] = "itt2ga1=0x%x";
+static const char vstr_maxp5ga1[] = "maxp5ga1=0x%x";
+static const char vstr_itt5ga1[] = "itt5ga1=0x%x";
+static const char vstr_maxp5gha1[] = "maxp5gha1=0x%x";
+static const char vstr_maxp5gla1[] = "maxp5gla1=0x%x";
+static const char vstr_cck2gpo[] = "cck2gpo=0x%x";
+static const char vstr_ofdm2gpo[] = "ofdm2gpo=0x%x";
+static const char vstr_ofdm5gpo[] = "ofdm5gpo=0x%x";
+static const char vstr_ofdm5glpo[] = "ofdm5glpo=0x%x";
+static const char vstr_ofdm5ghpo[] = "ofdm5ghpo=0x%x";
+static const char vstr_cddpo[] = "cddpo=0x%x";
+static const char vstr_stbcpo[] = "stbcpo=0x%x";
+static const char vstr_bw40po[] = "bw40po=0x%x";
+static const char vstr_bwduppo[] = "bwduppo=0x%x";
+static const char vstr_mcspo[] = "mcs%dgpo%d=0x%x";
+static const char vstr_mcspohl[] = "mcs%dg%cpo%d=0x%x";
+static const char vstr_custom[] = "customvar%d=0x%x";
+static const char vstr_cckdigfilttype[] = "cckdigfilttype=%d";
+static const char vstr_boardnum[] = "boardnum=%d";
+static const char vstr_macaddr[] = "macaddr=%s";
+static const char vstr_usbepnum[] = "usbepnum=0x%x";
+static const char vstr_end[] = "END\0";
+
+u8 patch_pair;
 
 /* For dongle HW, accept partial calibration parameters */
 #define BCMDONGLECASE(n)
 
-int
-BCMATTACHFN(srom_parsecis) (osl_t * osh, uint8 * pcis[], uint ciscnt,
-			    char **vars, uint * count)
+int srom_parsecis(osl_t *osh, u8 *pcis[], uint ciscnt, char **vars, uint *count)
 {
 	char eabuf[32];
 	char *base;
 	varbuf_t b;
-	uint8 *cis, tup, tlen, sromrev = 1;
+	u8 *cis, tup, tlen, sromrev = 1;
 	int i, j;
-	bool ag_init = FALSE;
-	uint32 w32;
+	bool ag_init = false;
+	u32 w32;
 	uint funcid;
 	uint cisnum;
-	int32 boardnum;
+	s32 boardnum;
 	int err;
 	bool standard_cis;
 
@@ -398,7 +396,7 @@ BCMATTACHFN(srom_parsecis) (osl_t * osh, uint8 * pcis[], uint ciscnt,
 
 	boardnum = -1;
 
-	base = MALLOC(osh, MAXSZ_NVRAM_VARS);
+	base = kmalloc(MAXSZ_NVRAM_VARS, GFP_ATOMIC);
 	ASSERT(base != NULL);
 	if (!base)
 		return -2;
@@ -410,7 +408,7 @@ BCMATTACHFN(srom_parsecis) (osl_t * osh, uint8 * pcis[], uint ciscnt,
 		cis = *pcis++;
 		i = 0;
 		funcid = 0;
-		standard_cis = TRUE;
+		standard_cis = true;
 		do {
 			if (standard_cis) {
 				tup = cis[i++];
@@ -462,7 +460,7 @@ BCMATTACHFN(srom_parsecis) (osl_t * osh, uint8 * pcis[], uint ciscnt,
 				case CISTPL_FID_SDIO:
 #ifdef BCMSDIO
 					if (cis[i] == 0) {
-						uint8 spd = cis[i + 3];
+						u8 spd = cis[i + 3];
 						static int base[] = {
 							-1, 10, 12, 13, 15, 20,
 							    25, 30,
@@ -504,10 +502,8 @@ BCMATTACHFN(srom_parsecis) (osl_t * osh, uint8 * pcis[], uint ciscnt,
 					    && !(ETHER_ISMULTI(&cis[i + 2]))) {
 						ASSERT(cis[i + 1] ==
 						       ETHER_ADDR_LEN);
-						bcm_ether_ntoa((struct
-								ether_addr *)
-							       &cis[i + 2],
-							       eabuf);
+						snprintf(eabuf, sizeof(eabuf),
+							"%pM", &cis[i + 2]);
 
 						/* set boardnum if HNBU_BOARDNUM not seen yet */
 						if (boardnum == -1)
@@ -694,7 +690,7 @@ BCMATTACHFN(srom_parsecis) (osl_t * osh, uint8 * pcis[], uint ciscnt,
 					 * after this tuple
 					 */
 					tlen++;
-					standard_cis = FALSE;
+					standard_cis = false;
 					break;
 
 				case HNBU_USBEPNUM:
@@ -724,7 +720,7 @@ BCMATTACHFN(srom_parsecis) (osl_t * osh, uint8 * pcis[], uint ciscnt,
 					if (tlen >= 5)
 						varbuf_append(&b, vstr_ag, 3,
 							      cis[i + 4]);
-					ag_init = TRUE;
+					ag_init = true;
 					break;
 
 				case HNBU_ANT5G:
@@ -976,10 +972,8 @@ BCMATTACHFN(srom_parsecis) (osl_t * osh, uint8 * pcis[], uint ciscnt,
 				case HNBU_MACADDR:
 					if (!(ETHER_ISNULLADDR(&cis[i + 1])) &&
 					    !(ETHER_ISMULTI(&cis[i + 1]))) {
-						bcm_ether_ntoa((struct
-								ether_addr *)
-							       &cis[i + 1],
-							       eabuf);
+						snprintf(eabuf, sizeof(eabuf),
+							"%pM", &cis[i + 1]);
 
 						/* set boardnum if HNBU_BOARDNUM not seen yet */
 						if (boardnum == -1)
@@ -1012,7 +1006,7 @@ BCMATTACHFN(srom_parsecis) (osl_t * osh, uint8 * pcis[], uint ciscnt,
 					break;
 
 				case HNBU_FEM:{
-						uint16 fem =
+						u16 fem =
 						    (cis[i + 2] << 8) + cis[i +
 									    1];
 						varbuf_append(&b,
@@ -1334,8 +1328,8 @@ BCMATTACHFN(srom_parsecis) (osl_t * osh, uint8 * pcis[], uint ciscnt,
 #if defined(BCMSDIO)
 				case HNBU_SROM3SWRGN:
 					if (tlen >= 73) {
-						uint16 srom[35];
-						uint8 srev = cis[i + 1 + 70];
+						u16 srom[35];
+						u8 srev = cis[i + 1 + 70];
 						ASSERT(srev == 3);
 						/* make tuple value 16-bit aligned and parse it */
 						bcopy(&cis[i + 1], srom,
@@ -1344,7 +1338,7 @@ BCMATTACHFN(srom_parsecis) (osl_t * osh, uint8 * pcis[], uint ciscnt,
 								   SROM3_SWRGN_OFF,
 								   &b);
 						/* 2.4G antenna gain is included in SROM */
-						ag_init = TRUE;
+						ag_init = true;
 						/* Ethernet MAC address is included in SROM */
 						eabuf[0] = 0;
 						boardnum = -1;
@@ -1392,7 +1386,7 @@ BCMATTACHFN(srom_parsecis) (osl_t * osh, uint8 * pcis[], uint ciscnt,
 	}
 
 	/* if there is no antenna gain field, set default */
-	if (getvar(NULL, "ag0") == NULL && ag_init == FALSE) {
+	if (getvar(NULL, "ag0") == NULL && ag_init == false) {
 		varbuf_append(&b, vstr_ag, 0, 0xff);
 	}
 
@@ -1403,16 +1397,16 @@ BCMATTACHFN(srom_parsecis) (osl_t * osh, uint8 * pcis[], uint ciscnt,
 	ASSERT(b.buf - base <= MAXSZ_NVRAM_VARS);
 	err = initvars_table(osh, base, b.buf, vars, count);
 
-	MFREE(osh, base, MAXSZ_NVRAM_VARS);
+	kfree(base);
 	return err;
 }
 
 /* In chips with chipcommon rev 32 and later, the srom is in chipcommon,
  * not in the bus cores.
  */
-static uint16
-srom_cc_cmd(si_t * sih, osl_t * osh, void *ccregs, uint32 cmd, uint wordoff,
-	    uint16 data)
+static u16
+srom_cc_cmd(si_t *sih, osl_t *osh, void *ccregs, u32 cmd, uint wordoff,
+	    u16 data)
 {
 	chipcregs_t *cc = (chipcregs_t *) ccregs;
 	uint wait_cnt = 1000;
@@ -1435,7 +1429,7 @@ srom_cc_cmd(si_t * sih, osl_t * osh, void *ccregs, uint32 cmd, uint wordoff,
 		return 0xffff;
 	}
 	if (cmd == SRC_OP_READ)
-		return (uint16) R_REG(osh, &cc->sromdata);
+		return (u16) R_REG(osh, &cc->sromdata);
 	else
 		return 0xffff;
 }
@@ -1445,8 +1439,8 @@ srom_cc_cmd(si_t * sih, osl_t * osh, void *ccregs, uint32 cmd, uint wordoff,
  * Return 0 on success, nonzero on error.
  */
 static int
-sprom_read_pci(osl_t * osh, si_t * sih, uint16 * sprom, uint wordoff,
-	       uint16 * buf, uint nwords, bool check_crc)
+sprom_read_pci(osl_t *osh, si_t *sih, u16 *sprom, uint wordoff,
+	       u16 *buf, uint nwords, bool check_crc)
 {
 	int err = 0;
 	uint i;
@@ -1460,7 +1454,7 @@ sprom_read_pci(osl_t * osh, si_t * sih, uint16 * sprom, uint wordoff,
 			if ((sih->cccaps & CC_CAP_SROM) == 0)
 				return 1;
 
-			ccregs = (void *)((uint8 *) sprom - CC_SROM_OTP);
+			ccregs = (void *)((u8 *) sprom - CC_SROM_OTP);
 			buf[i] =
 			    srom_cc_cmd(sih, osh, ccregs, SRC_OP_READ,
 					wordoff + i, 0);
@@ -1492,7 +1486,7 @@ sprom_read_pci(osl_t * osh, si_t * sih, uint16 * sprom, uint wordoff,
 
 		/* fixup the endianness so crc8 will pass */
 		htol16_buf(buf, nwords * 2);
-		if (hndcrc8((uint8 *) buf, nwords * 2, CRC8_INIT_VALUE) !=
+		if (hndcrc8((u8 *) buf, nwords * 2, CRC8_INIT_VALUE) !=
 		    CRC8_GOOD_VALUE) {
 			/* DBG only pci always read srom4 first, then srom8/9 */
 			/* BS_ERROR(("%s: bad crc\n", __func__)); */
@@ -1505,26 +1499,25 @@ sprom_read_pci(osl_t * osh, si_t * sih, uint16 * sprom, uint wordoff,
 }
 
 #if defined(BCMNVRAMR)
-static int otp_read_pci(osl_t * osh, si_t * sih, uint16 * buf, uint bufsz)
+static int otp_read_pci(osl_t *osh, si_t *sih, u16 *buf, uint bufsz)
 {
-	uint8 *otp;
+	u8 *otp;
 	uint sz = OTP_SZ_MAX / 2;	/* size in words */
 	int err = 0;
 
 	ASSERT(bufsz <= OTP_SZ_MAX);
 
-	if ((otp = MALLOC(osh, OTP_SZ_MAX)) == NULL) {
+	otp = kzalloc(OTP_SZ_MAX, GFP_ATOMIC);
+	if (otp == NULL) {
 		return BCME_ERROR;
 	}
 
-	bzero(otp, OTP_SZ_MAX);
-
-	err = otp_read_region(sih, OTP_HW_RGN, (uint16 *) otp, &sz);
+	err = otp_read_region(sih, OTP_HW_RGN, (u16 *) otp, &sz);
 
 	bcopy(otp, buf, bufsz);
 
 	if (otp)
-		MFREE(osh, otp, OTP_SZ_MAX);
+		kfree(otp);
 
 	/* Check CRC */
 	if (buf[0] == 0xffff) {
@@ -1539,7 +1532,7 @@ static int otp_read_pci(osl_t * osh, si_t * sih, uint16 * buf, uint bufsz)
 
 	/* fixup the endianness so crc8 will pass */
 	htol16_buf(buf, bufsz);
-	if (hndcrc8((uint8 *) buf, SROM4_WORDS * 2, CRC8_INIT_VALUE) !=
+	if (hndcrc8((u8 *) buf, SROM4_WORDS * 2, CRC8_INIT_VALUE) !=
 	    CRC8_GOOD_VALUE) {
 		BS_ERROR(("%s: bad crc\n", __func__));
 		err = 1;
@@ -1554,14 +1547,14 @@ static int otp_read_pci(osl_t * osh, si_t * sih, uint16 * buf, uint bufsz)
 * Create variable table from memory.
 * Return 0 on success, nonzero on error.
 */
-static int
-BCMATTACHFN(initvars_table) (osl_t * osh, char *start, char *end, char **vars,
-			     uint * count) {
+static int initvars_table(osl_t *osh, char *start, char *end, char **vars,
+			  uint *count)
+{
 	int c = (int)(end - start);
 
 	/* do it only when there is more than just the null string */
 	if (c > 1) {
-		char *vp = MALLOC(osh, c);
+		char *vp = kmalloc(c, GFP_ATOMIC);
 		ASSERT(vp != NULL);
 		if (!vp)
 			return BCME_NOMEM;
@@ -1581,8 +1574,8 @@ BCMATTACHFN(initvars_table) (osl_t * osh, char *start, char *end, char **vars,
  * of the table upon enter and to the end of the table upon exit when success.
  * Return 0 on success, nonzero on error.
  */
-static int
-BCMATTACHFN(initvars_flash) (si_t * sih, osl_t * osh, char **base, uint len) {
+static int initvars_flash(si_t *sih, osl_t *osh, char **base, uint len)
+{
 	char *vp = *base;
 	char *flash;
 	int err;
@@ -1591,9 +1584,11 @@ BCMATTACHFN(initvars_flash) (si_t * sih, osl_t * osh, char **base, uint len) {
 	char devpath[SI_DEVPATH_BUFSZ];
 
 	/* allocate memory and read in flash */
-	if (!(flash = MALLOC(osh, NVRAM_SPACE)))
+	flash = kmalloc(NVRAM_SPACE, GFP_ATOMIC);
+	if (!flash)
 		return BCME_NOMEM;
-	if ((err = nvram_getall(flash, NVRAM_SPACE)))
+	err = nvram_getall(flash, NVRAM_SPACE);
+	if (err)
 		goto exit;
 
 	si_devpath(sih, devpath, sizeof(devpath));
@@ -1629,7 +1624,7 @@ BCMATTACHFN(initvars_flash) (si_t * sih, osl_t * osh, char **base, uint len) {
 
 	*base = vp;
 
- exit:	MFREE(osh, flash, NVRAM_SPACE);
+ exit:	kfree(flash);
 	return err;
 }
 
@@ -1637,8 +1632,8 @@ BCMATTACHFN(initvars_flash) (si_t * sih, osl_t * osh, char **base, uint len) {
  * Initialize nonvolatile variable table from flash.
  * Return 0 on success, nonzero on error.
  */
-static int
-BCMATTACHFN(initvars_flash_si) (si_t * sih, char **vars, uint * count) {
+static int initvars_flash_si(si_t *sih, char **vars, uint *count)
+{
 	osl_t *osh = si_osh(sih);
 	char *vp, *base;
 	int err;
@@ -1646,15 +1641,16 @@ BCMATTACHFN(initvars_flash_si) (si_t * sih, char **vars, uint * count) {
 	ASSERT(vars != NULL);
 	ASSERT(count != NULL);
 
-	base = vp = MALLOC(osh, MAXSZ_NVRAM_VARS);
+	base = vp = kmalloc(MAXSZ_NVRAM_VARS, GFP_ATOMIC);
 	ASSERT(vp != NULL);
 	if (!vp)
 		return BCME_NOMEM;
 
-	if ((err = initvars_flash(sih, osh, &vp, MAXSZ_NVRAM_VARS)) == 0)
+	err = initvars_flash(sih, osh, &vp, MAXSZ_NVRAM_VARS);
+	if (err == 0)
 		err = initvars_table(osh, base, vp, vars, count);
 
-	MFREE(osh, base, MAXSZ_NVRAM_VARS);
+	kfree(base);
 
 	return err;
 }
@@ -1665,7 +1661,7 @@ BCMATTACHFN(initvars_flash_si) (si_t * sih, char **vars, uint * count) {
  * SROM3_SWRG_OFF (full SROM or software region).
  */
 
-static uint mask_shift(uint16 mask)
+static uint mask_shift(u16 mask)
 {
 	uint i;
 	for (i = 0; i < (sizeof(mask) << 3); i++) {
@@ -1676,7 +1672,7 @@ static uint mask_shift(uint16 mask)
 	return 0;
 }
 
-static uint mask_width(uint16 mask)
+static uint mask_width(u16 mask)
 {
 	int i;
 	for (i = (sizeof(mask) << 3) - 1; i >= 0; i--) {
@@ -1688,7 +1684,7 @@ static uint mask_width(uint16 mask)
 }
 
 #if defined(BCMDBG)
-static bool mask_valid(uint16 mask)
+static bool mask_valid(u16 mask)
 {
 	uint shift = mask_shift(mask);
 	uint width = mask_width(mask);
@@ -1696,15 +1692,14 @@ static bool mask_valid(uint16 mask)
 }
 #endif				/* BCMDBG */
 
-static void
-BCMATTACHFN(_initvars_srom_pci) (uint8 sromrev, uint16 * srom, uint off,
-				 varbuf_t * b) {
-	uint16 w;
-	uint32 val;
+static void _initvars_srom_pci(u8 sromrev, u16 *srom, uint off, varbuf_t *b)
+{
+	u16 w;
+	u32 val;
 	const sromvar_t *srv;
 	uint width;
 	uint flags;
-	uint32 sr = (1 << sromrev);
+	u32 sr = (1 << sromrev);
 
 	varbuf_append(b, "sromrev=%d", sromrev);
 
@@ -1725,7 +1720,6 @@ BCMATTACHFN(_initvars_srom_pci) (uint8 sromrev, uint16 * srom, uint off,
 			continue;
 
 		if (flags & SRFL_ETHADDR) {
-			char eabuf[ETHER_ADDR_STR_LEN];
 			struct ether_addr ea;
 
 			ea.octet[0] = (srom[srv->off - off] >> 8) & 0xff;
@@ -1734,9 +1728,8 @@ BCMATTACHFN(_initvars_srom_pci) (uint8 sromrev, uint16 * srom, uint off,
 			ea.octet[3] = srom[srv->off + 1 - off] & 0xff;
 			ea.octet[4] = (srom[srv->off + 2 - off] >> 8) & 0xff;
 			ea.octet[5] = srom[srv->off + 2 - off] & 0xff;
-			bcm_ether_ntoa(&ea, eabuf);
 
-			varbuf_append(b, "%s=%s", name, eabuf);
+			varbuf_append(b, "%s=%pM", name, ea.octet);
 		} else {
 			ASSERT(mask_valid(srv->mask));
 			ASSERT(mask_width(srv->mask));
@@ -1778,7 +1771,7 @@ BCMATTACHFN(_initvars_srom_pci) (uint8 sromrev, uint16 * srom, uint off,
 			 *(oncount >> 24) (offcount >> 8)
 			 */
 			else if (flags & SRFL_LEDDC) {
-				uint32 w32 = (((val >> 8) & 0xff) << 24) |	/* oncount */
+				u32 w32 = (((val >> 8) & 0xff) << 24) |	/* oncount */
 				    (((val & 0xff)) << 8);	/* offcount */
 				varbuf_append(b, "leddc=%d", w32);
 			} else if (flags & SRFL_PRHEX)
@@ -1845,16 +1838,15 @@ BCMATTACHFN(_initvars_srom_pci) (uint8 sromrev, uint16 * srom, uint off,
  * Initialize nonvolatile variable table from sprom.
  * Return 0 on success, nonzero on error.
  */
-static int
-BCMATTACHFN(initvars_srom_pci) (si_t * sih, void *curmap, char **vars,
-				uint * count) {
-	uint16 *srom, *sromwindow;
-	uint8 sromrev = 0;
-	uint32 sr;
+static int initvars_srom_pci(si_t *sih, void *curmap, char **vars, uint *count)
+{
+	u16 *srom, *sromwindow;
+	u8 sromrev = 0;
+	u32 sr;
 	varbuf_t b;
 	char *vp, *base = NULL;
 	osl_t *osh = si_osh(sih);
-	bool flash = FALSE;
+	bool flash = false;
 	int err = 0;
 
 	/*
@@ -1863,16 +1855,16 @@ BCMATTACHFN(initvars_srom_pci) (si_t * sih, void *curmap, char **vars,
 	 * if we should return an error when CRC fails or read SROM variables
 	 * from flash.
 	 */
-	srom = MALLOC(osh, SROM_MAX);
+	srom = kmalloc(SROM_MAX, GFP_ATOMIC);
 	ASSERT(srom != NULL);
 	if (!srom)
 		return -2;
 
-	sromwindow = (uint16 *) SROM_OFFSET(sih);
+	sromwindow = (u16 *) SROM_OFFSET(sih);
 	if (si_is_sprom_available(sih)) {
 		err =
 		    sprom_read_pci(osh, sih, sromwindow, 0, srom, SROM_WORDS,
-				   TRUE);
+				   true);
 
 		if ((srom[SROM4_SIGN] == SROM4_SIGNATURE) ||
 		    (((sih->buscoretype == PCIE_CORE_ID)
@@ -1882,7 +1874,7 @@ BCMATTACHFN(initvars_srom_pci) (si_t * sih, void *curmap, char **vars,
 			/* sromrev >= 4, read more */
 			err =
 			    sprom_read_pci(osh, sih, sromwindow, 0, srom,
-					   SROM4_WORDS, TRUE);
+					   SROM4_WORDS, true);
 			sromrev = srom[SROM4_CRCREV] & 0xff;
 			if (err)
 				BS_ERROR(("%s: srom %d, bad crc\n", __func__,
@@ -1914,18 +1906,20 @@ BCMATTACHFN(initvars_srom_pci) (si_t * sih, void *curmap, char **vars,
 	 */
 	if (err) {
 		char *value;
-		uint32 val;
+		u32 val;
 		val = 0;
 
-		if ((value = si_getdevpathvar(sih, "sromrev"))) {
-			sromrev = (uint8) bcm_strtoul(value, NULL, 0);
-			flash = TRUE;
+		value = si_getdevpathvar(sih, "sromrev");
+		if (value) {
+			sromrev = (u8) simple_strtoul(value, NULL, 0);
+			flash = true;
 			goto varscont;
 		}
 
 		BS_ERROR(("%s, SROM CRC Error\n", __func__));
 
-		if ((value = si_getnvramflvar(sih, "sromrev"))) {
+		value = si_getnvramflvar(sih, "sromrev");
+		if (value) {
 			err = 0;
 			goto errout;
 		}
@@ -1949,7 +1943,7 @@ BCMATTACHFN(initvars_srom_pci) (si_t * sih, void *curmap, char **vars,
 	ASSERT(vars != NULL);
 	ASSERT(count != NULL);
 
-	base = vp = MALLOC(osh, MAXSZ_NVRAM_VARS);
+	base = vp = kmalloc(MAXSZ_NVRAM_VARS, GFP_ATOMIC);
 	ASSERT(vp != NULL);
 	if (!vp) {
 		err = -2;
@@ -1958,7 +1952,8 @@ BCMATTACHFN(initvars_srom_pci) (si_t * sih, void *curmap, char **vars,
 
 	/* read variables from flash */
 	if (flash) {
-		if ((err = initvars_flash(sih, osh, &vp, MAXSZ_NVRAM_VARS)))
+		err = initvars_flash(sih, osh, &vp, MAXSZ_NVRAM_VARS);
+		if (err)
 			goto errout;
 		goto varsdone;
 	}
@@ -1980,9 +1975,9 @@ BCMATTACHFN(initvars_srom_pci) (si_t * sih, void *curmap, char **vars,
 
  errout:
 	if (base)
-		MFREE(osh, base, MAXSZ_NVRAM_VARS);
+		kfree(base);
 
-	MFREE(osh, srom, SROM_MAX);
+	kfree(srom);
 	return err;
 }
 
@@ -1991,9 +1986,9 @@ BCMATTACHFN(initvars_srom_pci) (si_t * sih, void *curmap, char **vars,
  * Read the SDIO cis and call parsecis to initialize the vars.
  * Return 0 on success, nonzero on error.
  */
-static int
-BCMATTACHFN(initvars_cis_sdio) (osl_t * osh, char **vars, uint * count) {
-	uint8 *cis[SBSDIO_NUM_FUNCTION + 1];
+static int initvars_cis_sdio(osl_t *osh, char **vars, uint *count)
+{
+	u8 *cis[SBSDIO_NUM_FUNCTION + 1];
 	uint fn, numfn;
 	int rc = 0;
 
@@ -2001,16 +1996,15 @@ BCMATTACHFN(initvars_cis_sdio) (osl_t * osh, char **vars, uint * count) {
 	ASSERT(numfn <= SDIOD_MAX_IOFUNCS);
 
 	for (fn = 0; fn <= numfn; fn++) {
-		if ((cis[fn] = MALLOC(osh, SBSDIO_CIS_SIZE_LIMIT)) == NULL) {
+		cis[fn] = kzalloc(SBSDIO_CIS_SIZE_LIMIT, GFP_ATOMIC);
+		if (cis[fn] == NULL) {
 			rc = -1;
 			break;
 		}
 
-		bzero(cis[fn], SBSDIO_CIS_SIZE_LIMIT);
-
 		if (bcmsdh_cis_read(NULL, fn, cis[fn], SBSDIO_CIS_SIZE_LIMIT) !=
 		    0) {
-			MFREE(osh, cis[fn], SBSDIO_CIS_SIZE_LIMIT);
+			kfree(cis[fn]);
 			rc = -2;
 			break;
 		}
@@ -2020,14 +2014,15 @@ BCMATTACHFN(initvars_cis_sdio) (osl_t * osh, char **vars, uint * count) {
 		rc = srom_parsecis(osh, cis, fn, vars, count);
 
 	while (fn-- > 0)
-		MFREE(osh, cis[fn], SBSDIO_CIS_SIZE_LIMIT);
+		kfree(cis[fn]);
 
-	return (rc);
+	return rc;
 }
 
 /* set SDIO sprom command register */
-static int BCMATTACHFN(sprom_cmd_sdio) (osl_t * osh, uint8 cmd) {
-	uint8 status = 0;
+static int sprom_cmd_sdio(osl_t *osh, u8 cmd)
+{
+	u8 status = 0;
 	uint wait_cnt = 1000;
 
 	/* write sprom command register */
@@ -2045,12 +2040,12 @@ static int BCMATTACHFN(sprom_cmd_sdio) (osl_t * osh, uint8 cmd) {
 }
 
 /* read a word from the SDIO srom */
-static int sprom_read_sdio(osl_t * osh, uint16 addr, uint16 * data)
+static int sprom_read_sdio(osl_t *osh, u16 addr, u16 *data)
 {
-	uint8 addr_l, addr_h, data_l, data_h;
+	u8 addr_l, addr_h, data_l, data_h;
 
-	addr_l = (uint8) ((addr * 2) & 0xff);
-	addr_h = (uint8) (((addr * 2) >> 8) & 0xff);
+	addr_l = (u8) ((addr * 2) & 0xff);
+	addr_h = (u8) (((addr * 2) >> 8) & 0xff);
 
 	/* set address */
 	bcmsdh_cfg_write(NULL, SDIO_FUNC_1, SBSDIO_SPROM_ADDR_HIGH, addr_h,
@@ -2073,9 +2068,9 @@ static int sprom_read_sdio(osl_t * osh, uint16 addr, uint16 * data)
 }
 #endif				/* BCMSDIO */
 
-static int
-BCMATTACHFN(initvars_srom_si) (si_t * sih, osl_t * osh, void *curmap,
-			       char **vars, uint * varsz) {
+static int initvars_srom_si(si_t *sih, osl_t *osh, void *curmap, char **vars,
+			    uint *varsz)
+{
 	/* Search flash nvram section for srom variables */
 	return initvars_flash_si(sih, vars, varsz);
 }
diff --git a/drivers/staging/brcm80211/util/bcmutils.c b/drivers/staging/brcm80211/util/bcmutils.c
index 364f837..9789ea4 100644
--- a/drivers/staging/brcm80211/util/bcmutils.c
+++ b/drivers/staging/brcm80211/util/bcmutils.c
@@ -14,10 +14,13 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <typedefs.h>
+#include <linux/ctype.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
 #include <bcmdefs.h>
 #include <stdarg.h>
 #include <osl.h>
+#include <linuxver.h>
 #include <bcmutils.h>
 #include <siutils.h>
 #include <bcmnvram.h>
@@ -27,45 +30,9 @@
 #include <proto/802.1d.h>
 #include <proto/802.11.h>
 
-#ifdef WLC_LOW
-/* nvram vars cache */
-static char *nvram_vars = NULL;
-static int vars_len = -1;
-#endif				/* WLC_LOW */
-
-/* copy a pkt buffer chain into a buffer */
-uint pktcopy(osl_t * osh, void *p, uint offset, int len, uchar * buf)
-{
-	uint n, ret = 0;
-
-	if (len < 0)
-		len = 4096;	/* "infinite" */
-
-	/* skip 'offset' bytes */
-	for (; p && offset; p = PKTNEXT(p)) {
-		if (offset < (uint) PKTLEN(p))
-			break;
-		offset -= PKTLEN(p);
-	}
-
-	if (!p)
-		return 0;
-
-	/* copy the data */
-	for (; p && len; p = PKTNEXT(p)) {
-		n = MIN((uint) PKTLEN(p) - offset, (uint) len);
-		bcopy(PKTDATA(p) + offset, buf, n);
-		buf += n;
-		len -= n;
-		ret += n;
-		offset = 0;
-	}
-
-	return ret;
-}
 
 /* copy a buffer into a pkt buffer chain */
-uint pktfrombuf(osl_t * osh, void *p, uint offset, int len, uchar * buf)
+uint pktfrombuf(osl_t *osh, void *p, uint offset, int len, unsigned char *buf)
 {
 	uint n, ret = 0;
 
@@ -81,7 +48,7 @@ uint pktfrombuf(osl_t * osh, void *p, uint offset, int len, uchar * buf)
 
 	/* copy the data */
 	for (; p && len; p = PKTNEXT(p)) {
-		n = MIN((uint) PKTLEN(p) - offset, (uint) len);
+		n = min((uint) PKTLEN(p) - offset, (uint) len);
 		bcopy(buf, PKTDATA(p) + offset, n);
 		buf += n;
 		len -= n;
@@ -91,35 +58,15 @@ uint pktfrombuf(osl_t * osh, void *p, uint offset, int len, uchar * buf)
 
 	return ret;
 }
-
 /* return total length of buffer chain */
-uint BCMFASTPATH pkttotlen(osl_t * osh, void *p)
+uint BCMFASTPATH pkttotlen(osl_t *osh, void *p)
 {
 	uint total;
 
 	total = 0;
 	for (; p; p = PKTNEXT(p))
 		total += PKTLEN(p);
-	return (total);
-}
-
-/* return the last buffer of chained pkt */
-void *pktlast(osl_t * osh, void *p)
-{
-	for (; PKTNEXT(p); p = PKTNEXT(p)) ;
-
-	return (p);
-}
-
-/* count segments of a chained packet */
-uint BCMFASTPATH pktsegcnt(osl_t * osh, void *p)
-{
-	uint cnt;
-
-	for (cnt = 0; p; p = PKTNEXT(p))
-		cnt++;
-
-	return cnt;
+	return total;
 }
 
 /*
@@ -149,7 +96,7 @@ void *BCMFASTPATH pktq_penq(struct pktq *pq, int prec, void *p)
 	pq->len++;
 
 	if (pq->hi_prec < prec)
-		pq->hi_prec = (uint8) prec;
+		pq->hi_prec = (u8) prec;
 
 	return p;
 }
@@ -176,7 +123,7 @@ void *BCMFASTPATH pktq_penq_head(struct pktq *pq, int prec, void *p)
 	pq->len++;
 
 	if (pq->hi_prec < prec)
-		pq->hi_prec = (uint8) prec;
+		pq->hi_prec = (u8) prec;
 
 	return p;
 }
@@ -190,10 +137,12 @@ void *BCMFASTPATH pktq_pdeq(struct pktq *pq, int prec)
 
 	q = &pq->q[prec];
 
-	if ((p = q->head) == NULL)
+	p = q->head;
+	if (p == NULL)
 		return NULL;
 
-	if ((q->head = PKTLINK(p)) == NULL)
+	q->head = PKTLINK(p);
+	if (q->head == NULL)
 		q->tail = NULL;
 
 	q->len--;
@@ -214,7 +163,8 @@ void *BCMFASTPATH pktq_pdeq_tail(struct pktq *pq, int prec)
 
 	q = &pq->q[prec];
 
-	if ((p = q->head) == NULL)
+	p = q->head;
+	if (p == NULL)
 		return NULL;
 
 	for (prev = NULL; p != q->tail; p = PKTLINK(p))
@@ -233,8 +183,36 @@ void *BCMFASTPATH pktq_pdeq_tail(struct pktq *pq, int prec)
 	return p;
 }
 
+#ifdef BRCM_FULLMAC
+void pktq_pflush(osl_t *osh, struct pktq *pq, int prec, bool dir)
+{
+	struct pktq_prec *q;
+	void *p;
+
+	q = &pq->q[prec];
+	p = q->head;
+	while (p) {
+		q->head = PKTLINK(p);
+		PKTSETLINK(p, NULL);
+		PKTFREE(osh, p, dir);
+		q->len--;
+		pq->len--;
+		p = q->head;
+	}
+	ASSERT(q->len == 0);
+	q->tail = NULL;
+}
+
+void pktq_flush(osl_t *osh, struct pktq *pq, bool dir)
+{
+	int prec;
+	for (prec = 0; prec < pq->num_prec; prec++)
+		pktq_pflush(osh, pq, prec, dir);
+	ASSERT(pq->len == 0);
+}
+#else /* !BRCM_FULLMAC */
 void
-pktq_pflush(osl_t * osh, struct pktq *pq, int prec, bool dir, ifpkt_cb_t fn,
+pktq_pflush(osl_t *osh, struct pktq *pq, int prec, bool dir, ifpkt_cb_t fn,
 	    int arg)
 {
 	struct pktq_prec *q;
@@ -266,36 +244,15 @@ pktq_pflush(osl_t * osh, struct pktq *pq, int prec, bool dir, ifpkt_cb_t fn,
 	}
 }
 
-bool BCMFASTPATH pktq_pdel(struct pktq *pq, void *pktbuf, int prec)
+void pktq_flush(osl_t *osh, struct pktq *pq, bool dir, ifpkt_cb_t fn, int arg)
 {
-	struct pktq_prec *q;
-	void *p;
-
-	ASSERT(prec >= 0 && prec < pq->num_prec);
-
-	if (!pktbuf)
-		return FALSE;
-
-	q = &pq->q[prec];
-
-	if (q->head == pktbuf) {
-		if ((q->head = PKTLINK(pktbuf)) == NULL)
-			q->tail = NULL;
-	} else {
-		for (p = q->head; p && PKTLINK(p) != pktbuf; p = PKTLINK(p)) ;
-		if (p == NULL)
-			return FALSE;
-
-		PKTSETLINK(p, PKTLINK(pktbuf));
-		if (q->tail == pktbuf)
-			q->tail = p;
-	}
-
-	q->len--;
-	pq->len--;
-	PKTSETLINK(pktbuf, NULL);
-	return TRUE;
+	int prec;
+	for (prec = 0; prec < pq->num_prec; prec++)
+		pktq_pflush(osh, pq, prec, dir, fn, arg);
+	if (fn == NULL)
+		ASSERT(pq->len == 0);
 }
+#endif /* BRCM_FULLMAC */
 
 void pktq_init(struct pktq *pq, int num_prec, int max_len)
 {
@@ -305,103 +262,16 @@ void pktq_init(struct pktq *pq, int num_prec, int max_len)
 
 	/* pq is variable size; only zero out what's requested */
 	bzero(pq,
-	      OFFSETOF(struct pktq, q) + (sizeof(struct pktq_prec) * num_prec));
+	      offsetof(struct pktq, q) + (sizeof(struct pktq_prec) * num_prec));
 
-	pq->num_prec = (uint16) num_prec;
+	pq->num_prec = (u16) num_prec;
 
-	pq->max = (uint16) max_len;
+	pq->max = (u16) max_len;
 
 	for (prec = 0; prec < num_prec; prec++)
 		pq->q[prec].max = pq->max;
 }
 
-void *BCMFASTPATH pktq_deq(struct pktq *pq, int *prec_out)
-{
-	struct pktq_prec *q;
-	void *p;
-	int prec;
-
-	if (pq->len == 0)
-		return NULL;
-
-	while ((prec = pq->hi_prec) > 0 && pq->q[prec].head == NULL)
-		pq->hi_prec--;
-
-	q = &pq->q[prec];
-
-	if ((p = q->head) == NULL)
-		return NULL;
-
-	if ((q->head = PKTLINK(p)) == NULL)
-		q->tail = NULL;
-
-	q->len--;
-
-	pq->len--;
-
-	if (prec_out)
-		*prec_out = prec;
-
-	PKTSETLINK(p, NULL);
-
-	return p;
-}
-
-void *BCMFASTPATH pktq_deq_tail(struct pktq *pq, int *prec_out)
-{
-	struct pktq_prec *q;
-	void *p, *prev;
-	int prec;
-
-	if (pq->len == 0)
-		return NULL;
-
-	for (prec = 0; prec < pq->hi_prec; prec++)
-		if (pq->q[prec].head)
-			break;
-
-	q = &pq->q[prec];
-
-	if ((p = q->head) == NULL)
-		return NULL;
-
-	for (prev = NULL; p != q->tail; p = PKTLINK(p))
-		prev = p;
-
-	if (prev)
-		PKTSETLINK(prev, NULL);
-	else
-		q->head = NULL;
-
-	q->tail = prev;
-	q->len--;
-
-	pq->len--;
-
-	if (prec_out)
-		*prec_out = prec;
-
-	PKTSETLINK(p, NULL);
-
-	return p;
-}
-
-void *pktq_peek(struct pktq *pq, int *prec_out)
-{
-	int prec;
-
-	if (pq->len == 0)
-		return NULL;
-
-	while ((prec = pq->hi_prec) > 0 && pq->q[prec].head == NULL)
-		pq->hi_prec--;
-
-	if (prec_out)
-		*prec_out = prec;
-
-	return (pq->q[prec].head);
-}
-
 void *pktq_peek_tail(struct pktq *pq, int *prec_out)
 {
 	int prec;
@@ -416,16 +286,7 @@ void *pktq_peek_tail(struct pktq *pq, int *prec_out)
 	if (prec_out)
 		*prec_out = prec;
 
-	return (pq->q[prec].tail);
-}
-
-void pktq_flush(osl_t * osh, struct pktq *pq, bool dir, ifpkt_cb_t fn, int arg)
-{
-	int prec;
-	for (prec = 0; prec < pq->num_prec; prec++)
-		pktq_pflush(osh, pq, prec, dir, fn, arg);
-	if (fn == NULL)
-		ASSERT(pq->len == 0);
+	return pq->q[prec].tail;
 }
 
 /* Return sum of lengths of a specific set of precedences */
@@ -441,7 +302,6 @@ int pktq_mlen(struct pktq *pq, uint prec_bmp)
 
 	return len;
 }
-
 /* Priority dequeue from a specific set of precedences */
 void *BCMFASTPATH pktq_mdeq(struct pktq *pq, uint prec_bmp, int *prec_out)
 {
@@ -461,10 +321,12 @@ void *BCMFASTPATH pktq_mdeq(struct pktq *pq, uint prec_bmp, int *prec_out)
 
 	q = &pq->q[prec];
 
-	if ((p = q->head) == NULL)
+	p = q->head;
+	if (p == NULL)
 		return NULL;
 
-	if ((q->head = PKTLINK(p)) == NULL)
+	q->head = PKTLINK(p);
+	if (q->head == NULL)
 		q->tail = NULL;
 
 	q->len--;
@@ -479,333 +341,18 @@ void *BCMFASTPATH pktq_mdeq(struct pktq *pq, uint prec_bmp, int *prec_out)
 	return p;
 }
 
-const unsigned char bcm_ctype[] = {
-
-	_BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C,	/* 0-7 */
-	_BCM_C, _BCM_C | _BCM_S, _BCM_C | _BCM_S, _BCM_C | _BCM_S,
-	    _BCM_C | _BCM_S, _BCM_C | _BCM_S, _BCM_C,
-	_BCM_C,			/* 8-15 */
-	_BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C,	/* 16-23 */
-	_BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C,	/* 24-31 */
-	_BCM_S | _BCM_SP, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 32-39 */
-	_BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 40-47 */
-	_BCM_D, _BCM_D, _BCM_D, _BCM_D, _BCM_D, _BCM_D, _BCM_D, _BCM_D,	/* 48-55 */
-	_BCM_D, _BCM_D, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 56-63 */
-	_BCM_P, _BCM_U | _BCM_X, _BCM_U | _BCM_X, _BCM_U | _BCM_X,
-	    _BCM_U | _BCM_X, _BCM_U | _BCM_X,
-	_BCM_U | _BCM_X, _BCM_U,	/* 64-71 */
-	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U,	/* 72-79 */
-	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U,	/* 80-87 */
-	_BCM_U, _BCM_U, _BCM_U, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 88-95 */
-	_BCM_P, _BCM_L | _BCM_X, _BCM_L | _BCM_X, _BCM_L | _BCM_X,
-	    _BCM_L | _BCM_X, _BCM_L | _BCM_X,
-	_BCM_L | _BCM_X, _BCM_L,	/* 96-103 */
-	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L,	/* 104-111 */
-	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L,	/* 112-119 */
-	_BCM_L, _BCM_L, _BCM_L, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_C,	/* 120-127 */
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 128-143 */
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 144-159 */
-	_BCM_S | _BCM_SP, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,
-	    _BCM_P, _BCM_P, _BCM_P,
-	_BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 160-175 */
-	_BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,
-	    _BCM_P, _BCM_P,
-	_BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 176-191 */
-	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U,
-	    _BCM_U, _BCM_U,
-	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U,	/* 192-207 */
-	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_P, _BCM_U,
-	    _BCM_U, _BCM_U,
-	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_L,	/* 208-223 */
-	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L,
-	    _BCM_L, _BCM_L,
-	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L,	/* 224-239 */
-	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_P, _BCM_L,
-	    _BCM_L, _BCM_L,
-	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L	/* 240-255 */
-};
-
-ulong BCMROMFN(bcm_strtoul) (char *cp, char **endp, uint base) {
-	ulong result, last_result = 0, value;
-	bool minus;
-
-	minus = FALSE;
-
-	while (bcm_isspace(*cp))
-		cp++;
-
-	if (cp[0] == '+')
-		cp++;
-	else if (cp[0] == '-') {
-		minus = TRUE;
-		cp++;
-	}
-
-	if (base == 0) {
-		if (cp[0] == '0') {
-			if ((cp[1] == 'x') || (cp[1] == 'X')) {
-				base = 16;
-				cp = &cp[2];
-			} else {
-				base = 8;
-				cp = &cp[1];
-			}
-		} else
-			base = 10;
-	} else if (base == 16 && (cp[0] == '0')
-		   && ((cp[1] == 'x') || (cp[1] == 'X'))) {
-		cp = &cp[2];
-	}
-
-	result = 0;
-
-	while (bcm_isxdigit(*cp) &&
-	       (value =
-		bcm_isdigit(*cp) ? *cp - '0' : bcm_toupper(*cp) - 'A' + 10) <
-	       base) {
-		result = result * base + value;
-		/* Detected overflow */
-		if (result < last_result && !minus)
-			return (ulong) - 1;
-		last_result = result;
-		cp++;
-	}
-
-	if (minus)
-		result = (ulong) (-(long)result);
-
-	if (endp)
-		*endp = (char *)cp;
-
-	return (result);
-}
-
-int BCMROMFN(bcm_atoi) (char *s) {
-	return (int)bcm_strtoul(s, NULL, 10);
-}
-
-/* return pointer to location of substring 'needle' in 'haystack' */
-char *BCMROMFN(bcmstrstr) (char *haystack, char *needle) {
-	int len, nlen;
-	int i;
-
-	if ((haystack == NULL) || (needle == NULL))
-		return (haystack);
-
-	nlen = strlen(needle);
-	len = strlen(haystack) - nlen + 1;
-
-	for (i = 0; i < len; i++)
-		if (memcmp(needle, &haystack[i], nlen) == 0)
-			return (&haystack[i]);
-	return (NULL);
-}
-
-char *BCMROMFN(bcmstrcat) (char *dest, const char *src) {
-	char *p;
-
-	p = dest + strlen(dest);
-
-	while ((*p++ = *src++) != '\0') ;
-
-	return (dest);
-}
-
-char *BCMROMFN(bcmstrncat) (char *dest, const char *src, uint size) {
-	char *endp;
-	char *p;
-
-	p = dest + strlen(dest);
-	endp = p + size;
-
-	while (p != endp && (*p++ = *src++) != '\0') ;
-
-	return (dest);
-}
-
-/****************************************************************************
-* Function:   bcmstrtok
-*
-* Purpose:
-*  Tokenizes a string. This function is conceptually similiar to ANSI C strtok(),
-*  but allows strToken() to be used by different strings or callers at the same
-*  time. Each call modifies '*string' by substituting a NULL character for the
-*  first delimiter that is encountered, and updates 'string' to point to the char
-*  after the delimiter. Leading delimiters are skipped.
-*
-* Parameters:
-*  string      (mod) Ptr to string ptr, updated by token.
-*  delimiters  (in)  Set of delimiter characters.
-*  tokdelim    (out) Character that delimits the returned token. (May
-*                    be set to NULL if token delimiter is not required).
-*
-* Returns:  Pointer to the next token found. NULL when no more tokens are found.
-*****************************************************************************
-*/
-char *bcmstrtok(char **string, const char *delimiters, char *tokdelim)
-{
-	unsigned char *str;
-	unsigned long map[8];
-	int count;
-	char *nextoken;
-
-	if (tokdelim != NULL) {
-		/* Prime the token delimiter */
-		*tokdelim = '\0';
-	}
-
-	/* Clear control map */
-	for (count = 0; count < 8; count++) {
-		map[count] = 0;
-	}
-
-	/* Set bits in delimiter table */
-	do {
-		map[*delimiters >> 5] |= (1 << (*delimiters & 31));
-	}
-	while (*delimiters++);
-
-	str = (unsigned char *)*string;
-
-	/* Find beginning of token (skip over leading delimiters). Note that
-	 * there is no token iff this loop sets str to point to the terminal
-	 * null (*str == '\0')
-	 */
-	while (((map[*str >> 5] & (1 << (*str & 31))) && *str) || (*str == ' ')) {
-		str++;
-	}
-
-	nextoken = (char *)str;
-
-	/* Find the end of the token. If it is not the end of the string,
-	 * put a null there.
-	 */
-	for (; *str; str++) {
-		if (map[*str >> 5] & (1 << (*str & 31))) {
-			if (tokdelim != NULL) {
-				*tokdelim = *str;
-			}
-
-			*str++ = '\0';
-			break;
-		}
-	}
-
-	*string = (char *)str;
-
-	/* Determine if a token has been found. */
-	if (nextoken == (char *)str) {
-		return NULL;
-	} else {
-		return nextoken;
-	}
-}
-
-#define xToLower(C) \
-	((C >= 'A' && C <= 'Z') ? (char)((int)C - (int)'A' + (int)'a') : C)
-
-/****************************************************************************
-* Function:   bcmstricmp
-*
-* Purpose:    Compare to strings case insensitively.
-*
-* Parameters: s1 (in) First string to compare.
-*             s2 (in) Second string to compare.
-*
-* Returns:    Return 0 if the two strings are equal, -1 if t1 < t2 and 1 if
-*             t1 > t2, when ignoring case sensitivity.
-*****************************************************************************
-*/
-int bcmstricmp(const char *s1, const char *s2)
-{
-	char dc, sc;
-
-	while (*s2 && *s1) {
-		dc = xToLower(*s1);
-		sc = xToLower(*s2);
-		if (dc < sc)
-			return -1;
-		if (dc > sc)
-			return 1;
-		s1++;
-		s2++;
-	}
-
-	if (*s1 && !*s2)
-		return 1;
-	if (!*s1 && *s2)
-		return -1;
-	return 0;
-}
-
-/****************************************************************************
-* Function:   bcmstrnicmp
-*
-* Purpose:    Compare to strings case insensitively, upto a max of 'cnt'
-*             characters.
-*
-* Parameters: s1  (in) First string to compare.
-*             s2  (in) Second string to compare.
-*             cnt (in) Max characters to compare.
-*
-* Returns:    Return 0 if the two strings are equal, -1 if t1 < t2 and 1 if
-*             t1 > t2, when ignoring case sensitivity.
-*****************************************************************************
-*/
-int bcmstrnicmp(const char *s1, const char *s2, int cnt)
-{
-	char dc, sc;
-
-	while (*s2 && *s1 && cnt) {
-		dc = xToLower(*s1);
-		sc = xToLower(*s2);
-		if (dc < sc)
-			return -1;
-		if (dc > sc)
-			return 1;
-		s1++;
-		s2++;
-		cnt--;
-	}
-
-	if (!cnt)
-		return 0;
-	if (*s1 && !*s2)
-		return 1;
-	if (!*s1 && *s2)
-		return -1;
-	return 0;
-}
-
 /* parse a xx:xx:xx:xx:xx:xx format ethernet address */
-int BCMROMFN(bcm_ether_atoe) (char *p, struct ether_addr * ea) {
+int bcm_ether_atoe(char *p, struct ether_addr *ea)
+{
 	int i = 0;
 
 	for (;;) {
-		ea->octet[i++] = (char)bcm_strtoul(p, &p, 16);
+		ea->octet[i++] = (char)simple_strtoul(p, &p, 16);
 		if (!*p++ || i == 6)
 			break;
 	}
 
-	return (i == 6);
-}
-
-char *bcm_ether_ntoa(const struct ether_addr *ea, char *buf)
-{
-	static const char template[] = "%02x:%02x:%02x:%02x:%02x:%02x";
-	snprintf(buf, 18, template,
-		 ea->octet[0] & 0xff, ea->octet[1] & 0xff, ea->octet[2] & 0xff,
-		 ea->octet[3] & 0xff, ea->octet[4] & 0xff, ea->octet[5] & 0xff);
-	return (buf);
-}
-
-void bcm_mdelay(uint ms)
-{
-	uint i;
-
-	for (i = 0; i < ms; i++) {
-		OSL_DELAY(1000);
-	}
+	return i == 6;
 }
 
 /*
@@ -827,13 +374,17 @@ char *getvar(char *vars, const char *name)
 	/* first look in vars[] */
 	for (s = vars; s && *s;) {
 		if ((bcmp(s, name, len) == 0) && (s[len] == '='))
-			return (&s[len + 1]);
+			return &s[len + 1];
 
-		while (*s++) ;
+		while (*s++)
+			;
 	}
-
+#ifdef BRCM_FULLMAC
+	return NULL;
+#else
 	/* then query nvram */
-	return (nvram_get(name));
+	return nvram_get(name);
+#endif
 }
 
 /*
@@ -844,92 +395,16 @@ int getintvar(char *vars, const char *name)
 {
 	char *val;
 
-	if ((val = getvar(vars, name)) == NULL)
-		return (0);
-
-	return (bcm_strtoul(val, NULL, 0));
-}
-
-int getintvararray(char *vars, const char *name, uint8 index)
-{
-	char *buf, *endp;
-	int i = 0;
-	int val = 0;
-
-	if ((buf = getvar(vars, name)) == NULL) {
-		return (0);
-	}
-
-	/* table values are always separated by "," or " " */
-	while (*buf != '\0') {
-		val = bcm_strtoul(buf, &endp, 0);
-		if (i == index) {
-			return val;
-		}
-		buf = endp;
-		/* delimiter is ',' */
-		if (*buf == ',')
-			buf++;
-		i++;
-	}
-	return 0;
-}
-
-/* Search for token in comma separated token-string */
-static int findmatch(char *string, char *name)
-{
-	uint len;
-	char *c;
-
-	len = strlen(name);
-	while ((c = strchr(string, ',')) != NULL) {
-		if (len == (uint) (c - string) && !strncmp(string, name, len))
-			return 1;
-		string = c + 1;
-	}
-
-	return (!strcmp(string, name));
-}
-
-/* Return gpio pin number assigned to the named pin
- *
- * Variable should be in format:
- *
- *	gpio<N>=pin_name,pin_name
- *
- * This format allows multiple features to share the gpio with mutual
- * understanding.
- *
- * 'def_pin' is returned if a specific gpio is not defined for the requested functionality
- * and if def_pin is not used by others.
- */
-uint getgpiopin(char *vars, char *pin_name, uint def_pin)
-{
-	char name[] = "gpioXXXX";
-	char *val;
-	uint pin;
-
-	/* Go thru all possibilities till a match in pin name */
-	for (pin = 0; pin < GPIO_NUMPINS; pin++) {
-		snprintf(name, sizeof(name), "gpio%d", pin);
-		val = getvar(vars, name);
-		if (val && findmatch(val, pin_name))
-			return pin;
-	}
+	val = getvar(vars, name);
+	if (val == NULL)
+		return 0;
 
-	if (def_pin != GPIO_PIN_NOTDEFINED) {
-		/* make sure the default pin is not used by someone else */
-		snprintf(name, sizeof(name), "gpio%d", def_pin);
-		if (getvar(vars, name)) {
-			def_pin = GPIO_PIN_NOTDEFINED;
-		}
-	}
-	return def_pin;
+	return simple_strtoul(val, NULL, 0);
 }
 
 #if defined(BCMDBG)
 /* pretty hex print a pkt buffer chain */
-void prpkt(const char *msg, osl_t * osh, void *p0)
+void prpkt(const char *msg, osl_t *osh, void *p0)
 {
 	void *p;
 
@@ -941,18 +416,20 @@ void prpkt(const char *msg, osl_t * osh, void *p0)
 }
 #endif				/* defined(BCMDBG) */
 
-static char bcm_undeferrstr[32];
+static char bcm_undeferrstr[BCME_STRLEN];
+
 static const char *bcmerrorstrtable[] = BCMERRSTRINGTABLE;
 
 /* Convert the error codes into related error strings  */
 const char *bcmerrorstr(int bcmerror)
 {
-	/* check if someone added a bcmerror code but forgot to add errorstring */
-	ASSERT(ABS(BCME_LAST) == (ARRAYSIZE(bcmerrorstrtable) - 1));
+	/* check if someone added a bcmerror code but
+		 forgot to add errorstring */
+	ASSERT(ABS(BCME_LAST) == (ARRAY_SIZE(bcmerrorstrtable) - 1));
 
 	if (bcmerror > 0 || bcmerror < BCME_LAST) {
-		snprintf(bcm_undeferrstr, sizeof(bcm_undeferrstr),
-			 "Undefined error %d", bcmerror);
+		snprintf(bcm_undeferrstr, BCME_STRLEN, "Undefined error %d",
+			 bcmerror);
 		return bcm_undeferrstr;
 	}
 
@@ -961,88 +438,8 @@ const char *bcmerrorstr(int bcmerror)
 	return bcmerrorstrtable[-bcmerror];
 }
 
-#ifdef WLC_LOW
-static void BCMINITFN(bcm_nvram_refresh) (char *flash) {
-	int i;
-	int ret = 0;
-
-	ASSERT(flash != NULL);
-
-	/* default "empty" vars cache */
-	bzero(flash, 2);
-
-	if ((ret = nvram_getall(flash, NVRAM_SPACE)))
-		return;
-
-	/* determine nvram length */
-	for (i = 0; i < NVRAM_SPACE; i++) {
-		if (flash[i] == '\0' && flash[i + 1] == '\0')
-			break;
-	}
-
-	if (i > 1)
-		vars_len = i + 2;
-	else
-		vars_len = 0;
-}
-
-char *bcm_nvram_vars(uint * length)
-{
-#ifndef BCMNVRAMR
-	/* cache may be stale if nvram is read/write */
-	if (nvram_vars) {
-		ASSERT(!bcmreclaimed);
-		bcm_nvram_refresh(nvram_vars);
-	}
-#endif
-	if (length)
-		*length = vars_len;
-	return nvram_vars;
-}
-
-/* copy nvram vars into locally-allocated multi-string array */
-int BCMINITFN(bcm_nvram_cache) (void *sih) {
-	int ret = 0;
-	void *osh;
-	char *flash = NULL;
-
-	if (vars_len >= 0) {
-#ifndef BCMNVRAMR
-		bcm_nvram_refresh(nvram_vars);
-#endif
-		return 0;
-	}
-
-	osh = si_osh((si_t *) sih);
-
-	/* allocate memory and read in flash */
-	if (!(flash = MALLOC(osh, NVRAM_SPACE))) {
-		ret = BCME_NOMEM;
-		goto exit;
-	}
-
-	bcm_nvram_refresh(flash);
-#ifdef BCMNVRAMR
-	if (vars_len > 3) {
-		/* copy into a properly-sized buffer */
-		if (!(nvram_vars = MALLOC(osh, vars_len))) {
-			ret = BCME_NOMEM;
-		} else
-			bcopy(flash, nvram_vars, vars_len);
-	}
-	MFREE(osh, flash, NVRAM_SPACE);
-#else
-	/* cache must be full size of nvram if read/write */
-	nvram_vars = flash;
-#endif				/* BCMNVRAMR */
-
- exit:
-	return ret;
-}
-#endif				/* WLC_LOW */
-
 /* iovar table lookup */
-const bcm_iovar_t *bcm_iovar_lookup(const bcm_iovar_t * table, const char *name)
+const bcm_iovar_t *bcm_iovar_lookup(const bcm_iovar_t *table, const char *name)
 {
 	const bcm_iovar_t *vi;
 	const char *lookup_name;
@@ -1065,7 +462,7 @@ const bcm_iovar_t *bcm_iovar_lookup(const bcm_iovar_t * table, const char *name)
 	return NULL;		/* var name not found */
 }
 
-int bcm_iovar_lencheck(const bcm_iovar_t * vi, void *arg, int len, bool set)
+int bcm_iovar_lencheck(const bcm_iovar_t *vi, void *arg, int len, bool set)
 {
 	int bcmerror = 0;
 
@@ -1078,7 +475,7 @@ int bcm_iovar_lencheck(const bcm_iovar_t * vi, void *arg, int len, bool set)
 	case IOVT_UINT8:
 	case IOVT_UINT16:
 	case IOVT_UINT32:
-		/* all integers are int32 sized args at the ioctl interface */
+		/* all integers are s32 sized args at the ioctl interface */
 		if (len < (int)sizeof(int)) {
 			bcmerror = BCME_BUFTOOSHORT;
 		}
@@ -1132,7 +529,7 @@ int bcm_iovar_lencheck(const bcm_iovar_t * vi, void *arg, int len, bool set)
  * ****************************************************************************
  */
 
-static const uint8 crc8_table[256] = {
+static const u8 crc8_table[256] = {
 	0x00, 0xF7, 0xB9, 0x4E, 0x25, 0xD2, 0x9C, 0x6B,
 	0x4A, 0xBD, 0xF3, 0x04, 0x6F, 0x98, 0xD6, 0x21,
 	0x94, 0x63, 0x2D, 0xDA, 0xB1, 0x46, 0x08, 0xFF,
@@ -1168,14 +565,14 @@ static const uint8 crc8_table[256] = {
 };
 
 #define CRC_INNER_LOOP(n, c, x) \
-	(c) = ((c) >> 8) ^ crc##n##_table[((c) ^ (x)) & 0xff]
+	((c) = ((c) >> 8) ^ crc##n##_table[((c) ^ (x)) & 0xff])
 
-uint8 BCMROMFN(hndcrc8) (uint8 * pdata,	/* pointer to array of data to process */
+u8 hndcrc8(u8 *pdata,	/* pointer to array of data to process */
 			 uint nbytes,	/* number of input data bytes to process */
-			 uint8 crc	/* either CRC8_INIT_VALUE or previous return value */
+			 u8 crc	/* either CRC8_INIT_VALUE or previous return value */
     ) {
 	/* hard code the crc loop instead of using CRC_INNER_LOOP macro
-	 * to avoid the undefined and unnecessary (uint8 >> 8) operation.
+	 * to avoid the undefined and unnecessary (u8 >> 8) operation.
 	 */
 	while (nbytes-- > 0)
 		crc = crc8_table[(crc ^ *pdata++) & 0xff];
@@ -1205,7 +602,7 @@ uint8 BCMROMFN(hndcrc8) (uint8 * pdata,	/* pointer to array of data to process *
  * ****************************************************************************
  */
 
-static const uint16 crc16_table[256] = {
+static const u16 crc16_table[256] = {
 	0x0000, 0x1189, 0x2312, 0x329B, 0x4624, 0x57AD, 0x6536, 0x74BF,
 	0x8C48, 0x9DC1, 0xAF5A, 0xBED3, 0xCA6C, 0xDBE5, 0xE97E, 0xF8F7,
 	0x1081, 0x0108, 0x3393, 0x221A, 0x56A5, 0x472C, 0x75B7, 0x643E,
@@ -1240,48 +637,129 @@ static const uint16 crc16_table[256] = {
 	0x7BC7, 0x6A4E, 0x58D5, 0x495C, 0x3DE3, 0x2C6A, 0x1EF1, 0x0F78
 };
 
-uint16 BCMROMFN(hndcrc16) (uint8 * pdata,	/* pointer to array of data to process */
-			   uint nbytes,	/* number of input data bytes to process */
-			   uint16 crc	/* either CRC16_INIT_VALUE or previous return value */
+u16 hndcrc16(u8 *pdata,	/* pointer to array of data to process */
+	uint nbytes,	/* number of input data bytes to process */
+	u16 crc	/* either CRC16_INIT_VALUE or previous return value */
     ) {
 	while (nbytes-- > 0)
 		CRC_INNER_LOOP(16, crc, *pdata++);
 	return crc;
 }
 
-/*
- * Advance from the current 1-byte tag/1-byte length/variable-length value
- * triple, to the next, returning a pointer to the next.
- * If the current or next TLV is invalid (does not fit in given buffer length),
- * NULL is returned.
- * *buflen is not modified if the TLV elt parameter is invalid, or is decremented
- * by the TLV parameter's length if it is valid.
- */
-bcm_tlv_t *BCMROMFN(bcm_next_tlv) (bcm_tlv_t * elt, int *buflen) {
-	int len;
-
-	/* validate current elt */
-	if (!bcm_valid_tlv(elt, *buflen))
-		return NULL;
+static const u32 crc32_table[256] = {
+	0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
+	0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
+	0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
+	0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
+	0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
+	0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
+	0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
+	0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
+	0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
+	0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
+	0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
+	0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
+	0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
+	0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
+	0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
+	0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
+	0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
+	0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
+	0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
+	0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
+	0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
+	0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
+	0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
+	0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
+	0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
+	0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
+	0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
+	0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
+	0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
+	0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
+	0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
+	0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
+	0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
+	0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
+	0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
+	0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
+	0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
+	0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
+	0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
+	0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
+	0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
+	0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
+	0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
+	0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
+	0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
+	0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
+	0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
+	0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
+	0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
+	0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
+	0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
+	0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
+	0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
+	0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
+	0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
+	0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
+	0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
+	0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
+	0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
+	0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
+	0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
+	0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
+	0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
+	0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
+};
 
-	/* advance to next elt */
-	len = elt->len;
-	elt = (bcm_tlv_t *) (elt->data + len);
-	*buflen -= (2 + len);
+u32 hndcrc32(u8 *pdata,	/* pointer to array of data to process */
+		uint nbytes,	/* number of input data bytes to process */
+		u32 crc	/* either CRC32_INIT_VALUE or previous
+					 return value */
+)
+{
+	u8 *pend;
+#ifdef __mips__
+	u8 tmp[4];
+	unsigned long *tptr = (unsigned long *) tmp;
+
+	/* in case the beginning of the buffer isn't aligned */
+	pend = (u8 *) ((uint) (pdata + 3) & 0xfffffffc);
+	nbytes -= (pend - pdata);
+	while (pdata < pend)
+		CRC_INNER_LOOP(32, crc, *pdata++);
+
+	/* handle bulk of data as 32-bit words */
+	pend = pdata + (nbytes & 0xfffffffc);
+	while (pdata < pend) {
+		*tptr = *(unsigned long *) pdata;
+		pdata += sizeof(unsigned long *);
+		CRC_INNER_LOOP(32, crc, tmp[0]);
+		CRC_INNER_LOOP(32, crc, tmp[1]);
+		CRC_INNER_LOOP(32, crc, tmp[2]);
+		CRC_INNER_LOOP(32, crc, tmp[3]);
+	}
 
-	/* validate next elt */
-	if (!bcm_valid_tlv(elt, *buflen))
-		return NULL;
+	/* 1-3 bytes at end of buffer */
+	pend = pdata + (nbytes & 0x03);
+	while (pdata < pend)
+		CRC_INNER_LOOP(32, crc, *pdata++);
+#else
+	pend = pdata + nbytes;
+	while (pdata < pend)
+		CRC_INNER_LOOP(32, crc, *pdata++);
+#endif				/* __mips__ */
 
-	return elt;
+	return crc;
 }
-
 /*
  * Traverse a string of 1-byte tag/1-byte length/variable-length value
  * triples, returning a pointer to the substring whose first element
  * matches tag
  */
-bcm_tlv_t *BCMROMFN(bcm_parse_tlvs) (void *buf, int buflen, uint key) {
+bcm_tlv_t *bcm_parse_tlvs(void *buf, int buflen, uint key)
+{
 	bcm_tlv_t *elt;
 	int totlen;
 
@@ -1294,56 +772,25 @@ bcm_tlv_t *BCMROMFN(bcm_parse_tlvs) (void *buf, int buflen, uint key) {
 
 		/* validate remaining totlen */
 		if ((elt->id == key) && (totlen >= (len + 2)))
-			return (elt);
+			return elt;
 
-		elt = (bcm_tlv_t *) ((uint8 *) elt + (len + 2));
+		elt = (bcm_tlv_t *) ((u8 *) elt + (len + 2));
 		totlen -= (len + 2);
 	}
 
 	return NULL;
 }
 
-/*
- * Traverse a string of 1-byte tag/1-byte length/variable-length value
- * triples, returning a pointer to the substring whose first element
- * matches tag.  Stop parsing when we see an element whose ID is greater
- * than the target key.
- */
-bcm_tlv_t *BCMROMFN(bcm_parse_ordered_tlvs) (void *buf, int buflen, uint key) {
-	bcm_tlv_t *elt;
-	int totlen;
-
-	elt = (bcm_tlv_t *) buf;
-	totlen = buflen;
-
-	/* find tagged parameter */
-	while (totlen >= 2) {
-		uint id = elt->id;
-		int len = elt->len;
-
-		/* Punt if we start seeing IDs > than target key */
-		if (id > key)
-			return (NULL);
-
-		/* validate remaining totlen */
-		if ((id == key) && (totlen >= (len + 2)))
-			return (elt);
-
-		elt = (bcm_tlv_t *) ((uint8 *) elt + (len + 2));
-		totlen -= (len + 2);
-	}
-	return NULL;
-}
 
 #if defined(BCMDBG)
 int
-bcm_format_flags(const bcm_bit_desc_t * bd, uint32 flags, char *buf, int len)
+bcm_format_flags(const bcm_bit_desc_t *bd, u32 flags, char *buf, int len)
 {
 	int i;
 	char *p = buf;
 	char hexstr[16];
 	int slen = 0, nlen = 0;
-	uint32 bit;
+	u32 bit;
 	const char *name;
 
 	if (len < 2 || !buf)
@@ -1394,7 +841,7 @@ int bcm_format_hex(char *str, const void *bytes, int len)
 {
 	int i;
 	char *p = str;
-	const uint8 *src = (const uint8 *)bytes;
+	const u8 *src = (const u8 *)bytes;
 
 	for (i = 0; i < len; i++) {
 		p += snprintf(p, 3, "%02X", *src);
@@ -1405,7 +852,7 @@ int bcm_format_hex(char *str, const void *bytes, int len)
 #endif				/* defined(BCMDBG) */
 
 /* pretty hex print a contiguous buffer */
-void prhex(const char *msg, uchar * buf, uint nbytes)
+void prhex(const char *msg, unsigned char *buf, uint nbytes)
 {
 	char line[128], *p;
 	int len = sizeof(line);
@@ -1440,36 +887,6 @@ void prhex(const char *msg, uchar * buf, uint nbytes)
 		printf("%s\n", line);
 }
 
-static const char *crypto_algo_names[] = {
-	"NONE",
-	"WEP1",
-	"TKIP",
-	"WEP128",
-	"AES_CCM",
-	"NALG" "UNDEF",
-	"UNDEF",
-	"UNDEF",
-	"UNDEF"
-};
-
-const char *bcm_crypto_algo_name(uint algo)
-{
-	return (algo <
-		ARRAYSIZE(crypto_algo_names)) ? crypto_algo_names[algo] : "ERR";
-}
-
-#ifdef BCMDBG
-void deadbeef(void *p, uint len)
-{
-	static uint8 meat[] = { 0xde, 0xad, 0xbe, 0xef };
-
-	while (len-- > 0) {
-		*(uint8 *) p = meat[((uintptr) p) & 3];
-		p = (uint8 *) p + 1;
-	}
-}
-#endif				/* BCMDBG */
-
 char *bcm_chipname(uint chipid, char *buf, uint len)
 {
 	const char *fmt;
@@ -1479,72 +896,6 @@ char *bcm_chipname(uint chipid, char *buf, uint len)
 	return buf;
 }
 
-/* Produce a human-readable string for boardrev */
-char *bcm_brev_str(uint32 brev, char *buf)
-{
-	if (brev < 0x100)
-		snprintf(buf, 8, "%d.%d", (brev & 0xf0) >> 4, brev & 0xf);
-	else
-		snprintf(buf, 8, "%c%03x",
-			 ((brev & 0xf000) == 0x1000) ? 'P' : 'A', brev & 0xfff);
-
-	return (buf);
-}
-
-#define BUFSIZE_TODUMP_ATONCE 512	/* Buffer size */
-
-/* dump large strings to console */
-void printbig(char *buf)
-{
-	uint len, max_len;
-	char c;
-
-	len = strlen(buf);
-
-	max_len = BUFSIZE_TODUMP_ATONCE;
-
-	while (len > max_len) {
-		c = buf[max_len];
-		buf[max_len] = '\0';
-		printf("%s", buf);
-		buf[max_len] = c;
-
-		buf += max_len;
-		len -= max_len;
-	}
-	/* print the remaining string */
-	printf("%s\n", buf);
-	return;
-}
-
-/* routine to dump fields in a fileddesc structure */
-uint
-bcmdumpfields(bcmutl_rdreg_rtn read_rtn, void *arg0, uint arg1,
-	      struct fielddesc * fielddesc_array, char *buf, uint32 bufsize)
-{
-	uint filled_len;
-	int len;
-	struct fielddesc *cur_ptr;
-
-	filled_len = 0;
-	cur_ptr = fielddesc_array;
-
-	while (bufsize > 1) {
-		if (cur_ptr->nameandfmt == NULL)
-			break;
-		len = snprintf(buf, bufsize, cur_ptr->nameandfmt,
-			       read_rtn(arg0, arg1, cur_ptr->offset));
-		/* check for snprintf overflow or error */
-		if (len < 0 || (uint32) len >= bufsize)
-			len = bufsize - 1;
-		buf += len;
-		bufsize -= len;
-		filled_len += len;
-		cur_ptr++;
-	}
-	return filled_len;
-}
-
 uint bcm_mkiovar(char *name, char *data, uint datalen, char *buf, uint buflen)
 {
 	uint len;
@@ -1566,7 +917,7 @@ uint bcm_mkiovar(char *name, char *data, uint datalen, char *buf, uint buflen)
 /* Quarter dBm units to mW
  * Table starts at QDBM_OFFSET, so the first entry is mW for qdBm=153
  * Table is offset so the last entry is largest mW value that fits in
- * a uint16.
+ * a u16.
  */
 
 #define QDBM_OFFSET 153		/* Offset for first entry */
@@ -1579,11 +930,12 @@ uint bcm_mkiovar(char *name, char *data, uint datalen, char *buf, uint buflen)
 
 /* Largest mW value that will round down to the last table entry,
  * QDBM_OFFSET + QDBM_TABLE_LEN-1.
- * Value is ( mW(QDBM_OFFSET + QDBM_TABLE_LEN - 1) + mW(QDBM_OFFSET + QDBM_TABLE_LEN) ) / 2.
+ * Value is ( mW(QDBM_OFFSET + QDBM_TABLE_LEN - 1) +
+ * mW(QDBM_OFFSET + QDBM_TABLE_LEN) ) / 2.
  */
 #define QDBM_TABLE_HIGH_BOUND 64938	/* High bound */
 
-static const uint16 nqdBm_to_mW_map[QDBM_TABLE_LEN] = {
+static const u16 nqdBm_to_mW_map[QDBM_TABLE_LEN] = {
 /* qdBm: 	+0 	+1 	+2 	+3 	+4 	+5 	+6 	+7 */
 /* 153: */ 6683, 7079, 7499, 7943, 8414, 8913, 9441, 10000,
 /* 161: */ 10593, 11220, 11885, 12589, 13335, 14125, 14962, 15849,
@@ -1592,12 +944,13 @@ static const uint16 nqdBm_to_mW_map[QDBM_TABLE_LEN] = {
 /* 185: */ 42170, 44668, 47315, 50119, 53088, 56234, 59566, 63096
 };
 
-uint16 BCMROMFN(bcm_qdbm_to_mw) (uint8 qdbm) {
+u16 bcm_qdbm_to_mw(u8 qdbm)
+{
 	uint factor = 1;
 	int idx = qdbm - QDBM_OFFSET;
 
 	if (idx >= QDBM_TABLE_LEN) {
-		/* clamp to max uint16 mW value */
+		/* clamp to max u16 mW value */
 		return 0xFFFF;
 	}
 
@@ -1612,11 +965,11 @@ uint16 BCMROMFN(bcm_qdbm_to_mw) (uint8 qdbm) {
 	/* return the mW value scaled down to the correct factor of 10,
 	 * adding in factor/2 to get proper rounding.
 	 */
-	return ((nqdBm_to_mW_map[idx] + factor / 2) / factor);
+	return (nqdBm_to_mW_map[idx] + factor / 2) / factor;
 }
-
-uint8 BCMROMFN(bcm_mw_to_qdbm) (uint16 mw) {
-	uint8 qdbm;
+u8 bcm_mw_to_qdbm(u16 mw)
+{
+	u8 qdbm;
 	int offset;
 	uint mw_uint = mw;
 	uint boundary;
@@ -1640,14 +993,14 @@ uint8 BCMROMFN(bcm_mw_to_qdbm) (uint16 mw) {
 			break;
 	}
 
-	qdbm += (uint8) offset;
+	qdbm += (u8) offset;
 
-	return (qdbm);
+	return qdbm;
 }
-
-uint BCMROMFN(bcm_bitcount) (uint8 * bitmap, uint length) {
+uint bcm_bitcount(u8 *bitmap, uint length)
+{
 	uint bitcount = 0, i;
-	uint8 tmp;
+	u8 tmp;
 	for (i = 0; i < length; i++) {
 		tmp = bitmap[i];
 		while (tmp) {
@@ -1657,7 +1010,6 @@ uint BCMROMFN(bcm_bitcount) (uint8 * bitmap, uint length) {
 	}
 	return bitcount;
 }
-
 /* Initialization of bcmstrbuf structure */
 void bcm_binit(struct bcmstrbuf *b, char *buf, uint size)
 {
@@ -1690,71 +1042,3 @@ int bcm_bprintf(struct bcmstrbuf *b, const char *fmt, ...)
 	return r;
 }
 
-void bcm_inc_bytes(uchar * num, int num_bytes, uint8 amount)
-{
-	int i;
-
-	for (i = 0; i < num_bytes; i++) {
-		num[i] += amount;
-		if (num[i] >= amount)
-			break;
-		amount = 1;
-	}
-}
-
-int bcm_cmp_bytes(uchar * arg1, uchar * arg2, uint8 nbytes)
-{
-	int i;
-
-	for (i = nbytes - 1; i >= 0; i--) {
-		if (arg1[i] != arg2[i])
-			return (arg1[i] - arg2[i]);
-	}
-	return 0;
-}
-
-void bcm_print_bytes(char *name, const uchar * data, int len)
-{
-	int i;
-	int per_line = 0;
-
-	printf("%s: %d\n", name ? name : "", len);
-	for (i = 0; i < len; i++) {
-		printf("%02x ", *data++);
-		per_line++;
-		if (per_line == 16) {
-			per_line = 0;
-			printf("\n");
-		}
-	}
-	printf("\n");
-}
-
-#if defined(BCMDBG)
-#define SSID_FMT_BUF_LEN	((4 * DOT11_MAX_SSID_LEN) + 1)
-int bcm_format_ssid(char *buf, const uchar ssid[], uint ssid_len)
-{
-	uint i, c;
-	char *p = buf;
-	char *endp = buf + SSID_FMT_BUF_LEN;
-
-	if (ssid_len > DOT11_MAX_SSID_LEN)
-		ssid_len = DOT11_MAX_SSID_LEN;
-
-	for (i = 0; i < ssid_len; i++) {
-		c = (uint) ssid[i];
-		if (c == '\\') {
-			*p++ = '\\';
-			*p++ = '\\';
-		} else if (bcm_isprint((uchar) c)) {
-			*p++ = (char)c;
-		} else {
-			p += snprintf(p, (endp - p), "\\x%02X", c);
-		}
-	}
-	*p = '\0';
-	ASSERT(p < endp);
-
-	return (int)(p - buf);
-}
-#endif				/* defined(BCMDBG) */
diff --git a/drivers/staging/brcm80211/util/bcmwifi.c b/drivers/staging/brcm80211/util/bcmwifi.c
index ae5ff88..1bb6c78 100644
--- a/drivers/staging/brcm80211/util/bcmwifi.c
+++ b/drivers/staging/brcm80211/util/bcmwifi.c
@@ -13,166 +13,37 @@
  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
-
-#include <typedefs.h>
-
-#include <osl.h>
+#include <linux/ctype.h>
+#include <linux/kernel.h>
+#include <bcmdefs.h>
 #include <bcmutils.h>
-#define strtoul(nptr, endptr, base) bcm_strtoul((nptr), (endptr), (base))
-#define tolower(c) (bcm_isupper((c)) ? ((c) + 'a' - 'A') : (c))
 #include <bcmwifi.h>
 
-/* Chanspec ASCII representation:
- * <channel><band><bandwidth><ctl-sideband>
- *   digit   [AB]     [N]        [UL]
- *
- * <channel>: channel number of the 10MHz or 20MHz channel,
- *	or control sideband channel of 40MHz channel.
- * <band>: A for 5GHz, B for 2.4GHz
- * <bandwidth>: N for 10MHz, nothing for 20MHz or 40MHz
- *	(ctl-sideband spec implies 40MHz)
- * <ctl-sideband>: U for upper, L for lower
- *
- * <band> may be omitted on input, and will be assumed to be
- * 2.4GHz if channel number <= 14.
- *
- * Examples:
- *	8  ->  2.4GHz channel 8, 20MHz
- *	8b ->  2.4GHz channel 8, 20MHz
- *	8l ->  2.4GHz channel 8, 40MHz, lower ctl sideband
- *	8a ->  5GHz channel 8 (low 5 GHz band), 20MHz
- *	36 ->  5GHz channel 36, 20MHz
- *	36l -> 5GHz channel 36, 40MHz, lower ctl sideband
- *	40u -> 5GHz channel 40, 40MHz, upper ctl sideband
- *	180n -> channel 180, 10MHz
- */
-
-/* given a chanspec and a string buffer, format the chanspec as a
- * string, and return the original pointer a.
- * Min buffer length must be CHANSPEC_STR_LEN.
- * On error return NULL
- */
-char *wf_chspec_ntoa(chanspec_t chspec, char *buf)
-{
-	const char *band, *bw, *sb;
-	uint channel;
-
-	band = "";
-	bw = "";
-	sb = "";
-	channel = CHSPEC_CHANNEL(chspec);
-	/* check for non-default band spec */
-	if ((CHSPEC_IS2G(chspec) && channel > CH_MAX_2G_CHANNEL) ||
-	    (CHSPEC_IS5G(chspec) && channel <= CH_MAX_2G_CHANNEL))
-		band = (CHSPEC_IS2G(chspec)) ? "b" : "a";
-	if (CHSPEC_IS40(chspec)) {
-		if (CHSPEC_SB_UPPER(chspec)) {
-			sb = "u";
-			channel += CH_10MHZ_APART;
-		} else {
-			sb = "l";
-			channel -= CH_10MHZ_APART;
-		}
-	} else if (CHSPEC_IS10(chspec)) {
-		bw = "n";
-	}
-
-	/* Outputs a max of 6 chars including '\0'  */
-	snprintf(buf, 6, "%d%s%s%s", channel, band, bw, sb);
-	return (buf);
-}
-
-/* given a chanspec string, convert to a chanspec.
- * On error return 0
- */
-chanspec_t wf_chspec_aton(char *a)
-{
-	char *endp = NULL;
-	uint channel, band, bw, ctl_sb;
-	char c;
-
-	channel = strtoul(a, &endp, 10);
-
-	/* check for no digits parsed */
-	if (endp == a)
-		return 0;
-
-	if (channel > MAXCHANNEL)
-		return 0;
-
-	band =
-	    ((channel <=
-	      CH_MAX_2G_CHANNEL) ? WL_CHANSPEC_BAND_2G : WL_CHANSPEC_BAND_5G);
-	bw = WL_CHANSPEC_BW_20;
-	ctl_sb = WL_CHANSPEC_CTL_SB_NONE;
-
-	a = endp;
-
-	c = tolower(a[0]);
-	if (c == '\0')
-		goto done;
-
-	/* parse the optional ['A' | 'B'] band spec */
-	if (c == 'a' || c == 'b') {
-		band = (c == 'a') ? WL_CHANSPEC_BAND_5G : WL_CHANSPEC_BAND_2G;
-		a++;
-		c = tolower(a[0]);
-		if (c == '\0')
-			goto done;
-	}
-
-	/* parse bandwidth 'N' (10MHz) or 40MHz ctl sideband ['L' | 'U'] */
-	if (c == 'n') {
-		bw = WL_CHANSPEC_BW_10;
-	} else if (c == 'l') {
-		bw = WL_CHANSPEC_BW_40;
-		ctl_sb = WL_CHANSPEC_CTL_SB_LOWER;
-		/* adjust channel to center of 40MHz band */
-		if (channel <= (MAXCHANNEL - CH_20MHZ_APART))
-			channel += CH_10MHZ_APART;
-		else
-			return 0;
-	} else if (c == 'u') {
-		bw = WL_CHANSPEC_BW_40;
-		ctl_sb = WL_CHANSPEC_CTL_SB_UPPER;
-		/* adjust channel to center of 40MHz band */
-		if (channel > CH_20MHZ_APART)
-			channel -= CH_10MHZ_APART;
-		else
-			return 0;
-	} else {
-		return 0;
-	}
-
- done:
-	return (channel | band | bw | ctl_sb);
-}
-
 /*
  * Verify the chanspec is using a legal set of parameters, i.e. that the
  * chanspec specified a band, bw, ctl_sb and channel and that the
  * combination could be legal given any set of circumstances.
- * RETURNS: TRUE is the chanspec is malformed, false if it looks good.
+ * RETURNS: true is the chanspec is malformed, false if it looks good.
  */
 bool wf_chspec_malformed(chanspec_t chanspec)
 {
 	/* must be 2G or 5G band */
 	if (!CHSPEC_IS5G(chanspec) && !CHSPEC_IS2G(chanspec))
-		return TRUE;
+		return true;
 	/* must be 20 or 40 bandwidth */
 	if (!CHSPEC_IS40(chanspec) && !CHSPEC_IS20(chanspec))
-		return TRUE;
+		return true;
 
 	/* 20MHZ b/w must have no ctl sb, 40 must have a ctl sb */
 	if (CHSPEC_IS20(chanspec)) {
 		if (!CHSPEC_SB_NONE(chanspec))
-			return TRUE;
+			return true;
 	} else {
 		if (!CHSPEC_SB_UPPER(chanspec) && !CHSPEC_SB_LOWER(chanspec))
-			return TRUE;
+			return true;
 	}
 
-	return FALSE;
+	return false;
 }
 
 /*
@@ -180,9 +51,9 @@ bool wf_chspec_malformed(chanspec_t chanspec)
  * channels this is just the channel number, for 40MHZ channels it is the upper or lowre 20MHZ
  * sideband depending on the chanspec selected
  */
-uint8 wf_chspec_ctlchan(chanspec_t chspec)
+u8 wf_chspec_ctlchan(chanspec_t chspec)
 {
-	uint8 ctl_chan;
+	u8 ctl_chan;
 
 	/* Is there a sideband ? */
 	if (CHSPEC_CTL_SB(chspec) == WL_CHANSPEC_CTL_SB_NONE) {
@@ -210,7 +81,7 @@ uint8 wf_chspec_ctlchan(chanspec_t chspec)
 chanspec_t wf_chspec_ctlchspec(chanspec_t chspec)
 {
 	chanspec_t ctl_chspec = 0;
-	uint8 channel;
+	u8 channel;
 
 	ASSERT(!wf_chspec_malformed(chspec));
 
diff --git a/drivers/staging/brcm80211/util/bcmwpa.c b/drivers/staging/brcm80211/util/bcmwpa.c
deleted file mode 100644
index d1b7c8d..0000000
--- a/drivers/staging/brcm80211/util/bcmwpa.c
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (c) 2010 Broadcom Corporation
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#include <bcmutils.h>
-#include <bcmwpa.h>
-
-/* Is this body of this tlvs entry a WFA entry? If
- * not update the tlvs buffer pointer/length.
- */
-bool bcm_is_wfa_ie(uint8 * ie, uint8 ** tlvs, uint * tlvs_len, uint8 type)
-{
-	/* If the contents match the WFA_OUI and type */
-	if ((ie[TLV_LEN_OFF] > (WFA_OUI_LEN + 1)) &&
-	    !bcmp(&ie[TLV_BODY_OFF], WFA_OUI, WFA_OUI_LEN) &&
-	    type == ie[TLV_BODY_OFF + WFA_OUI_LEN]) {
-		return TRUE;
-	}
-
-	/* point to the next ie */
-	ie += ie[TLV_LEN_OFF] + TLV_HDR_LEN;
-	/* calculate the length of the rest of the buffer */
-	*tlvs_len -= (int)(ie - *tlvs);
-	/* update the pointer to the start of the buffer */
-	*tlvs = ie;
-
-	return FALSE;
-}
-
-wpa_ie_fixed_t *BCMROMFN(bcm_find_wpaie) (uint8 * parse, uint len) {
-	bcm_tlv_t *ie;
-
-	while ((ie = bcm_parse_tlvs(parse, len, DOT11_MNG_VS_ID))) {
-		if (bcm_is_wpa_ie((uint8 *) ie, &parse, &len)) {
-			return (wpa_ie_fixed_t *) ie;
-		}
-	}
-	return NULL;
-}
diff --git a/drivers/staging/brcm80211/util/hnddma.c b/drivers/staging/brcm80211/util/hnddma.c
index 5b59ad8..fe503e7 100644
--- a/drivers/staging/brcm80211/util/hnddma.c
+++ b/drivers/staging/brcm80211/util/hnddma.c
@@ -14,7 +14,9 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <typedefs.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linuxver.h>
 #include <bcmdefs.h>
 #include <bcmdevs.h>
 #include <osl.h>
@@ -28,8 +30,20 @@
 
 /* debug/trace */
 #ifdef BCMDBG
-#define	DMA_ERROR(args) if (!(*di->msg_level & 1)); else printf args
-#define	DMA_TRACE(args) if (!(*di->msg_level & 2)); else printf args
+#define	DMA_ERROR(args) \
+	do { \
+		if (!(*di->msg_level & 1)) \
+			; \
+		else \
+			printf args; \
+	} while (0)
+#define	DMA_TRACE(args) \
+	do { \
+		if (!(*di->msg_level & 2)) \
+			; \
+		else \
+			printf args; \
+	} while (0)
 #else
 #define	DMA_ERROR(args)
 #define	DMA_TRACE(args)
@@ -48,7 +62,7 @@
 #define rxd64		dregs.d64_u.rxd_64
 
 /* default dma message level (if input msg_level pointer is null in dma_attach()) */
-static uint dma_msg_level = 0;
+static uint dma_msg_level;
 
 #define	MAXNAMEL	8	/* 8 char names */
 
@@ -83,37 +97,37 @@ typedef struct dma_info {
 		} d64_u;
 	} dregs;
 
-	uint16 dmadesc_align;	/* alignment requirement for dma descriptors */
+	u16 dmadesc_align;	/* alignment requirement for dma descriptors */
 
-	uint16 ntxd;		/* # tx descriptors tunable */
-	uint16 txin;		/* index of next descriptor to reclaim */
-	uint16 txout;		/* index of next descriptor to post */
+	u16 ntxd;		/* # tx descriptors tunable */
+	u16 txin;		/* index of next descriptor to reclaim */
+	u16 txout;		/* index of next descriptor to post */
 	void **txp;		/* pointer to parallel array of pointers to packets */
 	osldma_t *tx_dmah;	/* DMA TX descriptor ring handle */
 	hnddma_seg_map_t *txp_dmah;	/* DMA MAP meta-data handle */
 	dmaaddr_t txdpa;	/* Aligned physical address of descriptor ring */
 	dmaaddr_t txdpaorig;	/* Original physical address of descriptor ring */
-	uint16 txdalign;	/* #bytes added to alloc'd mem to align txd */
-	uint32 txdalloc;	/* #bytes allocated for the ring */
-	uint32 xmtptrbase;	/* When using unaligned descriptors, the ptr register
+	u16 txdalign;	/* #bytes added to alloc'd mem to align txd */
+	u32 txdalloc;	/* #bytes allocated for the ring */
+	u32 xmtptrbase;	/* When using unaligned descriptors, the ptr register
 				 * is not just an index, it needs all 13 bits to be
 				 * an offset from the addr register.
 				 */
 
-	uint16 nrxd;		/* # rx descriptors tunable */
-	uint16 rxin;		/* index of next descriptor to reclaim */
-	uint16 rxout;		/* index of next descriptor to post */
+	u16 nrxd;		/* # rx descriptors tunable */
+	u16 rxin;		/* index of next descriptor to reclaim */
+	u16 rxout;		/* index of next descriptor to post */
 	void **rxp;		/* pointer to parallel array of pointers to packets */
 	osldma_t *rx_dmah;	/* DMA RX descriptor ring handle */
 	hnddma_seg_map_t *rxp_dmah;	/* DMA MAP meta-data handle */
 	dmaaddr_t rxdpa;	/* Aligned physical address of descriptor ring */
 	dmaaddr_t rxdpaorig;	/* Original physical address of descriptor ring */
-	uint16 rxdalign;	/* #bytes added to alloc'd mem to align rxd */
-	uint32 rxdalloc;	/* #bytes allocated for the ring */
-	uint32 rcvptrbase;	/* Base for ptr reg when using unaligned descriptors */
+	u16 rxdalign;	/* #bytes added to alloc'd mem to align rxd */
+	u32 rxdalloc;	/* #bytes allocated for the ring */
+	u32 rcvptrbase;	/* Base for ptr reg when using unaligned descriptors */
 
 	/* tunables */
-	uint16 rxbufsize;	/* rx buffer size in bytes,
+	unsigned int rxbufsize;	/* rx buffer size in bytes,
 				 * not including the extra headroom
 				 */
 	uint rxextrahdrroom;	/* extra rx headroom, reverseved to assist upper stack
@@ -123,7 +137,7 @@ typedef struct dma_info {
 				 *  Some dongle driver may not need it.
 				 */
 	uint nrxpost;		/* # rx buffers to keep posted */
-	uint rxoffset;		/* rxcontrol offset */
+	unsigned int rxoffset;	/* rxcontrol offset */
 	uint ddoffsetlow;	/* add to get dma address of descriptor ring, low 32 bits */
 	uint ddoffsethigh;	/*   high 32 bits */
 	uint dataoffsetlow;	/* add to get dma address of data buffer, low 32 bits */
@@ -152,9 +166,9 @@ typedef struct dma_info {
 
 /* DMA Scatter-gather list is supported. Note this is limited to TX direction only */
 #ifdef BCMDMASGLISTOSL
-#define DMASGLIST_ENAB TRUE
+#define DMASGLIST_ENAB true
 #else
-#define DMASGLIST_ENAB FALSE
+#define DMASGLIST_ENAB false
 #endif				/* BCMDMASGLISTOSL */
 
 /* descriptor bumping macros */
@@ -180,85 +194,85 @@ typedef struct dma_info {
 #define	PCI64ADDR_HIGH_SHIFT	31	/* address[63] */
 
 /* Common prototypes */
-static bool _dma_isaddrext(dma_info_t * di);
-static bool _dma_descriptor_align(dma_info_t * di);
-static bool _dma_alloc(dma_info_t * di, uint direction);
-static void _dma_detach(dma_info_t * di);
-static void _dma_ddtable_init(dma_info_t * di, uint direction, dmaaddr_t pa);
-static void _dma_rxinit(dma_info_t * di);
-static void *_dma_rx(dma_info_t * di);
-static bool _dma_rxfill(dma_info_t * di);
-static void _dma_rxreclaim(dma_info_t * di);
-static void _dma_rxenable(dma_info_t * di);
-static void *_dma_getnextrxp(dma_info_t * di, bool forceall);
-static void _dma_rx_param_get(dma_info_t * di, uint16 * rxoffset,
-			      uint16 * rxbufsize);
-
-static void _dma_txblock(dma_info_t * di);
-static void _dma_txunblock(dma_info_t * di);
-static uint _dma_txactive(dma_info_t * di);
-static uint _dma_rxactive(dma_info_t * di);
-static uint _dma_txpending(dma_info_t * di);
-static uint _dma_txcommitted(dma_info_t * di);
-
-static void *_dma_peeknexttxp(dma_info_t * di);
-static void *_dma_peeknextrxp(dma_info_t * di);
-static uintptr _dma_getvar(dma_info_t * di, const char *name);
-static void _dma_counterreset(dma_info_t * di);
-static void _dma_fifoloopbackenable(dma_info_t * di);
-static uint _dma_ctrlflags(dma_info_t * di, uint mask, uint flags);
-static uint8 dma_align_sizetobits(uint size);
-static void *dma_ringalloc(osl_t * osh, uint32 boundary, uint size,
-			   uint16 * alignbits, uint * alloced,
-			   dmaaddr_t * descpa, osldma_t ** dmah);
+static bool _dma_isaddrext(dma_info_t *di);
+static bool _dma_descriptor_align(dma_info_t *di);
+static bool _dma_alloc(dma_info_t *di, uint direction);
+static void _dma_detach(dma_info_t *di);
+static void _dma_ddtable_init(dma_info_t *di, uint direction, dmaaddr_t pa);
+static void _dma_rxinit(dma_info_t *di);
+static void *_dma_rx(dma_info_t *di);
+static bool _dma_rxfill(dma_info_t *di);
+static void _dma_rxreclaim(dma_info_t *di);
+static void _dma_rxenable(dma_info_t *di);
+static void *_dma_getnextrxp(dma_info_t *di, bool forceall);
+static void _dma_rx_param_get(dma_info_t *di, u16 *rxoffset,
+			      u16 *rxbufsize);
+
+static void _dma_txblock(dma_info_t *di);
+static void _dma_txunblock(dma_info_t *di);
+static uint _dma_txactive(dma_info_t *di);
+static uint _dma_rxactive(dma_info_t *di);
+static uint _dma_txpending(dma_info_t *di);
+static uint _dma_txcommitted(dma_info_t *di);
+
+static void *_dma_peeknexttxp(dma_info_t *di);
+static void *_dma_peeknextrxp(dma_info_t *di);
+static unsigned long _dma_getvar(dma_info_t *di, const char *name);
+static void _dma_counterreset(dma_info_t *di);
+static void _dma_fifoloopbackenable(dma_info_t *di);
+static uint _dma_ctrlflags(dma_info_t *di, uint mask, uint flags);
+static u8 dma_align_sizetobits(uint size);
+static void *dma_ringalloc(osl_t *osh, u32 boundary, uint size,
+			   u16 *alignbits, uint *alloced,
+			   dmaaddr_t *descpa, osldma_t **dmah);
 
 /* Prototypes for 32-bit routines */
-static bool dma32_alloc(dma_info_t * di, uint direction);
-static bool dma32_txreset(dma_info_t * di);
-static bool dma32_rxreset(dma_info_t * di);
-static bool dma32_txsuspendedidle(dma_info_t * di);
-static int dma32_txfast(dma_info_t * di, void *p0, bool commit);
-static void *dma32_getnexttxp(dma_info_t * di, txd_range_t range);
-static void *dma32_getnextrxp(dma_info_t * di, bool forceall);
-static void dma32_txrotate(dma_info_t * di);
-static bool dma32_rxidle(dma_info_t * di);
-static void dma32_txinit(dma_info_t * di);
-static bool dma32_txenabled(dma_info_t * di);
-static void dma32_txsuspend(dma_info_t * di);
-static void dma32_txresume(dma_info_t * di);
-static bool dma32_txsuspended(dma_info_t * di);
-static void dma32_txreclaim(dma_info_t * di, txd_range_t range);
-static bool dma32_txstopped(dma_info_t * di);
-static bool dma32_rxstopped(dma_info_t * di);
-static bool dma32_rxenabled(dma_info_t * di);
-
-static bool _dma32_addrext(osl_t * osh, dma32regs_t * dma32regs);
+static bool dma32_alloc(dma_info_t *di, uint direction);
+static bool dma32_txreset(dma_info_t *di);
+static bool dma32_rxreset(dma_info_t *di);
+static bool dma32_txsuspendedidle(dma_info_t *di);
+static int dma32_txfast(dma_info_t *di, void *p0, bool commit);
+static void *dma32_getnexttxp(dma_info_t *di, txd_range_t range);
+static void *dma32_getnextrxp(dma_info_t *di, bool forceall);
+static void dma32_txrotate(dma_info_t *di);
+static bool dma32_rxidle(dma_info_t *di);
+static void dma32_txinit(dma_info_t *di);
+static bool dma32_txenabled(dma_info_t *di);
+static void dma32_txsuspend(dma_info_t *di);
+static void dma32_txresume(dma_info_t *di);
+static bool dma32_txsuspended(dma_info_t *di);
+static void dma32_txreclaim(dma_info_t *di, txd_range_t range);
+static bool dma32_txstopped(dma_info_t *di);
+static bool dma32_rxstopped(dma_info_t *di);
+static bool dma32_rxenabled(dma_info_t *di);
+
+static bool _dma32_addrext(osl_t *osh, dma32regs_t *dma32regs);
 
 /* Prototypes for 64-bit routines */
-static bool dma64_alloc(dma_info_t * di, uint direction);
-static bool dma64_txreset(dma_info_t * di);
-static bool dma64_rxreset(dma_info_t * di);
-static bool dma64_txsuspendedidle(dma_info_t * di);
-static int dma64_txfast(dma_info_t * di, void *p0, bool commit);
-static int dma64_txunframed(dma_info_t * di, void *p0, uint len, bool commit);
-static void *dma64_getpos(dma_info_t * di, bool direction);
-static void *dma64_getnexttxp(dma_info_t * di, txd_range_t range);
-static void *dma64_getnextrxp(dma_info_t * di, bool forceall);
-static void dma64_txrotate(dma_info_t * di);
-
-static bool dma64_rxidle(dma_info_t * di);
-static void dma64_txinit(dma_info_t * di);
-static bool dma64_txenabled(dma_info_t * di);
-static void dma64_txsuspend(dma_info_t * di);
-static void dma64_txresume(dma_info_t * di);
-static bool dma64_txsuspended(dma_info_t * di);
-static void dma64_txreclaim(dma_info_t * di, txd_range_t range);
-static bool dma64_txstopped(dma_info_t * di);
-static bool dma64_rxstopped(dma_info_t * di);
-static bool dma64_rxenabled(dma_info_t * di);
-static bool _dma64_addrext(osl_t * osh, dma64regs_t * dma64regs);
-
-STATIC INLINE uint32 parity32(uint32 data);
+static bool dma64_alloc(dma_info_t *di, uint direction);
+static bool dma64_txreset(dma_info_t *di);
+static bool dma64_rxreset(dma_info_t *di);
+static bool dma64_txsuspendedidle(dma_info_t *di);
+static int dma64_txfast(dma_info_t *di, void *p0, bool commit);
+static int dma64_txunframed(dma_info_t *di, void *p0, uint len, bool commit);
+static void *dma64_getpos(dma_info_t *di, bool direction);
+static void *dma64_getnexttxp(dma_info_t *di, txd_range_t range);
+static void *dma64_getnextrxp(dma_info_t *di, bool forceall);
+static void dma64_txrotate(dma_info_t *di);
+
+static bool dma64_rxidle(dma_info_t *di);
+static void dma64_txinit(dma_info_t *di);
+static bool dma64_txenabled(dma_info_t *di);
+static void dma64_txsuspend(dma_info_t *di);
+static void dma64_txresume(dma_info_t *di);
+static bool dma64_txsuspended(dma_info_t *di);
+static void dma64_txreclaim(dma_info_t *di, txd_range_t range);
+static bool dma64_txstopped(dma_info_t *di);
+static bool dma64_rxstopped(dma_info_t *di);
+static bool dma64_rxenabled(dma_info_t *di);
+static bool _dma64_addrext(osl_t *osh, dma64regs_t *dma64regs);
+
+static inline u32 parity32(u32 data);
 
 const di_fcn_t dma64proc = {
 	(di_detach_t) _dma_detach,
@@ -354,25 +368,23 @@ static const di_fcn_t dma32proc = {
 	39
 };
 
-hnddma_t *dma_attach(osl_t * osh, char *name, si_t * sih, void *dmaregstx,
+hnddma_t *dma_attach(osl_t *osh, char *name, si_t *sih, void *dmaregstx,
 		     void *dmaregsrx, uint ntxd, uint nrxd, uint rxbufsize,
 		     int rxextheadroom, uint nrxpost, uint rxoffset,
-		     uint * msg_level)
+		     uint *msg_level)
 {
 	dma_info_t *di;
 	uint size;
 
 	/* allocate private info structure */
-	if ((di = MALLOC(osh, sizeof(dma_info_t))) == NULL) {
+	di = kzalloc(sizeof(dma_info_t), GFP_ATOMIC);
+	if (di == NULL) {
 #ifdef BCMDBG
-		printf("dma_attach: out of memory, malloced %d bytes\n",
-		       MALLOCED(osh));
+		printf("dma_attach: out of memory\n");
 #endif
-		return (NULL);
+		return NULL;
 	}
 
-	bzero((char *)di, sizeof(dma_info_t));
-
 	di->msg_level = msg_level ? msg_level : &dma_msg_level;
 
 	/* old chips w/o sb is no longer supported */
@@ -430,19 +442,19 @@ hnddma_t *dma_attach(osl_t * osh, char *name, si_t * sih, void *dmaregstx,
 	di->sih = sih;
 
 	/* save tunables */
-	di->ntxd = (uint16) ntxd;
-	di->nrxd = (uint16) nrxd;
+	di->ntxd = (u16) ntxd;
+	di->nrxd = (u16) nrxd;
 
 	/* the actual dma size doesn't include the extra headroom */
 	di->rxextrahdrroom =
 	    (rxextheadroom == -1) ? BCMEXTRAHDROOM : rxextheadroom;
 	if (rxbufsize > BCMEXTRAHDROOM)
-		di->rxbufsize = (uint16) (rxbufsize - di->rxextrahdrroom);
+		di->rxbufsize = (u16) (rxbufsize - di->rxextrahdrroom);
 	else
-		di->rxbufsize = (uint16) rxbufsize;
+		di->rxbufsize = (u16) rxbufsize;
 
-	di->nrxpost = (uint16) nrxpost;
-	di->rxoffset = (uint8) rxoffset;
+	di->nrxpost = (u16) nrxpost;
+	di->rxoffset = (u8) rxoffset;
 
 	/*
 	 * figure out the DMA physical address offset for dd and data
@@ -499,21 +511,21 @@ hnddma_t *dma_attach(osl_t * osh, char *name, si_t * sih, void *dmaregstx,
 	/* allocate tx packet pointer vector */
 	if (ntxd) {
 		size = ntxd * sizeof(void *);
-		if ((di->txp = MALLOC(osh, size)) == NULL) {
-			DMA_ERROR(("%s: dma_attach: out of tx memory, malloced %d bytes\n", di->name, MALLOCED(osh)));
+		di->txp = kzalloc(size, GFP_ATOMIC);
+		if (di->txp == NULL) {
+			DMA_ERROR(("%s: dma_attach: out of tx memory\n", di->name));
 			goto fail;
 		}
-		bzero((char *)di->txp, size);
 	}
 
 	/* allocate rx packet pointer vector */
 	if (nrxd) {
 		size = nrxd * sizeof(void *);
-		if ((di->rxp = MALLOC(osh, size)) == NULL) {
-			DMA_ERROR(("%s: dma_attach: out of rx memory, malloced %d bytes\n", di->name, MALLOCED(osh)));
+		di->rxp = kzalloc(size, GFP_ATOMIC);
+		if (di->rxp == NULL) {
+			DMA_ERROR(("%s: dma_attach: out of rx memory\n", di->name));
 			goto fail;
 		}
-		bzero((char *)di->rxp, size);
 	}
 
 	/* allocate transmit descriptor ring, only need ntxd descriptors but it must be aligned */
@@ -530,11 +542,11 @@ hnddma_t *dma_attach(osl_t * osh, char *name, si_t * sih, void *dmaregstx,
 
 	if ((di->ddoffsetlow != 0) && !di->addrext) {
 		if (PHYSADDRLO(di->txdpa) > SI_PCI_DMA_SZ) {
-			DMA_ERROR(("%s: dma_attach: txdpa 0x%x: addrext not supported\n", di->name, (uint32) PHYSADDRLO(di->txdpa)));
+			DMA_ERROR(("%s: dma_attach: txdpa 0x%x: addrext not supported\n", di->name, (u32) PHYSADDRLO(di->txdpa)));
 			goto fail;
 		}
 		if (PHYSADDRLO(di->rxdpa) > SI_PCI_DMA_SZ) {
-			DMA_ERROR(("%s: dma_attach: rxdpa 0x%x: addrext not supported\n", di->name, (uint32) PHYSADDRLO(di->rxdpa)));
+			DMA_ERROR(("%s: dma_attach: rxdpa 0x%x: addrext not supported\n", di->name, (u32) PHYSADDRLO(di->rxdpa)));
 			goto fail;
 		}
 	}
@@ -545,32 +557,30 @@ hnddma_t *dma_attach(osl_t * osh, char *name, si_t * sih, void *dmaregstx,
 	if (DMASGLIST_ENAB) {
 		if (ntxd) {
 			size = ntxd * sizeof(hnddma_seg_map_t);
-			if ((di->txp_dmah =
-			     (hnddma_seg_map_t *) MALLOC(osh, size)) == NULL)
+			di->txp_dmah = kzalloc(size, GFP_ATOMIC);
+			if (di->txp_dmah == NULL)
 				goto fail;
-			bzero((char *)di->txp_dmah, size);
 		}
 
 		if (nrxd) {
 			size = nrxd * sizeof(hnddma_seg_map_t);
-			if ((di->rxp_dmah =
-			     (hnddma_seg_map_t *) MALLOC(osh, size)) == NULL)
+			di->rxp_dmah = kzalloc(size, GFP_ATOMIC);
+			if (di->rxp_dmah == NULL)
 				goto fail;
-			bzero((char *)di->rxp_dmah, size);
 		}
 	}
 
-	return ((hnddma_t *) di);
+	return (hnddma_t *) di;
 
  fail:
 	_dma_detach(di);
-	return (NULL);
+	return NULL;
 }
 
 /* init the tx or rx descriptor */
-static INLINE void
-dma32_dd_upd(dma_info_t * di, dma32dd_t * ddring, dmaaddr_t pa, uint outidx,
-	     uint32 * flags, uint32 bufcount)
+static inline void
+dma32_dd_upd(dma_info_t *di, dma32dd_t *ddring, dmaaddr_t pa, uint outidx,
+	     u32 *flags, u32 bufcount)
 {
 	/* dma32 uses 32-bit control to fit both flags and bufcounter */
 	*flags = *flags | (bufcount & CTRL_BC_MASK);
@@ -581,7 +591,7 @@ dma32_dd_upd(dma_info_t * di, dma32dd_t * ddring, dmaaddr_t pa, uint outidx,
 		W_SM(&ddring[outidx].ctrl, BUS_SWAP32(*flags));
 	} else {
 		/* address extension */
-		uint32 ae;
+		u32 ae;
 		ASSERT(di->addrext);
 		ae = (PHYSADDRLO(pa) & PCI32ADDR_HIGH) >> PCI32ADDR_HIGH_SHIFT;
 		PHYSADDRLO(pa) &= ~PCI32ADDR_HIGH;
@@ -594,7 +604,7 @@ dma32_dd_upd(dma_info_t * di, dma32dd_t * ddring, dmaaddr_t pa, uint outidx,
 }
 
 /* Check for odd number of 1's */
-STATIC INLINE uint32 parity32(uint32 data)
+static inline u32 parity32(u32 data)
 {
 	data ^= data >> 16;
 	data ^= data >> 8;
@@ -602,16 +612,16 @@ STATIC INLINE uint32 parity32(uint32 data)
 	data ^= data >> 2;
 	data ^= data >> 1;
 
-	return (data & 1);
+	return data & 1;
 }
 
 #define DMA64_DD_PARITY(dd)  parity32((dd)->addrlow ^ (dd)->addrhigh ^ (dd)->ctrl1 ^ (dd)->ctrl2)
 
-static INLINE void
-dma64_dd_upd(dma_info_t * di, dma64dd_t * ddring, dmaaddr_t pa, uint outidx,
-	     uint32 * flags, uint32 bufcount)
+static inline void
+dma64_dd_upd(dma_info_t *di, dma64dd_t *ddring, dmaaddr_t pa, uint outidx,
+	     u32 *flags, u32 bufcount)
 {
-	uint32 ctrl2 = bufcount & D64_CTRL2_BC_MASK;
+	u32 ctrl2 = bufcount & D64_CTRL2_BC_MASK;
 
 	/* PCI bus with big(>1G) physical address, use address extension */
 #if defined(__mips__) && defined(IL_BIGENDIAN)
@@ -630,7 +640,7 @@ dma64_dd_upd(dma_info_t * di, dma64dd_t * ddring, dmaaddr_t pa, uint outidx,
 		W_SM(&ddring[outidx].ctrl2, BUS_SWAP32(ctrl2));
 	} else {
 		/* address extension for 32-bit PCI */
-		uint32 ae;
+		u32 ae;
 		ASSERT(di->addrext);
 
 		ae = (PHYSADDRLO(pa) & PCI32ADDR_HIGH) >> PCI32ADDR_HIGH_SHIFT;
@@ -653,17 +663,17 @@ dma64_dd_upd(dma_info_t * di, dma64dd_t * ddring, dmaaddr_t pa, uint outidx,
 	}
 }
 
-static bool _dma32_addrext(osl_t * osh, dma32regs_t * dma32regs)
+static bool _dma32_addrext(osl_t *osh, dma32regs_t *dma32regs)
 {
-	uint32 w;
+	u32 w;
 
 	OR_REG(osh, &dma32regs->control, XC_AE);
 	w = R_REG(osh, &dma32regs->control);
 	AND_REG(osh, &dma32regs->control, ~XC_AE);
-	return ((w & XC_AE) == XC_AE);
+	return (w & XC_AE) == XC_AE;
 }
 
-static bool _dma_alloc(dma_info_t * di, uint direction)
+static bool _dma_alloc(dma_info_t *di, uint direction)
 {
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 		return dma64_alloc(di, direction);
@@ -674,7 +684,7 @@ static bool _dma_alloc(dma_info_t * di, uint direction)
 }
 
 /* !! may be called with core in reset */
-static void _dma_detach(dma_info_t * di)
+static void _dma_detach(dma_info_t *di)
 {
 
 	DMA_TRACE(("%s: dma_detach\n", di->name));
@@ -687,23 +697,23 @@ static void _dma_detach(dma_info_t * di)
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 		if (di->txd64)
 			DMA_FREE_CONSISTENT(di->osh,
-					    ((int8 *) (uintptr) di->txd64 -
+					    ((s8 *)di->txd64 -
 					     di->txdalign), di->txdalloc,
 					    (di->txdpaorig), &di->tx_dmah);
 		if (di->rxd64)
 			DMA_FREE_CONSISTENT(di->osh,
-					    ((int8 *) (uintptr) di->rxd64 -
+					    ((s8 *)di->rxd64 -
 					     di->rxdalign), di->rxdalloc,
 					    (di->rxdpaorig), &di->rx_dmah);
 	} else if (DMA32_ENAB(di)) {
 		if (di->txd32)
 			DMA_FREE_CONSISTENT(di->osh,
-					    ((int8 *) (uintptr) di->txd32 -
+					    ((s8 *)di->txd32 -
 					     di->txdalign), di->txdalloc,
 					    (di->txdpaorig), &di->tx_dmah);
 		if (di->rxd32)
 			DMA_FREE_CONSISTENT(di->osh,
-					    ((int8 *) (uintptr) di->rxd32 -
+					    ((s8 *)di->rxd32 -
 					     di->rxdalign), di->rxdalloc,
 					    (di->rxdpaorig), &di->rx_dmah);
 	} else
@@ -711,48 +721,46 @@ static void _dma_detach(dma_info_t * di)
 
 	/* free packet pointer vectors */
 	if (di->txp)
-		MFREE(di->osh, (void *)di->txp, (di->ntxd * sizeof(void *)));
+		kfree((void *)di->txp);
 	if (di->rxp)
-		MFREE(di->osh, (void *)di->rxp, (di->nrxd * sizeof(void *)));
+		kfree((void *)di->rxp);
 
 	/* free tx packet DMA handles */
 	if (di->txp_dmah)
-		MFREE(di->osh, (void *)di->txp_dmah,
-		      di->ntxd * sizeof(hnddma_seg_map_t));
+		kfree(di->txp_dmah);
 
 	/* free rx packet DMA handles */
 	if (di->rxp_dmah)
-		MFREE(di->osh, (void *)di->rxp_dmah,
-		      di->nrxd * sizeof(hnddma_seg_map_t));
+		kfree(di->rxp_dmah);
 
 	/* free our private info structure */
-	MFREE(di->osh, (void *)di, sizeof(dma_info_t));
+	kfree((void *)di);
 
 }
 
-static bool _dma_descriptor_align(dma_info_t * di)
+static bool _dma_descriptor_align(dma_info_t *di)
 {
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
-		uint32 addrl;
+		u32 addrl;
 
 		/* Check to see if the descriptors need to be aligned on 4K/8K or not */
 		if (di->d64txregs != NULL) {
 			W_REG(di->osh, &di->d64txregs->addrlow, 0xff0);
 			addrl = R_REG(di->osh, &di->d64txregs->addrlow);
 			if (addrl != 0)
-				return FALSE;
+				return false;
 		} else if (di->d64rxregs != NULL) {
 			W_REG(di->osh, &di->d64rxregs->addrlow, 0xff0);
 			addrl = R_REG(di->osh, &di->d64rxregs->addrlow);
 			if (addrl != 0)
-				return FALSE;
+				return false;
 		}
 	}
-	return TRUE;
+	return true;
 }
 
-/* return TRUE if this dma engine supports DmaExtendedAddrChanges, otherwise FALSE */
-static bool _dma_isaddrext(dma_info_t * di)
+/* return true if this dma engine supports DmaExtendedAddrChanges, otherwise false */
+static bool _dma_isaddrext(dma_info_t *di)
 {
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 		/* DMA64 supports full 32- or 64-bit operation. AE is always valid */
@@ -763,28 +771,28 @@ static bool _dma_isaddrext(dma_info_t * di)
 				DMA_ERROR(("%s: _dma_isaddrext: DMA64 tx doesn't have AE set\n", di->name));
 				ASSERT(0);
 			}
-			return TRUE;
+			return true;
 		} else if (di->d64rxregs != NULL) {
 			if (!_dma64_addrext(di->osh, di->d64rxregs)) {
 				DMA_ERROR(("%s: _dma_isaddrext: DMA64 rx doesn't have AE set\n", di->name));
 				ASSERT(0);
 			}
-			return TRUE;
+			return true;
 		}
-		return FALSE;
+		return false;
 	} else if (DMA32_ENAB(di)) {
 		if (di->d32txregs)
-			return (_dma32_addrext(di->osh, di->d32txregs));
+			return _dma32_addrext(di->osh, di->d32txregs);
 		else if (di->d32rxregs)
-			return (_dma32_addrext(di->osh, di->d32rxregs));
+			return _dma32_addrext(di->osh, di->d32rxregs);
 	} else
 		ASSERT(0);
 
-	return FALSE;
+	return false;
 }
 
 /* initialize descriptor table base address */
-static void _dma_ddtable_init(dma_info_t * di, uint direction, dmaaddr_t pa)
+static void _dma_ddtable_init(dma_info_t *di, uint direction, dmaaddr_t pa)
 {
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 		if (!di->aligndesc_4k) {
@@ -809,7 +817,7 @@ static void _dma_ddtable_init(dma_info_t * di, uint direction, dmaaddr_t pa)
 			}
 		} else {
 			/* DMA64 32bits address extension */
-			uint32 ae;
+			u32 ae;
 			ASSERT(di->addrext);
 			ASSERT(PHYSADDRHI(pa) == 0);
 
@@ -847,7 +855,7 @@ static void _dma_ddtable_init(dma_info_t * di, uint direction, dmaaddr_t pa)
 				      (PHYSADDRLO(pa) + di->ddoffsetlow));
 		} else {
 			/* dma32 address extension */
-			uint32 ae;
+			u32 ae;
 			ASSERT(di->addrext);
 
 			/* shift the high bit(s) from pa to ae */
@@ -871,7 +879,7 @@ static void _dma_ddtable_init(dma_info_t * di, uint direction, dmaaddr_t pa)
 		ASSERT(0);
 }
 
-static void _dma_fifoloopbackenable(dma_info_t * di)
+static void _dma_fifoloopbackenable(dma_info_t *di)
 {
 	DMA_TRACE(("%s: dma_fifoloopbackenable\n", di->name));
 
@@ -883,7 +891,7 @@ static void _dma_fifoloopbackenable(dma_info_t * di)
 		ASSERT(0);
 }
 
-static void _dma_rxinit(dma_info_t * di)
+static void _dma_rxinit(dma_info_t *di)
 {
 	DMA_TRACE(("%s: dma_rxinit\n", di->name));
 
@@ -894,7 +902,7 @@ static void _dma_rxinit(dma_info_t * di)
 
 	/* clear rx descriptor ring */
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
-		BZERO_SM((void *)(uintptr) di->rxd64,
+		BZERO_SM((void *)di->rxd64,
 			 (di->nrxd * sizeof(dma64dd_t)));
 
 		/* DMA engine with out alignment requirement requires table to be inited
@@ -908,7 +916,7 @@ static void _dma_rxinit(dma_info_t * di)
 		if (di->aligndesc_4k)
 			_dma_ddtable_init(di, DMA_RX, di->rxdpa);
 	} else if (DMA32_ENAB(di)) {
-		BZERO_SM((void *)(uintptr) di->rxd32,
+		BZERO_SM((void *)di->rxd32,
 			 (di->nrxd * sizeof(dma32dd_t)));
 		_dma_rxenable(di);
 		_dma_ddtable_init(di, DMA_RX, di->rxdpa);
@@ -916,14 +924,14 @@ static void _dma_rxinit(dma_info_t * di)
 		ASSERT(0);
 }
 
-static void _dma_rxenable(dma_info_t * di)
+static void _dma_rxenable(dma_info_t *di)
 {
 	uint dmactrlflags = di->hnddma.dmactrlflags;
 
 	DMA_TRACE(("%s: dma_rxenable\n", di->name));
 
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
-		uint32 control =
+		u32 control =
 		    (R_REG(di->osh, &di->d64rxregs->control) & D64_RC_AE) |
 		    D64_RC_RE;
 
@@ -936,7 +944,7 @@ static void _dma_rxenable(dma_info_t * di)
 		W_REG(di->osh, &di->d64rxregs->control,
 		      ((di->rxoffset << D64_RC_RO_SHIFT) | control));
 	} else if (DMA32_ENAB(di)) {
-		uint32 control =
+		u32 control =
 		    (R_REG(di->osh, &di->d32rxregs->control) & RC_AE) | RC_RE;
 
 		if ((dmactrlflags & DMA_CTRL_PEN) == 0)
@@ -952,11 +960,11 @@ static void _dma_rxenable(dma_info_t * di)
 }
 
 static void
-_dma_rx_param_get(dma_info_t * di, uint16 * rxoffset, uint16 * rxbufsize)
+_dma_rx_param_get(dma_info_t *di, u16 *rxoffset, u16 *rxbufsize)
 {
 	/* the normal values fit into 16 bits */
-	*rxoffset = (uint16) di->rxoffset;
-	*rxbufsize = (uint16) di->rxbufsize;
+	*rxoffset = (u16) di->rxoffset;
+	*rxbufsize = (u16) di->rxbufsize;
 }
 
 /* !! rx entry routine
@@ -968,7 +976,7 @@ _dma_rx_param_get(dma_info_t * di, uint16 * rxoffset, uint16 * rxbufsize)
  *   After it reaches the max size of buffer, the data continues in next DMA descriptor
  *   buffer WITHOUT DMA header
  */
-static void *BCMFASTPATH _dma_rx(dma_info_t * di)
+static void *BCMFASTPATH _dma_rx(dma_info_t *di)
 {
 	void *p, *head, *tail;
 	uint len;
@@ -976,33 +984,33 @@ static void *BCMFASTPATH _dma_rx(dma_info_t * di)
 	int resid = 0;
 
  next_frame:
-	head = _dma_getnextrxp(di, FALSE);
+	head = _dma_getnextrxp(di, false);
 	if (head == NULL)
-		return (NULL);
+		return NULL;
 
-	len = ltoh16(*(uint16 *) (PKTDATA(head)));
+	len = ltoh16(*(u16 *) (PKTDATA(head)));
 	DMA_TRACE(("%s: dma_rx len %d\n", di->name, len));
 
 #if defined(__mips__)
 	if (!len) {
-		while (!(len = *(uint16 *) OSL_UNCACHED(PKTDATA(head))))
-			OSL_DELAY(1);
+		while (!(len = *(u16 *) OSL_UNCACHED(PKTDATA(head))))
+			udelay(1);
 
-		*(uint16 *) PKTDATA(head) = htol16((uint16) len);
+		*(u16 *) PKTDATA(head) = htol16((u16) len);
 	}
 #endif				/* defined(__mips__) */
 
 	/* set actual length */
-	pkt_len = MIN((di->rxoffset + len), di->rxbufsize);
+	pkt_len = min((di->rxoffset + len), di->rxbufsize);
 	PKTSETLEN(head, pkt_len);
 	resid = len - (di->rxbufsize - di->rxoffset);
 
 	/* check for single or multi-buffer rx */
 	if (resid > 0) {
 		tail = head;
-		while ((resid > 0) && (p = _dma_getnextrxp(di, FALSE))) {
+		while ((resid > 0) && (p = _dma_getnextrxp(di, false))) {
 			PKTSETNEXT(tail, p);
-			pkt_len = MIN(resid, (int)di->rxbufsize);
+			pkt_len = min(resid, (int)di->rxbufsize);
 			PKTSETLEN(p, pkt_len);
 
 			tail = p;
@@ -1029,32 +1037,32 @@ static void *BCMFASTPATH _dma_rx(dma_info_t * di)
 		if ((di->hnddma.dmactrlflags & DMA_CTRL_RXMULTI) == 0) {
 			DMA_ERROR(("%s: dma_rx: bad frame length (%d)\n",
 				   di->name, len));
-			PKTFREE(di->osh, head, FALSE);
+			PKTFREE(di->osh, head, false);
 			di->hnddma.rxgiants++;
 			goto next_frame;
 		}
 	}
 
-	return (head);
+	return head;
 }
 
 /* post receive buffers
- *  return FALSE is refill failed completely and ring is empty
+ *  return false is refill failed completely and ring is empty
  *  this will stall the rx dma and user might want to call rxfill again asap
  *  This unlikely happens on memory-rich NIC, but often on memory-constrained dongle
  */
-static bool BCMFASTPATH _dma_rxfill(dma_info_t * di)
+static bool BCMFASTPATH _dma_rxfill(dma_info_t *di)
 {
 	void *p;
-	uint16 rxin, rxout;
-	uint32 flags = 0;
+	u16 rxin, rxout;
+	u32 flags = 0;
 	uint n;
 	uint i;
 	dmaaddr_t pa;
 	uint extra_offset = 0;
 	bool ring_empty;
 
-	ring_empty = FALSE;
+	ring_empty = false;
 
 	/*
 	 * Determine how many receive buffers we're lacking
@@ -1086,12 +1094,12 @@ static bool BCMFASTPATH _dma_rxfill(dma_info_t * di)
 				if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 					if (dma64_rxidle(di)) {
 						DMA_ERROR(("%s: rxfill64: ring is empty !\n", di->name));
-						ring_empty = TRUE;
+						ring_empty = true;
 					}
 				} else if (DMA32_ENAB(di)) {
 					if (dma32_rxidle(di)) {
 						DMA_ERROR(("%s: rxfill32: ring is empty !\n", di->name));
-						ring_empty = TRUE;
+						ring_empty = true;
 					}
 				} else
 					ASSERT(0);
@@ -1106,7 +1114,7 @@ static bool BCMFASTPATH _dma_rxfill(dma_info_t * di)
 		/* Do a cached write instead of uncached write since DMA_MAP
 		 * will flush the cache.
 		 */
-		*(uint32 *) (PKTDATA(p)) = 0;
+		*(u32 *) (PKTDATA(p)) = 0;
 
 		if (DMASGLIST_ENAB)
 			bzero(&di->rxp_dmah[rxout], sizeof(hnddma_seg_map_t));
@@ -1114,7 +1122,7 @@ static bool BCMFASTPATH _dma_rxfill(dma_info_t * di)
 		pa = DMA_MAP(di->osh, PKTDATA(p),
 			     di->rxbufsize, DMA_RX, p, &di->rxp_dmah[rxout]);
 
-		ASSERT(ISALIGNED(PHYSADDRLO(pa), 4));
+		ASSERT(IS_ALIGNED(PHYSADDRLO(pa), 4));
 
 		/* save the free packet pointer */
 		ASSERT(di->rxp[rxout] == NULL);
@@ -1155,12 +1163,12 @@ static bool BCMFASTPATH _dma_rxfill(dma_info_t * di)
 }
 
 /* like getnexttxp but no reclaim */
-static void *_dma_peeknexttxp(dma_info_t * di)
+static void *_dma_peeknexttxp(dma_info_t *di)
 {
 	uint end, i;
 
 	if (di->ntxd == 0)
-		return (NULL);
+		return NULL;
 
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 		end =
@@ -1176,18 +1184,18 @@ static void *_dma_peeknexttxp(dma_info_t * di)
 
 	for (i = di->txin; i != end; i = NEXTTXD(i))
 		if (di->txp[i])
-			return (di->txp[i]);
+			return di->txp[i];
 
-	return (NULL);
+	return NULL;
 }
 
 /* like getnextrxp but not take off the ring */
-static void *_dma_peeknextrxp(dma_info_t * di)
+static void *_dma_peeknextrxp(dma_info_t *di)
 {
 	uint end, i;
 
 	if (di->nrxd == 0)
-		return (NULL);
+		return NULL;
 
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 		end =
@@ -1203,12 +1211,12 @@ static void *_dma_peeknextrxp(dma_info_t * di)
 
 	for (i = di->rxin; i != end; i = NEXTRXD(i))
 		if (di->rxp[i])
-			return (di->rxp[i]);
+			return di->rxp[i];
 
-	return (NULL);
+	return NULL;
 }
 
-static void _dma_rxreclaim(dma_info_t * di)
+static void _dma_rxreclaim(dma_info_t *di)
 {
 	void *p;
 
@@ -1219,14 +1227,14 @@ static void _dma_rxreclaim(dma_info_t * di)
 
 	DMA_TRACE(("%s: dma_rxreclaim\n", di->name));
 
-	while ((p = _dma_getnextrxp(di, TRUE)))
-		PKTFREE(di->osh, p, FALSE);
+	while ((p = _dma_getnextrxp(di, true)))
+		PKTFREE(di->osh, p, false);
 }
 
-static void *BCMFASTPATH _dma_getnextrxp(dma_info_t * di, bool forceall)
+static void *BCMFASTPATH _dma_getnextrxp(dma_info_t *di, bool forceall)
 {
 	if (di->nrxd == 0)
-		return (NULL);
+		return NULL;
 
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 		return dma64_getnextrxp(di, forceall);
@@ -1236,22 +1244,22 @@ static void *BCMFASTPATH _dma_getnextrxp(dma_info_t * di, bool forceall)
 		ASSERT(0);
 }
 
-static void _dma_txblock(dma_info_t * di)
+static void _dma_txblock(dma_info_t *di)
 {
 	di->hnddma.txavail = 0;
 }
 
-static void _dma_txunblock(dma_info_t * di)
+static void _dma_txunblock(dma_info_t *di)
 {
 	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 }
 
-static uint _dma_txactive(dma_info_t * di)
+static uint _dma_txactive(dma_info_t *di)
 {
 	return NTXDACTIVE(di->txin, di->txout);
 }
 
-static uint _dma_txpending(dma_info_t * di)
+static uint _dma_txpending(dma_info_t *di)
 {
 	uint curr;
 
@@ -1270,7 +1278,7 @@ static uint _dma_txpending(dma_info_t * di)
 	return NTXDACTIVE(curr, di->txout);
 }
 
-static uint _dma_txcommitted(dma_info_t * di)
+static uint _dma_txcommitted(dma_info_t *di)
 {
 	uint ptr;
 	uint txin = di->txin;
@@ -1288,12 +1296,12 @@ static uint _dma_txcommitted(dma_info_t * di)
 	return NTXDACTIVE(di->txin, ptr);
 }
 
-static uint _dma_rxactive(dma_info_t * di)
+static uint _dma_rxactive(dma_info_t *di)
 {
 	return NRXDACTIVE(di->rxin, di->rxout);
 }
 
-static void _dma_counterreset(dma_info_t * di)
+static void _dma_counterreset(dma_info_t *di)
 {
 	/* reset all software counter */
 	di->hnddma.rxgiants = 0;
@@ -1301,13 +1309,13 @@ static void _dma_counterreset(dma_info_t * di)
 	di->hnddma.txnobuf = 0;
 }
 
-static uint _dma_ctrlflags(dma_info_t * di, uint mask, uint flags)
+static uint _dma_ctrlflags(dma_info_t *di, uint mask, uint flags)
 {
 	uint dmactrlflags = di->hnddma.dmactrlflags;
 
 	if (di == NULL) {
 		DMA_ERROR(("%s: _dma_ctrlflags: NULL dma handle\n", di->name));
-		return (0);
+		return 0;
 	}
 
 	ASSERT((flags & ~mask) == 0);
@@ -1317,7 +1325,7 @@ static uint _dma_ctrlflags(dma_info_t * di, uint mask, uint flags)
 
 	/* If trying to enable parity, check if parity is actually supported */
 	if (dmactrlflags & DMA_CTRL_PEN) {
-		uint32 control;
+		u32 control;
 
 		if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 			control = R_REG(di->osh, &di->d64txregs->control);
@@ -1350,35 +1358,35 @@ static uint _dma_ctrlflags(dma_info_t * di, uint mask, uint flags)
 
 	di->hnddma.dmactrlflags = dmactrlflags;
 
-	return (dmactrlflags);
+	return dmactrlflags;
 }
 
 /* get the address of the var in order to change later */
-static uintptr _dma_getvar(dma_info_t * di, const char *name)
+static unsigned long _dma_getvar(dma_info_t *di, const char *name)
 {
 	if (!strcmp(name, "&txavail"))
-		return ((uintptr) & (di->hnddma.txavail));
+		return (unsigned long)&(di->hnddma.txavail);
 	else {
 		ASSERT(0);
 	}
-	return (0);
+	return 0;
 }
 
-void dma_txpioloopback(osl_t * osh, dma32regs_t * regs)
+void dma_txpioloopback(osl_t *osh, dma32regs_t *regs)
 {
 	OR_REG(osh, &regs->control, XC_LE);
 }
 
 static
-uint8 dma_align_sizetobits(uint size)
+u8 dma_align_sizetobits(uint size)
 {
-	uint8 bitpos = 0;
+	u8 bitpos = 0;
 	ASSERT(size);
 	ASSERT(!(size & (size - 1)));
 	while (size >>= 1) {
 		bitpos++;
 	}
-	return (bitpos);
+	return bitpos;
 }
 
 /* This function ensures that the DMA descriptor ring will not get allocated
@@ -1387,21 +1395,20 @@ uint8 dma_align_sizetobits(uint size)
  * descriptor ring size aligned location. This will ensure that the ring will
  * not cross page boundary
  */
-static void *dma_ringalloc(osl_t * osh, uint32 boundary, uint size,
-			   uint16 * alignbits, uint * alloced,
-			   dmaaddr_t * descpa, osldma_t ** dmah)
+static void *dma_ringalloc(osl_t *osh, u32 boundary, uint size,
+			   u16 *alignbits, uint *alloced,
+			   dmaaddr_t *descpa, osldma_t **dmah)
 {
 	void *va;
-	uint32 desc_strtaddr;
-	uint32 alignbytes = 1 << *alignbits;
+	u32 desc_strtaddr;
+	u32 alignbytes = 1 << *alignbits;
 
-	if (NULL ==
-	    (va =
-	     DMA_ALLOC_CONSISTENT(osh, size, *alignbits, alloced, descpa,
-				  dmah)))
+	va = DMA_ALLOC_CONSISTENT(osh, size, *alignbits, alloced, descpa,
+		dmah);
+	if (NULL == va)
 		return NULL;
 
-	desc_strtaddr = (uint32) ROUNDUP((uintptr) va, alignbytes);
+	desc_strtaddr = (u32) roundup((unsigned long)va, alignbytes);
 	if (((desc_strtaddr + size - 1) & boundary) != (desc_strtaddr
 							& boundary)) {
 		*alignbits = dma_align_sizetobits(size);
@@ -1414,9 +1421,9 @@ static void *dma_ringalloc(osl_t * osh, uint32 boundary, uint size,
 
 /* 32-bit DMA functions */
 
-static void dma32_txinit(dma_info_t * di)
+static void dma32_txinit(dma_info_t *di)
 {
-	uint32 control = XC_XE;
+	u32 control = XC_XE;
 
 	DMA_TRACE(("%s: dma_txinit\n", di->name));
 
@@ -1427,7 +1434,7 @@ static void dma32_txinit(dma_info_t * di)
 	di->hnddma.txavail = di->ntxd - 1;
 
 	/* clear tx descriptor ring */
-	BZERO_SM((void *)(uintptr) di->txd32, (di->ntxd * sizeof(dma32dd_t)));
+	BZERO_SM((void *)di->txd32, (di->ntxd * sizeof(dma32dd_t)));
 
 	if ((di->hnddma.dmactrlflags & DMA_CTRL_PEN) == 0)
 		control |= XC_PD;
@@ -1435,16 +1442,16 @@ static void dma32_txinit(dma_info_t * di)
 	_dma_ddtable_init(di, DMA_TX, di->txdpa);
 }
 
-static bool dma32_txenabled(dma_info_t * di)
+static bool dma32_txenabled(dma_info_t *di)
 {
-	uint32 xc;
+	u32 xc;
 
 	/* If the chip is dead, it is not enabled :-) */
 	xc = R_REG(di->osh, &di->d32txregs->control);
-	return ((xc != 0xffffffff) && (xc & XC_XE));
+	return (xc != 0xffffffff) && (xc & XC_XE);
 }
 
-static void dma32_txsuspend(dma_info_t * di)
+static void dma32_txsuspend(dma_info_t *di)
 {
 	DMA_TRACE(("%s: dma_txsuspend\n", di->name));
 
@@ -1454,7 +1461,7 @@ static void dma32_txsuspend(dma_info_t * di)
 	OR_REG(di->osh, &di->d32txregs->control, XC_SE);
 }
 
-static void dma32_txresume(dma_info_t * di)
+static void dma32_txresume(dma_info_t *di)
 {
 	DMA_TRACE(("%s: dma_txresume\n", di->name));
 
@@ -1464,13 +1471,13 @@ static void dma32_txresume(dma_info_t * di)
 	AND_REG(di->osh, &di->d32txregs->control, ~XC_SE);
 }
 
-static bool dma32_txsuspended(dma_info_t * di)
+static bool dma32_txsuspended(dma_info_t *di)
 {
 	return (di->ntxd == 0)
 	    || ((R_REG(di->osh, &di->d32txregs->control) & XC_SE) == XC_SE);
 }
 
-static void dma32_txreclaim(dma_info_t * di, txd_range_t range)
+static void dma32_txreclaim(dma_info_t *di, txd_range_t range)
 {
 	void *p;
 
@@ -1484,29 +1491,29 @@ static void dma32_txreclaim(dma_info_t * di, txd_range_t range)
 		return;
 
 	while ((p = dma32_getnexttxp(di, range)))
-		PKTFREE(di->osh, p, TRUE);
+		PKTFREE(di->osh, p, true);
 }
 
-static bool dma32_txstopped(dma_info_t * di)
+static bool dma32_txstopped(dma_info_t *di)
 {
 	return ((R_REG(di->osh, &di->d32txregs->status) & XS_XS_MASK) ==
 		XS_XS_STOPPED);
 }
 
-static bool dma32_rxstopped(dma_info_t * di)
+static bool dma32_rxstopped(dma_info_t *di)
 {
 	return ((R_REG(di->osh, &di->d32rxregs->status) & RS_RS_MASK) ==
 		RS_RS_STOPPED);
 }
 
-static bool dma32_alloc(dma_info_t * di, uint direction)
+static bool dma32_alloc(dma_info_t *di, uint direction)
 {
 	uint size;
 	uint ddlen;
 	void *va;
 	uint alloced;
-	uint16 align;
-	uint16 align_bits;
+	u16 align;
+	u16 align_bits;
 
 	ddlen = sizeof(dma32dd_t);
 
@@ -1517,19 +1524,18 @@ static bool dma32_alloc(dma_info_t * di, uint direction)
 	align = (1 << align_bits);
 
 	if (direction == DMA_TX) {
-		if ((va =
-		     dma_ringalloc(di->osh, D32RINGALIGN, size, &align_bits,
-				   &alloced, &di->txdpaorig,
-				   &di->tx_dmah)) == NULL) {
+		va = dma_ringalloc(di->osh, D32RINGALIGN, size, &align_bits,
+			&alloced, &di->txdpaorig, &di->tx_dmah);
+		if (va == NULL) {
 			DMA_ERROR(("%s: dma_alloc: DMA_ALLOC_CONSISTENT(ntxd) failed\n", di->name));
-			return FALSE;
+			return false;
 		}
 
 		PHYSADDRHISET(di->txdpa, 0);
 		ASSERT(PHYSADDRHI(di->txdpaorig) == 0);
-		di->txd32 = (dma32dd_t *) ROUNDUP((uintptr) va, align);
+		di->txd32 = (dma32dd_t *) roundup((unsigned long)va, align);
 		di->txdalign =
-		    (uint) ((int8 *) (uintptr) di->txd32 - (int8 *) va);
+		    (uint) ((s8 *)di->txd32 - (s8 *) va);
 
 		PHYSADDRLOSET(di->txdpa,
 			      PHYSADDRLO(di->txdpaorig) + di->txdalign);
@@ -1537,39 +1543,38 @@ static bool dma32_alloc(dma_info_t * di, uint direction)
 		ASSERT(PHYSADDRLO(di->txdpa) >= PHYSADDRLO(di->txdpaorig));
 
 		di->txdalloc = alloced;
-		ASSERT(ISALIGNED((uintptr) di->txd32, align));
+		ASSERT(IS_ALIGNED((unsigned long)di->txd32, align));
 	} else {
-		if ((va =
-		     dma_ringalloc(di->osh, D32RINGALIGN, size, &align_bits,
-				   &alloced, &di->rxdpaorig,
-				   &di->rx_dmah)) == NULL) {
+		va = dma_ringalloc(di->osh, D32RINGALIGN, size, &align_bits,
+			&alloced, &di->rxdpaorig, &di->rx_dmah);
+		if (va == NULL) {
 			DMA_ERROR(("%s: dma_alloc: DMA_ALLOC_CONSISTENT(nrxd) failed\n", di->name));
-			return FALSE;
+			return false;
 		}
 
 		PHYSADDRHISET(di->rxdpa, 0);
 		ASSERT(PHYSADDRHI(di->rxdpaorig) == 0);
-		di->rxd32 = (dma32dd_t *) ROUNDUP((uintptr) va, align);
+		di->rxd32 = (dma32dd_t *) roundup((unsigned long)va, align);
 		di->rxdalign =
-		    (uint) ((int8 *) (uintptr) di->rxd32 - (int8 *) va);
+		    (uint) ((s8 *)di->rxd32 - (s8 *) va);
 
 		PHYSADDRLOSET(di->rxdpa,
 			      PHYSADDRLO(di->rxdpaorig) + di->rxdalign);
 		/* Make sure that alignment didn't overflow */
 		ASSERT(PHYSADDRLO(di->rxdpa) >= PHYSADDRLO(di->rxdpaorig));
 		di->rxdalloc = alloced;
-		ASSERT(ISALIGNED((uintptr) di->rxd32, align));
+		ASSERT(IS_ALIGNED((unsigned long)di->rxd32, align));
 	}
 
-	return TRUE;
+	return true;
 }
 
-static bool dma32_txreset(dma_info_t * di)
+static bool dma32_txreset(dma_info_t *di)
 {
-	uint32 status;
+	u32 status;
 
 	if (di->ntxd == 0)
-		return TRUE;
+		return true;
 
 	/* suspend tx DMA first */
 	W_REG(di->osh, &di->d32txregs->control, XC_SE);
@@ -1584,49 +1589,49 @@ static bool dma32_txreset(dma_info_t * di)
 		  XS_XS_DISABLED), 10000);
 
 	/* wait for the last transaction to complete */
-	OSL_DELAY(300);
+	udelay(300);
 
-	return (status == XS_XS_DISABLED);
+	return status == XS_XS_DISABLED;
 }
 
-static bool dma32_rxidle(dma_info_t * di)
+static bool dma32_rxidle(dma_info_t *di)
 {
 	DMA_TRACE(("%s: dma_rxidle\n", di->name));
 
 	if (di->nrxd == 0)
-		return TRUE;
+		return true;
 
 	return ((R_REG(di->osh, &di->d32rxregs->status) & RS_CD_MASK) ==
 		R_REG(di->osh, &di->d32rxregs->ptr));
 }
 
-static bool dma32_rxreset(dma_info_t * di)
+static bool dma32_rxreset(dma_info_t *di)
 {
-	uint32 status;
+	u32 status;
 
 	if (di->nrxd == 0)
-		return TRUE;
+		return true;
 
 	W_REG(di->osh, &di->d32rxregs->control, 0);
 	SPINWAIT(((status = (R_REG(di->osh,
 				   &di->d32rxregs->status) & RS_RS_MASK)) !=
 		  RS_RS_DISABLED), 10000);
 
-	return (status == RS_RS_DISABLED);
+	return status == RS_RS_DISABLED;
 }
 
-static bool dma32_rxenabled(dma_info_t * di)
+static bool dma32_rxenabled(dma_info_t *di)
 {
-	uint32 rc;
+	u32 rc;
 
 	rc = R_REG(di->osh, &di->d32rxregs->control);
-	return ((rc != 0xffffffff) && (rc & RC_RE));
+	return (rc != 0xffffffff) && (rc & RC_RE);
 }
 
-static bool dma32_txsuspendedidle(dma_info_t * di)
+static bool dma32_txsuspendedidle(dma_info_t *di)
 {
 	if (di->ntxd == 0)
-		return TRUE;
+		return true;
 
 	if (!(R_REG(di->osh, &di->d32txregs->control) & XC_SE))
 		return 0;
@@ -1634,7 +1639,7 @@ static bool dma32_txsuspendedidle(dma_info_t * di)
 	if ((R_REG(di->osh, &di->d32txregs->status) & XS_XS_MASK) != XS_XS_IDLE)
 		return 0;
 
-	OSL_DELAY(2);
+	udelay(2);
 	return ((R_REG(di->osh, &di->d32txregs->status) & XS_XS_MASK) ==
 		XS_XS_IDLE);
 }
@@ -1646,13 +1651,13 @@ static bool dma32_txsuspendedidle(dma_info_t * di)
  * WARNING: call must check the return value for error.
  *   the error(toss frames) could be fatal and cause many subsequent hard to debug problems
  */
-static int dma32_txfast(dma_info_t * di, void *p0, bool commit)
+static int dma32_txfast(dma_info_t *di, void *p0, bool commit)
 {
 	void *p, *next;
-	uchar *data;
+	unsigned char *data;
 	uint len;
-	uint16 txout;
-	uint32 flags = 0;
+	u16 txout;
+	u32 flags = 0;
 	dmaaddr_t pa;
 
 	DMA_TRACE(("%s: dma_txfast\n", di->name));
@@ -1752,14 +1757,14 @@ static int dma32_txfast(dma_info_t * di, void *p0, bool commit)
 	/* tx flow control */
 	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 
-	return (0);
+	return 0;
 
  outoftxd:
 	DMA_ERROR(("%s: dma_txfast: out of txds\n", di->name));
-	PKTFREE(di->osh, p0, TRUE);
+	PKTFREE(di->osh, p0, true);
 	di->hnddma.txavail = 0;
 	di->hnddma.txnobuf++;
-	return (-1);
+	return -1;
 }
 
 /*
@@ -1772,10 +1777,10 @@ static int dma32_txfast(dma_info_t * di, void *p0, bool commit)
  * If range is HNDDMA_RANGE_ALL, reclaim all txd(s) posted to the ring and
  * return associated packet regardless of the value of hardware pointers.
  */
-static void *dma32_getnexttxp(dma_info_t * di, txd_range_t range)
+static void *dma32_getnexttxp(dma_info_t *di, txd_range_t range)
 {
-	uint16 start, end, i;
-	uint16 active_desc;
+	u16 start, end, i;
+	u16 active_desc;
 	void *txp;
 
 	DMA_TRACE(("%s: dma_getnexttxp %s\n", di->name,
@@ -1785,7 +1790,7 @@ static void *dma32_getnexttxp(dma_info_t * di, txd_range_t range)
 		    "transfered")));
 
 	if (di->ntxd == 0)
-		return (NULL);
+		return NULL;
 
 	txp = NULL;
 
@@ -1796,14 +1801,14 @@ static void *dma32_getnexttxp(dma_info_t * di, txd_range_t range)
 		dma32regs_t *dregs = di->d32txregs;
 
 		end =
-		    (uint16) B2I(R_REG(di->osh, &dregs->status) & XS_CD_MASK,
+		    (u16) B2I(R_REG(di->osh, &dregs->status) & XS_CD_MASK,
 				 dma32dd_t);
 
 		if (range == HNDDMA_RANGE_TRANSFERED) {
 			active_desc =
-			    (uint16) ((R_REG(di->osh, &dregs->status) &
+			    (u16) ((R_REG(di->osh, &dregs->status) &
 				       XS_AD_MASK) >> XS_AD_SHIFT);
-			active_desc = (uint16) B2I(active_desc, dma32dd_t);
+			active_desc = (u16) B2I(active_desc, dma32dd_t);
 			if (end != active_desc)
 				end = PREVTXD(active_desc);
 		}
@@ -1850,14 +1855,14 @@ static void *dma32_getnexttxp(dma_info_t * di, txd_range_t range)
 	/* tx flow control */
 	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 
-	return (txp);
+	return txp;
 
  bogus:
 	DMA_NONE(("dma_getnexttxp: bogus curr: start %d end %d txout %d force %d\n", start, end, di->txout, forceall));
-	return (NULL);
+	return NULL;
 }
 
-static void *dma32_getnextrxp(dma_info_t * di, bool forceall)
+static void *dma32_getnextrxp(dma_info_t *di, bool forceall)
 {
 	uint i, curr;
 	void *rxp;
@@ -1869,14 +1874,14 @@ static void *dma32_getnextrxp(dma_info_t * di, bool forceall)
 
 	/* return if no packets posted */
 	if (i == di->rxout)
-		return (NULL);
+		return NULL;
 
 	curr =
 	    B2I(R_REG(di->osh, &di->d32rxregs->status) & RS_CD_MASK, dma32dd_t);
 
 	/* ignore curr if forceall */
 	if (!forceall && (i == curr))
-		return (NULL);
+		return NULL;
 
 	/* get the packet pointer that corresponds to the rx descriptor */
 	rxp = di->rxp[i];
@@ -1895,25 +1900,25 @@ static void *dma32_getnextrxp(dma_info_t * di, bool forceall)
 
 	di->rxin = NEXTRXD(i);
 
-	return (rxp);
+	return rxp;
 }
 
 /*
  * Rotate all active tx dma ring entries "forward" by (ActiveDescriptor - txin).
  */
-static void dma32_txrotate(dma_info_t * di)
+static void dma32_txrotate(dma_info_t *di)
 {
-	uint16 ad;
+	u16 ad;
 	uint nactive;
 	uint rot;
-	uint16 old, new;
-	uint32 w;
-	uint16 first, last;
+	u16 old, new;
+	u32 w;
+	u16 first, last;
 
 	ASSERT(dma32_txsuspendedidle(di));
 
 	nactive = _dma_txactive(di);
-	ad = (uint16) (B2I
+	ad = (u16) (B2I
 		       (((R_REG(di->osh, &di->d32txregs->status) & XS_AD_MASK)
 			 >> XS_AD_SHIFT), dma32dd_t));
 	rot = TXD(ad - di->txin);
@@ -1971,9 +1976,9 @@ static void dma32_txrotate(dma_info_t * di)
 
 /* 64-bit DMA functions */
 
-static void dma64_txinit(dma_info_t * di)
+static void dma64_txinit(dma_info_t *di)
 {
-	uint32 control = D64_XC_XE;
+	u32 control = D64_XC_XE;
 
 	DMA_TRACE(("%s: dma_txinit\n", di->name));
 
@@ -1984,7 +1989,7 @@ static void dma64_txinit(dma_info_t * di)
 	di->hnddma.txavail = di->ntxd - 1;
 
 	/* clear tx descriptor ring */
-	BZERO_SM((void *)(uintptr) di->txd64, (di->ntxd * sizeof(dma64dd_t)));
+	BZERO_SM((void *)di->txd64, (di->ntxd * sizeof(dma64dd_t)));
 
 	/* DMA engine with out alignment requirement requires table to be inited
 	 * before enabling the engine
@@ -2003,16 +2008,16 @@ static void dma64_txinit(dma_info_t * di)
 		_dma_ddtable_init(di, DMA_TX, di->txdpa);
 }
 
-static bool dma64_txenabled(dma_info_t * di)
+static bool dma64_txenabled(dma_info_t *di)
 {
-	uint32 xc;
+	u32 xc;
 
 	/* If the chip is dead, it is not enabled :-) */
 	xc = R_REG(di->osh, &di->d64txregs->control);
-	return ((xc != 0xffffffff) && (xc & D64_XC_XE));
+	return (xc != 0xffffffff) && (xc & D64_XC_XE);
 }
 
-static void dma64_txsuspend(dma_info_t * di)
+static void dma64_txsuspend(dma_info_t *di)
 {
 	DMA_TRACE(("%s: dma_txsuspend\n", di->name));
 
@@ -2022,7 +2027,7 @@ static void dma64_txsuspend(dma_info_t * di)
 	OR_REG(di->osh, &di->d64txregs->control, D64_XC_SE);
 }
 
-static void dma64_txresume(dma_info_t * di)
+static void dma64_txresume(dma_info_t *di)
 {
 	DMA_TRACE(("%s: dma_txresume\n", di->name));
 
@@ -2032,14 +2037,14 @@ static void dma64_txresume(dma_info_t * di)
 	AND_REG(di->osh, &di->d64txregs->control, ~D64_XC_SE);
 }
 
-static bool dma64_txsuspended(dma_info_t * di)
+static bool dma64_txsuspended(dma_info_t *di)
 {
 	return (di->ntxd == 0) ||
 	    ((R_REG(di->osh, &di->d64txregs->control) & D64_XC_SE) ==
 	     D64_XC_SE);
 }
 
-static void BCMFASTPATH dma64_txreclaim(dma_info_t * di, txd_range_t range)
+static void BCMFASTPATH dma64_txreclaim(dma_info_t *di, txd_range_t range)
 {
 	void *p;
 
@@ -2055,30 +2060,30 @@ static void BCMFASTPATH dma64_txreclaim(dma_info_t * di, txd_range_t range)
 	while ((p = dma64_getnexttxp(di, range))) {
 		/* For unframed data, we don't have any packets to free */
 		if (!(di->hnddma.dmactrlflags & DMA_CTRL_UNFRAMED))
-			PKTFREE(di->osh, p, TRUE);
+			PKTFREE(di->osh, p, true);
 	}
 }
 
-static bool dma64_txstopped(dma_info_t * di)
+static bool dma64_txstopped(dma_info_t *di)
 {
 	return ((R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_XS_MASK) ==
 		D64_XS0_XS_STOPPED);
 }
 
-static bool dma64_rxstopped(dma_info_t * di)
+static bool dma64_rxstopped(dma_info_t *di)
 {
 	return ((R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_RS_MASK) ==
 		D64_RS0_RS_STOPPED);
 }
 
-static bool dma64_alloc(dma_info_t * di, uint direction)
+static bool dma64_alloc(dma_info_t *di, uint direction)
 {
-	uint16 size;
+	u16 size;
 	uint ddlen;
 	void *va;
 	uint alloced = 0;
-	uint16 align;
-	uint16 align_bits;
+	u16 align;
+	u16 align_bits;
 
 	ddlen = sizeof(dma64dd_t);
 
@@ -2087,17 +2092,15 @@ static bool dma64_alloc(dma_info_t * di, uint direction)
 	align = (1 << align_bits);
 
 	if (direction == DMA_TX) {
-		if ((va =
-		     dma_ringalloc(di->osh, D64RINGALIGN, size, &align_bits,
-				   &alloced, &di->txdpaorig,
-				   &di->tx_dmah)) == NULL) {
+		va = dma_ringalloc(di->osh, D64RINGALIGN, size, &align_bits,
+			&alloced, &di->txdpaorig, &di->tx_dmah);
+		if (va == NULL) {
 			DMA_ERROR(("%s: dma64_alloc: DMA_ALLOC_CONSISTENT(ntxd) failed\n", di->name));
-			return FALSE;
+			return false;
 		}
 		align = (1 << align_bits);
-		di->txd64 = (dma64dd_t *) ROUNDUP((uintptr) va, align);
-		di->txdalign =
-		    (uint) ((int8 *) (uintptr) di->txd64 - (int8 *) va);
+		di->txd64 = (dma64dd_t *) roundup((unsigned long)va, align);
+		di->txdalign = (uint) ((s8 *)di->txd64 - (s8 *) va);
 		PHYSADDRLOSET(di->txdpa,
 			      PHYSADDRLO(di->txdpaorig) + di->txdalign);
 		/* Make sure that alignment didn't overflow */
@@ -2105,19 +2108,17 @@ static bool dma64_alloc(dma_info_t * di, uint direction)
 
 		PHYSADDRHISET(di->txdpa, PHYSADDRHI(di->txdpaorig));
 		di->txdalloc = alloced;
-		ASSERT(ISALIGNED((uintptr) di->txd64, align));
+		ASSERT(IS_ALIGNED((unsigned long)di->txd64, align));
 	} else {
-		if ((va =
-		     dma_ringalloc(di->osh, D64RINGALIGN, size, &align_bits,
-				   &alloced, &di->rxdpaorig,
-				   &di->rx_dmah)) == NULL) {
+		va = dma_ringalloc(di->osh, D64RINGALIGN, size, &align_bits,
+			&alloced, &di->rxdpaorig, &di->rx_dmah);
+		if (va == NULL) {
 			DMA_ERROR(("%s: dma64_alloc: DMA_ALLOC_CONSISTENT(nrxd) failed\n", di->name));
-			return FALSE;
+			return false;
 		}
 		align = (1 << align_bits);
-		di->rxd64 = (dma64dd_t *) ROUNDUP((uintptr) va, align);
-		di->rxdalign =
-		    (uint) ((int8 *) (uintptr) di->rxd64 - (int8 *) va);
+		di->rxd64 = (dma64dd_t *) roundup((unsigned long)va, align);
+		di->rxdalign = (uint) ((s8 *)di->rxd64 - (s8 *) va);
 		PHYSADDRLOSET(di->rxdpa,
 			      PHYSADDRLO(di->rxdpaorig) + di->rxdalign);
 		/* Make sure that alignment didn't overflow */
@@ -2125,18 +2126,18 @@ static bool dma64_alloc(dma_info_t * di, uint direction)
 
 		PHYSADDRHISET(di->rxdpa, PHYSADDRHI(di->rxdpaorig));
 		di->rxdalloc = alloced;
-		ASSERT(ISALIGNED((uintptr) di->rxd64, align));
+		ASSERT(IS_ALIGNED((unsigned long)di->rxd64, align));
 	}
 
-	return TRUE;
+	return true;
 }
 
-static bool dma64_txreset(dma_info_t * di)
+static bool dma64_txreset(dma_info_t *di)
 {
-	uint32 status;
+	u32 status;
 
 	if (di->ntxd == 0)
-		return TRUE;
+		return true;
 
 	/* suspend tx DMA first */
 	W_REG(di->osh, &di->d64txregs->control, D64_XC_SE);
@@ -2151,50 +2152,50 @@ static bool dma64_txreset(dma_info_t * di)
 		  != D64_XS0_XS_DISABLED), 10000);
 
 	/* wait for the last transaction to complete */
-	OSL_DELAY(300);
+	udelay(300);
 
-	return (status == D64_XS0_XS_DISABLED);
+	return status == D64_XS0_XS_DISABLED;
 }
 
-static bool dma64_rxidle(dma_info_t * di)
+static bool dma64_rxidle(dma_info_t *di)
 {
 	DMA_TRACE(("%s: dma_rxidle\n", di->name));
 
 	if (di->nrxd == 0)
-		return TRUE;
+		return true;
 
 	return ((R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_CD_MASK) ==
 		(R_REG(di->osh, &di->d64rxregs->ptr) & D64_RS0_CD_MASK));
 }
 
-static bool dma64_rxreset(dma_info_t * di)
+static bool dma64_rxreset(dma_info_t *di)
 {
-	uint32 status;
+	u32 status;
 
 	if (di->nrxd == 0)
-		return TRUE;
+		return true;
 
 	W_REG(di->osh, &di->d64rxregs->control, 0);
 	SPINWAIT(((status =
 		   (R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_RS_MASK))
 		  != D64_RS0_RS_DISABLED), 10000);
 
-	return (status == D64_RS0_RS_DISABLED);
+	return status == D64_RS0_RS_DISABLED;
 }
 
-static bool dma64_rxenabled(dma_info_t * di)
+static bool dma64_rxenabled(dma_info_t *di)
 {
-	uint32 rc;
+	u32 rc;
 
 	rc = R_REG(di->osh, &di->d64rxregs->control);
-	return ((rc != 0xffffffff) && (rc & D64_RC_RE));
+	return (rc != 0xffffffff) && (rc & D64_RC_RE);
 }
 
-static bool dma64_txsuspendedidle(dma_info_t * di)
+static bool dma64_txsuspendedidle(dma_info_t *di)
 {
 
 	if (di->ntxd == 0)
-		return TRUE;
+		return true;
 
 	if (!(R_REG(di->osh, &di->d64txregs->control) & D64_XC_SE))
 		return 0;
@@ -2210,11 +2211,11 @@ static bool dma64_txsuspendedidle(dma_info_t * di)
  * We return a pointer to the beginning of the DATA buffer of the current descriptor.
  * If DMA is idle, we return NULL.
  */
-static void *dma64_getpos(dma_info_t * di, bool direction)
+static void *dma64_getpos(dma_info_t *di, bool direction)
 {
 	void *va;
 	bool idle;
-	uint32 cd_offset;
+	u32 cd_offset;
 
 	if (direction == DMA_TX) {
 		cd_offset =
@@ -2245,10 +2246,10 @@ static void *dma64_getpos(dma_info_t * di, bool direction)
  * Each call to this is results in a single descriptor being added for "len" bytes of
  * data starting at "buf", it doesn't handle chained buffers.
  */
-static int dma64_txunframed(dma_info_t * di, void *buf, uint len, bool commit)
+static int dma64_txunframed(dma_info_t *di, void *buf, uint len, bool commit)
 {
-	uint16 txout;
-	uint32 flags = 0;
+	u16 txout;
+	u32 flags = 0;
 	dmaaddr_t pa;		/* phys addr */
 
 	txout = di->txout;
@@ -2286,26 +2287,26 @@ static int dma64_txunframed(dma_info_t * di, void *buf, uint len, bool commit)
 	/* tx flow control */
 	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 
-	return (0);
+	return 0;
 
  outoftxd:
 	DMA_ERROR(("%s: %s: out of txds !!!\n", di->name, __func__));
 	di->hnddma.txavail = 0;
 	di->hnddma.txnobuf++;
-	return (-1);
+	return -1;
 }
 
 /* !! tx entry routine
  * WARNING: call must check the return value for error.
  *   the error(toss frames) could be fatal and cause many subsequent hard to debug problems
  */
-static int BCMFASTPATH dma64_txfast(dma_info_t * di, void *p0, bool commit)
+static int BCMFASTPATH dma64_txfast(dma_info_t *di, void *p0, bool commit)
 {
 	void *p, *next;
-	uchar *data;
+	unsigned char *data;
 	uint len;
-	uint16 txout;
-	uint32 flags = 0;
+	u16 txout;
+	u32 flags = 0;
 	dmaaddr_t pa;
 
 	DMA_TRACE(("%s: dma_txfast\n", di->name));
@@ -2404,14 +2405,14 @@ static int BCMFASTPATH dma64_txfast(dma_info_t * di, void *p0, bool commit)
 	/* tx flow control */
 	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 
-	return (0);
+	return 0;
 
  outoftxd:
 	DMA_ERROR(("%s: dma_txfast: out of txds !!!\n", di->name));
-	PKTFREE(di->osh, p0, TRUE);
+	PKTFREE(di->osh, p0, true);
 	di->hnddma.txavail = 0;
 	di->hnddma.txnobuf++;
-	return (-1);
+	return -1;
 }
 
 /*
@@ -2424,10 +2425,10 @@ static int BCMFASTPATH dma64_txfast(dma_info_t * di, void *p0, bool commit)
  * If range is HNDDMA_RANGE_ALL, reclaim all txd(s) posted to the ring and
  * return associated packet regardless of the value of hardware pointers.
  */
-static void *BCMFASTPATH dma64_getnexttxp(dma_info_t * di, txd_range_t range)
+static void *BCMFASTPATH dma64_getnexttxp(dma_info_t *di, txd_range_t range)
 {
-	uint16 start, end, i;
-	uint16 active_desc;
+	u16 start, end, i;
+	u16 active_desc;
 	void *txp;
 
 	DMA_TRACE(("%s: dma_getnexttxp %s\n", di->name,
@@ -2437,7 +2438,7 @@ static void *BCMFASTPATH dma64_getnexttxp(dma_info_t * di, txd_range_t range)
 		    "transfered")));
 
 	if (di->ntxd == 0)
-		return (NULL);
+		return NULL;
 
 	txp = NULL;
 
@@ -2448,14 +2449,14 @@ static void *BCMFASTPATH dma64_getnexttxp(dma_info_t * di, txd_range_t range)
 		dma64regs_t *dregs = di->d64txregs;
 
 		end =
-		    (uint16) (B2I
+		    (u16) (B2I
 			      (((R_REG(di->osh, &dregs->status0) &
 				 D64_XS0_CD_MASK) -
 				di->xmtptrbase) & D64_XS0_CD_MASK, dma64dd_t));
 
 		if (range == HNDDMA_RANGE_TRANSFERED) {
 			active_desc =
-			    (uint16) (R_REG(di->osh, &dregs->status1) &
+			    (u16) (R_REG(di->osh, &dregs->status1) &
 				      D64_XS1_AD_MASK);
 			active_desc =
 			    (active_desc - di->xmtptrbase) & D64_XS0_CD_MASK;
@@ -2509,14 +2510,14 @@ static void *BCMFASTPATH dma64_getnexttxp(dma_info_t * di, txd_range_t range)
 	/* tx flow control */
 	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 
-	return (txp);
+	return txp;
 
  bogus:
 	DMA_NONE(("dma_getnexttxp: bogus curr: start %d end %d txout %d force %d\n", start, end, di->txout, forceall));
-	return (NULL);
+	return NULL;
 }
 
-static void *BCMFASTPATH dma64_getnextrxp(dma_info_t * di, bool forceall)
+static void *BCMFASTPATH dma64_getnextrxp(dma_info_t *di, bool forceall)
 {
 	uint i, curr;
 	void *rxp;
@@ -2529,7 +2530,7 @@ static void *BCMFASTPATH dma64_getnextrxp(dma_info_t * di, bool forceall)
 
 	/* return if no packets posted */
 	if (i == di->rxout)
-		return (NULL);
+		return NULL;
 
 	curr =
 	    B2I(((R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_CD_MASK) -
@@ -2537,7 +2538,7 @@ static void *BCMFASTPATH dma64_getnextrxp(dma_info_t * di, bool forceall)
 
 	/* ignore curr if forceall */
 	if (!forceall && (i == curr))
-		return (NULL);
+		return NULL;
 
 	/* get the packet pointer that corresponds to the rx descriptor */
 	rxp = di->rxp[i];
@@ -2559,34 +2560,34 @@ static void *BCMFASTPATH dma64_getnextrxp(dma_info_t * di, bool forceall)
 
 	di->rxin = NEXTRXD(i);
 
-	return (rxp);
+	return rxp;
 }
 
-static bool _dma64_addrext(osl_t * osh, dma64regs_t * dma64regs)
+static bool _dma64_addrext(osl_t *osh, dma64regs_t * dma64regs)
 {
-	uint32 w;
+	u32 w;
 	OR_REG(osh, &dma64regs->control, D64_XC_AE);
 	w = R_REG(osh, &dma64regs->control);
 	AND_REG(osh, &dma64regs->control, ~D64_XC_AE);
-	return ((w & D64_XC_AE) == D64_XC_AE);
+	return (w & D64_XC_AE) == D64_XC_AE;
 }
 
 /*
  * Rotate all active tx dma ring entries "forward" by (ActiveDescriptor - txin).
  */
-static void dma64_txrotate(dma_info_t * di)
+static void dma64_txrotate(dma_info_t *di)
 {
-	uint16 ad;
+	u16 ad;
 	uint nactive;
 	uint rot;
-	uint16 old, new;
-	uint32 w;
-	uint16 first, last;
+	u16 old, new;
+	u32 w;
+	u16 first, last;
 
 	ASSERT(dma64_txsuspendedidle(di));
 
 	nactive = _dma_txactive(di);
-	ad = (uint16) (B2I
+	ad = (u16) (B2I
 		       ((((R_REG(di->osh, &di->d64txregs->status1) &
 			   D64_XS1_AD_MASK)
 			  - di->xmtptrbase) & D64_XS1_AD_MASK), dma64dd_t));
@@ -2650,7 +2651,7 @@ static void dma64_txrotate(dma_info_t * di)
 	      di->xmtptrbase + I2B(di->txout, dma64dd_t));
 }
 
-uint dma_addrwidth(si_t * sih, void *dmaregs)
+uint dma_addrwidth(si_t *sih, void *dmaregs)
 {
 	dma32regs_t *dma32regs;
 	osl_t *osh;
@@ -2666,12 +2667,12 @@ uint dma_addrwidth(si_t * sih, void *dmaregs)
 			if ((BUSTYPE(sih->bustype) == SI_BUS) ||
 			    ((BUSTYPE(sih->bustype) == PCI_BUS) &&
 			     (sih->buscoretype == PCIE_CORE_ID)))
-				return (DMADDRWIDTH_64);
+				return DMADDRWIDTH_64;
 
-		/* DMA64 is always 32-bit capable, AE is always TRUE */
+		/* DMA64 is always 32-bit capable, AE is always true */
 		ASSERT(_dma64_addrext(osh, (dma64regs_t *) dmaregs));
 
-		return (DMADDRWIDTH_32);
+		return DMADDRWIDTH_32;
 	}
 
 	/* Start checking for 32-bit / 30-bit addressing */
@@ -2682,8 +2683,8 @@ uint dma_addrwidth(si_t * sih, void *dmaregs)
 	    ((BUSTYPE(sih->bustype) == PCI_BUS)
 	     && sih->buscoretype == PCIE_CORE_ID)
 	    || (_dma32_addrext(osh, dma32regs)))
-		return (DMADDRWIDTH_32);
+		return DMADDRWIDTH_32;
 
 	/* Fallthru */
-	return (DMADDRWIDTH_30);
+	return DMADDRWIDTH_30;
 }
diff --git a/drivers/staging/brcm80211/util/hndpmu.c b/drivers/staging/brcm80211/util/hndpmu.c
index 5fca01e..a8f3306 100644
--- a/drivers/staging/brcm80211/util/hndpmu.c
+++ b/drivers/staging/brcm80211/util/hndpmu.c
@@ -13,8 +13,9 @@
  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
-
-#include <typedefs.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linuxver.h>
 #include <bcmdefs.h>
 #include <osl.h>
 #include <bcmutils.h>
@@ -39,25 +40,25 @@
 #define	PMU_NONE(args)
 
 /* PLL controls/clocks */
-static void si_pmu1_pllinit0(si_t * sih, osl_t * osh, chipcregs_t * cc,
-			     uint32 xtal);
-static uint32 si_pmu1_cpuclk0(si_t * sih, osl_t * osh, chipcregs_t * cc);
-static uint32 si_pmu1_alpclk0(si_t * sih, osl_t * osh, chipcregs_t * cc);
+static void si_pmu1_pllinit0(si_t *sih, osl_t *osh, chipcregs_t *cc,
+			     u32 xtal);
+static u32 si_pmu1_cpuclk0(si_t *sih, osl_t *osh, chipcregs_t *cc);
+static u32 si_pmu1_alpclk0(si_t *sih, osl_t *osh, chipcregs_t *cc);
 
 /* PMU resources */
-static bool si_pmu_res_depfltr_bb(si_t * sih);
-static bool si_pmu_res_depfltr_ncb(si_t * sih);
-static bool si_pmu_res_depfltr_paldo(si_t * sih);
-static bool si_pmu_res_depfltr_npaldo(si_t * sih);
-static uint32 si_pmu_res_deps(si_t * sih, osl_t * osh, chipcregs_t * cc,
-			      uint32 rsrcs, bool all);
-static uint si_pmu_res_uptime(si_t * sih, osl_t * osh, chipcregs_t * cc,
-			      uint8 rsrc);
-static void si_pmu_res_masks(si_t * sih, uint32 * pmin, uint32 * pmax);
-static void si_pmu_spuravoid_pllupdate(si_t * sih, chipcregs_t * cc,
-				       osl_t * osh, uint8 spuravoid);
-
-static void si_pmu_set_4330_plldivs(si_t * sih);
+static bool si_pmu_res_depfltr_bb(si_t *sih);
+static bool si_pmu_res_depfltr_ncb(si_t *sih);
+static bool si_pmu_res_depfltr_paldo(si_t *sih);
+static bool si_pmu_res_depfltr_npaldo(si_t *sih);
+static u32 si_pmu_res_deps(si_t *sih, osl_t *osh, chipcregs_t *cc,
+			      u32 rsrcs, bool all);
+static uint si_pmu_res_uptime(si_t *sih, osl_t *osh, chipcregs_t *cc,
+			      u8 rsrc);
+static void si_pmu_res_masks(si_t *sih, u32 * pmin, u32 * pmax);
+static void si_pmu_spuravoid_pllupdate(si_t *sih, chipcregs_t *cc,
+				       osl_t *osh, u8 spuravoid);
+
+static void si_pmu_set_4330_plldivs(si_t *sih);
 
 /* FVCO frequency */
 #define FVCO_880	880000	/* 880MHz */
@@ -66,43 +67,43 @@ static void si_pmu_set_4330_plldivs(si_t * sih);
 #define FVCO_960	960000	/* 960MHz */
 
 /* Read/write a chipcontrol reg */
-uint32 si_pmu_chipcontrol(si_t * sih, uint reg, uint32 mask, uint32 val)
+u32 si_pmu_chipcontrol(si_t *sih, uint reg, u32 mask, u32 val)
 {
-	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, chipcontrol_addr), ~0,
+	si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, chipcontrol_addr), ~0,
 		   reg);
 	return si_corereg(sih, SI_CC_IDX,
-			  OFFSETOF(chipcregs_t, chipcontrol_data), mask, val);
+			  offsetof(chipcregs_t, chipcontrol_data), mask, val);
 }
 
 /* Read/write a regcontrol reg */
-uint32 si_pmu_regcontrol(si_t * sih, uint reg, uint32 mask, uint32 val)
+u32 si_pmu_regcontrol(si_t *sih, uint reg, u32 mask, u32 val)
 {
-	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, regcontrol_addr), ~0,
+	si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, regcontrol_addr), ~0,
 		   reg);
 	return si_corereg(sih, SI_CC_IDX,
-			  OFFSETOF(chipcregs_t, regcontrol_data), mask, val);
+			  offsetof(chipcregs_t, regcontrol_data), mask, val);
 }
 
 /* Read/write a pllcontrol reg */
-uint32 si_pmu_pllcontrol(si_t * sih, uint reg, uint32 mask, uint32 val)
+u32 si_pmu_pllcontrol(si_t *sih, uint reg, u32 mask, u32 val)
 {
-	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, pllcontrol_addr), ~0,
+	si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, pllcontrol_addr), ~0,
 		   reg);
 	return si_corereg(sih, SI_CC_IDX,
-			  OFFSETOF(chipcregs_t, pllcontrol_data), mask, val);
+			  offsetof(chipcregs_t, pllcontrol_data), mask, val);
 }
 
 /* PMU PLL update */
-void si_pmu_pllupd(si_t * sih)
+void si_pmu_pllupd(si_t *sih)
 {
-	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, pmucontrol),
+	si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, pmucontrol),
 		   PCTL_PLL_PLLCTL_UPD, PCTL_PLL_PLLCTL_UPD);
 }
 
 /* Setup switcher voltage */
-void
-BCMATTACHFN(si_pmu_set_switcher_voltage) (si_t * sih, osl_t * osh,
-					  uint8 bb_voltage, uint8 rf_voltage) {
+void si_pmu_set_switcher_voltage(si_t *sih, osl_t *osh, u8 bb_voltage,
+				 u8 rf_voltage)
+{
 	chipcregs_t *cc;
 	uint origidx;
 
@@ -114,20 +115,19 @@ BCMATTACHFN(si_pmu_set_switcher_voltage) (si_t * sih, osl_t * osh,
 	ASSERT(cc != NULL);
 
 	W_REG(osh, &cc->regcontrol_addr, 0x01);
-	W_REG(osh, &cc->regcontrol_data, (uint32) (bb_voltage & 0x1f) << 22);
+	W_REG(osh, &cc->regcontrol_data, (u32) (bb_voltage & 0x1f) << 22);
 
 	W_REG(osh, &cc->regcontrol_addr, 0x00);
-	W_REG(osh, &cc->regcontrol_data, (uint32) (rf_voltage & 0x1f) << 14);
+	W_REG(osh, &cc->regcontrol_data, (u32) (rf_voltage & 0x1f) << 14);
 
 	/* Return to original core */
 	si_setcoreidx(sih, origidx);
 }
 
-void
-BCMATTACHFN(si_pmu_set_ldo_voltage) (si_t * sih, osl_t * osh, uint8 ldo,
-				     uint8 voltage) {
-	uint8 sr_cntl_shift = 0, rc_shift = 0, shift = 0, mask = 0;
-	uint8 addr = 0;
+void si_pmu_set_ldo_voltage(si_t *sih, osl_t *osh, u8 ldo, u8 voltage)
+{
+	u8 sr_cntl_shift = 0, rc_shift = 0, shift = 0, mask = 0;
+	u8 addr = 0;
 
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
@@ -150,7 +150,7 @@ BCMATTACHFN(si_pmu_set_ldo_voltage) (si_t * sih, osl_t * osh, uint8 ldo,
 			mask = 0xf;
 			break;
 		default:
-			ASSERT(FALSE);
+			ASSERT(false);
 			return;
 		}
 		break;
@@ -162,27 +162,28 @@ BCMATTACHFN(si_pmu_set_ldo_voltage) (si_t * sih, osl_t * osh, uint8 ldo,
 			mask = 0x1f;
 			break;
 		default:
-			ASSERT(FALSE);
+			ASSERT(false);
 			break;
 		}
 		break;
 	default:
-		ASSERT(FALSE);
+		ASSERT(false);
 		return;
 	}
 
 	shift = sr_cntl_shift + rc_shift;
 
-	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, regcontrol_addr),
+	si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, regcontrol_addr),
 		   ~0, addr);
-	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, regcontrol_data),
+	si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, regcontrol_data),
 		   mask << shift, (voltage & mask) << shift);
 }
 
 /* d11 slow to fast clock transition time in slow clock cycles */
 #define D11SCC_SLOW2FAST_TRANSITION	2
 
-uint16 BCMINITFN(si_pmu_fast_pwrup_delay) (si_t * sih, osl_t * osh) {
+u16 si_pmu_fast_pwrup_delay(si_t *sih, osl_t *osh)
+{
 	uint delay = PMU_MAX_TRANSITION_DLY;
 	chipcregs_t *cc;
 	uint origidx;
@@ -214,7 +215,7 @@ uint16 BCMINITFN(si_pmu_fast_pwrup_delay) (si_t * sih, osl_t * osh) {
 		if (ISSIM_ENAB(sih))
 			delay = 70;
 		else {
-			uint32 ilp = si_ilp_clock(sih);
+			u32 ilp = si_ilp_clock(sih);
 			delay =
 			    (si_pmu_res_uptime(sih, osh, cc, RES4329_HT_AVAIL) +
 			     D11SCC_SLOW2FAST_TRANSITION) * ((1000000 + ilp -
@@ -229,7 +230,7 @@ uint16 BCMINITFN(si_pmu_fast_pwrup_delay) (si_t * sih, osl_t * osh) {
 		if (ISSIM_ENAB(sih))
 			delay = 70;
 		else {
-			uint32 ilp = si_ilp_clock(sih);
+			u32 ilp = si_ilp_clock(sih);
 			delay =
 			    (si_pmu_res_uptime(sih, osh, cc, RES4336_HT_AVAIL) +
 			     D11SCC_SLOW2FAST_TRANSITION) * ((1000000 + ilp -
@@ -241,7 +242,7 @@ uint16 BCMINITFN(si_pmu_fast_pwrup_delay) (si_t * sih, osl_t * osh) {
 		if (ISSIM_ENAB(sih))
 			delay = 70;
 		else {
-			uint32 ilp = si_ilp_clock(sih);
+			u32 ilp = si_ilp_clock(sih);
 			delay =
 			    (si_pmu_res_uptime(sih, osh, cc, RES4330_HT_AVAIL) +
 			     D11SCC_SLOW2FAST_TRANSITION) * ((1000000 + ilp -
@@ -255,13 +256,14 @@ uint16 BCMINITFN(si_pmu_fast_pwrup_delay) (si_t * sih, osl_t * osh) {
 	/* Return to original core */
 	si_setcoreidx(sih, origidx);
 
-	return (uint16) delay;
+	return (u16) delay;
 }
 
-uint32 BCMATTACHFN(si_pmu_force_ilp) (si_t * sih, osl_t * osh, bool force) {
+u32 si_pmu_force_ilp(si_t *sih, osl_t *osh, bool force)
+{
 	chipcregs_t *cc;
 	uint origidx;
-	uint32 oldpmucontrol;
+	u32 oldpmucontrol;
 
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
@@ -286,16 +288,16 @@ uint32 BCMATTACHFN(si_pmu_force_ilp) (si_t * sih, osl_t * osh, bool force) {
 
 /* Setup resource up/down timers */
 typedef struct {
-	uint8 resnum;
-	uint16 updown;
+	u8 resnum;
+	u16 updown;
 } pmu_res_updown_t;
 
 /* Change resource dependancies masks */
 typedef struct {
-	uint32 res_mask;	/* resources (chip specific) */
-	int8 action;		/* action */
-	uint32 depend_mask;	/* changes to the dependancies mask */
-	 bool(*filter) (si_t * sih);	/* action is taken when filter is NULL or return TRUE */
+	u32 res_mask;	/* resources (chip specific) */
+	s8 action;		/* action */
+	u32 depend_mask;	/* changes to the dependancies mask */
+	 bool(*filter) (si_t *sih);	/* action is taken when filter is NULL or return true */
 } pmu_res_depend_t;
 
 /* Resource dependancies mask change action */
@@ -303,8 +305,7 @@ typedef struct {
 #define RES_DEPEND_ADD		1	/* Add to the  dependancies mask */
 #define RES_DEPEND_REMOVE	-1	/* Remove from the dependancies mask */
 
-static const pmu_res_updown_t BCMATTACHDATA(bcm4328a0_res_updown)[] =
-{
+static const pmu_res_updown_t bcm4328a0_res_updown[] = {
 	{
 	RES4328_EXT_SWITCHER_PWM, 0x0101}, {
 	RES4328_BB_SWITCHER_PWM, 0x1f01}, {
@@ -328,8 +329,7 @@ static const pmu_res_updown_t BCMATTACHDATA(bcm4328a0_res_updown)[] =
 	RES4328_BB_PLL_PU, 0x0701}
 };
 
-static const pmu_res_depend_t BCMATTACHDATA(bcm4328a0_res_depend)[] =
-{
+static const pmu_res_depend_t bcm4328a0_res_depend[] = {
 	/* Adjust ILP request resource not to force ext/BB switchers into burst mode */
 	{
 	PMURES_BIT(RES4328_ILP_REQUEST),
@@ -338,8 +338,7 @@ static const pmu_res_depend_t BCMATTACHDATA(bcm4328a0_res_depend)[] =
 		    PMURES_BIT(RES4328_BB_SWITCHER_PWM), NULL}
 };
 
-static const pmu_res_updown_t BCMATTACHDATA(bcm4325a0_res_updown_qt)[] =
-{
+static const pmu_res_updown_t bcm4325a0_res_updown_qt[] = {
 	{
 	RES4325_HT_AVAIL, 0x0300}, {
 	RES4325_BBPLL_PWRSW_PU, 0x0101}, {
@@ -351,14 +350,12 @@ static const pmu_res_updown_t BCMATTACHDATA(bcm4325a0_res_updown_qt)[] =
 	RES4325_CBUCK_PWM, 0x0803}
 };
 
-static const pmu_res_updown_t BCMATTACHDATA(bcm4325a0_res_updown)[] =
-{
+static const pmu_res_updown_t bcm4325a0_res_updown[] = {
 	{
 	RES4325_XTAL_PU, 0x1501}
 };
 
-static const pmu_res_depend_t BCMATTACHDATA(bcm4325a0_res_depend)[] =
-{
+static const pmu_res_depend_t bcm4325a0_res_depend[] = {
 	/* Adjust OTP PU resource dependencies - remove BB BURST */
 	{
 	PMURES_BIT(RES4325_OTP_PU),
@@ -399,8 +396,7 @@ static const pmu_res_depend_t BCMATTACHDATA(bcm4325a0_res_depend)[] =
 		    PMURES_BIT(RES4325B0_CBUCK_PWM), si_pmu_res_depfltr_ncb}
 };
 
-static const pmu_res_updown_t BCMATTACHDATA(bcm4315a0_res_updown_qt)[] =
-{
+static const pmu_res_updown_t bcm4315a0_res_updown_qt[] = {
 	{
 	RES4315_HT_AVAIL, 0x0101}, {
 	RES4315_XTAL_PU, 0x0100}, {
@@ -412,14 +408,12 @@ static const pmu_res_updown_t BCMATTACHDATA(bcm4315a0_res_updown_qt)[] =
 	RES4315_CBUCK_LPOM, 0x0100}
 };
 
-static const pmu_res_updown_t BCMATTACHDATA(bcm4315a0_res_updown)[] =
-{
+static const pmu_res_updown_t bcm4315a0_res_updown[] = {
 	{
 	RES4315_XTAL_PU, 0x2501}
 };
 
-static const pmu_res_depend_t BCMATTACHDATA(bcm4315a0_res_depend)[] =
-{
+static const pmu_res_depend_t bcm4315a0_res_depend[] = {
 	/* Adjust OTP PU resource dependencies - not need PALDO unless write */
 	{
 	PMURES_BIT(RES4315_OTP_PU),
@@ -459,14 +453,12 @@ static const pmu_res_depend_t BCMATTACHDATA(bcm4315a0_res_depend)[] =
 };
 
 	/* 4329 specific. needs to come back this issue later */
-static const pmu_res_updown_t BCMINITDATA(bcm4329_res_updown)[] =
-{
+static const pmu_res_updown_t bcm4329_res_updown[] = {
 	{
 	RES4329_XTAL_PU, 0x1501}
 };
 
-static const pmu_res_depend_t BCMINITDATA(bcm4329_res_depend)[] =
-{
+static const pmu_res_depend_t bcm4329_res_depend[] = {
 	/* Adjust HT Avail resource dependencies */
 	{
 	PMURES_BIT(RES4329_HT_AVAIL),
@@ -487,8 +479,7 @@ static const pmu_res_depend_t BCMINITDATA(bcm4329_res_depend)[] =
 		    PMURES_BIT(RES4329_BBPLL_PWRSW_PU), NULL}
 };
 
-static const pmu_res_updown_t BCMATTACHDATA(bcm4319a0_res_updown_qt)[] =
-{
+static const pmu_res_updown_t bcm4319a0_res_updown_qt[] = {
 	{
 	RES4319_HT_AVAIL, 0x0101}, {
 	RES4319_XTAL_PU, 0x0100}, {
@@ -500,14 +491,12 @@ static const pmu_res_updown_t BCMATTACHDATA(bcm4319a0_res_updown_qt)[] =
 	RES4319_CBUCK_LPOM, 0x0100}
 };
 
-static const pmu_res_updown_t BCMATTACHDATA(bcm4319a0_res_updown)[] =
-{
+static const pmu_res_updown_t bcm4319a0_res_updown[] = {
 	{
 	RES4319_XTAL_PU, 0x3f01}
 };
 
-static const pmu_res_depend_t BCMATTACHDATA(bcm4319a0_res_depend)[] =
-{
+static const pmu_res_depend_t bcm4319a0_res_depend[] = {
 	/* Adjust OTP PU resource dependencies - not need PALDO unless write */
 	{
 	PMURES_BIT(RES4319_OTP_PU),
@@ -529,8 +518,7 @@ static const pmu_res_depend_t BCMATTACHDATA(bcm4319a0_res_depend)[] =
 		    PMURES_BIT(RES4319_AFE_PWRSW_PU), NULL}
 };
 
-static const pmu_res_updown_t BCMATTACHDATA(bcm4336a0_res_updown_qt)[] =
-{
+static const pmu_res_updown_t bcm4336a0_res_updown_qt[] = {
 	{
 	RES4336_HT_AVAIL, 0x0101}, {
 	RES4336_XTAL_PU, 0x0100}, {
@@ -540,21 +528,18 @@ static const pmu_res_updown_t BCMATTACHDATA(bcm4336a0_res_updown_qt)[] =
 	RES4336_CBUCK_LPOM, 0x0100}
 };
 
-static const pmu_res_updown_t BCMATTACHDATA(bcm4336a0_res_updown)[] =
-{
+static const pmu_res_updown_t bcm4336a0_res_updown[] = {
 	{
 	RES4336_HT_AVAIL, 0x0D01}
 };
 
-static const pmu_res_depend_t BCMATTACHDATA(bcm4336a0_res_depend)[] =
-{
+static const pmu_res_depend_t bcm4336a0_res_depend[] = {
 	/* Just a dummy entry for now */
 	{
 	PMURES_BIT(RES4336_RSVD), RES_DEPEND_ADD, 0, NULL}
 };
 
-static const pmu_res_updown_t BCMATTACHDATA(bcm4330a0_res_updown_qt)[] =
-{
+static const pmu_res_updown_t bcm4330a0_res_updown_qt[] = {
 	{
 	RES4330_HT_AVAIL, 0x0101}, {
 	RES4330_XTAL_PU, 0x0100}, {
@@ -564,37 +549,39 @@ static const pmu_res_updown_t BCMATTACHDATA(bcm4330a0_res_updown_qt)[] =
 	RES4330_CBUCK_LPOM, 0x0100}
 };
 
-static const pmu_res_updown_t BCMATTACHDATA(bcm4330a0_res_updown)[] =
-{
+static const pmu_res_updown_t bcm4330a0_res_updown[] = {
 	{
 	RES4330_HT_AVAIL, 0x0e02}
 };
 
-static const pmu_res_depend_t BCMATTACHDATA(bcm4330a0_res_depend)[] =
-{
+static const pmu_res_depend_t bcm4330a0_res_depend[] = {
 	/* Just a dummy entry for now */
 	{
 	PMURES_BIT(RES4330_HT_AVAIL), RES_DEPEND_ADD, 0, NULL}
 };
 
-/* TRUE if the power topology uses the buck boost to provide 3.3V to VDDIO_RF and WLAN PA */
-static bool BCMATTACHFN(si_pmu_res_depfltr_bb) (si_t * sih) {
+/* true if the power topology uses the buck boost to provide 3.3V to VDDIO_RF and WLAN PA */
+static bool si_pmu_res_depfltr_bb(si_t *sih)
+{
 	return (sih->boardflags & BFL_BUCKBOOST) != 0;
 }
 
-/* TRUE if the power topology doesn't use the cbuck. Key on chiprev also if the chip is BCM4325. */
-static bool BCMATTACHFN(si_pmu_res_depfltr_ncb) (si_t * sih) {
+/* true if the power topology doesn't use the cbuck. Key on chiprev also if the chip is BCM4325. */
+static bool si_pmu_res_depfltr_ncb(si_t *sih)
+{
 
-	return ((sih->boardflags & BFL_NOCBUCK) != 0);
+	return (sih->boardflags & BFL_NOCBUCK) != 0;
 }
 
-/* TRUE if the power topology uses the PALDO */
-static bool BCMATTACHFN(si_pmu_res_depfltr_paldo) (si_t * sih) {
+/* true if the power topology uses the PALDO */
+static bool si_pmu_res_depfltr_paldo(si_t *sih)
+{
 	return (sih->boardflags & BFL_PALDO) != 0;
 }
 
-/* TRUE if the power topology doesn't use the PALDO */
-static bool BCMATTACHFN(si_pmu_res_depfltr_npaldo) (si_t * sih) {
+/* true if the power topology doesn't use the PALDO */
+static bool si_pmu_res_depfltr_npaldo(si_t *sih)
+{
 	return (sih->boardflags & BFL_PALDO) == 0;
 }
 
@@ -602,9 +589,9 @@ static bool BCMATTACHFN(si_pmu_res_depfltr_npaldo) (si_t * sih) {
 					sih->boardtype == BCM94325BGABU_BOARD)
 
 /* Determine min/max rsrc masks. Value 0 leaves hardware at default. */
-static void si_pmu_res_masks(si_t * sih, uint32 * pmin, uint32 * pmax)
+static void si_pmu_res_masks(si_t *sih, u32 * pmin, u32 * pmax)
 {
-	uint32 min_mask = 0, max_mask = 0;
+	u32 min_mask = 0, max_mask = 0;
 	uint rsrcs;
 	char *val;
 
@@ -673,14 +660,16 @@ static void si_pmu_res_masks(si_t * sih, uint32 * pmin, uint32 * pmax)
 	}
 
 	/* Apply nvram override to min mask */
-	if ((val = getvar(NULL, "rmin")) != NULL) {
+	val = getvar(NULL, "rmin");
+	if (val != NULL) {
 		PMU_MSG(("Applying rmin=%s to min_mask\n", val));
-		min_mask = (uint32) bcm_strtoul(val, NULL, 0);
+		min_mask = (u32) simple_strtoul(val, NULL, 0);
 	}
 	/* Apply nvram override to max mask */
-	if ((val = getvar(NULL, "rmax")) != NULL) {
+	val = getvar(NULL, "rmax");
+	if (val != NULL) {
 		PMU_MSG(("Applying rmax=%s to max_mask\n", val));
-		max_mask = (uint32) bcm_strtoul(val, NULL, 0);
+		max_mask = (u32) simple_strtoul(val, NULL, 0);
 	}
 
 	*pmin = min_mask;
@@ -688,14 +677,15 @@ static void si_pmu_res_masks(si_t * sih, uint32 * pmin, uint32 * pmax)
 }
 
 /* initialize PMU resources */
-void BCMATTACHFN(si_pmu_res_init) (si_t * sih, osl_t * osh) {
+void si_pmu_res_init(si_t *sih, osl_t *osh)
+{
 	chipcregs_t *cc;
 	uint origidx;
 	const pmu_res_updown_t *pmu_res_updown_table = NULL;
 	uint pmu_res_updown_table_sz = 0;
 	const pmu_res_depend_t *pmu_res_depend_table = NULL;
 	uint pmu_res_depend_table_sz = 0;
-	uint32 min_mask = 0, max_mask = 0;
+	u32 min_mask = 0, max_mask = 0;
 	char name[8], *val;
 	uint i, rsrcs;
 
@@ -714,11 +704,11 @@ void BCMATTACHFN(si_pmu_res_init) (si_t * sih, osl_t * osh) {
 			pmu_res_updown_table_sz = 0;
 		} else {
 			pmu_res_updown_table = bcm4329_res_updown;
-			pmu_res_updown_table_sz = ARRAYSIZE(bcm4329_res_updown);
+			pmu_res_updown_table_sz = ARRAY_SIZE(bcm4329_res_updown);
 		}
 		/* Optimize resources dependencies */
 		pmu_res_depend_table = bcm4329_res_depend;
-		pmu_res_depend_table_sz = ARRAYSIZE(bcm4329_res_depend);
+		pmu_res_depend_table_sz = ARRAY_SIZE(bcm4329_res_depend);
 		break;
 
 	case BCM4319_CHIP_ID:
@@ -726,15 +716,15 @@ void BCMATTACHFN(si_pmu_res_init) (si_t * sih, osl_t * osh) {
 		if (ISSIM_ENAB(sih)) {
 			pmu_res_updown_table = bcm4319a0_res_updown_qt;
 			pmu_res_updown_table_sz =
-			    ARRAYSIZE(bcm4319a0_res_updown_qt);
+			    ARRAY_SIZE(bcm4319a0_res_updown_qt);
 		} else {
 			pmu_res_updown_table = bcm4319a0_res_updown;
 			pmu_res_updown_table_sz =
-			    ARRAYSIZE(bcm4319a0_res_updown);
+			    ARRAY_SIZE(bcm4319a0_res_updown);
 		}
 		/* Optimize resources dependancies masks */
 		pmu_res_depend_table = bcm4319a0_res_depend;
-		pmu_res_depend_table_sz = ARRAYSIZE(bcm4319a0_res_depend);
+		pmu_res_depend_table_sz = ARRAY_SIZE(bcm4319a0_res_depend);
 		break;
 
 	case BCM4336_CHIP_ID:
@@ -742,15 +732,15 @@ void BCMATTACHFN(si_pmu_res_init) (si_t * sih, osl_t * osh) {
 		if (ISSIM_ENAB(sih)) {
 			pmu_res_updown_table = bcm4336a0_res_updown_qt;
 			pmu_res_updown_table_sz =
-			    ARRAYSIZE(bcm4336a0_res_updown_qt);
+			    ARRAY_SIZE(bcm4336a0_res_updown_qt);
 		} else {
 			pmu_res_updown_table = bcm4336a0_res_updown;
 			pmu_res_updown_table_sz =
-			    ARRAYSIZE(bcm4336a0_res_updown);
+			    ARRAY_SIZE(bcm4336a0_res_updown);
 		}
 		/* Optimize resources dependancies masks */
 		pmu_res_depend_table = bcm4336a0_res_depend;
-		pmu_res_depend_table_sz = ARRAYSIZE(bcm4336a0_res_depend);
+		pmu_res_depend_table_sz = ARRAY_SIZE(bcm4336a0_res_depend);
 		break;
 
 	case BCM4330_CHIP_ID:
@@ -758,15 +748,15 @@ void BCMATTACHFN(si_pmu_res_init) (si_t * sih, osl_t * osh) {
 		if (ISSIM_ENAB(sih)) {
 			pmu_res_updown_table = bcm4330a0_res_updown_qt;
 			pmu_res_updown_table_sz =
-			    ARRAYSIZE(bcm4330a0_res_updown_qt);
+			    ARRAY_SIZE(bcm4330a0_res_updown_qt);
 		} else {
 			pmu_res_updown_table = bcm4330a0_res_updown;
 			pmu_res_updown_table_sz =
-			    ARRAYSIZE(bcm4330a0_res_updown);
+			    ARRAY_SIZE(bcm4330a0_res_updown);
 		}
 		/* Optimize resources dependancies masks */
 		pmu_res_depend_table = bcm4330a0_res_depend;
-		pmu_res_depend_table_sz = ARRAYSIZE(bcm4330a0_res_depend);
+		pmu_res_depend_table_sz = ARRAY_SIZE(bcm4330a0_res_depend);
 		break;
 
 	default:
@@ -790,13 +780,14 @@ void BCMATTACHFN(si_pmu_res_init) (si_t * sih, osl_t * osh) {
 	/* Apply nvram overrides to up/down timers */
 	for (i = 0; i < rsrcs; i++) {
 		snprintf(name, sizeof(name), "r%dt", i);
-		if ((val = getvar(NULL, name)) == NULL)
+		val = getvar(NULL, name);
+		if (val == NULL)
 			continue;
 		PMU_MSG(("Applying %s=%s to rsrc %d res_updn_timer\n", name,
 			 val, i));
-		W_REG(osh, &cc->res_table_sel, (uint32) i);
+		W_REG(osh, &cc->res_table_sel, (u32) i);
 		W_REG(osh, &cc->res_updn_timer,
-		      (uint32) bcm_strtoul(val, NULL, 0));
+		      (u32) simple_strtoul(val, NULL, 0));
 	}
 
 	/* Program resource dependencies table */
@@ -840,13 +831,14 @@ void BCMATTACHFN(si_pmu_res_init) (si_t * sih, osl_t * osh) {
 	/* Apply nvram overrides to dependancies masks */
 	for (i = 0; i < rsrcs; i++) {
 		snprintf(name, sizeof(name), "r%dd", i);
-		if ((val = getvar(NULL, name)) == NULL)
+		val = getvar(NULL, name);
+		if (val == NULL)
 			continue;
 		PMU_MSG(("Applying %s=%s to rsrc %d res_dep_mask\n", name, val,
 			 i));
-		W_REG(osh, &cc->res_table_sel, (uint32) i);
+		W_REG(osh, &cc->res_table_sel, (u32) i);
 		W_REG(osh, &cc->res_dep_mask,
-		      (uint32) bcm_strtoul(val, NULL, 0));
+		      (u32) simple_strtoul(val, NULL, 0));
 	}
 
 	/* Determine min/max rsrc masks */
@@ -869,7 +861,7 @@ void BCMATTACHFN(si_pmu_res_init) (si_t * sih, osl_t * osh) {
 	}
 
 	/* Add some delay; allow resources to come up and settle. */
-	OSL_DELAY(2000);
+	mdelay(2);
 
 	/* Return to original core */
 	si_setcoreidx(sih, origidx);
@@ -877,15 +869,14 @@ void BCMATTACHFN(si_pmu_res_init) (si_t * sih, osl_t * osh) {
 
 /* setup pll and query clock speed */
 typedef struct {
-	uint16 freq;
-	uint8 xf;
-	uint8 wbint;
-	uint32 wbfrac;
+	u16 freq;
+	u8 xf;
+	u8 wbint;
+	u32 wbfrac;
 } pmu0_xtaltab0_t;
 
 /* the following table is based on 880Mhz fvco */
-static const pmu0_xtaltab0_t BCMINITDATA(pmu0_xtaltab0)[] =
-{
+static const pmu0_xtaltab0_t pmu0_xtaltab0[] = {
 	{
 	12000, 1, 73, 349525}, {
 	13000, 2, 67, 725937}, {
@@ -908,16 +899,15 @@ static const pmu0_xtaltab0_t BCMINITDATA(pmu0_xtaltab0)[] =
 
 /* setup pll and query clock speed */
 typedef struct {
-	uint16 fref;
-	uint8 xf;
-	uint8 p1div;
-	uint8 p2div;
-	uint8 ndiv_int;
-	uint32 ndiv_frac;
+	u16 fref;
+	u8 xf;
+	u8 p1div;
+	u8 p2div;
+	u8 ndiv_int;
+	u32 ndiv_frac;
 } pmu1_xtaltab0_t;
 
-static const pmu1_xtaltab0_t BCMINITDATA(pmu1_xtaltab0_880_4329)[] =
-{
+static const pmu1_xtaltab0_t pmu1_xtaltab0_880_4329[] = {
 	{
 	12000, 1, 3, 22, 0x9, 0xFFFFEF}, {
 	13000, 2, 1, 6, 0xb, 0x483483}, {
@@ -939,8 +929,7 @@ static const pmu1_xtaltab0_t BCMINITDATA(pmu1_xtaltab0_880_4329)[] =
 };
 
 /* the following table is based on 880Mhz fvco */
-static const pmu1_xtaltab0_t BCMINITDATA(pmu1_xtaltab0_880)[] =
-{
+static const pmu1_xtaltab0_t pmu1_xtaltab0_880[] = {
 	{
 	12000, 1, 3, 22, 0x9, 0xFFFFEF}, {
 	13000, 2, 1, 6, 0xb, 0x483483}, {
@@ -979,8 +968,7 @@ static const pmu1_xtaltab0_t BCMINITDATA(pmu1_xtaltab0_880)[] =
 #define PMU1_XTALTAB0_880_40000K	15
 
 /* the following table is based on 1760Mhz fvco */
-static const pmu1_xtaltab0_t BCMINITDATA(pmu1_xtaltab0_1760)[] =
-{
+static const pmu1_xtaltab0_t pmu1_xtaltab0_1760[] = {
 	{
 	12000, 1, 3, 44, 0x9, 0xFFFFEF}, {
 	13000, 2, 1, 12, 0xb, 0x483483}, {
@@ -1018,8 +1006,7 @@ static const pmu1_xtaltab0_t BCMINITDATA(pmu1_xtaltab0_1760)[] =
 #define PMU1_XTALTAB0_1760_40000K	14
 
 /* the following table is based on 1440Mhz fvco */
-static const pmu1_xtaltab0_t BCMINITDATA(pmu1_xtaltab0_1440)[] =
-{
+static const pmu1_xtaltab0_t pmu1_xtaltab0_1440[] = {
 	{
 	12000, 1, 1, 1, 0x78, 0x0}, {
 	13000, 2, 1, 1, 0x6E, 0xC4EC4E}, {
@@ -1063,8 +1050,7 @@ static const pmu1_xtaltab0_t BCMINITDATA(pmu1_xtaltab0_1440)[] =
 #define XTAL_FREQ_37400MHZ		37400
 #define XTAL_FREQ_48000MHZ		48000
 
-static const pmu1_xtaltab0_t BCMINITDATA(pmu1_xtaltab0_960)[] =
-{
+static const pmu1_xtaltab0_t pmu1_xtaltab0_960[] = {
 	{
 	12000, 1, 1, 1, 0x50, 0x0}, {
 	13000, 2, 1, 1, 0x49, 0xD89D89}, {
@@ -1104,7 +1090,8 @@ static const pmu1_xtaltab0_t BCMINITDATA(pmu1_xtaltab0_960)[] =
 #define PMU1_XTALTAB0_960_48000K	15
 
 /* select xtal table for each chip */
-static const pmu1_xtaltab0_t *BCMINITFN(si_pmu1_xtaltab0) (si_t * sih) {
+static const pmu1_xtaltab0_t *si_pmu1_xtaltab0(si_t *sih)
+{
 #ifdef BCMDBG
 	char chn[8];
 #endif
@@ -1130,7 +1117,8 @@ static const pmu1_xtaltab0_t *BCMINITFN(si_pmu1_xtaltab0) (si_t * sih) {
 }
 
 /* select default xtal frequency for each chip */
-static const pmu1_xtaltab0_t *BCMINITFN(si_pmu1_xtaldef0) (si_t * sih) {
+static const pmu1_xtaltab0_t *si_pmu1_xtaldef0(si_t *sih)
+{
 #ifdef BCMDBG
 	char chn[8];
 #endif
@@ -1161,7 +1149,8 @@ static const pmu1_xtaltab0_t *BCMINITFN(si_pmu1_xtaldef0) (si_t * sih) {
 }
 
 /* select default pll fvco for each chip */
-static uint32 BCMINITFN(si_pmu1_pllfvco0) (si_t * sih) {
+static u32 si_pmu1_pllfvco0(si_t *sih)
+{
 #ifdef BCMDBG
 	char chn[8];
 #endif
@@ -1188,10 +1177,11 @@ static uint32 BCMINITFN(si_pmu1_pllfvco0) (si_t * sih) {
 }
 
 /* query alp/xtal clock frequency */
-static uint32
-BCMINITFN(si_pmu1_alpclk0) (si_t * sih, osl_t * osh, chipcregs_t * cc) {
+static u32
+si_pmu1_alpclk0(si_t *sih, osl_t *osh, chipcregs_t *cc)
+{
 	const pmu1_xtaltab0_t *xt;
-	uint32 xf;
+	u32 xf;
 
 	/* Find the frequency in the table */
 	xf = (R_REG(osh, &cc->pmucontrol) & PCTL_XTALFREQ_MASK) >>
@@ -1213,13 +1203,12 @@ BCMINITFN(si_pmu1_alpclk0) (si_t * sih, osl_t * osh, chipcregs_t * cc) {
  * case the xtal frequency is unknown to the s/w so we need to call
  * si_pmu1_xtaldef0() wherever it is needed to return a default value.
  */
-static void
-BCMATTACHFN(si_pmu1_pllinit0) (si_t * sih, osl_t * osh, chipcregs_t * cc,
-			       uint32 xtal) {
+static void si_pmu1_pllinit0(si_t *sih, osl_t *osh, chipcregs_t *cc, u32 xtal)
+{
 	const pmu1_xtaltab0_t *xt;
-	uint32 tmp;
-	uint32 buf_strength = 0;
-	uint8 ndiv_mode = 1;
+	u32 tmp;
+	u32 buf_strength = 0;
+	u8 ndiv_mode = 1;
 
 	/* Use h/w default PLL config */
 	if (xtal == 0) {
@@ -1304,13 +1293,13 @@ BCMATTACHFN(si_pmu1_pllinit0) (si_t * sih, osl_t * osh, chipcregs_t * cc,
 		AND_REG(osh, &cc->max_res_mask,
 			~(PMURES_BIT(RES4319_HT_AVAIL)));
 
-		OSL_DELAY(100);
+		udelay(100);
 		AND_REG(osh, &cc->min_res_mask,
 			~(PMURES_BIT(RES4319_BBPLL_PWRSW_PU)));
 		AND_REG(osh, &cc->max_res_mask,
 			~(PMURES_BIT(RES4319_BBPLL_PWRSW_PU)));
 
-		OSL_DELAY(100);
+		udelay(100);
 		SPINWAIT(R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL,
 			 PMU_MAX_TRANSITION_DLY);
 		ASSERT(!(R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL));
@@ -1326,7 +1315,7 @@ BCMATTACHFN(si_pmu1_pllinit0) (si_t * sih, osl_t * osh, chipcregs_t * cc,
 		AND_REG(osh, &cc->max_res_mask,
 			~(PMURES_BIT(RES4336_HT_AVAIL) |
 			  PMURES_BIT(RES4336_MACPHY_CLKAVAIL)));
-		OSL_DELAY(100);
+		udelay(100);
 		SPINWAIT(R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL,
 			 PMU_MAX_TRANSITION_DLY);
 		ASSERT(!(R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL));
@@ -1339,7 +1328,7 @@ BCMATTACHFN(si_pmu1_pllinit0) (si_t * sih, osl_t * osh, chipcregs_t * cc,
 		AND_REG(osh, &cc->max_res_mask,
 			~(PMURES_BIT(RES4330_HT_AVAIL) |
 			  PMURES_BIT(RES4330_MACPHY_CLKAVAIL)));
-		OSL_DELAY(100);
+		udelay(100);
 		SPINWAIT(R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL,
 			 PMU_MAX_TRANSITION_DLY);
 		ASSERT(!(R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL));
@@ -1458,14 +1447,15 @@ BCMATTACHFN(si_pmu1_pllinit0) (si_t * sih, osl_t * osh, chipcregs_t * cc,
 }
 
 /* query the CPU clock frequency */
-static uint32
-BCMINITFN(si_pmu1_cpuclk0) (si_t * sih, osl_t * osh, chipcregs_t * cc) {
-	uint32 tmp, m1div;
+static u32
+si_pmu1_cpuclk0(si_t *sih, osl_t *osh, chipcregs_t *cc)
+{
+	u32 tmp, m1div;
 #ifdef BCMDBG
-	uint32 ndiv_int, ndiv_frac, p2div, p1div, fvco;
-	uint32 fref;
+	u32 ndiv_int, ndiv_frac, p2div, p1div, fvco;
+	u32 fref;
 #endif
-	uint32 FVCO = si_pmu1_pllfvco0(sih);
+	u32 FVCO = si_pmu1_pllfvco0(sih);
 
 	/* Read m1div from pllcontrol[1] */
 	W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL1);
@@ -1512,7 +1502,8 @@ BCMINITFN(si_pmu1_cpuclk0) (si_t * sih, osl_t * osh, chipcregs_t * cc) {
 }
 
 /* initialize PLL */
-void BCMATTACHFN(si_pmu_pll_init) (si_t * sih, osl_t * osh, uint xtalfreq) {
+void si_pmu_pll_init(si_t *sih, osl_t *osh, uint xtalfreq)
+{
 	chipcregs_t *cc;
 	uint origidx;
 #ifdef BCMDBG
@@ -1564,10 +1555,11 @@ void BCMATTACHFN(si_pmu_pll_init) (si_t * sih, osl_t * osh, uint xtalfreq) {
 }
 
 /* query alp/xtal clock frequency */
-uint32 BCMINITFN(si_pmu_alp_clock) (si_t * sih, osl_t * osh) {
+u32 si_pmu_alp_clock(si_t *sih, osl_t *osh)
+{
 	chipcregs_t *cc;
 	uint origidx;
-	uint32 clock = ALP_CLOCK;
+	u32 clock = ALP_CLOCK;
 #ifdef BCMDBG
 	char chn[8];
 #endif
@@ -1623,10 +1615,10 @@ uint32 BCMINITFN(si_pmu_alp_clock) (si_t * sih, osl_t * osh) {
 /* Find the output of the "m" pll divider given pll controls that start with
  * pllreg "pll0" i.e. 12 for main 6 for phy, 0 for misc.
  */
-static uint32
-BCMINITFN(si_pmu5_clock) (si_t * sih, osl_t * osh, chipcregs_t * cc, uint pll0,
+static u32
+si_pmu5_clock(si_t *sih, osl_t *osh, chipcregs_t *cc, uint pll0,
 			  uint m) {
-	uint32 tmp, div, ndiv, p1, p2, fc;
+	u32 tmp, div, ndiv, p1, p2, fc;
 
 	if ((pll0 & 3) || (pll0 > PMU4716_MAINPLL_PLL0)) {
 		PMU_ERROR(("%s: Bad pll0: %d\n", __func__, pll0));
@@ -1642,7 +1634,7 @@ BCMINITFN(si_pmu5_clock) (si_t * sih, osl_t * osh, chipcregs_t * cc, uint pll0,
 	if (CHIPID(sih->chip) == BCM5357_CHIP_ID) {
 		/* Detect failure in clock setting */
 		if ((R_REG(osh, &cc->chipstatus) & 0x40000) != 0) {
-			return (133 * 1000000);
+			return 133 * 1000000;
 		}
 	}
 
@@ -1670,17 +1662,18 @@ BCMINITFN(si_pmu5_clock) (si_t * sih, osl_t * osh, chipcregs_t * cc, uint pll0,
 		  __func__, p1, p2, ndiv, ndiv, m, div, fc, fc / div));
 
 	/* Return clock in Hertz */
-	return ((fc / div) * 1000000);
+	return (fc / div) * 1000000;
 }
 
 /* query backplane clock frequency */
 /* For designs that feed the same clock to both backplane
  * and CPU just return the CPU clock speed.
  */
-uint32 BCMINITFN(si_pmu_si_clock) (si_t * sih, osl_t * osh) {
+u32 si_pmu_si_clock(si_t *sih, osl_t *osh)
+{
 	chipcregs_t *cc;
 	uint origidx;
-	uint32 clock = HT_CLOCK;
+	u32 clock = HT_CLOCK;
 #ifdef BCMDBG
 	char chn[8];
 #endif
@@ -1755,10 +1748,11 @@ uint32 BCMINITFN(si_pmu_si_clock) (si_t * sih, osl_t * osh) {
 }
 
 /* query CPU clock frequency */
-uint32 BCMINITFN(si_pmu_cpu_clock) (si_t * sih, osl_t * osh) {
+u32 si_pmu_cpu_clock(si_t *sih, osl_t *osh)
+{
 	chipcregs_t *cc;
 	uint origidx;
-	uint32 clock;
+	u32 clock;
 
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
@@ -1798,10 +1792,11 @@ uint32 BCMINITFN(si_pmu_cpu_clock) (si_t * sih, osl_t * osh) {
 }
 
 /* query memory clock frequency */
-uint32 BCMINITFN(si_pmu_mem_clock) (si_t * sih, osl_t * osh) {
+u32 si_pmu_mem_clock(si_t *sih, osl_t *osh)
+{
 	chipcregs_t *cc;
 	uint origidx;
-	uint32 clock;
+	u32 clock;
 
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
@@ -1844,19 +1839,20 @@ uint32 BCMINITFN(si_pmu_mem_clock) (si_t * sih, osl_t * osh) {
 /* Measure ILP clock frequency */
 #define ILP_CALC_DUR	10	/* ms, make sure 1000 can be divided by it. */
 
-static uint32 ilpcycles_per_sec = 0;
+static u32 ilpcycles_per_sec;
 
-uint32 BCMINITFN(si_pmu_ilp_clock) (si_t * sih, osl_t * osh) {
+u32 si_pmu_ilp_clock(si_t *sih, osl_t *osh)
+{
 	if (ISSIM_ENAB(sih))
 		return ILP_CLOCK;
 
 	if (ilpcycles_per_sec == 0) {
-		uint32 start, end, delta;
-		uint32 origidx = si_coreidx(sih);
+		u32 start, end, delta;
+		u32 origidx = si_coreidx(sih);
 		chipcregs_t *cc = si_setcoreidx(sih, SI_CC_IDX);
 		ASSERT(cc != NULL);
 		start = R_REG(osh, &cc->pmutimer);
-		OSL_DELAY(ILP_CALC_DUR * 1000);
+		mdelay(ILP_CALC_DUR);
 		end = R_REG(osh, &cc->pmutimer);
 		delta = end - start;
 		ilpcycles_per_sec = delta * (1000 / ILP_CALC_DUR);
@@ -1868,22 +1864,21 @@ uint32 BCMINITFN(si_pmu_ilp_clock) (si_t * sih, osl_t * osh) {
 
 /* SDIO Pad drive strength to select value mappings */
 typedef struct {
-	uint8 strength;		/* Pad Drive Strength in mA */
-	uint8 sel;		/* Chip-specific select value */
+	u8 strength;		/* Pad Drive Strength in mA */
+	u8 sel;		/* Chip-specific select value */
 } sdiod_drive_str_t;
 
 /* SDIO Drive Strength to sel value table for PMU Rev 1 */
-static const sdiod_drive_str_t BCMINITDATA(sdiod_drive_strength_tab1)[] =
-{
+static const sdiod_drive_str_t sdiod_drive_strength_tab1[] = {
 	{
 	4, 0x2}, {
 	2, 0x3}, {
 	1, 0x0}, {
-0, 0x0}};
+	0, 0x0}
+	};
 
 /* SDIO Drive Strength to sel value table for PMU Rev 2, 3 */
-static const sdiod_drive_str_t BCMINITDATA(sdiod_drive_strength_tab2)[] =
-{
+static const sdiod_drive_str_t sdiod_drive_strength_tab2[] = {
 	{
 	12, 0x7}, {
 	10, 0x6}, {
@@ -1891,11 +1886,11 @@ static const sdiod_drive_str_t BCMINITDATA(sdiod_drive_strength_tab2)[] =
 	6, 0x4}, {
 	4, 0x2}, {
 	2, 0x1}, {
-0, 0x0}};
+	0, 0x0}
+	};
 
 /* SDIO Drive Strength to sel value table for PMU Rev 8 (1.8V) */
-static const sdiod_drive_str_t BCMINITDATA(sdiod_drive_strength_tab3)[] =
-{
+static const sdiod_drive_str_t sdiod_drive_strength_tab3[] = {
 	{
 	32, 0x7}, {
 	26, 0x6}, {
@@ -1904,18 +1899,19 @@ static const sdiod_drive_str_t BCMINITDATA(sdiod_drive_strength_tab3)[] =
 	12, 0x3}, {
 	8, 0x2}, {
 	4, 0x1}, {
-0, 0x0}};
+	0, 0x0}
+	};
 
 #define SDIOD_DRVSTR_KEY(chip, pmu)	(((chip) << 16) | (pmu))
 
 void
-BCMINITFN(si_sdiod_drive_strength_init) (si_t * sih, osl_t * osh,
-					 uint32 drivestrength) {
+si_sdiod_drive_strength_init(si_t *sih, osl_t *osh,
+					 u32 drivestrength) {
 	chipcregs_t *cc;
 	uint origidx, intr_val = 0;
 	sdiod_drive_str_t *str_tab = NULL;
-	uint32 str_mask = 0;
-	uint32 str_shift = 0;
+	u32 str_mask = 0;
+	u32 str_shift = 0;
 #ifdef BCMDBG
 	char chn[8];
 #endif
@@ -1929,8 +1925,19 @@ BCMINITFN(si_sdiod_drive_strength_init) (si_t * sih, osl_t * osh,
 					    &intr_val);
 
 	switch (SDIOD_DRVSTR_KEY(sih->chip, sih->pmurev)) {
+	case SDIOD_DRVSTR_KEY(BCM4325_CHIP_ID, 1):
+		str_tab = (sdiod_drive_str_t *)&sdiod_drive_strength_tab1;
+		str_mask = 0x30000000;
+		str_shift = 28;
+		break;
+	case SDIOD_DRVSTR_KEY(BCM4325_CHIP_ID, 2):
+	case SDIOD_DRVSTR_KEY(BCM4325_CHIP_ID, 3):
+		str_tab = (sdiod_drive_str_t *)&sdiod_drive_strength_tab2;
+		str_mask = 0x00003800;
+		str_shift = 11;
+		break;
 	case SDIOD_DRVSTR_KEY(BCM4336_CHIP_ID, 8):
-		str_tab = (sdiod_drive_str_t *) & sdiod_drive_strength_tab3;
+		str_tab = (sdiod_drive_str_t *) &sdiod_drive_strength_tab3;
 		str_mask = 0x00003800;
 		str_shift = 11;
 		break;
@@ -1942,8 +1949,8 @@ BCMINITFN(si_sdiod_drive_strength_init) (si_t * sih, osl_t * osh,
 	}
 
 	if (str_tab != NULL) {
-		uint32 drivestrength_sel = 0;
-		uint32 cc_data_temp;
+		u32 drivestrength_sel = 0;
+		u32 cc_data_temp;
 		int i;
 
 		for (i = 0; str_tab[i].strength != 0; i++) {
@@ -1969,7 +1976,8 @@ BCMINITFN(si_sdiod_drive_strength_init) (si_t * sih, osl_t * osh,
 }
 
 /* initialize PMU */
-void BCMATTACHFN(si_pmu_init) (si_t * sih, osl_t * osh) {
+void si_pmu_init(si_t *sih, osl_t *osh)
+{
 	chipcregs_t *cc;
 	uint origidx;
 
@@ -2000,22 +2008,22 @@ void BCMATTACHFN(si_pmu_init) (si_t * sih, osl_t * osh) {
 
 /* Return up time in ILP cycles for the given resource. */
 static uint
-BCMINITFN(si_pmu_res_uptime) (si_t * sih, osl_t * osh, chipcregs_t * cc,
-			      uint8 rsrc) {
-	uint32 deps;
+si_pmu_res_uptime(si_t *sih, osl_t *osh, chipcregs_t *cc,
+			      u8 rsrc) {
+	u32 deps;
 	uint up, i, dup, dmax;
-	uint32 min_mask = 0, max_mask = 0;
+	u32 min_mask = 0, max_mask = 0;
 
 	/* uptime of resource 'rsrc' */
 	W_REG(osh, &cc->res_table_sel, rsrc);
 	up = (R_REG(osh, &cc->res_updn_timer) >> 8) & 0xff;
 
 	/* direct dependancies of resource 'rsrc' */
-	deps = si_pmu_res_deps(sih, osh, cc, PMURES_BIT(rsrc), FALSE);
+	deps = si_pmu_res_deps(sih, osh, cc, PMURES_BIT(rsrc), false);
 	for (i = 0; i <= PMURES_MAX_RESNUM; i++) {
 		if (!(deps & PMURES_BIT(i)))
 			continue;
-		deps &= ~si_pmu_res_deps(sih, osh, cc, PMURES_BIT(i), TRUE);
+		deps &= ~si_pmu_res_deps(sih, osh, cc, PMURES_BIT(i), true);
 	}
 	si_pmu_res_masks(sih, &min_mask, &max_mask);
 	deps &= ~min_mask;
@@ -2025,7 +2033,7 @@ BCMINITFN(si_pmu_res_uptime) (si_t * sih, osl_t * osh, chipcregs_t * cc,
 	for (i = 0; i <= PMURES_MAX_RESNUM; i++) {
 		if (!(deps & PMURES_BIT(i)))
 			continue;
-		dup = si_pmu_res_uptime(sih, osh, cc, (uint8) i);
+		dup = si_pmu_res_uptime(sih, osh, cc, (u8) i);
 		if (dmax < dup)
 			dmax = dup;
 	}
@@ -2036,12 +2044,12 @@ BCMINITFN(si_pmu_res_uptime) (si_t * sih, osl_t * osh, chipcregs_t * cc,
 }
 
 /* Return dependancies (direct or all/indirect) for the given resources */
-static uint32
-si_pmu_res_deps(si_t * sih, osl_t * osh, chipcregs_t * cc, uint32 rsrcs,
+static u32
+si_pmu_res_deps(si_t *sih, osl_t *osh, chipcregs_t *cc, u32 rsrcs,
 		bool all)
 {
-	uint32 deps = 0;
-	uint32 i;
+	u32 deps = 0;
+	u32 i;
 
 	for (i = 0; i <= PMURES_MAX_RESNUM; i++) {
 		if (!(rsrcs & PMURES_BIT(i)))
@@ -2053,15 +2061,15 @@ si_pmu_res_deps(si_t * sih, osl_t * osh, chipcregs_t * cc, uint32 rsrcs,
 	return !all ? deps : (deps
 			      ? (deps |
 				 si_pmu_res_deps(sih, osh, cc, deps,
-						 TRUE)) : 0);
+						 true)) : 0);
 }
 
 /* power up/down OTP through PMU resources */
-void si_pmu_otp_power(si_t * sih, osl_t * osh, bool on)
+void si_pmu_otp_power(si_t *sih, osl_t *osh, bool on)
 {
 	chipcregs_t *cc;
 	uint origidx;
-	uint32 rsrcs = 0;	/* rsrcs to turn on/off OTP power */
+	u32 rsrcs = 0;	/* rsrcs to turn on/off OTP power */
 
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
@@ -2094,11 +2102,11 @@ void si_pmu_otp_power(si_t * sih, osl_t * osh, bool on)
 	}
 
 	if (rsrcs != 0) {
-		uint32 otps;
+		u32 otps;
 
 		/* Figure out the dependancies (exclude min_res_mask) */
-		uint32 deps = si_pmu_res_deps(sih, osh, cc, rsrcs, TRUE);
-		uint32 min_mask = 0, max_mask = 0;
+		u32 deps = si_pmu_res_deps(sih, osh, cc, rsrcs, true);
+		u32 min_mask = 0, max_mask = 0;
 		si_pmu_res_masks(sih, &min_mask, &max_mask);
 		deps &= ~min_mask;
 		/* Turn on/off the power */
@@ -2127,7 +2135,7 @@ void si_pmu_otp_power(si_t * sih, osl_t * osh, bool on)
 	si_setcoreidx(sih, origidx);
 }
 
-void si_pmu_rcal(si_t * sih, osl_t * osh)
+void si_pmu_rcal(si_t *sih, osl_t *osh)
 {
 	chipcregs_t *cc;
 	uint origidx;
@@ -2141,8 +2149,8 @@ void si_pmu_rcal(si_t * sih, osl_t * osh)
 
 	switch (CHIPID(sih->chip)) {
 	case BCM4329_CHIP_ID:{
-			uint8 rcal_code;
-			uint32 val;
+			u8 rcal_code;
+			u32 val;
 
 			/* Kick RCal */
 			W_REG(osh, &cc->chipcontrol_addr, 1);
@@ -2160,7 +2168,7 @@ void si_pmu_rcal(si_t * sih, osl_t * osh)
 
 			/* Drop the LSB to convert from 5 bit code to 4 bit code */
 			rcal_code =
-			    (uint8) (R_REG(osh, &cc->chipstatus) >> 5) & 0x0f;
+			    (u8) (R_REG(osh, &cc->chipstatus) >> 5) & 0x0f;
 
 			PMU_MSG(("RCal completed, status 0x%x, code 0x%x\n",
 				 R_REG(osh, &cc->chipstatus), rcal_code));
@@ -2170,12 +2178,12 @@ void si_pmu_rcal(si_t * sih, osl_t * osh)
 			val =
 			    R_REG(osh,
 				  &cc->
-				  regcontrol_data) & ~((uint32) 0x07 << 29);
-			val |= (uint32) (rcal_code & 0x07) << 29;
+				  regcontrol_data) & ~((u32) 0x07 << 29);
+			val |= (u32) (rcal_code & 0x07) << 29;
 			W_REG(osh, &cc->regcontrol_data, val);
 			W_REG(osh, &cc->regcontrol_addr, 1);
-			val = R_REG(osh, &cc->regcontrol_data) & ~(uint32) 0x01;
-			val |= (uint32) ((rcal_code >> 3) & 0x01);
+			val = R_REG(osh, &cc->regcontrol_data) & ~(u32) 0x01;
+			val |= (u32) ((rcal_code >> 3) & 0x01);
 			W_REG(osh, &cc->regcontrol_data, val);
 
 			/* Write RCal code into pmu_chip_ctrl[33:30] */
@@ -2183,13 +2191,13 @@ void si_pmu_rcal(si_t * sih, osl_t * osh)
 			val =
 			    R_REG(osh,
 				  &cc->
-				  chipcontrol_data) & ~((uint32) 0x03 << 30);
-			val |= (uint32) (rcal_code & 0x03) << 30;
+				  chipcontrol_data) & ~((u32) 0x03 << 30);
+			val |= (u32) (rcal_code & 0x03) << 30;
 			W_REG(osh, &cc->chipcontrol_data, val);
 			W_REG(osh, &cc->chipcontrol_addr, 1);
 			val =
-			    R_REG(osh, &cc->chipcontrol_data) & ~(uint32) 0x03;
-			val |= (uint32) ((rcal_code >> 2) & 0x03);
+			    R_REG(osh, &cc->chipcontrol_data) & ~(u32) 0x03;
+			val |= (u32) ((rcal_code >> 2) & 0x03);
 			W_REG(osh, &cc->chipcontrol_data, val);
 
 			/* Set override in pmu_chip_ctrl[29] */
@@ -2210,11 +2218,11 @@ void si_pmu_rcal(si_t * sih, osl_t * osh)
 	si_setcoreidx(sih, origidx);
 }
 
-void si_pmu_spuravoid(si_t * sih, osl_t * osh, uint8 spuravoid)
+void si_pmu_spuravoid(si_t *sih, osl_t *osh, u8 spuravoid)
 {
 	chipcregs_t *cc;
 	uint origidx, intr_val;
-	uint32 tmp = 0;
+	u32 tmp = 0;
 
 	/* Remember original core before switch to chipc */
 	cc = (chipcregs_t *) si_switch_core(sih, CC_CORE_ID, &origidx,
@@ -2247,13 +2255,13 @@ void si_pmu_spuravoid(si_t * sih, osl_t * osh, uint8 spuravoid)
 }
 
 static void
-si_pmu_spuravoid_pllupdate(si_t * sih, chipcregs_t * cc, osl_t * osh,
-			   uint8 spuravoid)
+si_pmu_spuravoid_pllupdate(si_t *sih, chipcregs_t *cc, osl_t *osh,
+			   u8 spuravoid)
 {
-	uint32 tmp = 0;
-	uint8 phypll_offset = 0;
-	uint8 bcm5357_bcm43236_p1div[] = { 0x1, 0x5, 0x5 };
-	uint8 bcm5357_bcm43236_ndiv[] = { 0x30, 0xf6, 0xfc };
+	u32 tmp = 0;
+	u8 phypll_offset = 0;
+	u8 bcm5357_bcm43236_p1div[] = { 0x1, 0x5, 0x5 };
+	u8 bcm5357_bcm43236_ndiv[] = { 0x30, 0xf6, 0xfc };
 
 	switch (CHIPID(sih->chip)) {
 	case BCM5357_CHIP_ID:
@@ -2443,7 +2451,7 @@ si_pmu_spuravoid_pllupdate(si_t * sih, chipcregs_t * cc, osl_t * osh,
 	W_REG(osh, &cc->pmucontrol, tmp);
 }
 
-bool si_pmu_is_otp_powered(si_t * sih, osl_t * osh)
+bool si_pmu_is_otp_powered(si_t *sih, osl_t *osh)
 {
 	uint idx;
 	chipcregs_t *cc;
@@ -2481,10 +2489,10 @@ bool si_pmu_is_otp_powered(si_t * sih, osl_t * osh)
 	case BCM43236_CHIP_ID:
 	case BCM43235_CHIP_ID:
 	case BCM43238_CHIP_ID:
-		st = TRUE;
+		st = true;
 		break;
 	default:
-		st = TRUE;
+		st = true;
 		break;
 	}
 
@@ -2495,9 +2503,9 @@ bool si_pmu_is_otp_powered(si_t * sih, osl_t * osh)
 
 void
 #if defined(BCMDBG)
-si_pmu_sprom_enable(si_t * sih, osl_t * osh, bool enable)
+si_pmu_sprom_enable(si_t *sih, osl_t *osh, bool enable)
 #else
-BCMATTACHFN(si_pmu_sprom_enable) (si_t * sih, osl_t * osh, bool enable)
+si_pmu_sprom_enable(si_t *sih, osl_t *osh, bool enable)
 #endif
 {
 	chipcregs_t *cc;
@@ -2513,18 +2521,19 @@ BCMATTACHFN(si_pmu_sprom_enable) (si_t * sih, osl_t * osh, bool enable)
 }
 
 /* initialize PMU chip controls and other chip level stuff */
-void BCMATTACHFN(si_pmu_chip_init) (si_t * sih, osl_t * osh) {
+void si_pmu_chip_init(si_t *sih, osl_t *osh)
+{
 	uint origidx;
 
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
 #ifdef CHIPC_UART_ALWAYS_ON
-	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, clk_ctl_st),
+	si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, clk_ctl_st),
 		   CCS_FORCEALP, CCS_FORCEALP);
 #endif				/* CHIPC_UART_ALWAYS_ON */
 
 	/* Gate off SPROM clock and chip select signals */
-	si_pmu_sprom_enable(sih, osh, FALSE);
+	si_pmu_sprom_enable(sih, osh, false);
 
 	/* Remember original core */
 	origidx = si_coreidx(sih);
@@ -2534,7 +2543,8 @@ void BCMATTACHFN(si_pmu_chip_init) (si_t * sih, osl_t * osh) {
 }
 
 /* initialize PMU switch/regulators */
-void BCMATTACHFN(si_pmu_swreg_init) (si_t * sih, osl_t * osh) {
+void si_pmu_swreg_init(si_t *sih, osl_t *osh)
+{
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
 	switch (CHIPID(sih->chip)) {
@@ -2559,7 +2569,7 @@ void BCMATTACHFN(si_pmu_swreg_init) (si_t * sih, osl_t * osh) {
 	}
 }
 
-void si_pmu_radio_enable(si_t * sih, bool enable)
+void si_pmu_radio_enable(si_t *sih, bool enable)
 {
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
@@ -2567,18 +2577,18 @@ void si_pmu_radio_enable(si_t * sih, bool enable)
 	case BCM4319_CHIP_ID:
 		if (enable)
 			si_write_wrapperreg(sih, AI_OOBSELOUTB74,
-					    (uint32) 0x868584);
+					    (u32) 0x868584);
 		else
 			si_write_wrapperreg(sih, AI_OOBSELOUTB74,
-					    (uint32) 0x060584);
+					    (u32) 0x060584);
 		break;
 	}
 }
 
 /* Wait for a particular clock level to be on the backplane */
-uint32
-si_pmu_waitforclk_on_backplane(si_t * sih, osl_t * osh, uint32 clk,
-			       uint32 delay)
+u32
+si_pmu_waitforclk_on_backplane(si_t *sih, osl_t *osh, u32 clk,
+			       u32 delay)
 {
 	chipcregs_t *cc;
 	uint origidx;
@@ -2596,7 +2606,7 @@ si_pmu_waitforclk_on_backplane(si_t * sih, osl_t * osh, uint32 clk,
 	/* Return to original core */
 	si_setcoreidx(sih, origidx);
 
-	return (R_REG(osh, &cc->pmustatus) & clk);
+	return R_REG(osh, &cc->pmustatus) & clk;
 }
 
 /*
@@ -2606,10 +2616,11 @@ si_pmu_waitforclk_on_backplane(si_t * sih, osl_t * osh, uint32 clk,
 
 #define EXT_ILP_HZ 32768
 
-uint32 BCMATTACHFN(si_pmu_measure_alpclk) (si_t * sih, osl_t * osh) {
+u32 si_pmu_measure_alpclk(si_t *sih, osl_t *osh)
+{
 	chipcregs_t *cc;
 	uint origidx;
-	uint32 alp_khz;
+	u32 alp_khz;
 
 	if (sih->pmurev < 10)
 		return 0;
@@ -2622,14 +2633,14 @@ uint32 BCMATTACHFN(si_pmu_measure_alpclk) (si_t * sih, osl_t * osh) {
 	ASSERT(cc != NULL);
 
 	if (R_REG(osh, &cc->pmustatus) & PST_EXTLPOAVAIL) {
-		uint32 ilp_ctr, alp_hz;
+		u32 ilp_ctr, alp_hz;
 
 		/* Enable the reg to measure the freq, in case disabled before */
 		W_REG(osh, &cc->pmu_xtalfreq,
 		      1U << PMU_XTALFREQ_REG_MEASURE_SHIFT);
 
 		/* Delay for well over 4 ILP clocks */
-		OSL_DELAY(1000);
+		udelay(1000);
 
 		/* Read the latched number of ALP ticks per 4 ILP ticks */
 		ilp_ctr =
@@ -2653,10 +2664,11 @@ uint32 BCMATTACHFN(si_pmu_measure_alpclk) (si_t * sih, osl_t * osh) {
 	return alp_khz;
 }
 
-static void BCMATTACHFN(si_pmu_set_4330_plldivs) (si_t * sih) {
-	uint32 FVCO = si_pmu1_pllfvco0(sih) / 1000;
-	uint32 m1div, m2div, m3div, m4div, m5div, m6div;
-	uint32 pllc1, pllc2;
+static void si_pmu_set_4330_plldivs(si_t *sih)
+{
+	u32 FVCO = si_pmu1_pllfvco0(sih) / 1000;
+	u32 m1div, m2div, m3div, m4div, m5div, m6div;
+	u32 pllc1, pllc2;
 
 	m2div = m3div = m4div = m6div = FVCO / 80;
 	m5div = FVCO / 160;
diff --git a/drivers/staging/brcm80211/util/linux_osl.c b/drivers/staging/brcm80211/util/linux_osl.c
index a1898bb..2bb5b87 100644
--- a/drivers/staging/brcm80211/util/linux_osl.c
+++ b/drivers/staging/brcm80211/util/linux_osl.c
@@ -14,47 +14,37 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <typedefs.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#ifdef mips
+#include <asm/paccess.h>
+#endif				/* mips */
 #include <bcmendian.h>
 #include <linuxver.h>
 #include <bcmdefs.h>
 #include <osl.h>
 #include <bcmutils.h>
-#include <linux/delay.h>
-#ifdef mips
-#include <asm/paccess.h>
-#endif				/* mips */
 #include <pcicfg.h>
 
-#include <linux/fs.h>
 
 #define PCI_CFG_RETRY 		10
 
 #define OS_HANDLE_MAGIC		0x1234abcd	/* Magic # to recognise osh */
 #define BCM_MEM_FILENAME_LEN 	24	/* Mem. filename length */
 
-typedef struct bcm_mem_link {
-	struct bcm_mem_link *prev;
-	struct bcm_mem_link *next;
-	uint size;
-	int line;
-	char file[BCM_MEM_FILENAME_LEN];
-} bcm_mem_link_t;
-
 struct osl_info {
 	osl_pubinfo_t pub;
 	uint magic;
 	void *pdev;
-	uint malloced;
 	uint failed;
 	uint bustype;
-	bcm_mem_link_t *dbgmem_list;
 };
 
 /* Global ASSERT type flag */
-uint32 g_assert_type = 0;
+u32 g_assert_type;
 
-static int16 linuxbcmerrormap[] = { 0,	/* 0 */
+#ifdef BRCM_FULLMAC
+static s16 linuxbcmerrormap[] = { 0,	/* 0 */
 	-EINVAL,		/* BCME_ERROR */
 	-EINVAL,		/* BCME_BADARG */
 	-EINVAL,		/* BCME_BADOPTION */
@@ -119,6 +109,7 @@ int osl_error(int bcmerror)
 	/* Array bounds covered by ASSERT in osl_attach */
 	return linuxbcmerrormap[-bcmerror];
 }
+#endif /* BRCM_FULLMAC */
 
 osl_t *osl_attach(void *pdev, uint bustype, bool pkttag)
 {
@@ -129,13 +120,13 @@ osl_t *osl_attach(void *pdev, uint bustype, bool pkttag)
 
 	bzero(osh, sizeof(osl_t));
 
+#ifdef BRCM_FULLMAC
 	/* Check that error map has the right number of entries in it */
-	ASSERT(ABS(BCME_LAST) == (ARRAYSIZE(linuxbcmerrormap) - 1));
+	ASSERT(ABS(BCME_LAST) == (ARRAY_SIZE(linuxbcmerrormap) - 1));
+#endif /* BRCM_FULLMAC */
 
 	osh->magic = OS_HANDLE_MAGIC;
-	osh->malloced = 0;
 	osh->failed = 0;
-	osh->dbgmem_list = NULL;
 	osh->pdev = pdev;
 	osh->pub.pkttag = pkttag;
 	osh->bustype = bustype;
@@ -143,21 +134,22 @@ osl_t *osl_attach(void *pdev, uint bustype, bool pkttag)
 	switch (bustype) {
 	case PCI_BUS:
 	case SI_BUS:
-		osh->pub.mmbus = TRUE;
+	case PCMCIA_BUS:
+		osh->pub.mmbus = true;
 		break;
 	case JTAG_BUS:
 	case SDIO_BUS:
 	case USB_BUS:
 	case SPI_BUS:
 	case RPC_BUS:
-		osh->pub.mmbus = FALSE;
+		osh->pub.mmbus = false;
 		break;
 	default:
-		ASSERT(FALSE);
+		ASSERT(false);
 		break;
 	}
 
-#ifdef BCMDBG
+#if defined(BCMDBG) && !defined(BRCM_FULLMAC)
 	if (pkttag) {
 		struct sk_buff *skb;
 		ASSERT(OSL_PKTTAG_SZ <= sizeof(skb->cb));
@@ -166,7 +158,7 @@ osl_t *osl_attach(void *pdev, uint bustype, bool pkttag)
 	return osh;
 }
 
-void osl_detach(osl_t * osh)
+void osl_detach(osl_t *osh)
 {
 	if (osh == NULL)
 		return;
@@ -176,22 +168,23 @@ void osl_detach(osl_t * osh)
 }
 
 /* Return a new packet. zero out pkttag */
-void *BCMFASTPATH osl_pktget(osl_t * osh, uint len)
+void *BCMFASTPATH osl_pktget(osl_t *osh, uint len)
 {
 	struct sk_buff *skb;
 
-	if ((skb = dev_alloc_skb(len))) {
+	skb = dev_alloc_skb(len);
+	if (skb) {
 		skb_put(skb, len);
 		skb->priority = 0;
 
 		osh->pub.pktalloced++;
 	}
 
-	return ((void *)skb);
+	return (void *)skb;
 }
 
 /* Free the driver packet. Free the tag if present */
-void BCMFASTPATH osl_pktfree(osl_t * osh, void *p, bool send)
+void BCMFASTPATH osl_pktfree(osl_t *osh, void *p, bool send)
 {
 	struct sk_buff *skb, *nskb;
 	int nest = 0;
@@ -224,7 +217,7 @@ void BCMFASTPATH osl_pktfree(osl_t * osh, void *p, bool send)
 	}
 }
 
-uint32 osl_pci_read_config(osl_t * osh, uint offset, uint size)
+u32 osl_pci_read_config(osl_t *osh, uint offset, uint size)
 {
 	uint val = 0;
 	uint retry = PCI_CFG_RETRY;
@@ -246,10 +239,10 @@ uint32 osl_pci_read_config(osl_t * osh, uint offset, uint size)
 		       offset, (PCI_CFG_RETRY - retry));
 #endif				/* BCMDBG */
 
-	return (val);
+	return val;
 }
 
-void osl_pci_write_config(osl_t * osh, uint offset, uint size, uint val)
+void osl_pci_write_config(osl_t *osh, uint offset, uint size, uint val)
 {
 	uint retry = PCI_CFG_RETRY;
 
@@ -266,7 +259,7 @@ void osl_pci_write_config(osl_t * osh, uint offset, uint size, uint val)
 			break;
 	} while (retry--);
 
-#ifdef BCMDBG
+#if defined(BCMDBG) && !defined(BRCM_FULLMAC)
 	if (retry < PCI_CFG_RETRY)
 		printk("PCI CONFIG WRITE access to %d required %d retries\n",
 		       offset, (PCI_CFG_RETRY - retry));
@@ -274,7 +267,7 @@ void osl_pci_write_config(osl_t * osh, uint offset, uint size, uint val)
 }
 
 /* return bus # for the pci device pointed by osh->pdev */
-uint osl_pci_bus(osl_t * osh)
+uint osl_pci_bus(osl_t *osh)
 {
 	ASSERT(osh && (osh->magic == OS_HANDLE_MAGIC) && osh->pdev);
 
@@ -282,109 +275,55 @@ uint osl_pci_bus(osl_t * osh)
 }
 
 /* return slot # for the pci device pointed by osh->pdev */
-uint osl_pci_slot(osl_t * osh)
+uint osl_pci_slot(osl_t *osh)
 {
 	ASSERT(osh && (osh->magic == OS_HANDLE_MAGIC) && osh->pdev);
 
 	return PCI_SLOT(((struct pci_dev *)osh->pdev)->devfn);
 }
 
-static void
-osl_pcmcia_attr(osl_t * osh, uint offset, char *buf, int size, bool write)
-{
-}
-
-void osl_pcmcia_read_attr(osl_t * osh, uint offset, void *buf, int size)
-{
-	osl_pcmcia_attr(osh, offset, (char *)buf, size, FALSE);
-}
-
-void osl_pcmcia_write_attr(osl_t * osh, uint offset, void *buf, int size)
-{
-	osl_pcmcia_attr(osh, offset, (char *)buf, size, TRUE);
-}
-
-void *osl_malloc(osl_t * osh, uint size)
-{
-	void *addr;
-
-	/* only ASSERT if osh is defined */
-	if (osh)
-		ASSERT(osh->magic == OS_HANDLE_MAGIC);
-
-	if ((addr = kmalloc(size, GFP_ATOMIC)) == NULL) {
-		if (osh)
-			osh->failed++;
-		return (NULL);
-	}
-	if (osh)
-		osh->malloced += size;
-
-	return (addr);
-}
-
-void osl_mfree(osl_t * osh, void *addr, uint size)
-{
-	if (osh) {
-		ASSERT(osh->magic == OS_HANDLE_MAGIC);
-		osh->malloced -= size;
-	}
-	kfree(addr);
-}
-
-uint osl_malloced(osl_t * osh)
-{
-	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
-	return (osh->malloced);
-}
-
-uint osl_malloc_failed(osl_t * osh)
-{
-	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
-	return (osh->failed);
-}
-
 uint osl_dma_consistent_align(void)
 {
-	return (PAGE_SIZE);
+	return PAGE_SIZE;
 }
 
-void *osl_dma_alloc_consistent(osl_t * osh, uint size, uint16 align_bits,
-			       uint * alloced, ulong * pap)
+void *osl_dma_alloc_consistent(osl_t *osh, uint size, u16 align_bits,
+			       uint *alloced, unsigned long *pap)
 {
-	uint16 align = (1 << align_bits);
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
-	if (!ISALIGNED(DMA_CONSISTENT_ALIGN, align))
-		size += align;
-	*alloced = size;
-
-	return (pci_alloc_consistent(osh->pdev, size, (dma_addr_t *) pap));
+	if (align_bits) {
+		u16 align = (1 << align_bits);
+		if (!IS_ALIGNED(DMA_CONSISTENT_ALIGN, align))
+			size += align;
+		*alloced = size;
+	}
+	return pci_alloc_consistent(osh->pdev, size, (dma_addr_t *) pap);
 }
 
-void osl_dma_free_consistent(osl_t * osh, void *va, uint size, ulong pa)
+void osl_dma_free_consistent(osl_t *osh, void *va, uint size, unsigned long pa)
 {
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
 	pci_free_consistent(osh->pdev, size, va, (dma_addr_t) pa);
 }
 
-uint BCMFASTPATH osl_dma_map(osl_t * osh, void *va, uint size, int direction)
+uint BCMFASTPATH osl_dma_map(osl_t *osh, void *va, uint size, int direction)
 {
 	int dir;
 
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 	dir = (direction == DMA_TX) ? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE;
-	return (pci_map_single(osh->pdev, va, size, dir));
+	return pci_map_single(osh->pdev, va, size, dir);
 }
 
-void BCMFASTPATH osl_dma_unmap(osl_t * osh, uint pa, uint size, int direction)
+void BCMFASTPATH osl_dma_unmap(osl_t *osh, uint pa, uint size, int direction)
 {
 	int dir;
 
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 	dir = (direction == DMA_TX) ? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE;
-	pci_unmap_single(osh->pdev, (uint32) pa, size, dir);
+	pci_unmap_single(osh->pdev, (u32) pa, size, dir);
 }
 
 #if defined(BCMDBG_ASSERT)
@@ -409,22 +348,22 @@ void osl_assert(char *exp, char *file, int line)
 	/* Print assert message and give it time to be written to /var/log/messages */
 	if (!in_interrupt()) {
 		const int delay = 3;
-		printk("%s", tempbuf);
-		printk("panic in %d seconds\n", delay);
+		printk(KERN_ERR "%s", tempbuf);
+		printk(KERN_ERR "panic in %d seconds\n", delay);
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(delay * HZ);
 	}
 
 	switch (g_assert_type) {
 	case 0:
-		panic("%s", tempbuf);
+		panic(KERN_ERR "%s", tempbuf);
 		break;
 	case 1:
-		printk("%s", tempbuf);
+		printk(KERN_ERR "%s", tempbuf);
 		BUG();
 		break;
 	case 2:
-		printk("%s", tempbuf);
+		printk(KERN_ERR "%s", tempbuf);
 		break;
 	default:
 		break;
@@ -434,83 +373,52 @@ void osl_assert(char *exp, char *file, int line)
 }
 #endif				/* defined(BCMDBG_ASSERT) */
 
-void osl_delay(uint usec)
-{
-	uint d;
-
-	while (usec > 0) {
-		d = MIN(usec, 1000);
-		udelay(d);
-		usec -= d;
-	}
-}
-
-/* Clone a packet.
- * The pkttag contents are NOT cloned.
- */
-void *osl_pktdup(osl_t * osh, void *skb)
-{
-	void *p;
-
-	if ((p = skb_clone((struct sk_buff *)skb, GFP_ATOMIC)) == NULL)
-		return NULL;
-
-	/* skb_clone copies skb->cb.. we don't want that */
-	if (osh->pub.pkttag)
-		bzero((void *)((struct sk_buff *)p)->cb, OSL_PKTTAG_SZ);
-
-	/* Increment the packet counter */
-	osh->pub.pktalloced++;
-	return (p);
-}
-
-#ifdef BCMSDIO
-uint8 osl_readb(osl_t * osh, volatile uint8 * r)
+#if defined(BCMSDIO) && !defined(BRCM_FULLMAC)
+u8 osl_readb(osl_t *osh, volatile u8 *r)
 {
 	osl_rreg_fn_t rreg = ((osl_pubinfo_t *) osh)->rreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
 
-	return (uint8) ((rreg) (ctx, (void *)r, sizeof(uint8)));
+	return (u8) ((rreg) (ctx, (void *)r, sizeof(u8)));
 }
 
-uint16 osl_readw(osl_t * osh, volatile uint16 * r)
+u16 osl_readw(osl_t *osh, volatile u16 *r)
 {
 	osl_rreg_fn_t rreg = ((osl_pubinfo_t *) osh)->rreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
 
-	return (uint16) ((rreg) (ctx, (void *)r, sizeof(uint16)));
+	return (u16) ((rreg) (ctx, (void *)r, sizeof(u16)));
 }
 
-uint32 osl_readl(osl_t * osh, volatile uint32 * r)
+u32 osl_readl(osl_t *osh, volatile u32 *r)
 {
 	osl_rreg_fn_t rreg = ((osl_pubinfo_t *) osh)->rreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
 
-	return (uint32) ((rreg) (ctx, (void *)r, sizeof(uint32)));
+	return (u32) ((rreg) (ctx, (void *)r, sizeof(u32)));
 }
 
-void osl_writeb(osl_t * osh, volatile uint8 * r, uint8 v)
+void osl_writeb(osl_t *osh, volatile u8 *r, u8 v)
 {
 	osl_wreg_fn_t wreg = ((osl_pubinfo_t *) osh)->wreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
 
-	((wreg) (ctx, (void *)r, v, sizeof(uint8)));
+	((wreg) (ctx, (void *)r, v, sizeof(u8)));
 }
 
-void osl_writew(osl_t * osh, volatile uint16 * r, uint16 v)
+void osl_writew(osl_t *osh, volatile u16 *r, u16 v)
 {
 	osl_wreg_fn_t wreg = ((osl_pubinfo_t *) osh)->wreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
 
-	((wreg) (ctx, (void *)r, v, sizeof(uint16)));
+	((wreg) (ctx, (void *)r, v, sizeof(u16)));
 }
 
-void osl_writel(osl_t * osh, volatile uint32 * r, uint32 v)
+void osl_writel(osl_t *osh, volatile u32 *r, u32 v)
 {
 	osl_wreg_fn_t wreg = ((osl_pubinfo_t *) osh)->wreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
 
-	((wreg) (ctx, (void *)r, v, sizeof(uint32)));
+	((wreg) (ctx, (void *)r, v, sizeof(u32)));
 }
-#endif				/* BCMSDIO */
-/* Linux Kernel: File Operations: end */
+#endif	/* BCMSDIO */
diff --git a/drivers/staging/brcm80211/util/nicpci.c b/drivers/staging/brcm80211/util/nicpci.c
index feaa54f..23f86dd 100644
--- a/drivers/staging/brcm80211/util/nicpci.c
+++ b/drivers/staging/brcm80211/util/nicpci.c
@@ -14,7 +14,8 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <typedefs.h>
+#include <linux/string.h>
+#include <linuxver.h>
 #include <bcmdefs.h>
 #include <osl.h>
 #include <bcmutils.h>
@@ -30,17 +31,17 @@
 typedef struct {
 	union {
 		sbpcieregs_t *pcieregs;
-		sbpciregs_t *pciregs;
+		struct sbpciregs *pciregs;
 	} regs;			/* Memory mapped register to the core */
 
 	si_t *sih;		/* System interconnect handle */
 	osl_t *osh;		/* OSL handle */
-	uint8 pciecap_lcreg_offset;	/* PCIE capability LCreg offset in the config space */
+	u8 pciecap_lcreg_offset;	/* PCIE capability LCreg offset in the config space */
 	bool pcie_pr42767;
-	uint8 pcie_polarity;
-	uint8 pcie_war_aspm_ovr;	/* Override ASPM/Clkreq settings */
+	u8 pcie_polarity;
+	u8 pcie_war_aspm_ovr;	/* Override ASPM/Clkreq settings */
 
-	uint8 pmecap_offset;	/* PM Capability offset in the config space */
+	u8 pmecap_offset;	/* PM Capability offset in the config space */
 	bool pmecap;		/* Capable of generating PME */
 } pcicore_info_t;
 
@@ -49,24 +50,24 @@ typedef struct {
 #define PCIE_PUB(sih) ((BUSTYPE((sih)->bustype) == PCI_BUS) && ((sih)->buscoretype == PCIE_CORE_ID))
 
 /* routines to access mdio slave device registers */
-static bool pcie_mdiosetblock(pcicore_info_t * pi, uint blk);
-static int pcie_mdioop(pcicore_info_t * pi, uint physmedia, uint regaddr,
-		       bool write, uint * val);
-static int pcie_mdiowrite(pcicore_info_t * pi, uint physmedia, uint readdr,
+static bool pcie_mdiosetblock(pcicore_info_t *pi, uint blk);
+static int pcie_mdioop(pcicore_info_t *pi, uint physmedia, uint regaddr,
+		       bool write, uint *val);
+static int pcie_mdiowrite(pcicore_info_t *pi, uint physmedia, uint readdr,
 			  uint val);
-static int pcie_mdioread(pcicore_info_t * pi, uint physmedia, uint readdr,
-			 uint * ret_val);
+static int pcie_mdioread(pcicore_info_t *pi, uint physmedia, uint readdr,
+			 uint *ret_val);
 
-static void pcie_extendL1timer(pcicore_info_t * pi, bool extend);
-static void pcie_clkreq_upd(pcicore_info_t * pi, uint state);
+static void pcie_extendL1timer(pcicore_info_t *pi, bool extend);
+static void pcie_clkreq_upd(pcicore_info_t *pi, uint state);
 
-static void pcie_war_aspm_clkreq(pcicore_info_t * pi);
-static void pcie_war_serdes(pcicore_info_t * pi);
-static void pcie_war_noplldown(pcicore_info_t * pi);
-static void pcie_war_polarity(pcicore_info_t * pi);
-static void pcie_war_pci_setup(pcicore_info_t * pi);
+static void pcie_war_aspm_clkreq(pcicore_info_t *pi);
+static void pcie_war_serdes(pcicore_info_t *pi);
+static void pcie_war_noplldown(pcicore_info_t *pi);
+static void pcie_war_polarity(pcicore_info_t *pi);
+static void pcie_war_pci_setup(pcicore_info_t *pi);
 
-static bool pcicore_pmecap(pcicore_info_t * pi);
+static bool pcicore_pmecap(pcicore_info_t *pi);
 
 #define PCIE_ASPM(sih)	((PCIE_PUB(sih)) && (((sih)->buscorerev >= 3) && ((sih)->buscorerev <= 5)))
 
@@ -87,45 +88,43 @@ static bool pcicore_pmecap(pcicore_info_t * pi);
 	(WORD_VAL(OSL_PCI_READ_CONFIG(osh, DWORD_ALIGN(a), 4), a) & 0xffff)
 
 #define write_pci_cfg_byte(a, val) do { \
-	uint32 tmpval; \
+	u32 tmpval; \
 	tmpval = (OSL_PCI_READ_CONFIG(osh, DWORD_ALIGN(a), 4) & ~0xFF << BYTE_POS(a)) | \
 		val << BYTE_POS(a); \
 	OSL_PCI_WRITE_CONFIG(osh, DWORD_ALIGN(a), 4, tmpval); \
 	} while (0)
 
 #define write_pci_cfg_word(a, val) do { \
-	uint32 tmpval; \
+	u32 tmpval; \
 	tmpval = (OSL_PCI_READ_CONFIG(osh, DWORD_ALIGN(a), 4) & ~0xFFFF << WORD_POS(a)) | \
 		val << WORD_POS(a); \
 	OSL_PCI_WRITE_CONFIG(osh, DWORD_ALIGN(a), 4, tmpval); \
 	} while (0)
 
 /* delay needed between the mdio control/ mdiodata register data access */
-#define PR28829_DELAY() OSL_DELAY(10)
+#define PR28829_DELAY() udelay(10)
 
 /* Initialize the PCI core. It's caller's responsibility to make sure that this is done
  * only once
  */
-void *pcicore_init(si_t * sih, osl_t * osh, void *regs)
+void *pcicore_init(si_t *sih, osl_t *osh, void *regs)
 {
 	pcicore_info_t *pi;
 
 	ASSERT(sih->bustype == PCI_BUS);
 
 	/* alloc pcicore_info_t */
-	if ((pi = MALLOC(osh, sizeof(pcicore_info_t))) == NULL) {
-		PCI_ERROR(("pci_attach: malloc failed! malloced %d bytes\n",
-			   MALLOCED(osh)));
-		return (NULL);
+	pi = kzalloc(sizeof(pcicore_info_t), GFP_ATOMIC);
+	if (pi == NULL) {
+		PCI_ERROR(("pci_attach: malloc failed!\n"));
+		return NULL;
 	}
 
-	bzero(pi, sizeof(pcicore_info_t));
-
 	pi->sih = sih;
 	pi->osh = osh;
 
 	if (sih->buscoretype == PCIE_CORE_ID) {
-		uint8 cap_ptr;
+		u8 cap_ptr;
 		pi->regs.pcieregs = (sbpcieregs_t *) regs;
 		cap_ptr =
 		    pcicore_find_pci_capability(pi->osh, PCI_CAP_PCIECAP_ID,
@@ -133,7 +132,7 @@ void *pcicore_init(si_t * sih, osl_t * osh, void *regs)
 		ASSERT(cap_ptr);
 		pi->pciecap_lcreg_offset = cap_ptr + PCIE_CAP_LINKCTRL_OFFSET;
 	} else
-		pi->regs.pciregs = (sbpciregs_t *) regs;
+		pi->regs.pciregs = (struct sbpciregs *) regs;
 
 	return pi;
 }
@@ -144,19 +143,19 @@ void pcicore_deinit(void *pch)
 
 	if (pi == NULL)
 		return;
-	MFREE(pi->osh, pi, sizeof(pcicore_info_t));
+	kfree(pi);
 }
 
 /* return cap_offset if requested capability exists in the PCI config space */
 /* Note that it's caller's responsibility to make sure it's a pci bus */
-uint8
-pcicore_find_pci_capability(osl_t * osh, uint8 req_cap_id, uchar * buf,
-			    uint32 * buflen)
+u8
+pcicore_find_pci_capability(osl_t *osh, u8 req_cap_id, unsigned char *buf,
+			    u32 *buflen)
 {
-	uint8 cap_id;
-	uint8 cap_ptr = 0;
-	uint32 bufsize;
-	uint8 byte_val;
+	u8 cap_id;
+	u8 cap_ptr = 0;
+	u32 bufsize;
+	u8 byte_val;
 
 	/* check for Header type 0 */
 	byte_val = read_pci_cfg_byte(PCI_CFG_HDR);
@@ -188,7 +187,7 @@ pcicore_find_pci_capability(osl_t * osh, uint8 req_cap_id, uchar * buf,
 	}
 	/* found the caller requested capability */
 	if ((buf != NULL) && (buflen != NULL)) {
-		uint8 cap_data;
+		u8 cap_data;
 
 		bufsize = *buflen;
 		if (!bufsize)
@@ -211,7 +210,7 @@ pcicore_find_pci_capability(osl_t * osh, uint8 req_cap_id, uchar * buf,
 
 /* ***** Register Access API */
 uint
-pcie_readreg(osl_t * osh, sbpcieregs_t * pcieregs, uint addrtype, uint offset)
+pcie_readreg(osl_t *osh, sbpcieregs_t *pcieregs, uint addrtype, uint offset)
 {
 	uint retval = 0xFFFFFFFF;
 
@@ -237,7 +236,7 @@ pcie_readreg(osl_t * osh, sbpcieregs_t * pcieregs, uint addrtype, uint offset)
 }
 
 uint
-pcie_writereg(osl_t * osh, sbpcieregs_t * pcieregs, uint addrtype, uint offset,
+pcie_writereg(osl_t *osh, sbpcieregs_t *pcieregs, uint addrtype, uint offset,
 	      uint val)
 {
 	ASSERT(pcieregs != NULL);
@@ -258,7 +257,7 @@ pcie_writereg(osl_t * osh, sbpcieregs_t * pcieregs, uint addrtype, uint offset,
 	return 0;
 }
 
-static bool pcie_mdiosetblock(pcicore_info_t * pi, uint blk)
+static bool pcie_mdiosetblock(pcicore_info_t *pi, uint blk)
 {
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
 	uint mdiodata, i = 0;
@@ -278,21 +277,21 @@ static bool pcie_mdiosetblock(pcicore_info_t * pi, uint blk)
 		    MDIOCTL_ACCESS_DONE) {
 			break;
 		}
-		OSL_DELAY(1000);
+		udelay(1000);
 		i++;
 	}
 
 	if (i >= pcie_serdes_spinwait) {
 		PCI_ERROR(("pcie_mdiosetblock: timed out\n"));
-		return FALSE;
+		return false;
 	}
 
-	return TRUE;
+	return true;
 }
 
 static int
-pcie_mdioop(pcicore_info_t * pi, uint physmedia, uint regaddr, bool write,
-	    uint * val)
+pcie_mdioop(pcicore_info_t *pi, uint physmedia, uint regaddr, bool write,
+	    uint *val)
 {
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
 	uint mdiodata;
@@ -339,7 +338,7 @@ pcie_mdioop(pcicore_info_t * pi, uint physmedia, uint regaddr, bool write,
 			W_REG(pi->osh, (&pcieregs->mdiocontrol), 0);
 			return 0;
 		}
-		OSL_DELAY(1000);
+		udelay(1000);
 		i++;
 	}
 
@@ -351,38 +350,38 @@ pcie_mdioop(pcicore_info_t * pi, uint physmedia, uint regaddr, bool write,
 
 /* use the mdio interface to read from mdio slaves */
 static int
-pcie_mdioread(pcicore_info_t * pi, uint physmedia, uint regaddr, uint * regval)
+pcie_mdioread(pcicore_info_t *pi, uint physmedia, uint regaddr, uint *regval)
 {
-	return pcie_mdioop(pi, physmedia, regaddr, FALSE, regval);
+	return pcie_mdioop(pi, physmedia, regaddr, false, regval);
 }
 
 /* use the mdio interface to write to mdio slaves */
 static int
-pcie_mdiowrite(pcicore_info_t * pi, uint physmedia, uint regaddr, uint val)
+pcie_mdiowrite(pcicore_info_t *pi, uint physmedia, uint regaddr, uint val)
 {
-	return pcie_mdioop(pi, physmedia, regaddr, TRUE, &val);
+	return pcie_mdioop(pi, physmedia, regaddr, true, &val);
 }
 
 /* ***** Support functions ***** */
-uint8 pcie_clkreq(void *pch, uint32 mask, uint32 val)
+u8 pcie_clkreq(void *pch, u32 mask, u32 val)
 {
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
-	uint32 reg_val;
-	uint8 offset;
+	u32 reg_val;
+	u8 offset;
 
 	offset = pi->pciecap_lcreg_offset;
 	if (!offset)
 		return 0;
 
-	reg_val = OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(uint32));
+	reg_val = OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(u32));
 	/* set operation */
 	if (mask) {
 		if (val)
 			reg_val |= PCIE_CLKREQ_ENAB;
 		else
 			reg_val &= ~PCIE_CLKREQ_ENAB;
-		OSL_PCI_WRITE_CONFIG(pi->osh, offset, sizeof(uint32), reg_val);
-		reg_val = OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(uint32));
+		OSL_PCI_WRITE_CONFIG(pi->osh, offset, sizeof(u32), reg_val);
+		reg_val = OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(u32));
 	}
 	if (reg_val & PCIE_CLKREQ_ENAB)
 		return 1;
@@ -390,9 +389,9 @@ uint8 pcie_clkreq(void *pch, uint32 mask, uint32 val)
 		return 0;
 }
 
-static void pcie_extendL1timer(pcicore_info_t * pi, bool extend)
+static void pcie_extendL1timer(pcicore_info_t *pi, bool extend)
 {
-	uint32 w;
+	u32 w;
 	si_t *sih = pi->sih;
 	osl_t *osh = pi->osh;
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
@@ -410,7 +409,7 @@ static void pcie_extendL1timer(pcicore_info_t * pi, bool extend)
 }
 
 /* centralized clkreq control policy */
-static void pcie_clkreq_upd(pcicore_info_t * pi, uint state)
+static void pcie_clkreq_upd(pcicore_info_t *pi, uint state)
 {
 	si_t *sih = pi->sih;
 	ASSERT(PCIE_PUB(sih));
@@ -423,10 +422,10 @@ static void pcie_clkreq_upd(pcicore_info_t * pi, uint state)
 	case SI_PCIDOWN:
 		if (sih->buscorerev == 6) {	/* turn on serdes PLL down */
 			si_corereg(sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, chipcontrol_addr), ~0,
+				   offsetof(chipcregs_t, chipcontrol_addr), ~0,
 				   0);
 			si_corereg(sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, chipcontrol_data),
+				   offsetof(chipcregs_t, chipcontrol_data),
 				   ~0x40, 0);
 		} else if (pi->pcie_pr42767) {
 			pcie_clkreq((void *)pi, 1, 1);
@@ -435,10 +434,10 @@ static void pcie_clkreq_upd(pcicore_info_t * pi, uint state)
 	case SI_PCIUP:
 		if (sih->buscorerev == 6) {	/* turn off serdes PLL down */
 			si_corereg(sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, chipcontrol_addr), ~0,
+				   offsetof(chipcregs_t, chipcontrol_addr), ~0,
 				   0);
 			si_corereg(sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, chipcontrol_data),
+				   offsetof(chipcregs_t, chipcontrol_data),
 				   ~0x40, 0x40);
 		} else if (PCIE_ASPM(sih)) {	/* disable clkreq */
 			pcie_clkreq((void *)pi, 1, 0);
@@ -452,9 +451,9 @@ static void pcie_clkreq_upd(pcicore_info_t * pi, uint state)
 
 /* ***** PCI core WARs ***** */
 /* Done only once at attach time */
-static void pcie_war_polarity(pcicore_info_t * pi)
+static void pcie_war_polarity(pcicore_info_t *pi)
 {
-	uint32 w;
+	u32 w;
 
 	if (pi->pcie_polarity != 0)
 		return;
@@ -477,12 +476,12 @@ static void pcie_war_polarity(pcicore_info_t * pi)
  *   : Coming out of 'standby'/'hibernate'
  *   : If pcie_war_aspm_ovr state changed
  */
-static void pcie_war_aspm_clkreq(pcicore_info_t * pi)
+static void pcie_war_aspm_clkreq(pcicore_info_t *pi)
 {
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
 	si_t *sih = pi->sih;
-	uint16 val16, *reg16;
-	uint32 w;
+	u16 val16, *reg16;
+	u32 w;
 
 	if (!PCIE_ASPM(sih))
 		return;
@@ -504,11 +503,11 @@ static void pcie_war_aspm_clkreq(pcicore_info_t * pi)
 		W_REG(pi->osh, reg16, val16);
 
 		w = OSL_PCI_READ_CONFIG(pi->osh, pi->pciecap_lcreg_offset,
-					sizeof(uint32));
+					sizeof(u32));
 		w &= ~PCIE_ASPM_ENAB;
 		w |= pi->pcie_war_aspm_ovr;
 		OSL_PCI_WRITE_CONFIG(pi->osh, pi->pciecap_lcreg_offset,
-				     sizeof(uint32), w);
+				     sizeof(u32), w);
 	}
 
 	reg16 = &pcieregs->sprom[SRSH_CLKREQ_OFFSET_REV5];
@@ -516,7 +515,7 @@ static void pcie_war_aspm_clkreq(pcicore_info_t * pi)
 
 	if (pi->pcie_war_aspm_ovr != PCIE_ASPM_DISAB) {
 		val16 |= SRSH_CLKREQ_ENB;
-		pi->pcie_pr42767 = TRUE;
+		pi->pcie_pr42767 = true;
 	} else
 		val16 &= ~SRSH_CLKREQ_ENB;
 
@@ -525,9 +524,9 @@ static void pcie_war_aspm_clkreq(pcicore_info_t * pi)
 
 /* Apply the polarity determined at the start */
 /* Needs to happen when coming out of 'standby'/'hibernate' */
-static void pcie_war_serdes(pcicore_info_t * pi)
+static void pcie_war_serdes(pcicore_info_t *pi)
 {
-	uint32 w = 0;
+	u32 w = 0;
 
 	if (pi->pcie_polarity != 0)
 		pcie_mdiowrite(pi, MDIODATA_DEV_RX, SERDES_RX_CTRL,
@@ -542,9 +541,10 @@ static void pcie_war_serdes(pcicore_info_t * pi)
 
 /* Fix MISC config to allow coming out of L2/L3-Ready state w/o PRST */
 /* Needs to happen when coming out of 'standby'/'hibernate' */
-static void BCMINITFN(pcie_misc_config_fixup) (pcicore_info_t * pi) {
+static void pcie_misc_config_fixup(pcicore_info_t *pi)
+{
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
-	uint16 val16, *reg16;
+	u16 val16, *reg16;
 
 	reg16 = &pcieregs->sprom[SRSH_PCIE_MISC_CONFIG];
 	val16 = R_REG(pi->osh, reg16);
@@ -557,15 +557,15 @@ static void BCMINITFN(pcie_misc_config_fixup) (pcicore_info_t * pi) {
 
 /* quick hack for testing */
 /* Needs to happen when coming out of 'standby'/'hibernate' */
-static void pcie_war_noplldown(pcicore_info_t * pi)
+static void pcie_war_noplldown(pcicore_info_t *pi)
 {
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
-	uint16 *reg16;
+	u16 *reg16;
 
 	ASSERT(pi->sih->buscorerev == 7);
 
 	/* turn off serdes PLL down */
-	si_corereg(pi->sih, SI_CC_IDX, OFFSETOF(chipcregs_t, chipcontrol),
+	si_corereg(pi->sih, SI_CC_IDX, offsetof(chipcregs_t, chipcontrol),
 		   CHIPCTRL_4321_PLL_DOWN, CHIPCTRL_4321_PLL_DOWN);
 
 	/*  clear srom shadow backdoor */
@@ -574,12 +574,12 @@ static void pcie_war_noplldown(pcicore_info_t * pi)
 }
 
 /* Needs to happen when coming out of 'standby'/'hibernate' */
-static void pcie_war_pci_setup(pcicore_info_t * pi)
+static void pcie_war_pci_setup(pcicore_info_t *pi)
 {
 	si_t *sih = pi->sih;
 	osl_t *osh = pi->osh;
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
-	uint32 w;
+	u32 w;
 
 	if ((sih->buscorerev == 0) || (sih->buscorerev == 1)) {
 		w = pcie_readreg(osh, pcieregs, PCIE_PCIEREGS,
@@ -619,7 +619,7 @@ static void pcie_war_pci_setup(pcicore_info_t * pi)
 		pcie_misc_config_fixup(pi);
 }
 
-void pcie_war_ovr_aspm_update(void *pch, uint8 aspm)
+void pcie_war_ovr_aspm_update(void *pch, u8 aspm)
 {
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
 
@@ -637,13 +637,14 @@ void pcie_war_ovr_aspm_update(void *pch, uint8 aspm)
 }
 
 /* ***** Functions called during driver state changes ***** */
-void BCMATTACHFN(pcicore_attach) (void *pch, char *pvars, int state) {
+void pcicore_attach(void *pch, char *pvars, int state)
+{
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
 	si_t *sih = pi->sih;
 
 	/* Determine if this board needs override */
 	if (PCIE_ASPM(sih)) {
-		if ((uint32) getintvar(pvars, "boardflags2") & BFL2_PCIEWAR_OVR) {
+		if ((u32) getintvar(pvars, "boardflags2") & BFL2_PCIEWAR_OVR) {
 			pi->pcie_war_aspm_ovr = PCIE_ASPM_DISAB;
 		} else {
 			pi->pcie_war_aspm_ovr = PCIE_ASPM_ENAB;
@@ -679,7 +680,7 @@ void pcicore_up(void *pch, int state)
 		return;
 
 	/* Restore L1 timer for better performance */
-	pcie_extendL1timer(pi, TRUE);
+	pcie_extendL1timer(pi, true);
 
 	pcie_clkreq_upd(pi, state);
 }
@@ -688,18 +689,18 @@ void pcicore_up(void *pch, int state)
 void pcicore_sleep(void *pch)
 {
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
-	uint32 w;
+	u32 w;
 
 	if (!pi || !PCIE_ASPM(pi->sih))
 		return;
 
 	w = OSL_PCI_READ_CONFIG(pi->osh, pi->pciecap_lcreg_offset,
-				sizeof(uint32));
+				sizeof(u32));
 	w &= ~PCIE_CAP_LCREG_ASPML1;
-	OSL_PCI_WRITE_CONFIG(pi->osh, pi->pciecap_lcreg_offset, sizeof(uint32),
+	OSL_PCI_WRITE_CONFIG(pi->osh, pi->pciecap_lcreg_offset, sizeof(u32),
 			     w);
 
-	pi->pcie_pr42767 = FALSE;
+	pi->pcie_pr42767 = false;
 }
 
 void pcicore_down(void *pch, int state)
@@ -712,35 +713,35 @@ void pcicore_down(void *pch, int state)
 	pcie_clkreq_upd(pi, state);
 
 	/* Reduce L1 timer for better power savings */
-	pcie_extendL1timer(pi, FALSE);
+	pcie_extendL1timer(pi, false);
 }
 
 /* ***** Wake-on-wireless-LAN (WOWL) support functions ***** */
 /* Just uses PCI config accesses to find out, when needed before sb_attach is done */
-bool pcicore_pmecap_fast(osl_t * osh)
+bool pcicore_pmecap_fast(osl_t *osh)
 {
-	uint8 cap_ptr;
-	uint32 pmecap;
+	u8 cap_ptr;
+	u32 pmecap;
 
 	cap_ptr =
 	    pcicore_find_pci_capability(osh, PCI_CAP_POWERMGMTCAP_ID, NULL,
 					NULL);
 
 	if (!cap_ptr)
-		return FALSE;
+		return false;
 
-	pmecap = OSL_PCI_READ_CONFIG(osh, cap_ptr, sizeof(uint32));
+	pmecap = OSL_PCI_READ_CONFIG(osh, cap_ptr, sizeof(u32));
 
-	return ((pmecap & PME_CAP_PM_STATES) != 0);
+	return (pmecap & PME_CAP_PM_STATES) != 0;
 }
 
-/* return TRUE if PM capability exists in the pci config space
+/* return true if PM capability exists in the pci config space
  * Uses and caches the information using core handle
  */
-static bool pcicore_pmecap(pcicore_info_t * pi)
+static bool pcicore_pmecap(pcicore_info_t *pi)
 {
-	uint8 cap_ptr;
-	uint32 pmecap;
+	u8 cap_ptr;
+	u32 pmecap;
 
 	if (!pi->pmecap_offset) {
 		cap_ptr =
@@ -748,51 +749,51 @@ static bool pcicore_pmecap(pcicore_info_t * pi)
 						PCI_CAP_POWERMGMTCAP_ID, NULL,
 						NULL);
 		if (!cap_ptr)
-			return FALSE;
+			return false;
 
 		pi->pmecap_offset = cap_ptr;
 
 		pmecap =
 		    OSL_PCI_READ_CONFIG(pi->osh, pi->pmecap_offset,
-					sizeof(uint32));
+					sizeof(u32));
 
 		/* At least one state can generate PME */
 		pi->pmecap = (pmecap & PME_CAP_PM_STATES) != 0;
 	}
 
-	return (pi->pmecap);
+	return pi->pmecap;
 }
 
 /* Enable PME generation */
 void pcicore_pmeen(void *pch)
 {
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
-	uint32 w;
+	u32 w;
 
 	/* if not pmecapable return */
 	if (!pcicore_pmecap(pi))
 		return;
 
 	w = OSL_PCI_READ_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
-				sizeof(uint32));
+				sizeof(u32));
 	w |= (PME_CSR_PME_EN);
 	OSL_PCI_WRITE_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
-			     sizeof(uint32), w);
+			     sizeof(u32), w);
 }
 
 /*
- * Return TRUE if PME status set
+ * Return true if PME status set
  */
 bool pcicore_pmestat(void *pch)
 {
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
-	uint32 w;
+	u32 w;
 
 	if (!pcicore_pmecap(pi))
-		return FALSE;
+		return false;
 
 	w = OSL_PCI_READ_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
-				sizeof(uint32));
+				sizeof(u32));
 
 	return (w & PME_CSR_PME_STAT) == PME_CSR_PME_STAT;
 }
@@ -802,13 +803,13 @@ bool pcicore_pmestat(void *pch)
 void pcicore_pmeclr(void *pch)
 {
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
-	uint32 w;
+	u32 w;
 
 	if (!pcicore_pmecap(pi))
 		return;
 
 	w = OSL_PCI_READ_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
-				sizeof(uint32));
+				sizeof(u32));
 
 	PCI_ERROR(("pcicore_pci_pmeclr PMECSR : 0x%x\n", w));
 
@@ -816,13 +817,13 @@ void pcicore_pmeclr(void *pch)
 	w &= ~(PME_CSR_PME_EN);
 
 	OSL_PCI_WRITE_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
-			     sizeof(uint32), w);
+			     sizeof(u32), w);
 }
 
-uint32 pcie_lcreg(void *pch, uint32 mask, uint32 val)
+u32 pcie_lcreg(void *pch, u32 mask, u32 val)
 {
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
-	uint8 offset;
+	u8 offset;
 
 	offset = pi->pciecap_lcreg_offset;
 	if (!offset)
@@ -830,15 +831,15 @@ uint32 pcie_lcreg(void *pch, uint32 mask, uint32 val)
 
 	/* set operation */
 	if (mask)
-		OSL_PCI_WRITE_CONFIG(pi->osh, offset, sizeof(uint32), val);
+		OSL_PCI_WRITE_CONFIG(pi->osh, offset, sizeof(u32), val);
 
-	return OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(uint32));
+	return OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(u32));
 }
 
-uint32
-pcicore_pciereg(void *pch, uint32 offset, uint32 mask, uint32 val, uint type)
+u32
+pcicore_pciereg(void *pch, u32 offset, u32 mask, u32 val, uint type)
 {
-	uint32 reg_val = 0;
+	u32 reg_val = 0;
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
 	osl_t *osh = pi->osh;
@@ -859,11 +860,11 @@ pcicore_pciereg(void *pch, uint32 offset, uint32 mask, uint32 val, uint type)
 	return reg_val;
 }
 
-uint32
-pcicore_pcieserdesreg(void *pch, uint32 mdioslave, uint32 offset, uint32 mask,
-		      uint32 val)
+u32
+pcicore_pcieserdesreg(void *pch, u32 mdioslave, u32 offset, u32 mask,
+		      u32 val)
 {
-	uint32 reg_val = 0;
+	u32 reg_val = 0;
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
 
 	if (mask) {
diff --git a/drivers/staging/brcm80211/util/nvram/nvram_ro.c b/drivers/staging/brcm80211/util/nvram/nvram_ro.c
index 68c69ee..f80375c 100644
--- a/drivers/staging/brcm80211/util/nvram/nvram_ro.c
+++ b/drivers/staging/brcm80211/util/nvram/nvram_ro.c
@@ -14,7 +14,8 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <typedefs.h>
+#include <linux/slab.h>
+#include <linux/string.h>
 #include <bcmdefs.h>
 #include <osl.h>
 #include <bcmutils.h>
@@ -38,7 +39,7 @@ typedef struct _vars {
 
 #define	VARS_T_OH	sizeof(vars_t)
 
-static vars_t *vars = NULL;
+static vars_t *vars;
 
 #define NVRAM_FILE	1
 
@@ -46,7 +47,8 @@ static char *findvar(char *vars, char *lim, const char *name);
 
 #if defined(FLASH)
 /* copy flash to ram */
-static void BCMINITFN(get_flash_nvram) (si_t * sih, struct nvram_header * nvh) {
+static void get_flash_nvram(si_t *sih, struct nvram_header *nvh)
+{
 	osl_t *osh;
 	uint nvs, bufsz;
 	vars_t *new;
@@ -56,7 +58,8 @@ static void BCMINITFN(get_flash_nvram) (si_t * sih, struct nvram_header * nvh) {
 	nvs = R_REG(osh, &nvh->len) - sizeof(struct nvram_header);
 	bufsz = nvs + VARS_T_OH;
 
-	if ((new = (vars_t *) MALLOC(osh, bufsz)) == NULL) {
+	new = kmalloc(bufsz, GFP_ATOMIC);
+	if (new == NULL) {
 		NVR_MSG(("Out of memory for flash vars\n"));
 		return;
 	}
@@ -74,7 +77,8 @@ static void BCMINITFN(get_flash_nvram) (si_t * sih, struct nvram_header * nvh) {
 }
 #endif				/* FLASH */
 
-int BCMATTACHFN(nvram_init) (void *si) {
+int nvram_init(void *si)
+{
 
 	/* Make sure we read nvram in flash just once before freeing the memory */
 	if (vars != NULL) {
@@ -84,11 +88,13 @@ int BCMATTACHFN(nvram_init) (void *si) {
 	return 0;
 }
 
-int BCMATTACHFN(nvram_append) (void *si, char *varlst, uint varsz) {
+int nvram_append(void *si, char *varlst, uint varsz)
+{
 	uint bufsz = VARS_T_OH;
 	vars_t *new;
 
-	if ((new = MALLOC(si_osh((si_t *) si), bufsz)) == NULL)
+	new = kmalloc(bufsz, GFP_ATOMIC);
+	if (new == NULL)
 		return BCME_NOMEM;
 
 	new->vars = varlst;
@@ -100,7 +106,8 @@ int BCMATTACHFN(nvram_append) (void *si, char *varlst, uint varsz) {
 	return BCME_OK;
 }
 
-void BCMUNINITFN(nvram_exit) (void *si) {
+void nvram_exit(void *si)
+{
 	vars_t *this, *next;
 	si_t *sih;
 
@@ -108,11 +115,11 @@ void BCMUNINITFN(nvram_exit) (void *si) {
 	this = vars;
 
 	if (this)
-		MFREE(si_osh(sih), this->vars, this->size);
+		kfree(this->vars);
 
 	while (this) {
 		next = this->next;
-		MFREE(si_osh(sih), this, this->bufsz);
+		kfree(this);
 		this = next;
 	}
 	vars = NULL;
@@ -127,9 +134,10 @@ static char *findvar(char *vars, char *lim, const char *name)
 
 	for (s = vars; (s < lim) && *s;) {
 		if ((bcmp(s, name, len) == 0) && (s[len] == '='))
-			return (&s[len + 1]);
+			return &s[len + 1];
 
-		while (*s++) ;
+		while (*s++)
+			;
 	}
 
 	return NULL;
@@ -140,26 +148,32 @@ char *nvram_get(const char *name)
 	char *v = NULL;
 	vars_t *cur;
 
-	for (cur = vars; cur; cur = cur->next)
-		if ((v = findvar(cur->vars, cur->vars + cur->size, name)))
+	for (cur = vars; cur; cur = cur->next) {
+		v = findvar(cur->vars, cur->vars + cur->size, name);
+		if (v)
 			break;
+	}
 
 	return v;
 }
 
-int BCMATTACHFN(nvram_set) (const char *name, const char *value) {
+int nvram_set(const char *name, const char *value)
+{
 	return 0;
 }
 
-int BCMATTACHFN(nvram_unset) (const char *name) {
+int nvram_unset(const char *name)
+{
 	return 0;
 }
 
-int BCMATTACHFN(nvram_reset) (void *si) {
+int nvram_reset(void *si)
+{
 	return 0;
 }
 
-int BCMATTACHFN(nvram_commit) (void) {
+int nvram_commit(void)
+{
 	return 0;
 }
 
@@ -174,7 +188,7 @@ int nvram_getall(char *buf, int count)
 		int acc;
 
 		from = this->vars;
-		lim = (char *)((uintptr) this->vars + this->size);
+		lim = (char *)(this->vars + this->size);
 		to = buf;
 		acc = 0;
 		while ((from < lim) && (*from)) {
diff --git a/drivers/staging/brcm80211/util/qmath.c b/drivers/staging/brcm80211/util/qmath.c
index 99a1776..40c9929 100644
--- a/drivers/staging/brcm80211/util/qmath.c
+++ b/drivers/staging/brcm80211/util/qmath.c
@@ -14,6 +14,7 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#include <linux/types.h>
 #include "qmath.h"
 
 /*
@@ -22,15 +23,15 @@ If input number is greater than 0x7fff then output is saturated to 0x7fff.
 else if input number is less than 0xffff8000 then output is saturated to 0xffff8000
 else output is same as input.
 */
-int16 qm_sat32(int32 op)
+s16 qm_sat32(s32 op)
 {
-	int16 result;
-	if (op > (int32) 0x7fff) {
+	s16 result;
+	if (op > (s32) 0x7fff) {
 		result = 0x7fff;
-	} else if (op < (int32) 0xffff8000) {
-		result = (int16) (0x8000);
+	} else if (op < (s32) 0xffff8000) {
+		result = (s16) (0x8000);
 	} else {
-		result = (int16) op;
+		result = (s16) op;
 	}
 	return result;
 }
@@ -41,9 +42,9 @@ This multiplication is similar to compiler multiplication. This operation is def
 16 bit multiplication on the processor platform is cheaper than 32 bit multiplication (as
 the most of qmath functions can be replaced with processor intrinsic instructions).
 */
-int32 qm_mul321616(int16 op1, int16 op2)
+s32 qm_mul321616(s16 op1, s16 op2)
 {
-	return ((int32) (op1) * (int32) (op2));
+	return (s32) (op1) * (s32) (op2);
 }
 
 /*
@@ -51,11 +52,11 @@ Description: This function make 16 bit multiplication and return the result in 1
 To fit the result into 16 bits the 32 bit multiplication result is right
 shifted by 16 bits.
 */
-int16 qm_mul16(int16 op1, int16 op2)
+s16 qm_mul16(s16 op1, s16 op2)
 {
-	int32 result;
-	result = ((int32) (op1) * (int32) (op2));
-	return ((int16) (result >> 16));
+	s32 result;
+	result = ((s32) (op1) * (s32) (op2));
+	return (s16) (result >> 16);
 }
 
 /*
@@ -65,13 +66,13 @@ This function remove the extra sign bit created by the multiplication by leftshi
 twice that of compiler multiplication. (i.e. qm_muls321616(2,3)=12).
 When both input 16 bit numbers are 0x8000, then the result is saturated to 0x7fffffff.
 */
-int32 qm_muls321616(int16 op1, int16 op2)
+s32 qm_muls321616(s16 op1, s16 op2)
 {
-	int32 result;
-	if (op1 == (int16) (0x8000) && op2 == (int16) (0x8000)) {
+	s32 result;
+	if (op1 == (s16) (0x8000) && op2 == (s16) (0x8000)) {
 		result = 0x7fffffff;
 	} else {
-		result = ((int32) (op1) * (int32) (op2));
+		result = ((s32) (op1) * (s32) (op2));
 		result = result << 1;
 	}
 	return result;
@@ -81,9 +82,9 @@ int32 qm_muls321616(int16 op1, int16 op2)
 Description: This function make 16 bit unsigned multiplication. To fit the output into
 16 bits the 32 bit multiplication result is right shifted by 16 bits.
 */
-uint16 qm_mulu16(uint16 op1, uint16 op2)
+u16 qm_mulu16(u16 op1, u16 op2)
 {
-	return (uint16) (((uint32) op1 * (uint32) op2) >> 16);
+	return (u16) (((u32) op1 * (u32) op2) >> 16);
 }
 
 /*
@@ -93,24 +94,24 @@ To fit the multiplication result into 16 bits the multiplication result is right
 due to the multiplication.
 When both the 16bit inputs are 0x8000 then the output is saturated to 0x7fffffff.
 */
-int16 qm_muls16(int16 op1, int16 op2)
+s16 qm_muls16(s16 op1, s16 op2)
 {
-	int32 result;
-	if (op1 == (int16) 0x8000 && op2 == (int16) 0x8000) {
+	s32 result;
+	if (op1 == (s16) 0x8000 && op2 == (s16) 0x8000) {
 		result = 0x7fffffff;
 	} else {
-		result = ((int32) (op1) * (int32) (op2));
+		result = ((s32) (op1) * (s32) (op2));
 	}
-	return ((int16) (result >> 15));
+	return (s16) (result >> 15);
 }
 
 /*
 Description: This function add two 32 bit numbers and return the 32bit result.
 If the result overflow 32 bits, the output will be saturated to 32bits.
 */
-int32 qm_add32(int32 op1, int32 op2)
+s32 qm_add32(s32 op1, s32 op2)
 {
-	int32 result;
+	s32 result;
 	result = op1 + op2;
 	if (op1 < 0 && op2 < 0 && result > 0) {
 		result = 0x80000000;
@@ -124,16 +125,16 @@ int32 qm_add32(int32 op1, int32 op2)
 Description: This function add two 16 bit numbers and return the 16bit result.
 If the result overflow 16 bits, the output will be saturated to 16bits.
 */
-int16 qm_add16(int16 op1, int16 op2)
+s16 qm_add16(s16 op1, s16 op2)
 {
-	int16 result;
-	int32 temp = (int32) op1 + (int32) op2;
-	if (temp > (int32) 0x7fff) {
-		result = (int16) 0x7fff;
-	} else if (temp < (int32) 0xffff8000) {
-		result = (int16) 0xffff8000;
+	s16 result;
+	s32 temp = (s32) op1 + (s32) op2;
+	if (temp > (s32) 0x7fff) {
+		result = (s16) 0x7fff;
+	} else if (temp < (s32) 0xffff8000) {
+		result = (s16) 0xffff8000;
 	} else {
-		result = (int16) temp;
+		result = (s16) temp;
 	}
 	return result;
 }
@@ -142,16 +143,16 @@ int16 qm_add16(int16 op1, int16 op2)
 Description: This function make 16 bit subtraction and return the 16bit result.
 If the result overflow 16 bits, the output will be saturated to 16bits.
 */
-int16 qm_sub16(int16 op1, int16 op2)
+s16 qm_sub16(s16 op1, s16 op2)
 {
-	int16 result;
-	int32 temp = (int32) op1 - (int32) op2;
-	if (temp > (int32) 0x7fff) {
-		result = (int16) 0x7fff;
-	} else if (temp < (int32) 0xffff8000) {
-		result = (int16) 0xffff8000;
+	s16 result;
+	s32 temp = (s32) op1 - (s32) op2;
+	if (temp > (s32) 0x7fff) {
+		result = (s16) 0x7fff;
+	} else if (temp < (s32) 0xffff8000) {
+		result = (s16) 0xffff8000;
 	} else {
-		result = (int16) temp;
+		result = (s16) temp;
 	}
 	return result;
 }
@@ -160,9 +161,9 @@ int16 qm_sub16(int16 op1, int16 op2)
 Description: This function make 32 bit subtraction and return the 32bit result.
 If the result overflow 32 bits, the output will be saturated to 32bits.
 */
-int32 qm_sub32(int32 op1, int32 op2)
+s32 qm_sub32(s32 op1, s32 op2)
 {
-	int32 result;
+	s32 result;
 	result = op1 - op2;
 	if (op1 >= 0 && op2 < 0 && result < 0) {
 		result = 0x7fffffff;
@@ -177,9 +178,9 @@ Description: This function multiply input 16 bit numbers and accumulate the resu
 into the input 32 bit number and return the 32 bit accumulated result.
 If the accumulation result in overflow, then the output will be saturated.
 */
-int32 qm_mac321616(int32 acc, int16 op1, int16 op2)
+s32 qm_mac321616(s32 acc, s16 op1, s16 op2)
 {
-	int32 result;
+	s32 result;
 	result = qm_add32(acc, qm_mul321616(op1, op2));
 	return result;
 }
@@ -189,10 +190,10 @@ Description: This function make a 32 bit saturated left shift when the specified
 is +ve. This function will make a 32 bit right shift when the specified shift is -ve.
 This function return the result after shifting operation.
 */
-int32 qm_shl32(int32 op, int shift)
+s32 qm_shl32(s32 op, int shift)
 {
 	int i;
-	int32 result;
+	s32 result;
 	result = op;
 	if (shift > 31)
 		shift = 31;
@@ -213,7 +214,7 @@ Description: This function make a 32 bit right shift when shift is +ve.
 This function make a 32 bit saturated left shift when shift is -ve. This function
 return the result of the shift operation.
 */
-int32 qm_shr32(int32 op, int shift)
+s32 qm_shr32(s32 op, int shift)
 {
 	return qm_shl32(op, -shift);
 }
@@ -223,10 +224,10 @@ Description: This function make a 16 bit saturated left shift when the specified
 is +ve. This function will make a 16 bit right shift when the specified shift is -ve.
 This function return the result after shifting operation.
 */
-int16 qm_shl16(int16 op, int shift)
+s16 qm_shl16(s16 op, int shift)
 {
 	int i;
-	int16 result;
+	s16 result;
 	result = op;
 	if (shift > 15)
 		shift = 15;
@@ -247,7 +248,7 @@ Description: This function make a 16 bit right shift when shift is +ve.
 This function make a 16 bit saturated left shift when shift is -ve. This function
 return the result of the shift operation.
 */
-int16 qm_shr16(int16 op, int shift)
+s16 qm_shr16(s16 op, int shift)
 {
 	return qm_shl16(op, -shift);
 }
@@ -256,9 +257,9 @@ int16 qm_shr16(int16 op, int shift)
 Description: This function return the number of redundant sign bits in a 16 bit number.
 Example: qm_norm16(0x0080) = 7.
 */
-int16 qm_norm16(int16 op)
+s16 qm_norm16(s16 op)
 {
-	uint16 u16extraSignBits;
+	u16 u16extraSignBits;
 	if (op == 0) {
 		return 15;
 	} else {
@@ -275,9 +276,9 @@ int16 qm_norm16(int16 op)
 Description: This function return the number of redundant sign bits in a 32 bit number.
 Example: qm_norm32(0x00000080) = 23
 */
-int16 qm_norm32(int32 op)
+s16 qm_norm32(s32 op)
 {
-	uint16 u16extraSignBits;
+	u16 u16extraSignBits;
 	if (op == 0) {
 		return 31;
 	} else {
@@ -295,12 +296,12 @@ Description: This function divide two 16 bit unsigned numbers.
 The numerator should be less than denominator. So the quotient is always less than 1.
 This function return the quotient in q.15 format.
 */
-int16 qm_div_s(int16 num, int16 denom)
+s16 qm_div_s(s16 num, s16 denom)
 {
-	int16 var_out;
-	int16 iteration;
-	int32 L_num;
-	int32 L_denom;
+	s16 var_out;
+	s16 iteration;
+	s32 L_num;
+	s32 L_denom;
 	L_num = (num) << 15;
 	L_denom = (denom) << 15;
 	for (iteration = 0; iteration < 15; iteration++) {
@@ -310,17 +311,17 @@ int16 qm_div_s(int16 num, int16 denom)
 			L_num = qm_add32(L_num, 1);
 		}
 	}
-	var_out = (int16) (L_num & 0x7fff);
-	return (var_out);
+	var_out = (s16) (L_num & 0x7fff);
+	return var_out;
 }
 
 /*
 Description: This function compute the absolute value of a 16 bit number.
 */
-int16 qm_abs16(int16 op)
+s16 qm_abs16(s16 op)
 {
 	if (op < 0) {
-		if (op == (int16) 0xffff8000) {
+		if (op == (s16) 0xffff8000) {
 			return 0x7fff;
 		} else {
 			return -op;
@@ -337,10 +338,10 @@ The qformat of the quotient is returned through the pointer (qQuotient) passed
 to this function. The qformat of quotient is adjusted appropriately such that
 the quotient occupies all 16 bits.
 */
-int16 qm_div16(int16 num, int16 denom, int16 * qQuotient)
+s16 qm_div16(s16 num, s16 denom, s16 *qQuotient)
 {
-	int16 sign;
-	int16 nNum, nDenom;
+	s16 sign;
+	s16 nNum, nDenom;
 	sign = num ^ denom;
 	num = qm_abs16(num);
 	denom = qm_abs16(denom);
@@ -359,10 +360,10 @@ int16 qm_div16(int16 num, int16 denom, int16 * qQuotient)
 /*
 Description: This function compute absolute value of a 32 bit number.
 */
-int32 qm_abs32(int32 op)
+s32 qm_abs32(s32 op)
 {
 	if (op < 0) {
-		if (op == (int32) 0x80000000) {
+		if (op == (s32) 0x80000000) {
 			return 0x7fffffff;
 		} else {
 			return -op;
@@ -380,10 +381,10 @@ The qformat of the quotient is returned through the pointer (qquotient) passed
 to this function. The qformat of quotient is adjusted appropriately such that
 the quotient occupies all 16 bits.
 */
-int16 qm_div163232(int32 num, int32 denom, int16 * qquotient)
+s16 qm_div163232(s32 num, s32 denom, s16 *qquotient)
 {
-	int32 sign;
-	int16 nNum, nDenom;
+	s32 sign;
+	s16 nNum, nDenom;
 	sign = num ^ denom;
 	num = qm_abs32(num);
 	denom = qm_abs32(denom);
@@ -393,9 +394,9 @@ int16 qm_div163232(int32 num, int32 denom, int16 * qquotient)
 	denom = qm_shl32(denom, nDenom);
 	*qquotient = nNum - 1 - nDenom + 15;
 	if (sign >= 0) {
-		return qm_div_s((int16) (num >> 16), (int16) (denom >> 16));
+		return qm_div_s((s16) (num >> 16), (s16) (denom >> 16));
 	} else {
-		return -qm_div_s((int16) (num >> 16), (int16) (denom >> 16));
+		return -qm_div_s((s16) (num >> 16), (s16) (denom >> 16));
 	}
 }
 
@@ -404,13 +405,13 @@ Description: This function multiply a 32 bit number with a 16 bit number.
 The multiplicaton result is right shifted by 16 bits to fit the result
 into 32 bit output.
 */
-int32 qm_mul323216(int32 op1, int16 op2)
+s32 qm_mul323216(s32 op1, s16 op2)
 {
-	int16 hi;
-	uint16 lo;
-	int32 result;
+	s16 hi;
+	u16 lo;
+	s32 result;
 	hi = op1 >> 16;
-	lo = (int16) (op1 & 0xffff);
+	lo = (s16) (op1 & 0xffff);
 	result = qm_mul321616(hi, op2);
 	result = result + (qm_mulsu321616(op2, lo) >> 16);
 	return result;
@@ -420,9 +421,9 @@ int32 qm_mul323216(int32 op1, int16 op2)
 Description: This function multiply signed 16 bit number with unsigned 16 bit number and return
 the result in 32 bits.
 */
-int32 qm_mulsu321616(int16 op1, uint16 op2)
+s32 qm_mulsu321616(s16 op1, u16 op2)
 {
-	return (int32) (op1) * op2;
+	return (s32) (op1) * op2;
 }
 
 /*
@@ -431,13 +432,13 @@ right shifted by 15 bits to fit the result into 32 bits. Right shifting by only
 16 bits is done to remove the extra sign bit formed by multiplication from the return value.
 When the input numbers are 0x80000000, 0x8000 the return value is saturated to 0x7fffffff.
 */
-int32 qm_muls323216(int32 op1, int16 op2)
+s32 qm_muls323216(s32 op1, s16 op2)
 {
-	int16 hi;
-	uint16 lo;
-	int32 result;
+	s16 hi;
+	u16 lo;
+	s32 result;
 	hi = op1 >> 16;
-	lo = (int16) (op1 & 0xffff);
+	lo = (s16) (op1 & 0xffff);
 	result = qm_muls321616(hi, op2);
 	result = qm_add32(result, (qm_mulsu321616(op2, lo) >> 15));
 	return result;
@@ -448,15 +449,15 @@ Description: This function multiply two 32 bit numbers. The multiplication resul
 shifted by 32 bits to fit the multiplication result into 32 bits. The right shifted
 multiplication result is returned as output.
 */
-int32 qm_mul32(int32 a, int32 b)
+s32 qm_mul32(s32 a, s32 b)
 {
-	int16 hi1, hi2;
-	uint16 lo1, lo2;
-	int32 result;
+	s16 hi1, hi2;
+	u16 lo1, lo2;
+	s32 result;
 	hi1 = a >> 16;
 	hi2 = b >> 16;
-	lo1 = (uint16) (a & 0xffff);
-	lo2 = (uint16) (b & 0xffff);
+	lo1 = (u16) (a & 0xffff);
+	lo2 = (u16) (b & 0xffff);
 	result = qm_mul321616(hi1, hi2);
 	result = result + (qm_mulsu321616(hi1, lo2) >> 16);
 	result = result + (qm_mulsu321616(hi2, lo1) >> 16);
@@ -471,15 +472,15 @@ instead of 32 bits is done to remove the extra sign bit formed by multiplication
 When the input numbers are 0x80000000, 0x80000000 the return value is saturated to
 0x7fffffff.
 */
-int32 qm_muls32(int32 a, int32 b)
+s32 qm_muls32(s32 a, s32 b)
 {
-	int16 hi1, hi2;
-	uint16 lo1, lo2;
-	int32 result;
+	s16 hi1, hi2;
+	u16 lo1, lo2;
+	s32 result;
 	hi1 = a >> 16;
 	hi2 = b >> 16;
-	lo1 = (uint16) (a & 0xffff);
-	lo2 = (uint16) (b & 0xffff);
+	lo1 = (u16) (a & 0xffff);
+	lo2 = (u16) (b & 0xffff);
 	result = qm_muls321616(hi1, hi2);
 	result = qm_add32(result, (qm_mulsu321616(hi1, lo2) >> 15));
 	result = qm_add32(result, (qm_mulsu321616(hi2, lo1) >> 15));
@@ -488,7 +489,7 @@ int32 qm_muls32(int32 a, int32 b)
 }
 
 /* This table is log2(1+(i/32)) where i=[0:1:31], in q.15 format */
-static const int16 log_table[] = {
+static const s16 log_table[] = {
 	0,
 	1455,
 	2866,
@@ -545,11 +546,11 @@ qLog10N - address where log10N qformat will be written.
 Note/Problem:
 For accurate results input should be in normalized or near normalized form.
 */
-void qm_log10(int32 N, int16 qN, int16 * log10N, int16 * qLog10N)
+void qm_log10(s32 N, s16 qN, s16 *log10N, s16 *qLog10N)
 {
-	int16 s16norm, s16tableIndex, s16errorApproximation;
-	uint16 u16offset;
-	int32 s32log;
+	s16 s16norm, s16tableIndex, s16errorApproximation;
+	u16 u16offset;
+	s32 s32log;
 
 	/* Logerithm of negative values is undefined.
 	 * assert N is greater than 0.
@@ -569,31 +570,31 @@ void qm_log10(int32 N, int16 qN, int16 * log10N, int16 * qLog10N)
 	qN = qN + s16norm - 30;
 
 	/* take the table index as the LOG2_OF_LOG_TABLE_SIZE bits right of the MSB */
-	s16tableIndex = (int16) (N >> (32 - (2 + LOG2_LOG_TABLE_SIZE)));
+	s16tableIndex = (s16) (N >> (32 - (2 + LOG2_LOG_TABLE_SIZE)));
 
 	/* remove the MSB. the MSB is always 1 after normalization. */
 	s16tableIndex =
-	    s16tableIndex & (int16) ((1 << LOG2_LOG_TABLE_SIZE) - 1);
+	    s16tableIndex & (s16) ((1 << LOG2_LOG_TABLE_SIZE) - 1);
 
 	/* remove the (1+LOG2_OF_LOG_TABLE_SIZE) MSBs in the N. */
 	N = N & ((1 << (32 - (2 + LOG2_LOG_TABLE_SIZE))) - 1);
 
 	/* take the offset as the 16 MSBS after table index.
 	 */
-	u16offset = (uint16) (N >> (32 - (2 + LOG2_LOG_TABLE_SIZE + 16)));
+	u16offset = (u16) (N >> (32 - (2 + LOG2_LOG_TABLE_SIZE + 16)));
 
 	/* look the log value in the table. */
 	s32log = log_table[s16tableIndex];	/* q.15 format */
 
 	/* interpolate using the offset. */
-	s16errorApproximation = (int16) qm_mulu16(u16offset, (uint16) (log_table[s16tableIndex + 1] - log_table[s16tableIndex]));	/* q.15 */
+	s16errorApproximation = (s16) qm_mulu16(u16offset, (u16) (log_table[s16tableIndex + 1] - log_table[s16tableIndex]));	/* q.15 */
 
-	s32log = qm_add16((int16) s32log, s16errorApproximation);	/* q.15 format */
+	s32log = qm_add16((s16) s32log, s16errorApproximation);	/* q.15 format */
 
 	/* adjust for the qformat of the N as
 	 * log2(mag * 2^x) = log2(mag) + x
 	 */
-	s32log = qm_add32(s32log, ((int32) - qN) << 15);	/* q.15 format */
+	s32log = qm_add32(s32log, ((s32) -qN) << 15);	/* q.15 format */
 
 	/* normalize the result. */
 	s16norm = qm_norm32(s32log);
@@ -605,7 +606,7 @@ void qm_log10(int32 N, int16 qN, int16 * log10N, int16 * qLog10N)
 	 * as log10(mag * 2^x) = log2(mag * 2^x) * log10(2)
 	 * log10N in q.15+s16norm-16+1 (LOG10_2 is in q.16)
 	 */
-	*log10N = qm_muls16((int16) s32log, (int16) LOG10_2);
+	*log10N = qm_muls16((s16) s32log, (s16) LOG10_2);
 
 	/* write the q format of the result. */
 	*qLog10N = 15 + s16norm - 16 + 1;
@@ -631,10 +632,10 @@ sqrtN - address where 1/N has to be written.
 qsqrtN - address where q format of 1/N has to be written.
 */
 #define qx 29
-void qm_1byN(int32 N, int16 qN, int32 * result, int16 * qResult)
+void qm_1byN(s32 N, s16 qN, s32 *result, s16 *qResult)
 {
-	int16 normN;
-	int32 s32firstTerm, s32secondTerm, x;
+	s16 normN;
+	s32 s32firstTerm, s32secondTerm, x;
 	int i;
 
 	normN = qm_norm32(N);
@@ -646,10 +647,10 @@ void qm_1byN(int32 N, int16 qN, int32 * result, int16 * qResult)
 
 	/* Take the initial guess as 1/0.75 in qx format with appropriate sign. */
 	if (N >= 0) {
-		x = (int32) ((1 / 0.75) * (1 << qx));
+		x = (s32) ((1 / 0.75) * (1 << qx));
 		/* input no is in the range 0.5 to 1. So 1/0.75 is taken as initial guess. */
 	} else {
-		x = (int32) ((1 / -0.75) * (1 << qx));
+		x = (s32) ((1 / -0.75) * (1 << qx));
 		/* input no is in the range -0.5 to -1. So 1/-0.75 is taken as initial guess. */
 	}
 
@@ -657,11 +658,11 @@ void qm_1byN(int32 N, int16 qN, int32 * result, int16 * qResult)
 	for (i = 0; i < 4; i++) {
 		s32firstTerm = qm_shl32(x, 1);	/* s32firstTerm = 2*x in q.29 */
 		s32secondTerm =
-		    qm_muls321616((int16) (s32firstTerm >> 16),
-				  (int16) (s32firstTerm >> 16));
+		    qm_muls321616((s16) (s32firstTerm >> 16),
+				  (s16) (s32firstTerm >> 16));
 		/* s32secondTerm = x*x in q.(29+1-16)*2+1 */
 		s32secondTerm =
-		    qm_muls321616((int16) (s32secondTerm >> 16), (int16) N);
+		    qm_muls321616((s16) (s32secondTerm >> 16), (s16) N);
 		/* s32secondTerm = N*x*x in q.((29+1-16)*2+1)-16+15+1 i.e. in q.29 */
 		x = qm_sub32(s32firstTerm, s32secondTerm);
 		/* can be added directly as both are in q.29 */
diff --git a/drivers/staging/brcm80211/util/sbutils.c b/drivers/staging/brcm80211/util/sbutils.c
new file mode 100644
index 0000000..e4c0bab
--- /dev/null
+++ b/drivers/staging/brcm80211/util/sbutils.c
@@ -0,0 +1,585 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/types.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <bcmdevs.h>
+#include <hndsoc.h>
+#include <sbchipc.h>
+#include <pci_core.h>
+#include <pcicfg.h>
+#include <sbpcmcia.h>
+#include "siutils_priv.h"
+
+/* local prototypes */
+static uint _sb_coreidx(si_info_t *sii, u32 sba);
+static uint _sb_scan(si_info_t *sii, u32 sba, void *regs, uint bus,
+		     u32 sbba, uint ncores);
+static u32 _sb_coresba(si_info_t *sii);
+static void *_sb_setcoreidx(si_info_t *sii, uint coreidx);
+
+#define	SET_SBREG(sii, r, mask, val)	\
+		W_SBREG((sii), (r), ((R_SBREG((sii), (r)) & ~(mask)) | (val)))
+#define	REGS2SB(va)	(sbconfig_t *) ((s8 *)(va) + SBCONFIGOFF)
+
+/* sonicsrev */
+#define	SONICS_2_2	(SBIDL_RV_2_2 >> SBIDL_RV_SHIFT)
+#define	SONICS_2_3	(SBIDL_RV_2_3 >> SBIDL_RV_SHIFT)
+
+#define	R_SBREG(sii, sbr)	sb_read_sbreg((sii), (sbr))
+#define	W_SBREG(sii, sbr, v)	sb_write_sbreg((sii), (sbr), (v))
+#define	AND_SBREG(sii, sbr, v)	\
+	W_SBREG((sii), (sbr), (R_SBREG((sii), (sbr)) & (v)))
+#define	OR_SBREG(sii, sbr, v)	\
+	W_SBREG((sii), (sbr), (R_SBREG((sii), (sbr)) | (v)))
+
+static u32 sb_read_sbreg(si_info_t *sii, volatile u32 *sbr)
+{
+	return R_REG(sii->osh, sbr);
+}
+
+static void sb_write_sbreg(si_info_t *sii, volatile u32 *sbr, u32 v)
+{
+	W_REG(sii->osh, sbr, v);
+}
+
+uint sb_coreid(si_t *sih)
+{
+	si_info_t *sii;
+	sbconfig_t *sb;
+
+	sii = SI_INFO(sih);
+	sb = REGS2SB(sii->curmap);
+
+	return (R_SBREG(sii, &sb->sbidhigh) & SBIDH_CC_MASK) >>
+		SBIDH_CC_SHIFT;
+}
+
+/* return core index of the core with address 'sba' */
+static uint _sb_coreidx(si_info_t *sii, u32 sba)
+{
+	uint i;
+
+	for (i = 0; i < sii->numcores; i++)
+		if (sba == sii->coresba[i])
+			return i;
+	return BADIDX;
+}
+
+/* return core address of the current core */
+static u32 _sb_coresba(si_info_t *sii)
+{
+	u32 sbaddr = 0;
+
+	switch (BUSTYPE(sii->pub.bustype)) {
+	case SPI_BUS:
+	case SDIO_BUS:
+		sbaddr = (u32)(unsigned long)sii->curmap;
+		break;
+	default:
+		ASSERT(0);
+		break;
+	}
+
+	return sbaddr;
+}
+
+uint sb_corerev(si_t *sih)
+{
+	si_info_t *sii;
+	sbconfig_t *sb;
+	uint sbidh;
+
+	sii = SI_INFO(sih);
+	sb = REGS2SB(sii->curmap);
+	sbidh = R_SBREG(sii, &sb->sbidhigh);
+
+	return SBCOREREV(sbidh);
+}
+
+bool sb_iscoreup(si_t *sih)
+{
+	si_info_t *sii;
+	sbconfig_t *sb;
+
+	sii = SI_INFO(sih);
+	sb = REGS2SB(sii->curmap);
+
+	return (R_SBREG(sii, &sb->sbtmstatelow) &
+		 (SBTML_RESET | SBTML_REJ_MASK |
+		  (SICF_CLOCK_EN << SBTML_SICF_SHIFT))) ==
+		(SICF_CLOCK_EN << SBTML_SICF_SHIFT);
+}
+
+/*
+ * Switch to 'coreidx', issue a single arbitrary 32bit
+ * register mask&set operation,
+ * switch back to the original core, and return the new value.
+ *
+ * When using the silicon backplane, no fidleing with interrupts
+ * or core switches are needed.
+ *
+ * Also, when using pci/pcie, we can optimize away the core switching
+ * for pci registers
+ * and (on newer pci cores) chipcommon registers.
+ */
+uint sb_corereg(si_t *sih, uint coreidx, uint regoff, uint mask, uint val)
+{
+	uint origidx = 0;
+	u32 *r = NULL;
+	uint w;
+	uint intr_val = 0;
+	bool fast = false;
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	ASSERT(GOODIDX(coreidx));
+	ASSERT(regoff < SI_CORE_SIZE);
+	ASSERT((val & ~mask) == 0);
+
+	if (coreidx >= SI_MAXCORES)
+		return 0;
+
+	if (!fast) {
+		INTR_OFF(sii, intr_val);
+
+		/* save current core index */
+		origidx = si_coreidx(&sii->pub);
+
+		/* switch core */
+		r = (u32 *) ((unsigned char *) sb_setcoreidx(&sii->pub, coreidx) +
+				regoff);
+	}
+	ASSERT(r != NULL);
+
+	/* mask and set */
+	if (mask || val) {
+		if (regoff >= SBCONFIGOFF) {
+			w = (R_SBREG(sii, r) & ~mask) | val;
+			W_SBREG(sii, r, w);
+		} else {
+			w = (R_REG(sii->osh, r) & ~mask) | val;
+			W_REG(sii->osh, r, w);
+		}
+	}
+
+	/* readback */
+	if (regoff >= SBCONFIGOFF)
+		w = R_SBREG(sii, r);
+	else
+		w = R_REG(sii->osh, r);
+
+	if (!fast) {
+		/* restore core index */
+		if (origidx != coreidx)
+			sb_setcoreidx(&sii->pub, origidx);
+
+		INTR_RESTORE(sii, intr_val);
+	}
+
+	return w;
+}
+
+/* Scan the enumeration space to find all cores starting from the given
+ * bus 'sbba'. Append coreid and other info to the lists in 'si'. 'sba'
+ * is the default core address at chip POR time and 'regs' is the virtual
+ * address that the default core is mapped at. 'ncores' is the number of
+ * cores expected on bus 'sbba'. It returns the total number of cores
+ * starting from bus 'sbba', inclusive.
+ */
+#define SB_MAXBUSES	2
+static uint _sb_scan(si_info_t *sii, u32 sba, void *regs, uint bus, u32 sbba,
+		     uint numcores)
+{
+	uint next;
+	uint ncc = 0;
+	uint i;
+
+	if (bus >= SB_MAXBUSES) {
+		SI_ERROR(("_sb_scan: bus 0x%08x at level %d is too deep to "
+			"scan\n", sbba, bus));
+		return 0;
+	}
+	SI_MSG(("_sb_scan: scan bus 0x%08x assume %u cores\n",
+		sbba, numcores));
+
+	/* Scan all cores on the bus starting from core 0.
+	 * Core addresses must be contiguous on each bus.
+	 */
+	for (i = 0, next = sii->numcores;
+	     i < numcores && next < SB_BUS_MAXCORES; i++, next++) {
+		sii->coresba[next] = sbba + (i * SI_CORE_SIZE);
+
+		/* change core to 'next' and read its coreid */
+		sii->curmap = _sb_setcoreidx(sii, next);
+		sii->curidx = next;
+
+		sii->coreid[next] = sb_coreid(&sii->pub);
+
+		/* core specific processing... */
+		/* chipc provides # cores */
+		if (sii->coreid[next] == CC_CORE_ID) {
+			chipcregs_t *cc = (chipcregs_t *) sii->curmap;
+			u32 ccrev = sb_corerev(&sii->pub);
+
+			/* determine numcores - this is the
+				 total # cores in the chip */
+			if (((ccrev == 4) || (ccrev >= 6)))
+				numcores =
+				    (R_REG(sii->osh, &cc->chipid) & CID_CC_MASK)
+				    >> CID_CC_SHIFT;
+			else {
+				/* Older chips */
+				SI_ERROR(("sb_chip2numcores: unsupported chip "
+					"0x%x\n", CHIPID(sii->pub.chip)));
+				ASSERT(0);
+				numcores = 1;
+			}
+
+			SI_VMSG(("_sb_scan: %u cores in the chip %s\n",
+			numcores, sii->pub.issim ? "QT" : ""));
+		}
+		/* scan bridged SB(s) and add results to the end of the list */
+		else if (sii->coreid[next] == OCP_CORE_ID) {
+			sbconfig_t *sb = REGS2SB(sii->curmap);
+			u32 nsbba = R_SBREG(sii, &sb->sbadmatch1);
+			uint nsbcc;
+
+			sii->numcores = next + 1;
+
+			if ((nsbba & 0xfff00000) != SI_ENUM_BASE)
+				continue;
+			nsbba &= 0xfffff000;
+			if (_sb_coreidx(sii, nsbba) != BADIDX)
+				continue;
+
+			nsbcc =
+			    (R_SBREG(sii, &sb->sbtmstatehigh) & 0x000f0000) >>
+			    16;
+			nsbcc = _sb_scan(sii, sba, regs, bus + 1, nsbba, nsbcc);
+			if (sbba == SI_ENUM_BASE)
+				numcores -= nsbcc;
+			ncc += nsbcc;
+		}
+	}
+
+	SI_MSG(("_sb_scan: found %u cores on bus 0x%08x\n", i, sbba));
+
+	sii->numcores = i + ncc;
+	return sii->numcores;
+}
+
+/* scan the sb enumerated space to identify all cores */
+void sb_scan(si_t *sih, void *regs, uint devid)
+{
+	si_info_t *sii;
+	u32 origsba;
+	sbconfig_t *sb;
+
+	sii = SI_INFO(sih);
+	sb = REGS2SB(sii->curmap);
+
+	sii->pub.socirev =
+	    (R_SBREG(sii, &sb->sbidlow) & SBIDL_RV_MASK) >> SBIDL_RV_SHIFT;
+
+	/* Save the current core info and validate it later till we know
+	 * for sure what is good and what is bad.
+	 */
+	origsba = _sb_coresba(sii);
+
+	/* scan all SB(s) starting from SI_ENUM_BASE */
+	sii->numcores = _sb_scan(sii, origsba, regs, 0, SI_ENUM_BASE, 1);
+}
+
+/*
+ * This function changes logical "focus" to the indicated core;
+ * must be called with interrupts off.
+ * Moreover, callers should keep interrupts off during switching out of
+ * and back to d11 core
+ */
+void *sb_setcoreidx(si_t *sih, uint coreidx)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	if (coreidx >= sii->numcores)
+		return NULL;
+
+	/*
+	 * If the user has provided an interrupt mask enabled function,
+	 * then assert interrupts are disabled before switching the core.
+	 */
+	ASSERT((sii->intrsenabled_fn == NULL)
+	       || !(*(sii)->intrsenabled_fn) ((sii)->intr_arg));
+
+	sii->curmap = _sb_setcoreidx(sii, coreidx);
+	sii->curidx = coreidx;
+
+	return sii->curmap;
+}
+
+/* This function changes the logical "focus" to the indicated core.
+ * Return the current core's virtual address.
+ */
+static void *_sb_setcoreidx(si_info_t *sii, uint coreidx)
+{
+	u32 sbaddr = sii->coresba[coreidx];
+	void *regs;
+
+	switch (BUSTYPE(sii->pub.bustype)) {
+#ifdef BCMSDIO
+	case SPI_BUS:
+	case SDIO_BUS:
+		/* map new one */
+		if (!sii->regs[coreidx]) {
+			sii->regs[coreidx] = (void *)sbaddr;
+			ASSERT(GOODREGS(sii->regs[coreidx]));
+		}
+		regs = sii->regs[coreidx];
+		break;
+#endif				/* BCMSDIO */
+	default:
+		ASSERT(0);
+		regs = NULL;
+		break;
+	}
+
+	return regs;
+}
+
+/* traverse all cores to find and clear source of serror */
+static void sb_serr_clear(si_info_t *sii)
+{
+	sbconfig_t *sb;
+	uint origidx;
+	uint i, intr_val = 0;
+	void *corereg = NULL;
+
+	INTR_OFF(sii, intr_val);
+	origidx = si_coreidx(&sii->pub);
+
+	for (i = 0; i < sii->numcores; i++) {
+		corereg = sb_setcoreidx(&sii->pub, i);
+		if (NULL != corereg) {
+			sb = REGS2SB(corereg);
+			if ((R_SBREG(sii, &sb->sbtmstatehigh)) & SBTMH_SERR) {
+				AND_SBREG(sii, &sb->sbtmstatehigh, ~SBTMH_SERR);
+				SI_ERROR(("sb_serr_clear: SError core 0x%x\n",
+				sb_coreid(&sii->pub)));
+			}
+		}
+	}
+
+	sb_setcoreidx(&sii->pub, origidx);
+	INTR_RESTORE(sii, intr_val);
+}
+
+/*
+ * Check if any inband, outband or timeout errors has happened and clear them.
+ * Must be called with chip clk on !
+ */
+bool sb_taclear(si_t *sih, bool details)
+{
+	si_info_t *sii;
+	sbconfig_t *sb;
+	uint origidx;
+	uint intr_val = 0;
+	bool rc = false;
+	u32 inband = 0, serror = 0, timeout = 0;
+	void *corereg = NULL;
+	volatile u32 imstate, tmstate;
+
+	sii = SI_INFO(sih);
+
+	if ((BUSTYPE(sii->pub.bustype) == SDIO_BUS) ||
+	    (BUSTYPE(sii->pub.bustype) == SPI_BUS)) {
+
+		INTR_OFF(sii, intr_val);
+		origidx = si_coreidx(sih);
+
+		corereg = si_setcore(sih, PCMCIA_CORE_ID, 0);
+		if (NULL == corereg)
+			corereg = si_setcore(sih, SDIOD_CORE_ID, 0);
+		if (NULL != corereg) {
+			sb = REGS2SB(corereg);
+
+			imstate = R_SBREG(sii, &sb->sbimstate);
+			if ((imstate != 0xffffffff)
+			    && (imstate & (SBIM_IBE | SBIM_TO))) {
+				AND_SBREG(sii, &sb->sbimstate,
+					  ~(SBIM_IBE | SBIM_TO));
+				/* inband = imstate & SBIM_IBE; cmd error */
+				timeout = imstate & SBIM_TO;
+			}
+			tmstate = R_SBREG(sii, &sb->sbtmstatehigh);
+			if ((tmstate != 0xffffffff)
+			    && (tmstate & SBTMH_INT_STATUS)) {
+				sb_serr_clear(sii);
+				serror = 1;
+				OR_SBREG(sii, &sb->sbtmstatelow, SBTML_INT_ACK);
+				AND_SBREG(sii, &sb->sbtmstatelow,
+					  ~SBTML_INT_ACK);
+			}
+		}
+
+		sb_setcoreidx(sih, origidx);
+		INTR_RESTORE(sii, intr_val);
+	}
+
+	if (inband | timeout | serror) {
+		rc = true;
+		SI_ERROR(("sb_taclear: inband 0x%x, serror 0x%x, timeout "
+			"0x%x!\n", inband, serror, timeout));
+	}
+
+	return rc;
+}
+
+void sb_core_disable(si_t *sih, u32 bits)
+{
+	si_info_t *sii;
+	volatile u32 dummy;
+	sbconfig_t *sb;
+
+	sii = SI_INFO(sih);
+
+	ASSERT(GOODREGS(sii->curmap));
+	sb = REGS2SB(sii->curmap);
+
+	/* if core is already in reset, just return */
+	if (R_SBREG(sii, &sb->sbtmstatelow) & SBTML_RESET)
+		return;
+
+	/* if clocks are not enabled, put into reset and return */
+	if ((R_SBREG(sii, &sb->sbtmstatelow) &
+	     (SICF_CLOCK_EN << SBTML_SICF_SHIFT)) == 0)
+		goto disable;
+
+	/* set target reject and spin until busy is clear
+	   (preserve core-specific bits) */
+	OR_SBREG(sii, &sb->sbtmstatelow, SBTML_REJ);
+	dummy = R_SBREG(sii, &sb->sbtmstatelow);
+	udelay(1);
+	SPINWAIT((R_SBREG(sii, &sb->sbtmstatehigh) & SBTMH_BUSY), 100000);
+	if (R_SBREG(sii, &sb->sbtmstatehigh) & SBTMH_BUSY)
+		SI_ERROR(("%s: target state still busy\n", __func__));
+
+	if (R_SBREG(sii, &sb->sbidlow) & SBIDL_INIT) {
+		OR_SBREG(sii, &sb->sbimstate, SBIM_RJ);
+		dummy = R_SBREG(sii, &sb->sbimstate);
+		udelay(1);
+		SPINWAIT((R_SBREG(sii, &sb->sbimstate) & SBIM_BY), 100000);
+	}
+
+	/* set reset and reject while enabling the clocks */
+	W_SBREG(sii, &sb->sbtmstatelow,
+		(((bits | SICF_FGC | SICF_CLOCK_EN) << SBTML_SICF_SHIFT) |
+		 SBTML_REJ | SBTML_RESET));
+	dummy = R_SBREG(sii, &sb->sbtmstatelow);
+	udelay(10);
+
+	/* don't forget to clear the initiator reject bit */
+	if (R_SBREG(sii, &sb->sbidlow) & SBIDL_INIT)
+		AND_SBREG(sii, &sb->sbimstate, ~SBIM_RJ);
+
+disable:
+	/* leave reset and reject asserted */
+	W_SBREG(sii, &sb->sbtmstatelow,
+		((bits << SBTML_SICF_SHIFT) | SBTML_REJ | SBTML_RESET));
+	udelay(1);
+}
+
+/* reset and re-enable a core
+ * inputs:
+ * bits - core specific bits that are set during and after reset sequence
+ * resetbits - core specific bits that are set only during reset sequence
+ */
+void sb_core_reset(si_t *sih, u32 bits, u32 resetbits)
+{
+	si_info_t *sii;
+	sbconfig_t *sb;
+	volatile u32 dummy;
+
+	sii = SI_INFO(sih);
+	ASSERT(GOODREGS(sii->curmap));
+	sb = REGS2SB(sii->curmap);
+
+	/*
+	 * Must do the disable sequence first to work for
+	 * arbitrary current core state.
+	 */
+	sb_core_disable(sih, (bits | resetbits));
+
+	/*
+	 * Now do the initialization sequence.
+	 */
+
+	/* set reset while enabling the clock and
+		 forcing them on throughout the core */
+	W_SBREG(sii, &sb->sbtmstatelow,
+		(((bits | resetbits | SICF_FGC | SICF_CLOCK_EN) <<
+		  SBTML_SICF_SHIFT) | SBTML_RESET));
+	dummy = R_SBREG(sii, &sb->sbtmstatelow);
+	udelay(1);
+
+	if (R_SBREG(sii, &sb->sbtmstatehigh) & SBTMH_SERR)
+		W_SBREG(sii, &sb->sbtmstatehigh, 0);
+
+	dummy = R_SBREG(sii, &sb->sbimstate);
+	if (dummy & (SBIM_IBE | SBIM_TO))
+		AND_SBREG(sii, &sb->sbimstate, ~(SBIM_IBE | SBIM_TO));
+
+	/* clear reset and allow it to propagate throughout the core */
+	W_SBREG(sii, &sb->sbtmstatelow,
+		((bits | resetbits | SICF_FGC | SICF_CLOCK_EN) <<
+		 SBTML_SICF_SHIFT));
+	dummy = R_SBREG(sii, &sb->sbtmstatelow);
+	udelay(1);
+
+	/* leave clock enabled */
+	W_SBREG(sii, &sb->sbtmstatelow,
+		((bits | SICF_CLOCK_EN) << SBTML_SICF_SHIFT));
+	dummy = R_SBREG(sii, &sb->sbtmstatelow);
+	udelay(1);
+}
+
+u32 sb_base(u32 admatch)
+{
+	u32 base;
+	uint type;
+
+	type = admatch & SBAM_TYPE_MASK;
+	ASSERT(type < 3);
+
+	base = 0;
+
+	if (type == 0) {
+		base = admatch & SBAM_BASE0_MASK;
+	} else if (type == 1) {
+		ASSERT(!(admatch & SBAM_ADNEG));	/* neg not supported */
+		base = admatch & SBAM_BASE1_MASK;
+	} else if (type == 2) {
+		ASSERT(!(admatch & SBAM_ADNEG));	/* neg not supported */
+		base = admatch & SBAM_BASE2_MASK;
+	}
+
+	return base;
+}
diff --git a/drivers/staging/brcm80211/util/siutils.c b/drivers/staging/brcm80211/util/siutils.c
index af35564..f3ea7e1 100644
--- a/drivers/staging/brcm80211/util/siutils.c
+++ b/drivers/staging/brcm80211/util/siutils.c
@@ -14,9 +14,11 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <typedefs.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
 #include <bcmdefs.h>
 #include <osl.h>
+#include <linuxver.h>
 #include <bcmutils.h>
 #include <siutils.h>
 #include <bcmdevs.h>
@@ -27,7 +29,6 @@
 #include <nicpci.h>
 #include <bcmnvram.h>
 #include <bcmsrom.h>
-#include <hndtcam.h>
 #include <pcicfg.h>
 #include <sbsocram.h>
 #ifdef BCMSDIO
@@ -52,26 +53,24 @@
 #endif
 
 /* local prototypes */
-static si_info_t *si_doattach(si_info_t * sii, uint devid, osl_t * osh,
+static si_info_t *si_doattach(si_info_t *sii, uint devid, osl_t *osh,
 			      void *regs, uint bustype, void *sdh, char **vars,
-			      uint * varsz);
-static bool si_buscore_prep(si_info_t * sii, uint bustype, uint devid,
+			      uint *varsz);
+static bool si_buscore_prep(si_info_t *sii, uint bustype, uint devid,
 			    void *sdh);
-static bool si_buscore_setup(si_info_t * sii, chipcregs_t * cc, uint bustype,
-			     uint32 savewin, uint * origidx, void *regs);
-static void si_nvram_process(si_info_t * sii, char *pvars);
+static bool si_buscore_setup(si_info_t *sii, chipcregs_t *cc, uint bustype,
+			     u32 savewin, uint *origidx, void *regs);
+static void si_nvram_process(si_info_t *sii, char *pvars);
 
 /* dev path concatenation util */
-static char *si_devpathvar(si_t * sih, char *var, int len, const char *name);
-static bool _si_clkctl_cc(si_info_t * sii, uint mode);
-static bool si_ispcie(si_info_t * sii);
-static uint BCMINITFN(socram_banksize) (si_info_t * sii, sbsocramregs_t * r,
-					uint8 idx, uint8 mtype);
+static char *si_devpathvar(si_t *sih, char *var, int len, const char *name);
+static bool _si_clkctl_cc(si_info_t *sii, uint mode);
+static bool si_ispcie(si_info_t *sii);
+static uint socram_banksize(si_info_t *sii, sbsocramregs_t *r,
+					u8 idx, u8 mtype);
 
 /* global variable to indicate reservation/release of gpio's */
-static uint32 si_gpioreservation = 0;
-
-/* global flag to prevent shared resources from being initialized multiple times in si_attach() */
+static u32 si_gpioreservation;
 
 /*
  * Allocate a si handle.
@@ -82,22 +81,22 @@ static uint32 si_gpioreservation = 0;
  * vars - pointer to a pointer area for "environment" variables
  * varsz - pointer to int to return the size of the vars
  */
-si_t *BCMATTACHFN(si_attach) (uint devid, osl_t * osh, void *regs,
-			      uint bustype, void *sdh, char **vars,
-			      uint * varsz) {
+si_t *si_attach(uint devid, osl_t *osh, void *regs, uint bustype, void *sdh,
+		char **vars, uint *varsz)
+{
 	si_info_t *sii;
 
 	/* alloc si_info_t */
-	if ((sii = MALLOC(osh, sizeof(si_info_t))) == NULL) {
-		SI_ERROR(("si_attach: malloc failed! malloced %d bytes\n",
-			  MALLOCED(osh)));
-		return (NULL);
+	sii = kmalloc(sizeof(si_info_t), GFP_ATOMIC);
+	if (sii == NULL) {
+		SI_ERROR(("si_attach: malloc failed!\n"));
+		return NULL;
 	}
 
 	if (si_doattach(sii, devid, osh, regs, bustype, sdh, vars, varsz) ==
 	    NULL) {
-		MFREE(osh, sii, sizeof(si_info_t));
-		return (NULL);
+		kfree(sii);
+		return NULL;
 	}
 	sii->vars = vars ? *vars : NULL;
 	sii->varsz = varsz ? *varsz : 0;
@@ -108,27 +107,27 @@ si_t *BCMATTACHFN(si_attach) (uint devid, osl_t * osh, void *regs,
 /* global kernel resource */
 static si_info_t ksii;
 
-static uint32 wd_msticks;	/* watchdog timer ticks normalized to ms */
-
-static bool
-BCMATTACHFN(si_buscore_prep) (si_info_t * sii, uint bustype, uint devid,
-			      void *sdh) {
+static bool si_buscore_prep(si_info_t *sii, uint bustype, uint devid,
+			    void *sdh)
+{
 
+#ifndef BRCM_FULLMAC
 	/* kludge to enable the clock on the 4306 which lacks a slowclock */
 	if (BUSTYPE(bustype) == PCI_BUS && !si_ispcie(sii))
 		si_clkctl_xtal(&sii->pub, XTAL | PLL, ON);
+#endif
 
 #if defined(BCMSDIO)
 	if (BUSTYPE(bustype) == SDIO_BUS) {
 		int err;
-		uint8 clkset;
+		u8 clkset;
 
 		/* Try forcing SDIO core to do ALPAvail request only */
 		clkset = SBSDIO_FORCE_HW_CLKREQ_OFF | SBSDIO_ALP_AVAIL_REQ;
 		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
 				 clkset, &err);
 		if (!err) {
-			uint8 clkval;
+			u8 clkval;
 
 			/* If register supported, wait for ALPAvail and then force ALP */
 			clkval =
@@ -143,7 +142,7 @@ BCMATTACHFN(si_buscore_prep) (si_info_t * sii, uint bustype, uint devid,
 					 PMU_MAX_TRANSITION_DLY);
 				if (!SBSDIO_ALPAV(clkval)) {
 					SI_ERROR(("timeout on ALPAV wait, clkval 0x%02x\n", clkval));
-					return FALSE;
+					return false;
 				}
 				clkset =
 				    SBSDIO_FORCE_HW_CLKREQ_OFF |
@@ -151,7 +150,7 @@ BCMATTACHFN(si_buscore_prep) (si_info_t * sii, uint bustype, uint devid,
 				bcmsdh_cfg_write(sdh, SDIO_FUNC_1,
 						 SBSDIO_FUNC1_CHIPCLKCSR,
 						 clkset, &err);
-				OSL_DELAY(65);
+				udelay(65);
 			}
 		}
 
@@ -161,18 +160,18 @@ BCMATTACHFN(si_buscore_prep) (si_info_t * sii, uint bustype, uint devid,
 	}
 #endif				/* defined(BCMSDIO) */
 
-	return TRUE;
+	return true;
 }
 
-static bool
-BCMATTACHFN(si_buscore_setup) (si_info_t * sii, chipcregs_t * cc, uint bustype,
-			       uint32 savewin, uint * origidx, void *regs) {
+static bool si_buscore_setup(si_info_t *sii, chipcregs_t *cc, uint bustype,
+			     u32 savewin, uint *origidx, void *regs)
+{
 	bool pci, pcie;
 	uint i;
 	uint pciidx, pcieidx, pcirev, pcierev;
 
 	cc = si_setcoreidx(&sii->pub, SI_CC_IDX);
-	ASSERT((uintptr) cc);
+	ASSERT(cc);
 
 	/* get chipcommon rev */
 	sii->pub.ccrev = (int)si_corerev(&sii->pub);
@@ -185,9 +184,10 @@ BCMATTACHFN(si_buscore_setup) (si_info_t * sii, chipcregs_t * cc, uint bustype,
 	sii->pub.cccaps = R_REG(sii->osh, &cc->capabilities);
 	/* get chipcommon extended capabilities */
 
+#ifndef BRCM_FULLMAC
 	if (sii->pub.ccrev >= 35)
 		sii->pub.cccaps_ext = R_REG(sii->osh, &cc->capabilities_ext);
-
+#endif
 	/* get pmu rev and caps */
 	if (sii->pub.cccaps & CC_CAP_PMU) {
 		sii->pub.pmucaps = R_REG(sii->osh, &cc->pmucapabilities);
@@ -205,7 +205,7 @@ BCMATTACHFN(si_buscore_setup) (si_info_t * sii, chipcregs_t * cc, uint bustype,
 	sii->pub.buscorerev = NOREV;
 	sii->pub.buscoreidx = BADIDX;
 
-	pci = pcie = FALSE;
+	pci = pcie = false;
 	pcirev = pcierev = NOREV;
 	pciidx = pcieidx = BADIDX;
 
@@ -224,11 +224,11 @@ BCMATTACHFN(si_buscore_setup) (si_info_t * sii, chipcregs_t * cc, uint bustype,
 			if (cid == PCI_CORE_ID) {
 				pciidx = i;
 				pcirev = crev;
-				pci = TRUE;
+				pci = true;
 			} else if (cid == PCIE_CORE_ID) {
 				pcieidx = i;
 				pcierev = crev;
-				pcie = TRUE;
+				pcie = true;
 			}
 		}
 #ifdef BCMSDIO
@@ -247,11 +247,25 @@ BCMATTACHFN(si_buscore_setup) (si_info_t * sii, chipcregs_t * cc, uint bustype,
 			*origidx = i;
 	}
 
+#ifdef BRCM_FULLMAC
+	SI_MSG(("Buscore id/type/rev %d/0x%x/%d\n", sii->pub.buscoreidx,
+		sii->pub.buscoretype, sii->pub.buscorerev));
+
+	/* Make sure any on-chip ARM is off (in case strapping is wrong),
+	* or downloaded code was
+	* already running.
+	*/
+	if ((BUSTYPE(bustype) == SDIO_BUS) || (BUSTYPE(bustype) == SPI_BUS)) {
+		if (si_setcore(&sii->pub, ARM7S_CORE_ID, 0) ||
+			si_setcore(&sii->pub, ARMCM3_CORE_ID, 0))
+			si_core_disable(&sii->pub, 0);
+	}
+#else
 	if (pci && pcie) {
 		if (si_ispcie(sii))
-			pci = FALSE;
+			pci = false;
 		else
-			pcie = FALSE;
+			pcie = false;
 	}
 	if (pci) {
 		sii->pub.buscoretype = PCI_CORE_ID;
@@ -269,45 +283,45 @@ BCMATTACHFN(si_buscore_setup) (si_info_t * sii, chipcregs_t * cc, uint bustype,
 	/* fixup necessary chip/core configurations */
 	if (BUSTYPE(sii->pub.bustype) == PCI_BUS) {
 		if (SI_FAST(sii)) {
-			if (!sii->pch &&
-			    ((sii->pch =
-			      (void *)(uintptr) pcicore_init(&sii->pub,
-							     sii->osh,
-							     (void *)
-							     PCIEREGS(sii))) ==
-			     NULL))
-				return FALSE;
+			if (!sii->pch) {
+				sii->pch = (void *)pcicore_init(
+					&sii->pub, sii->osh,
+					(void *)PCIEREGS(sii));
+				if (sii->pch == NULL)
+					return false;
+			}
 		}
 		if (si_pci_fixcfg(&sii->pub)) {
 			SI_ERROR(("si_doattach: sb_pci_fixcfg failed\n"));
-			return FALSE;
+			return false;
 		}
 	}
-
+#endif
 	/* return to the original core */
 	si_setcoreidx(&sii->pub, *origidx);
 
-	return TRUE;
+	return true;
 }
 
-static void BCMATTACHFN(si_nvram_process) (si_info_t * sii, char *pvars) {
+static __used void si_nvram_process(si_info_t *sii, char *pvars)
+{
 	uint w = 0;
 
 	/* get boardtype and boardrev */
 	switch (BUSTYPE(sii->pub.bustype)) {
 	case PCI_BUS:
 		/* do a pci config read to get subsystem id and subvendor id */
-		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_CFG_SVID, sizeof(uint32));
+		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_CFG_SVID, sizeof(u32));
 		/* Let nvram variables override subsystem Vend/ID */
-		if ((sii->pub.boardvendor =
-		     (uint16) si_getdevpathintvar(&sii->pub, "boardvendor"))
-		    == 0)
+		sii->pub.boardvendor = (u16)si_getdevpathintvar(&sii->pub,
+			"boardvendor");
+		if (sii->pub.boardvendor == 0)
 			sii->pub.boardvendor = w & 0xffff;
 		else
 			SI_ERROR(("Overriding boardvendor: 0x%x instead of 0x%x\n", sii->pub.boardvendor, w & 0xffff));
-		if ((sii->pub.boardtype =
-		     (uint16) si_getdevpathintvar(&sii->pub, "boardtype"))
-		    == 0)
+		sii->pub.boardtype = (u16)si_getdevpathintvar(&sii->pub,
+			"boardtype");
+		if (sii->pub.boardtype == 0)
 			sii->pub.boardtype = (w >> 16) & 0xffff;
 		else
 			SI_ERROR(("Overriding boardtype: 0x%x instead of 0x%x\n", sii->pub.boardtype, (w >> 16) & 0xffff));
@@ -330,11 +344,12 @@ static void BCMATTACHFN(si_nvram_process) (si_info_t * sii, char *pvars) {
 	case SI_BUS:
 	case JTAG_BUS:
 		sii->pub.boardvendor = VENDOR_BROADCOM;
-		if (pvars == NULL
-		    || ((sii->pub.boardtype = getintvar(pvars, "prodid")) == 0))
-			if ((sii->pub.boardtype =
-			     getintvar(NULL, "boardtype")) == 0)
+		sii->pub.boardtype = getintvar(pvars, "prodid");
+		if (pvars == NULL || (sii->pub.boardtype == 0)) {
+			sii->pub.boardtype = getintvar(NULL, "boardtype");
+			if (sii->pub.boardtype == 0)
 				sii->pub.boardtype = 0xffff;
+		}
 		break;
 	}
 
@@ -349,19 +364,19 @@ static void BCMATTACHFN(si_nvram_process) (si_info_t * sii, char *pvars) {
 /* this is will make Sonics calls directly, since Sonics is no longer supported in the Si abstraction */
 /* this has been customized for the bcm 4329 ONLY */
 #ifdef BCMSDIO
-static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
-					    osl_t * osh, void *regs,
-					    uint bustype, void *sdh,
-					    char **vars, uint * varsz) {
+static si_info_t *si_doattach(si_info_t *sii, uint devid, osl_t *osh,
+			      void *regs, uint bustype, void *sdh,
+			      char **vars, uint *varsz)
+{
 	struct si_pub *sih = &sii->pub;
-	uint32 w, savewin;
+	u32 w, savewin;
 	chipcregs_t *cc;
 	char *pvars = NULL;
 	uint origidx;
 
 	ASSERT(GOODREGS(regs));
 
-	bzero((uchar *) sii, sizeof(si_info_t));
+	bzero((unsigned char *) sii, sizeof(si_info_t));
 
 	savewin = 0;
 
@@ -399,10 +414,10 @@ static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
 	sih->chiprev = (w & CID_REV_MASK) >> CID_REV_SHIFT;
 	sih->chippkg = (w & CID_PKG_MASK) >> CID_PKG_SHIFT;
 
-	if ((CHIPID(sih->chip) == BCM4329_CHIP_ID) && (sih->chiprev == 0) &&
-	    (sih->chippkg != BCM4329_289PIN_PKG_ID)) {
-		sih->chippkg = BCM4329_182PIN_PKG_ID;
-	}
+	if ((CHIPID(sih->chip) == BCM4329_CHIP_ID) &&
+		(sih->chippkg != BCM4329_289PIN_PKG_ID))
+			sih->chippkg = BCM4329_182PIN_PKG_ID;
+
 	sih->issim = IS_SIM(sih->chippkg);
 
 	/* scan for cores */
@@ -421,6 +436,9 @@ static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
 		goto exit;
 	}
 
+#ifdef BRCM_FULLMAC
+	pvars = NULL;
+#else
 	/* Init nvram from flash if it exists */
 	nvram_init((void *)&(sii->pub));
 
@@ -432,17 +450,25 @@ static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
 	}
 	pvars = vars ? *vars : NULL;
 	si_nvram_process(sii, pvars);
+#endif
 
 	/* === NVRAM, clock is ready === */
 
+#ifdef BRCM_FULLMAC
+	if (sii->pub.ccrev >= 20) {
+#endif
 	cc = (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0);
 	W_REG(osh, &cc->gpiopullup, 0);
 	W_REG(osh, &cc->gpiopulldown, 0);
 	sb_setcoreidx(sih, origidx);
+#ifdef BRCM_FULLMAC
+	}
+#endif
 
+#ifndef BRCM_FULLMAC
 	/* PMU specific initializations */
 	if (PMUCTL_ENAB(sih)) {
-		uint32 xtalfreq;
+		u32 xtalfreq;
 		si_pmu_init(sih, sii->osh);
 		si_pmu_chip_init(sih, sii->osh);
 		xtalfreq = getintvar(pvars, "xtalfreq");
@@ -455,35 +481,37 @@ static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
 	}
 
 	/* setup the GPIO based LED powersave register */
-	if ((w = getintvar(pvars, "leddc")) == 0)
+	w = getintvar(pvars, "leddc");
+	if (w == 0)
 		w = DEFAULT_GPIOTIMERVAL;
-	sb_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gpiotimerval), ~0, w);
+	sb_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, gpiotimerval), ~0, w);
 
 #ifdef BCMDBG
 	/* clear any previous epidiag-induced target abort */
-	sb_taclear(sih, FALSE);
+	sb_taclear(sih, false);
 #endif				/* BCMDBG */
+#endif
 
-	return (sii);
+	return sii;
 
  exit:
 	return NULL;
 }
 
 #else				/* BCMSDIO */
-static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
-					    osl_t * osh, void *regs,
-					    uint bustype, void *sdh,
-					    char **vars, uint * varsz) {
+static si_info_t *si_doattach(si_info_t *sii, uint devid, osl_t *osh,
+			      void *regs, uint bustype, void *sdh,
+			      char **vars, uint *varsz)
+{
 	struct si_pub *sih = &sii->pub;
-	uint32 w, savewin;
+	u32 w, savewin;
 	chipcregs_t *cc;
 	char *pvars = NULL;
 	uint origidx;
 
 	ASSERT(GOODREGS(regs));
 
-	bzero((uchar *) sii, sizeof(si_info_t));
+	bzero((unsigned char *) sii, sizeof(si_info_t));
 
 	savewin = 0;
 
@@ -495,7 +523,7 @@ static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
 
 	/* check to see if we are a si core mimic'ing a pci core */
 	if ((bustype == PCI_BUS) &&
-	    (OSL_PCI_READ_CONFIG(sii->osh, PCI_SPROM_CONTROL, sizeof(uint32)) ==
+	    (OSL_PCI_READ_CONFIG(sii->osh, PCI_SPROM_CONTROL, sizeof(u32)) ==
 	     0xffffffff)) {
 		SI_ERROR(("%s: incoming bus is PCI but it's a lie, switching to SI " "devid:0x%x\n", __func__, devid));
 		bustype = SI_BUS;
@@ -504,7 +532,7 @@ static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
 	/* find Chipcommon address */
 	if (bustype == PCI_BUS) {
 		savewin =
-		    OSL_PCI_READ_CONFIG(sii->osh, PCI_BAR0_WIN, sizeof(uint32));
+		    OSL_PCI_READ_CONFIG(sii->osh, PCI_BAR0_WIN, sizeof(u32));
 		if (!GOODCOREADDR(savewin, SI_ENUM_BASE))
 			savewin = SI_ENUM_BASE;
 		OSL_PCI_WRITE_CONFIG(sii->osh, PCI_BAR0_WIN, 4, SI_ENUM_BASE);
@@ -544,7 +572,7 @@ static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
 	if (CHIPTYPE(sii->pub.socitype) == SOCI_AI) {
 		SI_MSG(("Found chip type AI (0x%08x)\n", w));
 		/* pass chipc address instead of original core base */
-		ai_scan(&sii->pub, (void *)(uintptr) cc, devid);
+		ai_scan(&sii->pub, (void *)cc, devid);
 	} else {
 		SI_ERROR(("Found chip of unknown type (0x%08x)\n", w));
 		return NULL;
@@ -577,7 +605,7 @@ static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
 			W_REG(osh, &cc->clkdiv, clkdiv);
 			SI_ERROR(("%s: set clkdiv to %x\n", __func__, clkdiv));
 		}
-		OSL_DELAY(10);
+		udelay(10);
 	}
 
 	/* Init nvram from flash if it exists */
@@ -600,7 +628,7 @@ static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
 
 	/* PMU specific initializations */
 	if (PMUCTL_ENAB(sih)) {
-		uint32 xtalfreq;
+		u32 xtalfreq;
 		si_pmu_init(sih, sii->osh);
 		si_pmu_chip_init(sih, sii->osh);
 		xtalfreq = getintvar(pvars, "xtalfreq");
@@ -613,9 +641,10 @@ static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
 	}
 
 	/* setup the GPIO based LED powersave register */
-	if ((w = getintvar(pvars, "leddc")) == 0)
+	w = getintvar(pvars, "leddc");
+	if (w == 0)
 		w = DEFAULT_GPIOTIMERVAL;
-	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gpiotimerval), ~0, w);
+	si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, gpiotimerval), ~0, w);
 
 	if (PCIE(sii)) {
 		ASSERT(sii->pch != NULL);
@@ -628,7 +657,7 @@ static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
 		if (CHIPREV(sih->chiprev) == 0) {
 			SI_MSG(("Applying 43224A0 WARs\n"));
 			si_corereg(sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, chipcontrol),
+				   offsetof(chipcregs_t, chipcontrol),
 				   CCTRL43224_GPIO_TOGGLE,
 				   CCTRL43224_GPIO_TOGGLE);
 			si_pmu_chipcontrol(sih, 0, CCTRL_43224A0_12MA_LED_DRIVE,
@@ -650,10 +679,10 @@ static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
 
 	if (CHIPID(sih->chip) == BCM4331_CHIP_ID) {
 		/* Enable Ext PA lines depending on chip package option */
-		si_chipcontrl_epa4331(sih, TRUE);
+		si_chipcontrl_epa4331(sih, true);
 	}
 
-	return (sii);
+	return sii;
  exit:
 	if (BUSTYPE(sih->bustype) == PCI_BUS) {
 		if (sii->pch)
@@ -666,7 +695,8 @@ static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
 #endif				/* BCMSDIO */
 
 /* may be called with core in reset */
-void BCMATTACHFN(si_detach) (si_t * sih) {
+void si_detach(si_t *sih)
+{
 	si_info_t *sii;
 	uint idx;
 
@@ -685,6 +715,7 @@ void BCMATTACHFN(si_detach) (si_t * sih) {
 				sii->regs[idx] = NULL;
 			}
 
+#ifndef BRCM_FULLMAC
 	nvram_exit((void *)si_local);	/* free up nvram buffers */
 
 	if (BUSTYPE(sih->bustype) == PCI_BUS) {
@@ -692,13 +723,14 @@ void BCMATTACHFN(si_detach) (si_t * sih) {
 			pcicore_deinit(sii->pch);
 		sii->pch = NULL;
 	}
+#endif
 #if !defined(BCMBUSTYPE) || (BCMBUSTYPE == SI_BUS)
 	if (sii != &ksii)
 #endif				/* !BCMBUSTYPE || (BCMBUSTYPE == SI_BUS) */
-		MFREE(sii->osh, sii, sizeof(si_info_t));
+		kfree(sii);
 }
 
-void *si_osh(si_t * sih)
+void *si_osh(si_t *sih)
 {
 	si_info_t *sii;
 
@@ -706,21 +738,9 @@ void *si_osh(si_t * sih)
 	return sii->osh;
 }
 
-void si_setosh(si_t * sih, osl_t * osh)
-{
-	si_info_t *sii;
-
-	sii = SI_INFO(sih);
-	if (sii->osh != NULL) {
-		SI_ERROR(("osh is already set....\n"));
-		ASSERT(!sii->osh);
-	}
-	sii->osh = osh;
-}
-
 /* register driver interrupt disabling and restoring callback functions */
 void
-si_register_intr_callback(si_t * sih, void *intrsoff_fn, void *intrsrestore_fn,
+si_register_intr_callback(si_t *sih, void *intrsoff_fn, void *intrsrestore_fn,
 			  void *intrsenabled_fn, void *intr_arg)
 {
 	si_info_t *sii;
@@ -736,7 +756,7 @@ si_register_intr_callback(si_t * sih, void *intrsoff_fn, void *intrsrestore_fn,
 	sii->dev_coreid = sii->coreid[sii->curidx];
 }
 
-void si_deregister_intr_callback(si_t * sih)
+void si_deregister_intr_callback(si_t *sih)
 {
 	si_info_t *sii;
 
@@ -744,21 +764,7 @@ void si_deregister_intr_callback(si_t * sih)
 	sii->intrsoff_fn = NULL;
 }
 
-uint si_intflag(si_t * sih)
-{
-	si_info_t *sii = SI_INFO(sih);
-
-	if (CHIPTYPE(sih->socitype) == SOCI_AI)
-		return R_REG(sii->osh,
-			     ((uint32 *) (uintptr) (sii->oob_router +
-						    OOB_STATUSA)));
-	else {
-		ASSERT(0);
-		return 0;
-	}
-}
-
-uint si_flag(si_t * sih)
+uint si_flag(si_t *sih)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_flag(sih);
@@ -768,7 +774,7 @@ uint si_flag(si_t * sih)
 	}
 }
 
-void si_setint(si_t * sih, int siflag)
+void si_setint(si_t *sih, int siflag)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		ai_setint(sih, siflag);
@@ -777,7 +783,7 @@ void si_setint(si_t * sih, int siflag)
 }
 
 #ifndef BCMSDIO
-uint si_coreid(si_t * sih)
+uint si_coreid(si_t *sih)
 {
 	si_info_t *sii;
 
@@ -786,7 +792,7 @@ uint si_coreid(si_t * sih)
 }
 #endif
 
-uint si_coreidx(si_t * sih)
+uint si_coreidx(si_t *sih)
 {
 	si_info_t *sii;
 
@@ -794,48 +800,13 @@ uint si_coreidx(si_t * sih)
 	return sii->curidx;
 }
 
-/* return the core-type instantiation # of the current core */
-uint si_coreunit(si_t * sih)
-{
-	si_info_t *sii;
-	uint idx;
-	uint coreid;
-	uint coreunit;
-	uint i;
-
-	sii = SI_INFO(sih);
-	coreunit = 0;
-
-	idx = sii->curidx;
-
-	ASSERT(GOODREGS(sii->curmap));
-	coreid = si_coreid(sih);
-
-	/* count the cores of our type */
-	for (i = 0; i < idx; i++)
-		if (sii->coreid[i] == coreid)
-			coreunit++;
-
-	return (coreunit);
-}
-
-uint si_corevendor(si_t * sih)
-{
-	if (CHIPTYPE(sih->socitype) == SOCI_AI)
-		return ai_corevendor(sih);
-	else {
-		ASSERT(0);
-		return 0;
-	}
-}
-
-bool si_backplane64(si_t * sih)
+bool si_backplane64(si_t *sih)
 {
-	return ((sih->cccaps & CC_CAP_BKPLN64) != 0);
+	return (sih->cccaps & CC_CAP_BKPLN64) != 0;
 }
 
 #ifndef BCMSDIO
-uint si_corerev(si_t * sih)
+uint si_corerev(si_t *sih)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_corerev(sih);
@@ -847,7 +818,7 @@ uint si_corerev(si_t * sih)
 #endif
 
 /* return index of coreid or BADIDX if not found */
-uint si_findcoreidx(si_t * sih, uint coreid, uint coreunit)
+uint si_findcoreidx(si_t *sih, uint coreid, uint coreunit)
 {
 	si_info_t *sii;
 	uint found;
@@ -860,34 +831,11 @@ uint si_findcoreidx(si_t * sih, uint coreid, uint coreunit)
 	for (i = 0; i < sii->numcores; i++)
 		if (sii->coreid[i] == coreid) {
 			if (found == coreunit)
-				return (i);
+				return i;
 			found++;
 		}
 
-	return (BADIDX);
-}
-
-/* return list of found cores */
-uint si_corelist(si_t * sih, uint coreid[])
-{
-	si_info_t *sii;
-
-	sii = SI_INFO(sih);
-
-	bcopy((uchar *) sii->coreid, (uchar *) coreid,
-	      (sii->numcores * sizeof(uint)));
-	return (sii->numcores);
-}
-
-/* return current register mapping */
-void *si_coreregs(si_t * sih)
-{
-	si_info_t *sii;
-
-	sii = SI_INFO(sih);
-	ASSERT(GOODREGS(sii->curmap));
-
-	return (sii->curmap);
+	return BADIDX;
 }
 
 /*
@@ -895,13 +843,13 @@ void *si_coreregs(si_t * sih)
  * must be called with interrupts off.
  * Moreover, callers should keep interrupts off during switching out of and back to d11 core
  */
-void *si_setcore(si_t * sih, uint coreid, uint coreunit)
+void *si_setcore(si_t *sih, uint coreid, uint coreunit)
 {
 	uint idx;
 
 	idx = si_findcoreidx(sih, coreid, coreunit);
 	if (!GOODIDX(idx))
-		return (NULL);
+		return NULL;
 
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_setcoreidx(sih, idx);
@@ -916,7 +864,7 @@ void *si_setcore(si_t * sih, uint coreid, uint coreunit)
 }
 
 #ifndef BCMSDIO
-void *si_setcoreidx(si_t * sih, uint coreidx)
+void *si_setcoreidx(si_t *sih, uint coreidx)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_setcoreidx(sih, coreidx);
@@ -928,7 +876,7 @@ void *si_setcoreidx(si_t * sih, uint coreidx)
 #endif
 
 /* Turn off interrupt as required by sb_setcore, before switch core */
-void *si_switch_core(si_t * sih, uint coreid, uint * origidx, uint * intr_val)
+void *si_switch_core(si_t *sih, uint coreid, uint *origidx, uint *intr_val)
 {
 	void *cc;
 	si_info_t *sii;
@@ -955,7 +903,7 @@ void *si_switch_core(si_t * sih, uint coreid, uint * origidx, uint * intr_val)
 }
 
 /* restore coreidx and restore interrupt */
-void si_restore_core(si_t * sih, uint coreid, uint intr_val)
+void si_restore_core(si_t *sih, uint coreid, uint intr_val)
 {
 	si_info_t *sii;
 
@@ -968,37 +916,7 @@ void si_restore_core(si_t * sih, uint coreid, uint intr_val)
 	INTR_RESTORE(sii, intr_val);
 }
 
-int si_numaddrspaces(si_t * sih)
-{
-	if (CHIPTYPE(sih->socitype) == SOCI_AI)
-		return ai_numaddrspaces(sih);
-	else {
-		ASSERT(0);
-		return 0;
-	}
-}
-
-uint32 si_addrspace(si_t * sih, uint asidx)
-{
-	if (CHIPTYPE(sih->socitype) == SOCI_AI)
-		return ai_addrspace(sih, asidx);
-	else {
-		ASSERT(0);
-		return 0;
-	}
-}
-
-uint32 si_addrspacesize(si_t * sih, uint asidx)
-{
-	if (CHIPTYPE(sih->socitype) == SOCI_AI)
-		return ai_addrspacesize(sih, asidx);
-	else {
-		ASSERT(0);
-		return 0;
-	}
-}
-
-uint32 si_core_cflags(si_t * sih, uint32 mask, uint32 val)
+u32 si_core_cflags(si_t *sih, u32 mask, u32 val)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_core_cflags(sih, mask, val);
@@ -1008,15 +926,7 @@ uint32 si_core_cflags(si_t * sih, uint32 mask, uint32 val)
 	}
 }
 
-void si_core_cflags_wo(si_t * sih, uint32 mask, uint32 val)
-{
-	if (CHIPTYPE(sih->socitype) == SOCI_AI)
-		ai_core_cflags_wo(sih, mask, val);
-	else
-		ASSERT(0);
-}
-
-uint32 si_core_sflags(si_t * sih, uint32 mask, uint32 val)
+u32 si_core_sflags(si_t *sih, u32 mask, u32 val)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_core_sflags(sih, mask, val);
@@ -1026,7 +936,7 @@ uint32 si_core_sflags(si_t * sih, uint32 mask, uint32 val)
 	}
 }
 
-bool si_iscoreup(si_t * sih)
+bool si_iscoreup(si_t *sih)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_iscoreup(sih);
@@ -1035,12 +945,12 @@ bool si_iscoreup(si_t * sih)
 		return sb_iscoreup(sih);
 #else
 		ASSERT(0);
-		return FALSE;
+		return false;
 #endif
 	}
 }
 
-void si_write_wrapperreg(si_t * sih, uint32 offset, uint32 val)
+void si_write_wrapperreg(si_t *sih, u32 offset, u32 val)
 {
 	/* only for 4319, no requirement for SOCI_SB */
 	if (CHIPTYPE(sih->socitype) == SOCI_AI) {
@@ -1048,7 +958,7 @@ void si_write_wrapperreg(si_t * sih, uint32 offset, uint32 val)
 	}
 }
 
-uint si_corereg(si_t * sih, uint coreidx, uint regoff, uint mask, uint val)
+uint si_corereg(si_t *sih, uint coreidx, uint regoff, uint mask, uint val)
 {
 
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
@@ -1063,7 +973,7 @@ uint si_corereg(si_t * sih, uint coreidx, uint regoff, uint mask, uint val)
 	}
 }
 
-void si_core_disable(si_t * sih, uint32 bits)
+void si_core_disable(si_t *sih, u32 bits)
 {
 
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
@@ -1074,7 +984,7 @@ void si_core_disable(si_t * sih, uint32 bits)
 #endif
 }
 
-void si_core_reset(si_t * sih, uint32 bits, uint32 resetbits)
+void si_core_reset(si_t *sih, u32 bits, u32 resetbits)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		ai_core_reset(sih, bits, resetbits);
@@ -1084,184 +994,16 @@ void si_core_reset(si_t * sih, uint32 bits, uint32 resetbits)
 #endif
 }
 
-/* Run bist on current core. Caller needs to take care of core-specific bist hazards */
-int si_corebist(si_t * sih)
+u32 si_alp_clock(si_t *sih)
 {
-	uint32 cflags;
-	int result = 0;
-
-	/* Read core control flags */
-	cflags = si_core_cflags(sih, 0, 0);
-
-	/* Set bist & fgc */
-	si_core_cflags(sih, ~0, (SICF_BIST_EN | SICF_FGC));
-
-	/* Wait for bist done */
-	SPINWAIT(((si_core_sflags(sih, 0, 0) & SISF_BIST_DONE) == 0), 100000);
-
-	if (si_core_sflags(sih, 0, 0) & SISF_BIST_ERROR)
-		result = BCME_ERROR;
-
-	/* Reset core control flags */
-	si_core_cflags(sih, 0xffff, cflags);
-
-	return result;
-}
-
-static uint32 BCMINITFN(factor6) (uint32 x) {
-	switch (x) {
-	case CC_F6_2:
-		return 2;
-	case CC_F6_3:
-		return 3;
-	case CC_F6_4:
-		return 4;
-	case CC_F6_5:
-		return 5;
-	case CC_F6_6:
-		return 6;
-	case CC_F6_7:
-		return 7;
-	default:
-		return 0;
-	}
-}
-
-/* calculate the speed the SI would run at given a set of clockcontrol values */
-uint32 BCMINITFN(si_clock_rate) (uint32 pll_type, uint32 n, uint32 m) {
-	uint32 n1, n2, clock, m1, m2, m3, mc;
-
-	n1 = n & CN_N1_MASK;
-	n2 = (n & CN_N2_MASK) >> CN_N2_SHIFT;
-
-	if (pll_type == PLL_TYPE6) {
-		if (m & CC_T6_MMASK)
-			return CC_T6_M1;
-		else
-			return CC_T6_M0;
-	} else if ((pll_type == PLL_TYPE1) ||
-		   (pll_type == PLL_TYPE3) ||
-		   (pll_type == PLL_TYPE4) || (pll_type == PLL_TYPE7)) {
-		n1 = factor6(n1);
-		n2 += CC_F5_BIAS;
-	} else if (pll_type == PLL_TYPE2) {
-		n1 += CC_T2_BIAS;
-		n2 += CC_T2_BIAS;
-		ASSERT((n1 >= 2) && (n1 <= 7));
-		ASSERT((n2 >= 5) && (n2 <= 23));
-	} else if (pll_type == PLL_TYPE5) {
-		return (100000000);
-	} else
-		ASSERT(0);
-	/* PLL types 3 and 7 use BASE2 (25Mhz) */
-	if ((pll_type == PLL_TYPE3) || (pll_type == PLL_TYPE7)) {
-		clock = CC_CLOCK_BASE2 * n1 * n2;
-	} else
-		clock = CC_CLOCK_BASE1 * n1 * n2;
-
-	if (clock == 0)
-		return 0;
-
-	m1 = m & CC_M1_MASK;
-	m2 = (m & CC_M2_MASK) >> CC_M2_SHIFT;
-	m3 = (m & CC_M3_MASK) >> CC_M3_SHIFT;
-	mc = (m & CC_MC_MASK) >> CC_MC_SHIFT;
-
-	if ((pll_type == PLL_TYPE1) ||
-	    (pll_type == PLL_TYPE3) ||
-	    (pll_type == PLL_TYPE4) || (pll_type == PLL_TYPE7)) {
-		m1 = factor6(m1);
-		if ((pll_type == PLL_TYPE1) || (pll_type == PLL_TYPE3))
-			m2 += CC_F5_BIAS;
-		else
-			m2 = factor6(m2);
-		m3 = factor6(m3);
-
-		switch (mc) {
-		case CC_MC_BYPASS:
-			return (clock);
-		case CC_MC_M1:
-			return (clock / m1);
-		case CC_MC_M1M2:
-			return (clock / (m1 * m2));
-		case CC_MC_M1M2M3:
-			return (clock / (m1 * m2 * m3));
-		case CC_MC_M1M3:
-			return (clock / (m1 * m3));
-		default:
-			return (0);
-		}
-	} else {
-		ASSERT(pll_type == PLL_TYPE2);
-
-		m1 += CC_T2_BIAS;
-		m2 += CC_T2M2_BIAS;
-		m3 += CC_T2_BIAS;
-		ASSERT((m1 >= 2) && (m1 <= 7));
-		ASSERT((m2 >= 3) && (m2 <= 10));
-		ASSERT((m3 >= 2) && (m3 <= 7));
-
-		if ((mc & CC_T2MC_M1BYP) == 0)
-			clock /= m1;
-		if ((mc & CC_T2MC_M2BYP) == 0)
-			clock /= m2;
-		if ((mc & CC_T2MC_M3BYP) == 0)
-			clock /= m3;
-
-		return (clock);
-	}
-}
-
-uint32 BCMINITFN(si_clock) (si_t * sih) {
-	si_info_t *sii;
-	chipcregs_t *cc;
-	uint32 n, m;
-	uint idx;
-	uint32 pll_type, rate;
-	uint intr_val = 0;
-
-	sii = SI_INFO(sih);
-	INTR_OFF(sii, intr_val);
-	if (PMUCTL_ENAB(sih)) {
-		rate = si_pmu_si_clock(sih, sii->osh);
-		goto exit;
-	}
-
-	idx = sii->curidx;
-	cc = (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0);
-	ASSERT(cc != NULL);
-
-	n = R_REG(sii->osh, &cc->clockcontrol_n);
-	pll_type = sih->cccaps & CC_CAP_PLL_MASK;
-	if (pll_type == PLL_TYPE6)
-		m = R_REG(sii->osh, &cc->clockcontrol_m3);
-	else if (pll_type == PLL_TYPE3)
-		m = R_REG(sii->osh, &cc->clockcontrol_m2);
-	else
-		m = R_REG(sii->osh, &cc->clockcontrol_sb);
-
-	/* calculate rate */
-	rate = si_clock_rate(pll_type, n, m);
-
-	if (pll_type == PLL_TYPE3)
-		rate = rate / 2;
-
-	/* switch back to previous core */
-	si_setcoreidx(sih, idx);
- exit:
-	INTR_RESTORE(sii, intr_val);
-
-	return rate;
-}
-
-uint32 BCMINITFN(si_alp_clock) (si_t * sih) {
 	if (PMUCTL_ENAB(sih))
 		return si_pmu_alp_clock(sih, si_osh(sih));
 
 	return ALP_CLOCK;
 }
 
-uint32 BCMINITFN(si_ilp_clock) (si_t * sih) {
+u32 si_ilp_clock(si_t *sih)
+{
 	if (PMUCTL_ENAB(sih))
 		return si_pmu_ilp_clock(sih, si_osh(sih));
 
@@ -1269,7 +1011,33 @@ uint32 BCMINITFN(si_ilp_clock) (si_t * sih) {
 }
 
 /* set chip watchdog reset timer to fire in 'ticks' */
-void si_watchdog(si_t * sih, uint ticks)
+#ifdef BRCM_FULLMAC
+void
+si_watchdog(si_t *sih, uint ticks)
+{
+	if (PMUCTL_ENAB(sih)) {
+
+		if ((sih->chip == BCM4319_CHIP_ID) && (sih->chiprev == 0) &&
+			(ticks != 0)) {
+			si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t,
+			clk_ctl_st), ~0, 0x2);
+			si_setcore(sih, USB20D_CORE_ID, 0);
+			si_core_disable(sih, 1);
+			si_setcore(sih, CC_CORE_ID, 0);
+		}
+
+		if (ticks == 1)
+			ticks = 2;
+		si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, pmuwatchdog),
+			~0, ticks);
+	} else {
+		/* instant NMI */
+		si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, watchdog),
+			~0, ticks);
+	}
+}
+#else
+void si_watchdog(si_t *sih, uint ticks)
 {
 	uint nb, maxt;
 
@@ -1278,7 +1046,7 @@ void si_watchdog(si_t * sih, uint ticks)
 		if ((CHIPID(sih->chip) == BCM4319_CHIP_ID) &&
 		    (CHIPREV(sih->chiprev) == 0) && (ticks != 0)) {
 			si_corereg(sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, clk_ctl_st), ~0, 0x2);
+				   offsetof(chipcregs_t, clk_ctl_st), ~0, 0x2);
 			si_setcore(sih, USB20D_CORE_ID, 0);
 			si_core_disable(sih, 1);
 			si_setcore(sih, CC_CORE_ID, 0);
@@ -1298,7 +1066,7 @@ void si_watchdog(si_t * sih, uint ticks)
 		else if (ticks > maxt)
 			ticks = maxt;
 
-		si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, pmuwatchdog),
+		si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, pmuwatchdog),
 			   ~0, ticks);
 	} else {
 		/* make sure we come up in fast clock mode; or if clearing, clear clock */
@@ -1307,36 +1075,14 @@ void si_watchdog(si_t * sih, uint ticks)
 		if (ticks > maxt)
 			ticks = maxt;
 
-		si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, watchdog), ~0,
+		si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, watchdog), ~0,
 			   ticks);
 	}
 }
-
-/* trigger watchdog reset after ms milliseconds */
-void si_watchdog_ms(si_t * sih, uint32 ms)
-{
-	si_watchdog(sih, wd_msticks * ms);
-}
-
-uint16 BCMATTACHFN(si_d11_devid) (si_t * sih) {
-	si_info_t *sii = SI_INFO(sih);
-	uint16 device;
-
-	/* normal case: nvram variable with devpath->devid->wl0id */
-	if ((device = (uint16) si_getdevpathintvar(sih, "devid")) != 0) ;
-	/* Get devid from OTP/SPROM depending on where the SROM is read */
-	else if ((device = (uint16) getintvar(sii->vars, "devid")) != 0) ;
-	/* no longer support wl0id, but keep the code here for backward compatibility. */
-	else if ((device = (uint16) getintvar(sii->vars, "wl0id")) != 0) ;
-	else
-		/* ignore it */
-		device = 0xffff;
-
-	return device;
-}
+#endif
 
 /* return the slow clock source - LPO, XTAL, or PCI */
-static uint si_slowclk_src(si_info_t * sii)
+static uint si_slowclk_src(si_info_t *sii)
 {
 	chipcregs_t *cc;
 
@@ -1344,22 +1090,22 @@ static uint si_slowclk_src(si_info_t * sii)
 
 	if (sii->pub.ccrev < 6) {
 		if ((BUSTYPE(sii->pub.bustype) == PCI_BUS) &&
-		    (OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_OUT, sizeof(uint32))
+		    (OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_OUT, sizeof(u32))
 		     & PCI_CFG_GPIO_SCS))
-			return (SCC_SS_PCI);
+			return SCC_SS_PCI;
 		else
-			return (SCC_SS_XTAL);
+			return SCC_SS_XTAL;
 	} else if (sii->pub.ccrev < 10) {
 		cc = (chipcregs_t *) si_setcoreidx(&sii->pub, sii->curidx);
-		return (R_REG(sii->osh, &cc->slow_clk_ctl) & SCC_SS_MASK);
+		return R_REG(sii->osh, &cc->slow_clk_ctl) & SCC_SS_MASK;
 	} else			/* Insta-clock */
-		return (SCC_SS_XTAL);
+		return SCC_SS_XTAL;
 }
 
 /* return the ILP (slowclock) min or max frequency */
-static uint si_slowclk_freq(si_info_t * sii, bool max_freq, chipcregs_t * cc)
+static uint si_slowclk_freq(si_info_t *sii, bool max_freq, chipcregs_t *cc)
 {
-	uint32 slowclk;
+	u32 slowclk;
 	uint div;
 
 	ASSERT(SI_FAST(sii) || si_coreid(&sii->pub) == CC_CORE_ID);
@@ -1370,35 +1116,36 @@ static uint si_slowclk_freq(si_info_t * sii, bool max_freq, chipcregs_t * cc)
 	slowclk = si_slowclk_src(sii);
 	if (sii->pub.ccrev < 6) {
 		if (slowclk == SCC_SS_PCI)
-			return (max_freq ? (PCIMAXFREQ / 64)
-				: (PCIMINFREQ / 64));
+			return max_freq ? (PCIMAXFREQ / 64)
+				: (PCIMINFREQ / 64);
 		else
-			return (max_freq ? (XTALMAXFREQ / 32)
-				: (XTALMINFREQ / 32));
+			return max_freq ? (XTALMAXFREQ / 32)
+				: (XTALMINFREQ / 32);
 	} else if (sii->pub.ccrev < 10) {
 		div = 4 *
 		    (((R_REG(sii->osh, &cc->slow_clk_ctl) & SCC_CD_MASK) >>
 		      SCC_CD_SHIFT) + 1);
 		if (slowclk == SCC_SS_LPO)
-			return (max_freq ? LPOMAXFREQ : LPOMINFREQ);
+			return max_freq ? LPOMAXFREQ : LPOMINFREQ;
 		else if (slowclk == SCC_SS_XTAL)
-			return (max_freq ? (XTALMAXFREQ / div)
-				: (XTALMINFREQ / div));
+			return max_freq ? (XTALMAXFREQ / div)
+				: (XTALMINFREQ / div);
 		else if (slowclk == SCC_SS_PCI)
-			return (max_freq ? (PCIMAXFREQ / div)
-				: (PCIMINFREQ / div));
+			return max_freq ? (PCIMAXFREQ / div)
+				: (PCIMINFREQ / div);
 		else
 			ASSERT(0);
 	} else {
 		/* Chipc rev 10 is InstaClock */
 		div = R_REG(sii->osh, &cc->system_clk_ctl) >> SYCC_CD_SHIFT;
 		div = 4 * (div + 1);
-		return (max_freq ? XTALMAXFREQ : (XTALMINFREQ / div));
+		return max_freq ? XTALMAXFREQ : (XTALMINFREQ / div);
 	}
-	return (0);
+	return 0;
 }
 
-static void BCMINITFN(si_clkctl_setdelay) (si_info_t * sii, void *chipcregs) {
+static void si_clkctl_setdelay(si_info_t *sii, void *chipcregs)
+{
 	chipcregs_t *cc = (chipcregs_t *) chipcregs;
 	uint slowmaxfreq, pll_delay, slowclk;
 	uint pll_on_delay, fref_sel_delay;
@@ -1415,7 +1162,7 @@ static void BCMINITFN(si_clkctl_setdelay) (si_info_t * sii, void *chipcregs) {
 
 	/* Starting with 4318 it is ILP that is used for the delays */
 	slowmaxfreq =
-	    si_slowclk_freq(sii, (sii->pub.ccrev >= 10) ? FALSE : TRUE, cc);
+	    si_slowclk_freq(sii, (sii->pub.ccrev >= 10) ? false : true, cc);
 
 	pll_on_delay = ((slowmaxfreq * pll_delay) + 999999) / 1000000;
 	fref_sel_delay = ((slowmaxfreq * FREF_DELAY) + 999999) / 1000000;
@@ -1425,7 +1172,8 @@ static void BCMINITFN(si_clkctl_setdelay) (si_info_t * sii, void *chipcregs) {
 }
 
 /* initialize power control delay registers */
-void BCMINITFN(si_clkctl_init) (si_t * sih) {
+void si_clkctl_init(si_t *sih)
+{
 	si_info_t *sii;
 	uint origidx = 0;
 	chipcregs_t *cc;
@@ -1438,11 +1186,14 @@ void BCMINITFN(si_clkctl_init) (si_t * sih) {
 	fast = SI_FAST(sii);
 	if (!fast) {
 		origidx = sii->curidx;
-		if ((cc =
-		     (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0)) == NULL)
+		cc = (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0);
+		if (cc == NULL)
 			return;
-	} else if ((cc = (chipcregs_t *) CCREGS_FAST(sii)) == NULL)
-		return;
+	} else {
+		cc = (chipcregs_t *) CCREGS_FAST(sii);
+		if (cc == NULL)
+			return;
+	}
 	ASSERT(cc != NULL);
 
 	/* set all Instaclk chip ILP to 1 MHz */
@@ -1450,19 +1201,20 @@ void BCMINITFN(si_clkctl_init) (si_t * sih) {
 		SET_REG(sii->osh, &cc->system_clk_ctl, SYCC_CD_MASK,
 			(ILP_DIV_1MHZ << SYCC_CD_SHIFT));
 
-	si_clkctl_setdelay(sii, (void *)(uintptr) cc);
+	si_clkctl_setdelay(sii, (void *)cc);
 
 	if (!fast)
 		si_setcoreidx(sih, origidx);
 }
 
 /* return the value suitable for writing to the dot11 core FAST_PWRUP_DELAY register */
-uint16 BCMINITFN(si_clkctl_fast_pwrup_delay) (si_t * sih) {
+u16 si_clkctl_fast_pwrup_delay(si_t *sih)
+{
 	si_info_t *sii;
 	uint origidx = 0;
 	chipcregs_t *cc;
 	uint slowminfreq;
-	uint16 fpdelay;
+	u16 fpdelay;
 	uint intr_val = 0;
 	bool fast;
 
@@ -1482,14 +1234,17 @@ uint16 BCMINITFN(si_clkctl_fast_pwrup_delay) (si_t * sih) {
 	if (!fast) {
 		origidx = sii->curidx;
 		INTR_OFF(sii, intr_val);
-		if ((cc =
-		     (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0)) == NULL)
+		cc = (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0);
+		if (cc == NULL)
 			goto done;
-	} else if ((cc = (chipcregs_t *) CCREGS_FAST(sii)) == NULL)
-		goto done;
+	} else {
+		cc = (chipcregs_t *) CCREGS_FAST(sii);
+		if (cc == NULL)
+			goto done;
+	}
 	ASSERT(cc != NULL);
 
-	slowminfreq = si_slowclk_freq(sii, FALSE, cc);
+	slowminfreq = si_slowclk_freq(sii, false, cc);
 	fpdelay = (((R_REG(sii->osh, &cc->pll_on_delay) + 2) * 1000000) +
 		   (slowminfreq - 1)) / slowminfreq;
 
@@ -1502,10 +1257,10 @@ uint16 BCMINITFN(si_clkctl_fast_pwrup_delay) (si_t * sih) {
 }
 
 /* turn primary xtal and/or pll off/on */
-int si_clkctl_xtal(si_t * sih, uint what, bool on)
+int si_clkctl_xtal(si_t *sih, uint what, bool on)
 {
 	si_info_t *sii;
-	uint32 in, out, outen;
+	u32 in, out, outen;
 
 	sii = SI_INFO(sih);
 
@@ -1513,7 +1268,7 @@ int si_clkctl_xtal(si_t * sih, uint what, bool on)
 
 #ifdef BCMSDIO
 	case SDIO_BUS:
-		return (-1);
+		return -1;
 #endif				/* BCMSDIO */
 
 	case PCI_BUS:
@@ -1521,12 +1276,12 @@ int si_clkctl_xtal(si_t * sih, uint what, bool on)
 		if (PCIE(sii))
 			return -1;
 
-		in = OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_IN, sizeof(uint32));
+		in = OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_IN, sizeof(u32));
 		out =
-		    OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_OUT, sizeof(uint32));
+		    OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_OUT, sizeof(u32));
 		outen =
 		    OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_OUTEN,
-					sizeof(uint32));
+					sizeof(u32));
 
 		/*
 		 * Avoid glitching the clock if GPRS is already using it.
@@ -1534,7 +1289,7 @@ int si_clkctl_xtal(si_t * sih, uint what, bool on)
 		 * by the value of XTAL_PU which *is* readable via gpioin.
 		 */
 		if (on && (in & PCI_CFG_GPIO_XTAL))
-			return (0);
+			return 0;
 
 		if (what & XTAL)
 			outen |= PCI_CFG_GPIO_XTAL;
@@ -1548,18 +1303,18 @@ int si_clkctl_xtal(si_t * sih, uint what, bool on)
 				if (what & PLL)
 					out |= PCI_CFG_GPIO_PLL;
 				OSL_PCI_WRITE_CONFIG(sii->osh, PCI_GPIO_OUT,
-						     sizeof(uint32), out);
+						     sizeof(u32), out);
 				OSL_PCI_WRITE_CONFIG(sii->osh, PCI_GPIO_OUTEN,
-						     sizeof(uint32), outen);
-				OSL_DELAY(XTAL_ON_DELAY);
+						     sizeof(u32), outen);
+				udelay(XTAL_ON_DELAY);
 			}
 
 			/* turn pll on */
 			if (what & PLL) {
 				out &= ~PCI_CFG_GPIO_PLL;
 				OSL_PCI_WRITE_CONFIG(sii->osh, PCI_GPIO_OUT,
-						     sizeof(uint32), out);
-				OSL_DELAY(2000);
+						     sizeof(u32), out);
+				mdelay(2);
 			}
 		} else {
 			if (what & XTAL)
@@ -1567,16 +1322,16 @@ int si_clkctl_xtal(si_t * sih, uint what, bool on)
 			if (what & PLL)
 				out |= PCI_CFG_GPIO_PLL;
 			OSL_PCI_WRITE_CONFIG(sii->osh, PCI_GPIO_OUT,
-					     sizeof(uint32), out);
+					     sizeof(u32), out);
 			OSL_PCI_WRITE_CONFIG(sii->osh, PCI_GPIO_OUTEN,
-					     sizeof(uint32), outen);
+					     sizeof(u32), outen);
 		}
 
 	default:
-		return (-1);
+		return -1;
 	}
 
-	return (0);
+	return 0;
 }
 
 /*
@@ -1587,7 +1342,7 @@ int si_clkctl_xtal(si_t * sih, uint what, bool on)
  *    this is a wrapper over the next internal function
  *      to allow flexible policy settings for outside caller
  */
-bool si_clkctl_cc(si_t * sih, uint mode)
+bool si_clkctl_cc(si_t *sih, uint mode)
 {
 	si_info_t *sii;
 
@@ -1595,26 +1350,26 @@ bool si_clkctl_cc(si_t * sih, uint mode)
 
 	/* chipcommon cores prior to rev6 don't support dynamic clock control */
 	if (sih->ccrev < 6)
-		return FALSE;
+		return false;
 
 	if (PCI_FORCEHT(sii))
-		return (mode == CLK_FAST);
+		return mode == CLK_FAST;
 
 	return _si_clkctl_cc(sii, mode);
 }
 
 /* clk control mechanism through chipcommon, no policy checking */
-static bool _si_clkctl_cc(si_info_t * sii, uint mode)
+static bool _si_clkctl_cc(si_info_t *sii, uint mode)
 {
 	uint origidx = 0;
 	chipcregs_t *cc;
-	uint32 scc;
+	u32 scc;
 	uint intr_val = 0;
 	bool fast = SI_FAST(sii);
 
 	/* chipcommon cores prior to rev6 don't support dynamic clock control */
 	if (sii->pub.ccrev < 6)
-		return (FALSE);
+		return false;
 
 	/* Chips with ccrev 10 are EOL and they don't have SYCC_HR which we use below */
 	ASSERT(sii->pub.ccrev != 10);
@@ -1629,8 +1384,11 @@ static bool _si_clkctl_cc(si_info_t * sii, uint mode)
 			goto done;
 
 		cc = (chipcregs_t *) si_setcore(&sii->pub, CC_CORE_ID, 0);
-	} else if ((cc = (chipcregs_t *) CCREGS_FAST(sii)) == NULL)
-		goto done;
+	} else {
+		cc = (chipcregs_t *) CCREGS_FAST(sii);
+		if (cc == NULL)
+			goto done;
+	}
 	ASSERT(cc != NULL);
 
 	if (!CCCTL_ENAB(&sii->pub) && (sii->pub.ccrev < 20))
@@ -1651,12 +1409,12 @@ static bool _si_clkctl_cc(si_info_t * sii, uint mode)
 
 		/* wait for the PLL */
 		if (PMUCTL_ENAB(&sii->pub)) {
-			uint32 htavail = CCS_HTAVAIL;
+			u32 htavail = CCS_HTAVAIL;
 			SPINWAIT(((R_REG(sii->osh, &cc->clk_ctl_st) & htavail)
 				  == 0), PMU_MAX_TRANSITION_DLY);
 			ASSERT(R_REG(sii->osh, &cc->clk_ctl_st) & htavail);
 		} else {
-			OSL_DELAY(PLL_DELAY);
+			udelay(PLL_DELAY);
 		}
 		break;
 
@@ -1688,11 +1446,12 @@ static bool _si_clkctl_cc(si_info_t * sii, uint mode)
 		si_setcoreidx(&sii->pub, origidx);
 		INTR_RESTORE(sii, intr_val);
 	}
-	return (mode == CLK_FAST);
+	return mode == CLK_FAST;
 }
 
 /* Build device path. Support SI, PCI, and JTAG for now. */
-int BCMATTACHFN(si_devpath) (si_t * sih, char *path, int size) {
+int si_devpath(si_t *sih, char *path, int size)
+{
 	int slen;
 
 	ASSERT(path != NULL);
@@ -1734,30 +1493,32 @@ int BCMATTACHFN(si_devpath) (si_t * sih, char *path, int size) {
 }
 
 /* Get a variable, but only if it has a devpath prefix */
-char *BCMATTACHFN(si_getdevpathvar) (si_t * sih, const char *name) {
+char *si_getdevpathvar(si_t *sih, const char *name)
+{
 	char varname[SI_DEVPATH_BUFSZ + 32];
 
 	si_devpathvar(sih, varname, sizeof(varname), name);
 
-	return (getvar(NULL, varname));
+	return getvar(NULL, varname);
 }
 
 /* Get a variable, but only if it has a devpath prefix */
-int BCMATTACHFN(si_getdevpathintvar) (si_t * sih, const char *name) {
+int si_getdevpathintvar(si_t *sih, const char *name)
+{
 #if defined(BCMBUSTYPE) && (BCMBUSTYPE == SI_BUS)
-	return (getintvar(NULL, name));
+	return getintvar(NULL, name);
 #else
 	char varname[SI_DEVPATH_BUFSZ + 32];
 
 	si_devpathvar(sih, varname, sizeof(varname), name);
 
-	return (getintvar(NULL, varname));
+	return getintvar(NULL, varname);
 #endif
 }
 
-char *si_getnvramflvar(si_t * sih, const char *name)
+char *si_getnvramflvar(si_t *sih, const char *name)
 {
-	return (getvar(NULL, name));
+	return getvar(NULL, name);
 }
 
 /* Concatenate the dev path with a varname into the given 'var' buffer
@@ -1765,8 +1526,8 @@ char *si_getnvramflvar(si_t * sih, const char *name)
  * Nothing is done to the arguments if len == 0 or var is NULL, var is still returned.
  * On overflow, the first char will be set to '\0'.
  */
-static char *BCMATTACHFN(si_devpathvar) (si_t * sih, char *var, int len,
-					 const char *name) {
+static char *si_devpathvar(si_t *sih, char *var, int len, const char *name)
+{
 	uint path_len;
 
 	if (!var || len <= 0)
@@ -1784,88 +1545,26 @@ static char *BCMATTACHFN(si_devpathvar) (si_t * sih, char *var, int len,
 	return var;
 }
 
-uint32 si_pciereg(si_t * sih, uint32 offset, uint32 mask, uint32 val, uint type)
-{
-	si_info_t *sii;
-
-	sii = SI_INFO(sih);
-
-	if (!PCIE(sii)) {
-		SI_ERROR(("%s: Not a PCIE device\n", __func__));
-		return 0;
-	}
-
-	return pcicore_pciereg(sii->pch, offset, mask, val, type);
-}
-
-uint32
-si_pcieserdesreg(si_t * sih, uint32 mdioslave, uint32 offset, uint32 mask,
-		 uint32 val)
+/* return true if PCIE capability exists in the pci config space */
+static __used bool si_ispcie(si_info_t *sii)
 {
-	si_info_t *sii;
-
-	sii = SI_INFO(sih);
-
-	if (!PCIE(sii)) {
-		SI_ERROR(("%s: Not a PCIE device\n", __func__));
-		return 0;
-	}
-
-	return pcicore_pcieserdesreg(sii->pch, mdioslave, offset, mask, val);
-
-}
-
-/* return TRUE if PCIE capability exists in the pci config space */
-static bool si_ispcie(si_info_t * sii)
-{
-	uint8 cap_ptr;
+	u8 cap_ptr;
 
 	if (BUSTYPE(sii->pub.bustype) != PCI_BUS)
-		return FALSE;
+		return false;
 
 	cap_ptr =
 	    pcicore_find_pci_capability(sii->osh, PCI_CAP_PCIECAP_ID, NULL,
 					NULL);
 	if (!cap_ptr)
-		return FALSE;
-
-	return TRUE;
-}
-
-/* Wake-on-wireless-LAN (WOWL) support functions */
-/* Enable PME generation and disable clkreq */
-void si_pci_pmeen(si_t * sih)
-{
-	si_info_t *sii;
-
-	sii = SI_INFO(sih);
-
-	pcicore_pmeen(sii->pch);
-}
-
-/* Return TRUE if PME status is set */
-bool si_pci_pmestat(si_t * sih)
-{
-	si_info_t *sii;
-
-	sii = SI_INFO(sih);
-
-	return pcicore_pmestat(sii->pch);
-}
-
-/* Disable PME generation, clear the PME status bit if set */
-void si_pci_pmeclr(si_t * sih)
-{
-	si_info_t *sii;
-
-	sii = SI_INFO(sih);
+		return false;
 
-	pcicore_pmeclr(sii->pch);
+	return true;
 }
 
 #ifdef BCMSDIO
 /* initialize the sdio core */
-void si_sdio_init(si_t * sih)
+void si_sdio_init(si_t *sih)
 {
 	si_info_t *sii = SI_INFO(sih);
 
@@ -1879,9 +1578,8 @@ void si_sdio_init(si_t * sih)
 		ASSERT(idx == si_findcoreidx(sih, D11_CORE_ID, 0));
 
 		/* switch to sdio core */
-		if (!
-		    (sdpregs =
-		     (sdpcmd_regs_t *) si_setcore(sih, PCMCIA_CORE_ID, 0)))
+		sdpregs = (sdpcmd_regs_t *) si_setcore(sih, PCMCIA_CORE_ID, 0);
+		if (!sdpregs)
 			sdpregs =
 			    (sdpcmd_regs_t *) si_setcore(sih, SDIOD_CORE_ID, 0);
 		ASSERT(sdpregs);
@@ -1903,46 +1601,21 @@ void si_sdio_init(si_t * sih)
 }
 #endif				/* BCMSDIO */
 
-bool BCMATTACHFN(si_pci_war16165) (si_t * sih) {
-	si_info_t *sii;
-
-	sii = SI_INFO(sih);
-
-	return (PCI(sii) && (sih->buscorerev <= 10));
-}
-
-/* Disable pcie_war_ovr for some platforms (sigh!)
- * This is for boards that have BFL2_PCIEWAR_OVR set
- * but are in systems that still want the benefits of ASPM
- * Note that this should be done AFTER si_doattach
- */
-void si_pcie_war_ovr_update(si_t * sih, uint8 aspm)
+bool si_pci_war16165(si_t *sih)
 {
 	si_info_t *sii;
 
 	sii = SI_INFO(sih);
 
-	if (!PCIE(sii))
-		return;
-
-	pcie_war_ovr_aspm_update(sii->pch, aspm);
+	return PCI(sii) && (sih->buscorerev <= 10);
 }
 
-/* back door for other module to override chippkg */
-void si_chippkg_set(si_t * sih, uint val)
+void si_pci_up(si_t *sih)
 {
 	si_info_t *sii;
 
 	sii = SI_INFO(sih);
 
-	sii->pub.chippkg = val;
-}
-
-void BCMINITFN(si_pci_up) (si_t * sih) {
-	si_info_t *sii;
-
-	sii = SI_INFO(sih);
-
 	/* if not pci bus, we're done */
 	if (BUSTYPE(sih->bustype) != PCI_BUS)
 		return;
@@ -1956,7 +1629,8 @@ void BCMINITFN(si_pci_up) (si_t * sih) {
 }
 
 /* Unconfigure and/or apply various WARs when system is going to sleep mode */
-void BCMUNINITFN(si_pci_sleep) (si_t * sih) {
+void si_pci_sleep(si_t *sih)
+{
 	si_info_t *sii;
 
 	sii = SI_INFO(sih);
@@ -1965,7 +1639,8 @@ void BCMUNINITFN(si_pci_sleep) (si_t * sih) {
 }
 
 /* Unconfigure and/or apply various WARs when going down */
-void BCMINITFN(si_pci_down) (si_t * sih) {
+void si_pci_down(si_t *sih)
+{
 	si_info_t *sii;
 
 	sii = SI_INFO(sih);
@@ -1985,10 +1660,11 @@ void BCMINITFN(si_pci_down) (si_t * sih) {
  * Configure the pci core for pci client (NIC) action
  * coremask is the bitvec of cores by index to be enabled.
  */
-void BCMATTACHFN(si_pci_setup) (si_t * sih, uint coremask) {
+void si_pci_setup(si_t *sih, uint coremask)
+{
 	si_info_t *sii;
-	sbpciregs_t *pciregs = NULL;
-	uint32 siflag = 0, w;
+	struct sbpciregs *pciregs = NULL;
+	u32 siflag = 0, w;
 	uint idx = 0;
 
 	sii = SI_INFO(sih);
@@ -2007,8 +1683,7 @@ void BCMATTACHFN(si_pci_setup) (si_t * sih, uint coremask) {
 		siflag = si_flag(sih);
 
 		/* switch over to pci core */
-		pciregs =
-		    (sbpciregs_t *) si_setcoreidx(sih, sii->pub.buscoreidx);
+		pciregs = (struct sbpciregs *)si_setcoreidx(sih, sii->pub.buscoreidx);
 	}
 
 	/*
@@ -2017,9 +1692,9 @@ void BCMATTACHFN(si_pci_setup) (si_t * sih, uint coremask) {
 	 */
 	if (PCIE(sii) || (PCI(sii) && ((sii->pub.buscorerev) >= 6))) {
 		/* pci config write to set this core bit in PCIIntMask */
-		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_INT_MASK, sizeof(uint32));
+		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_INT_MASK, sizeof(u32));
 		w |= (coremask << PCI_SBIM_SHIFT);
-		OSL_PCI_WRITE_CONFIG(sii->osh, PCI_INT_MASK, sizeof(uint32), w);
+		OSL_PCI_WRITE_CONFIG(sii->osh, PCI_INT_MASK, sizeof(u32), w);
 	} else {
 		/* set sbintvec bit for our flag number */
 		si_setint(sih, siflag);
@@ -2042,48 +1717,17 @@ void BCMATTACHFN(si_pci_setup) (si_t * sih, uint coremask) {
 	}
 }
 
-uint8 si_pcieclkreq(si_t * sih, uint32 mask, uint32 val)
-{
-	si_info_t *sii;
-
-	sii = SI_INFO(sih);
-
-	if (!(PCIE(sii)))
-		return 0;
-	return pcie_clkreq(sii->pch, mask, val);
-}
-
-uint32 si_pcielcreg(si_t * sih, uint32 mask, uint32 val)
-{
-	si_info_t *sii;
-
-	sii = SI_INFO(sih);
-
-	if (!PCIE(sii))
-		return 0;
-
-	return pcie_lcreg(sii->pch, mask, val);
-}
-
-/* indirect way to read pcie config regs */
-uint si_pcie_readreg(void *sih, uint addrtype, uint offset)
-{
-	return pcie_readreg(((si_info_t *) sih)->osh,
-			    (sbpcieregs_t *) PCIEREGS(((si_info_t *) sih)),
-			    addrtype, offset);
-}
-
 /*
  * Fixup SROMless PCI device's configuration.
  * The current core may be changed upon return.
  */
-int si_pci_fixcfg(si_t * sih)
+int si_pci_fixcfg(si_t *sih)
 {
 	uint origidx, pciidx;
-	sbpciregs_t *pciregs = NULL;
+	struct sbpciregs *pciregs = NULL;
 	sbpcieregs_t *pcieregs = NULL;
 	void *regs = NULL;
-	uint16 val16, *reg16 = NULL;
+	u16 val16, *reg16 = NULL;
 
 	si_info_t *sii = SI_INFO(sih);
 
@@ -2101,16 +1745,16 @@ int si_pci_fixcfg(si_t * sih)
 		ASSERT(pcieregs != NULL);
 		reg16 = &pcieregs->sprom[SRSH_PI_OFFSET];
 	} else if (sii->pub.buscoretype == PCI_CORE_ID) {
-		pciregs = (sbpciregs_t *) si_setcore(&sii->pub, PCI_CORE_ID, 0);
+		pciregs = (struct sbpciregs *)si_setcore(&sii->pub, PCI_CORE_ID, 0);
 		regs = pciregs;
 		ASSERT(pciregs != NULL);
 		reg16 = &pciregs->sprom[SRSH_PI_OFFSET];
 	}
 	pciidx = si_coreidx(&sii->pub);
 	val16 = R_REG(sii->osh, reg16);
-	if (((val16 & SRSH_PI_MASK) >> SRSH_PI_SHIFT) != (uint16) pciidx) {
+	if (((val16 & SRSH_PI_MASK) >> SRSH_PI_SHIFT) != (u16) pciidx) {
 		val16 =
-		    (uint16) (pciidx << SRSH_PI_SHIFT) | (val16 &
+		    (u16) (pciidx << SRSH_PI_SHIFT) | (val16 &
 							  ~SRSH_PI_MASK);
 		W_REG(sii->osh, reg16, val16);
 	}
@@ -2122,56 +1766,8 @@ int si_pci_fixcfg(si_t * sih)
 	return 0;
 }
 
-/* change logical "focus" to the gpio core for optimized access */
-void *si_gpiosetcore(si_t * sih)
-{
-	return (si_setcoreidx(sih, SI_CC_IDX));
-}
-
 /* mask&set gpiocontrol bits */
-uint32 si_gpiocontrol(si_t * sih, uint32 mask, uint32 val, uint8 priority)
-{
-	uint regoff;
-
-	regoff = 0;
-
-	/* gpios could be shared on router platforms
-	 * ignore reservation if it's high priority (e.g., test apps)
-	 */
-	if ((priority != GPIO_HI_PRIORITY) &&
-	    (BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
-		mask = priority ? (si_gpioreservation & mask) :
-		    ((si_gpioreservation | mask) & ~(si_gpioreservation));
-		val &= mask;
-	}
-
-	regoff = OFFSETOF(chipcregs_t, gpiocontrol);
-	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
-}
-
-/* mask&set gpio output enable bits */
-uint32 si_gpioouten(si_t * sih, uint32 mask, uint32 val, uint8 priority)
-{
-	uint regoff;
-
-	regoff = 0;
-
-	/* gpios could be shared on router platforms
-	 * ignore reservation if it's high priority (e.g., test apps)
-	 */
-	if ((priority != GPIO_HI_PRIORITY) &&
-	    (BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
-		mask = priority ? (si_gpioreservation & mask) :
-		    ((si_gpioreservation | mask) & ~(si_gpioreservation));
-		val &= mask;
-	}
-
-	regoff = OFFSETOF(chipcregs_t, gpioouten);
-	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
-}
-
-/* mask&set gpio output bits */
-uint32 si_gpioout(si_t * sih, uint32 mask, uint32 val, uint8 priority)
+u32 si_gpiocontrol(si_t *sih, u32 mask, u32 val, u8 priority)
 {
 	uint regoff;
 
@@ -2187,292 +1783,14 @@ uint32 si_gpioout(si_t * sih, uint32 mask, uint32 val, uint8 priority)
 		val &= mask;
 	}
 
-	regoff = OFFSETOF(chipcregs_t, gpioout);
-	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
-}
-
-/* reserve one gpio */
-uint32 si_gpioreserve(si_t * sih, uint32 gpio_bitmask, uint8 priority)
-{
-	si_info_t *sii;
-
-	sii = SI_INFO(sih);
-
-	/* only cores on SI_BUS share GPIO's and only applcation users need to
-	 * reserve/release GPIO
-	 */
-	if ((BUSTYPE(sih->bustype) != SI_BUS) || (!priority)) {
-		ASSERT((BUSTYPE(sih->bustype) == SI_BUS) && (priority));
-		return 0xffffffff;
-	}
-	/* make sure only one bit is set */
-	if ((!gpio_bitmask) || ((gpio_bitmask) & (gpio_bitmask - 1))) {
-		ASSERT((gpio_bitmask)
-		       && !((gpio_bitmask) & (gpio_bitmask - 1)));
-		return 0xffffffff;
-	}
-
-	/* already reserved */
-	if (si_gpioreservation & gpio_bitmask)
-		return 0xffffffff;
-	/* set reservation */
-	si_gpioreservation |= gpio_bitmask;
-
-	return si_gpioreservation;
-}
-
-/* release one gpio */
-/*
- * releasing the gpio doesn't change the current value on the GPIO last write value
- * persists till some one overwrites it
- */
-
-uint32 si_gpiorelease(si_t * sih, uint32 gpio_bitmask, uint8 priority)
-{
-	si_info_t *sii;
-
-	sii = SI_INFO(sih);
-
-	/* only cores on SI_BUS share GPIO's and only applcation users need to
-	 * reserve/release GPIO
-	 */
-	if ((BUSTYPE(sih->bustype) != SI_BUS) || (!priority)) {
-		ASSERT((BUSTYPE(sih->bustype) == SI_BUS) && (priority));
-		return 0xffffffff;
-	}
-	/* make sure only one bit is set */
-	if ((!gpio_bitmask) || ((gpio_bitmask) & (gpio_bitmask - 1))) {
-		ASSERT((gpio_bitmask)
-		       && !((gpio_bitmask) & (gpio_bitmask - 1)));
-		return 0xffffffff;
-	}
-
-	/* already released */
-	if (!(si_gpioreservation & gpio_bitmask))
-		return 0xffffffff;
-
-	/* clear reservation */
-	si_gpioreservation &= ~gpio_bitmask;
-
-	return si_gpioreservation;
-}
-
-/* return the current gpioin register value */
-uint32 si_gpioin(si_t * sih)
-{
-	si_info_t *sii;
-	uint regoff;
-
-	sii = SI_INFO(sih);
-	regoff = 0;
-
-	regoff = OFFSETOF(chipcregs_t, gpioin);
-	return (si_corereg(sih, SI_CC_IDX, regoff, 0, 0));
-}
-
-/* mask&set gpio interrupt polarity bits */
-uint32 si_gpiointpolarity(si_t * sih, uint32 mask, uint32 val, uint8 priority)
-{
-	si_info_t *sii;
-	uint regoff;
-
-	sii = SI_INFO(sih);
-	regoff = 0;
-
-	/* gpios could be shared on router platforms */
-	if ((BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
-		mask = priority ? (si_gpioreservation & mask) :
-		    ((si_gpioreservation | mask) & ~(si_gpioreservation));
-		val &= mask;
-	}
-
-	regoff = OFFSETOF(chipcregs_t, gpiointpolarity);
-	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
-}
-
-/* mask&set gpio interrupt mask bits */
-uint32 si_gpiointmask(si_t * sih, uint32 mask, uint32 val, uint8 priority)
-{
-	si_info_t *sii;
-	uint regoff;
-
-	sii = SI_INFO(sih);
-	regoff = 0;
-
-	/* gpios could be shared on router platforms */
-	if ((BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
-		mask = priority ? (si_gpioreservation & mask) :
-		    ((si_gpioreservation | mask) & ~(si_gpioreservation));
-		val &= mask;
-	}
-
-	regoff = OFFSETOF(chipcregs_t, gpiointmask);
-	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
-}
-
-/* assign the gpio to an led */
-uint32 si_gpioled(si_t * sih, uint32 mask, uint32 val)
-{
-	si_info_t *sii;
-
-	sii = SI_INFO(sih);
-	if (sih->ccrev < 16)
-		return 0xffffffff;
-
-	/* gpio led powersave reg */
-	return (si_corereg
-		(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gpiotimeroutmask), mask,
-		 val));
-}
-
-/* mask&set gpio timer val */
-uint32 si_gpiotimerval(si_t * sih, uint32 mask, uint32 gpiotimerval)
-{
-	si_info_t *sii;
-
-	sii = SI_INFO(sih);
-
-	if (sih->ccrev < 16)
-		return 0xffffffff;
-
-	return (si_corereg(sih, SI_CC_IDX,
-			   OFFSETOF(chipcregs_t, gpiotimerval), mask,
-			   gpiotimerval));
-}
-
-uint32 si_gpiopull(si_t * sih, bool updown, uint32 mask, uint32 val)
-{
-	si_info_t *sii;
-	uint offs;
-
-	sii = SI_INFO(sih);
-	if (sih->ccrev < 20)
-		return 0xffffffff;
-
-	offs =
-	    (updown ? OFFSETOF(chipcregs_t, gpiopulldown) :
-	     OFFSETOF(chipcregs_t, gpiopullup));
-	return (si_corereg(sih, SI_CC_IDX, offs, mask, val));
-}
-
-uint32 si_gpioevent(si_t * sih, uint regtype, uint32 mask, uint32 val)
-{
-	si_info_t *sii;
-	uint offs;
-
-	sii = SI_INFO(sih);
-	if (sih->ccrev < 11)
-		return 0xffffffff;
-
-	if (regtype == GPIO_REGEVT)
-		offs = OFFSETOF(chipcregs_t, gpioevent);
-	else if (regtype == GPIO_REGEVT_INTMSK)
-		offs = OFFSETOF(chipcregs_t, gpioeventintmask);
-	else if (regtype == GPIO_REGEVT_INTPOL)
-		offs = OFFSETOF(chipcregs_t, gpioeventintpolarity);
-	else
-		return 0xffffffff;
-
-	return (si_corereg(sih, SI_CC_IDX, offs, mask, val));
-}
-
-void *BCMATTACHFN(si_gpio_handler_register) (si_t * sih, uint32 event,
-					     bool level, gpio_handler_t cb,
-					     void *arg) {
-	si_info_t *sii;
-	gpioh_item_t *gi;
-
-	ASSERT(event);
-	ASSERT(cb != NULL);
-
-	sii = SI_INFO(sih);
-	if (sih->ccrev < 11)
-		return NULL;
-
-	if ((gi = MALLOC(sii->osh, sizeof(gpioh_item_t))) == NULL)
-		return NULL;
-
-	bzero(gi, sizeof(gpioh_item_t));
-	gi->event = event;
-	gi->handler = cb;
-	gi->arg = arg;
-	gi->level = level;
-
-	gi->next = sii->gpioh_head;
-	sii->gpioh_head = gi;
-
-	return (void *)(gi);
-}
-
-void BCMATTACHFN(si_gpio_handler_unregister) (si_t * sih, void *gpioh) {
-	si_info_t *sii;
-	gpioh_item_t *p, *n;
-
-	sii = SI_INFO(sih);
-	if (sih->ccrev < 11)
-		return;
-
-	ASSERT(sii->gpioh_head != NULL);
-	if ((void *)sii->gpioh_head == gpioh) {
-		sii->gpioh_head = sii->gpioh_head->next;
-		MFREE(sii->osh, gpioh, sizeof(gpioh_item_t));
-		return;
-	} else {
-		p = sii->gpioh_head;
-		n = p->next;
-		while (n) {
-			if ((void *)n == gpioh) {
-				p->next = n->next;
-				MFREE(sii->osh, gpioh, sizeof(gpioh_item_t));
-				return;
-			}
-			p = n;
-			n = n->next;
-		}
-	}
-
-	ASSERT(0);		/* Not found in list */
-}
-
-void si_gpio_handler_process(si_t * sih)
-{
-	si_info_t *sii;
-	gpioh_item_t *h;
-	uint32 status;
-	uint32 level = si_gpioin(sih);
-	uint32 edge = si_gpioevent(sih, GPIO_REGEVT, 0, 0);
-
-	sii = SI_INFO(sih);
-	for (h = sii->gpioh_head; h != NULL; h = h->next) {
-		if (h->handler) {
-			status = (h->level ? level : edge);
-
-			if (status & h->event)
-				h->handler(status, h->arg);
-		}
-	}
-
-	si_gpioevent(sih, GPIO_REGEVT, edge, edge);	/* clear edge-trigger status */
-}
-
-uint32 si_gpio_int_enable(si_t * sih, bool enable)
-{
-	si_info_t *sii;
-	uint offs;
-
-	sii = SI_INFO(sih);
-	if (sih->ccrev < 11)
-		return 0xffffffff;
-
-	offs = OFFSETOF(chipcregs_t, intmask);
-	return (si_corereg
-		(sih, SI_CC_IDX, offs, CI_GPIO, (enable ? CI_GPIO : 0)));
+	regoff = offsetof(chipcregs_t, gpiocontrol);
+	return si_corereg(sih, SI_CC_IDX, regoff, mask, val);
 }
 
 /* Return the size of the specified SOCRAM bank */
 static uint
-socram_banksize(si_info_t * sii, sbsocramregs_t * regs, uint8 index,
-		uint8 mem_type)
+socram_banksize(si_info_t *sii, sbsocramregs_t *regs, u8 index,
+		u8 mem_type)
 {
 	uint banksize, bankinfo;
 	uint bankidx = index | (mem_type << SOCRAM_BANKIDX_MEMTYPE_SHIFT);
@@ -2486,141 +1804,8 @@ socram_banksize(si_info_t * sii, sbsocramregs_t * regs, uint8 index,
 	return banksize;
 }
 
-void si_socdevram(si_t * sih, bool set, uint8 * enable, uint8 * protect)
-{
-	si_info_t *sii;
-	uint origidx;
-	uint intr_val = 0;
-	sbsocramregs_t *regs;
-	bool wasup;
-	uint corerev;
-
-	sii = SI_INFO(sih);
-
-	/* Block ints and save current core */
-	INTR_OFF(sii, intr_val);
-	origidx = si_coreidx(sih);
-
-	if (!set)
-		*enable = *protect = 0;
-
-	/* Switch to SOCRAM core */
-	if (!(regs = si_setcore(sih, SOCRAM_CORE_ID, 0)))
-		goto done;
-
-	/* Get info for determining size */
-	if (!(wasup = si_iscoreup(sih)))
-		si_core_reset(sih, 0, 0);
-
-	corerev = si_corerev(sih);
-	if (corerev >= 10) {
-		uint32 extcinfo;
-		uint8 nb;
-		uint8 i;
-		uint32 bankidx, bankinfo;
-
-		extcinfo = R_REG(sii->osh, &regs->extracoreinfo);
-		nb = ((extcinfo & SOCRAM_DEVRAMBANK_MASK) >>
-		      SOCRAM_DEVRAMBANK_SHIFT);
-		for (i = 0; i < nb; i++) {
-			bankidx =
-			    i | (SOCRAM_MEMTYPE_DEVRAM <<
-				 SOCRAM_BANKIDX_MEMTYPE_SHIFT);
-			W_REG(sii->osh, &regs->bankidx, bankidx);
-			bankinfo = R_REG(sii->osh, &regs->bankinfo);
-			if (set) {
-				bankinfo &= ~SOCRAM_BANKINFO_DEVRAMSEL_MASK;
-				bankinfo &= ~SOCRAM_BANKINFO_DEVRAMPRO_MASK;
-				if (*enable) {
-					bankinfo |=
-					    (1 <<
-					     SOCRAM_BANKINFO_DEVRAMSEL_SHIFT);
-					if (*protect)
-						bankinfo |=
-						    (1 <<
-						     SOCRAM_BANKINFO_DEVRAMPRO_SHIFT);
-				}
-				W_REG(sii->osh, &regs->bankinfo, bankinfo);
-			} else if (i == 0) {
-				if (bankinfo & SOCRAM_BANKINFO_DEVRAMSEL_MASK) {
-					*enable = 1;
-					if (bankinfo &
-					    SOCRAM_BANKINFO_DEVRAMPRO_MASK)
-						*protect = 1;
-				}
-			}
-		}
-	}
-
-	/* Return to previous state and core */
-	if (!wasup)
-		si_core_disable(sih, 0);
-	si_setcoreidx(sih, origidx);
-
- done:
-	INTR_RESTORE(sii, intr_val);
-}
-
-bool si_socdevram_pkg(si_t * sih)
-{
-	if (si_socdevram_size(sih) > 0)
-		return TRUE;
-	else
-		return FALSE;
-}
-
-uint32 si_socdevram_size(si_t * sih)
-{
-	si_info_t *sii;
-	uint origidx;
-	uint intr_val = 0;
-	uint32 memsize = 0;
-	sbsocramregs_t *regs;
-	bool wasup;
-	uint corerev;
-
-	sii = SI_INFO(sih);
-
-	/* Block ints and save current core */
-	INTR_OFF(sii, intr_val);
-	origidx = si_coreidx(sih);
-
-	/* Switch to SOCRAM core */
-	if (!(regs = si_setcore(sih, SOCRAM_CORE_ID, 0)))
-		goto done;
-
-	/* Get info for determining size */
-	if (!(wasup = si_iscoreup(sih)))
-		si_core_reset(sih, 0, 0);
-
-	corerev = si_corerev(sih);
-	if (corerev >= 10) {
-		uint32 extcinfo;
-		uint8 nb;
-		uint8 i;
-
-		extcinfo = R_REG(sii->osh, &regs->extracoreinfo);
-		nb = (((extcinfo & SOCRAM_DEVRAMBANK_MASK) >>
-		       SOCRAM_DEVRAMBANK_SHIFT));
-		for (i = 0; i < nb; i++)
-			memsize +=
-			    socram_banksize(sii, regs, i,
-					    SOCRAM_MEMTYPE_DEVRAM);
-	}
-
-	/* Return to previous state and core */
-	if (!wasup)
-		si_core_disable(sih, 0);
-	si_setcoreidx(sih, origidx);
-
- done:
-	INTR_RESTORE(sii, intr_val);
-
-	return memsize;
-}
-
 /* Return the RAM size of the SOCRAM core */
-uint32 si_socram_size(si_t * sih)
+u32 si_socram_size(si_t *sih)
 {
 	si_info_t *sii;
 	uint origidx;
@@ -2629,7 +1814,7 @@ uint32 si_socram_size(si_t * sih)
 	sbsocramregs_t *regs;
 	bool wasup;
 	uint corerev;
-	uint32 coreinfo;
+	u32 coreinfo;
 	uint memsize = 0;
 
 	sii = SI_INFO(sih);
@@ -2639,11 +1824,13 @@ uint32 si_socram_size(si_t * sih)
 	origidx = si_coreidx(sih);
 
 	/* Switch to SOCRAM core */
-	if (!(regs = si_setcore(sih, SOCRAM_CORE_ID, 0)))
+	regs = si_setcore(sih, SOCRAM_CORE_ID, 0);
+	if (!regs)
 		goto done;
 
 	/* Get info for determining size */
-	if (!(wasup = si_iscoreup(sih)))
+	wasup = si_iscoreup(sih);
+	if (!wasup)
 		si_core_reset(sih, 0, 0);
 	corerev = si_corerev(sih);
 	coreinfo = R_REG(sii->osh, &regs->coreinfo);
@@ -2664,7 +1851,7 @@ uint32 si_socram_size(si_t * sih)
 		if (lss != 0)
 			memsize += (1 << ((lss - 1) + SR_BSZ_BASE));
 	} else {
-		uint8 i;
+		u8 i;
 		uint nb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;
 		for (i = 0; i < nb; i++)
 			memsize +=
@@ -2682,12 +1869,12 @@ uint32 si_socram_size(si_t * sih)
 	return memsize;
 }
 
-void si_chipcontrl_epa4331(si_t * sih, bool on)
+void si_chipcontrl_epa4331(si_t *sih, bool on)
 {
 	si_info_t *sii;
 	chipcregs_t *cc;
 	uint origidx;
-	uint32 val;
+	u32 val;
 
 	sii = SI_INFO(sih);
 	origidx = si_coreidx(sih);
@@ -2716,7 +1903,7 @@ void si_chipcontrl_epa4331(si_t * sih, bool on)
 }
 
 /* Enable BT-COEX & Ex-PA for 4313 */
-void si_epa_4313war(si_t * sih)
+void si_epa_4313war(si_t *sih)
 {
 	si_info_t *sii;
 	chipcregs_t *cc;
@@ -2735,9 +1922,9 @@ void si_epa_4313war(si_t * sih)
 }
 
 /* check if the device is removed */
-bool si_deviceremoved(si_t * sih)
+bool si_deviceremoved(si_t *sih)
 {
-	uint32 w;
+	u32 w;
 	si_info_t *sii;
 
 	sii = SI_INFO(sih);
@@ -2745,31 +1932,31 @@ bool si_deviceremoved(si_t * sih)
 	switch (BUSTYPE(sih->bustype)) {
 	case PCI_BUS:
 		ASSERT(sii->osh != NULL);
-		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_CFG_VID, sizeof(uint32));
+		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_CFG_VID, sizeof(u32));
 		if ((w & 0xFFFF) != VENDOR_BROADCOM)
-			return TRUE;
+			return true;
 		break;
 	}
-	return FALSE;
+	return false;
 }
 
-bool si_is_sprom_available(si_t * sih)
+bool si_is_sprom_available(si_t *sih)
 {
 	if (sih->ccrev >= 31) {
 		si_info_t *sii;
 		uint origidx;
 		chipcregs_t *cc;
-		uint32 sromctrl;
+		u32 sromctrl;
 
 		if ((sih->cccaps & CC_CAP_SROM) == 0)
-			return FALSE;
+			return false;
 
 		sii = SI_INFO(sih);
 		origidx = sii->curidx;
 		cc = si_setcoreidx(sih, SI_CC_IDX);
 		sromctrl = R_REG(sii->osh, &cc->sromcontrol);
 		si_setcoreidx(sih, origidx);
-		return (sromctrl & SRC_PRESENT);
+		return sromctrl & SRC_PRESENT;
 	}
 
 	switch (CHIPID(sih->chip)) {
@@ -2786,11 +1973,11 @@ bool si_is_sprom_available(si_t * sih)
 	case BCM4331_CHIP_ID:
 		return (sih->chipst & CST4331_SPROM_PRESENT) != 0;
 	default:
-		return TRUE;
+		return true;
 	}
 }
 
-bool si_is_otp_disabled(si_t * sih)
+bool si_is_otp_disabled(si_t *sih)
 {
 	switch (CHIPID(sih->chip)) {
 	case BCM4329_CHIP_ID:
@@ -2800,9 +1987,9 @@ bool si_is_otp_disabled(si_t * sih)
 		return (sih->chipst & CST4319_SPROM_OTP_SEL_MASK) ==
 		    CST4319_OTP_PWRDN;
 	case BCM4336_CHIP_ID:
-		return ((sih->chipst & CST4336_OTP_PRESENT) == 0);
+		return (sih->chipst & CST4336_OTP_PRESENT) == 0;
 	case BCM4330_CHIP_ID:
-		return ((sih->chipst & CST4330_OTP_PRESENT) == 0);
+		return (sih->chipst & CST4330_OTP_PRESENT) == 0;
 	case BCM4313_CHIP_ID:
 		return (sih->chipst & CST4313_OTP_PRESENT) == 0;
 		/* These chips always have their OTP on */
@@ -2814,101 +2001,21 @@ bool si_is_otp_disabled(si_t * sih)
 	case BCM43238_CHIP_ID:
 	case BCM4331_CHIP_ID:
 	default:
-		return FALSE;
+		return false;
 	}
 }
 
-bool si_is_otp_powered(si_t * sih)
+bool si_is_otp_powered(si_t *sih)
 {
 	if (PMUCTL_ENAB(sih))
 		return si_pmu_is_otp_powered(sih, si_osh(sih));
-	return TRUE;
+	return true;
 }
 
-void si_otp_power(si_t * sih, bool on)
+void si_otp_power(si_t *sih, bool on)
 {
 	if (PMUCTL_ENAB(sih))
 		si_pmu_otp_power(sih, si_osh(sih), on);
-	OSL_DELAY(1000);
-}
-
-bool
-#if defined(BCMDBG)
-si_is_sprom_enabled(si_t * sih)
-#else
-BCMATTACHFN(si_is_sprom_enabled) (si_t * sih)
-#endif
-{
-
-	return TRUE;
+	udelay(1000);
 }
 
-void
-#if defined(BCMDBG)
-si_sprom_enable(si_t * sih, bool enable)
-#else
-BCMATTACHFN(si_sprom_enable) (si_t * sih, bool enable)
-#endif
-{
-	if (PMUCTL_ENAB(sih))
-		si_pmu_sprom_enable(sih, si_osh(sih), enable);
-}
-
-/* Return BCME_NOTFOUND if the card doesn't have CIS format nvram */
-int si_cis_source(si_t * sih)
-{
-	/* Many chips have the same mapping of their chipstatus field */
-	static const uint cis_sel[] =
-	    { CIS_DEFAULT, CIS_SROM, CIS_OTP, CIS_SROM };
-	static const uint cis_43236_sel[] =
-	    { CIS_DEFAULT, CIS_SROM, CIS_OTP, CIS_OTP };
-
-	/* PCI chips use SROM format instead of CIS */
-	if (BUSTYPE(sih->bustype) == PCI_BUS)
-		return BCME_NOTFOUND;
-
-	switch (CHIPID(sih->chip)) {
-	case BCM43235_CHIP_ID:
-	case BCM43236_CHIP_ID:
-	case BCM43238_CHIP_ID:{
-			uint8 strap =
-			    (sih->
-			     chipst & CST4322_SPROM_OTP_SEL_MASK) >>
-			    CST4322_SPROM_OTP_SEL_SHIFT;
-			return ((strap >=
-				 sizeof(cis_sel)) ? CIS_DEFAULT :
-				cis_43236_sel[strap]);
-		}
-
-	case BCM4329_CHIP_ID:
-		return ((sih->chipst & CST4329_SPROM_OTP_SEL_MASK) >=
-			sizeof(cis_sel)) ? CIS_DEFAULT : cis_sel[(sih->
-								  chipst &
-								  CST4329_SPROM_OTP_SEL_MASK)];
-	case BCM4319_CHIP_ID:{
-			uint cis_sel4319 =
-			    ((sih->
-			      chipst & CST4319_SPROM_OTP_SEL_MASK) >>
-			     CST4319_SPROM_OTP_SEL_SHIFT);
-			return (cis_sel4319 >=
-				sizeof(cis_sel)) ? CIS_DEFAULT :
-			    cis_sel[cis_sel4319];
-		}
-	case BCM4336_CHIP_ID:{
-			if (sih->chipst & CST4336_SPROM_PRESENT)
-				return CIS_SROM;
-			if (sih->chipst & CST4336_OTP_PRESENT)
-				return CIS_OTP;
-			return CIS_DEFAULT;
-		}
-	case BCM4330_CHIP_ID:{
-			if (sih->chipst & CST4330_SPROM_PRESENT)
-				return CIS_SROM;
-			if (sih->chipst & CST4330_OTP_PRESENT)
-				return CIS_OTP;
-			return CIS_DEFAULT;
-		}
-	default:
-		return CIS_DEFAULT;
-	}
-}
diff --git a/drivers/staging/brcm80211/util/siutils_priv.h b/drivers/staging/brcm80211/util/siutils_priv.h
index b0c7803..0284614 100644
--- a/drivers/staging/brcm80211/util/siutils_priv.h
+++ b/drivers/staging/brcm80211/util/siutils_priv.h
@@ -18,15 +18,15 @@
 #define	_siutils_priv_h_
 
 /* Silicon Backplane externs */
-extern void sb_scan(si_t * sih, void *regs, uint devid);
-uint sb_coreid(si_t * sih);
-uint sb_corerev(si_t * sih);
-extern uint sb_corereg(si_t * sih, uint coreidx, uint regoff, uint mask,
+extern void sb_scan(si_t *sih, void *regs, uint devid);
+uint sb_coreid(si_t *sih);
+uint sb_corerev(si_t *sih);
+extern uint sb_corereg(si_t *sih, uint coreidx, uint regoff, uint mask,
 		       uint val);
-extern bool sb_iscoreup(si_t * sih);
-void *sb_setcoreidx(si_t * sih, uint coreidx);
-extern uint32 sb_base(uint32 admatch);
-extern void sb_core_reset(si_t * sih, uint32 bits, uint32 resetbits);
-extern void sb_core_disable(si_t * sih, uint32 bits);
-extern bool sb_taclear(si_t * sih, bool details);
+extern bool sb_iscoreup(si_t *sih);
+void *sb_setcoreidx(si_t *sih, uint coreidx);
+extern u32 sb_base(u32 admatch);
+extern void sb_core_reset(si_t *sih, u32 bits, u32 resetbits);
+extern void sb_core_disable(si_t *sih, u32 bits);
+extern bool sb_taclear(si_t *sih, bool details);
 #endif				/* _siutils_priv_h_ */
