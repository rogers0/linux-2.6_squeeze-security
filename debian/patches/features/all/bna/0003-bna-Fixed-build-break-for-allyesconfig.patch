From: Rasesh Mody <rmody@brocade.com>
Date: Wed, 25 Aug 2010 23:00:27 -0700
Subject: [PATCH 03/23] bna: Fixed build break for allyesconfig

commit 8a891429d1879ae4f37f547ef5c2d68e19277e4a upstream.

This is the patch to fix the build break caused by multiple
definitions of symbols between Brocade's FC/FCOE driver(BFA)
and 10G Networking Driver(BNA).

Changes are:

1. locally used functions are made static

2. unused functions are removed

3. using unique namespaces for the function names that must be
globally visible

Signed-off-by: Debashis Dutt <ddutt@brocade.com>
Signed-off-by: Rasesh Mody <rmody@brocade.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
---
 drivers/net/bna/bfa_cee.c      |  136 ++--------------------
 drivers/net/bna/bfa_cee.h      |   14 +--
 drivers/net/bna/bfa_ioc.c      |  249 ++++++++++++----------------------------
 drivers/net/bna/bfa_ioc.h      |   96 +++++-----------
 drivers/net/bna/bfa_ioc_ct.c   |   49 ++++----
 drivers/net/bna/bna_ctrl.c     |   38 +++---
 drivers/net/bna/bnad.c         |    9 +-
 drivers/net/bna/bnad_ethtool.c |    2 +-
 8 files changed, 162 insertions(+), 431 deletions(-)

diff --git a/drivers/net/bna/bfa_cee.c b/drivers/net/bna/bfa_cee.c
index 1545fc9..f7b789a 100644
--- a/drivers/net/bna/bfa_cee.c
+++ b/drivers/net/bna/bfa_cee.c
@@ -152,7 +152,7 @@ bfa_cee_reset_stats_isr(struct bfa_cee *cee, enum bfa_status status)
 		cee->cbfn.reset_stats_cbfn(cee->cbfn.reset_stats_cbarg, status);
 }
 /**
- * bfa_cee_meminfo()
+ * bfa_nw_cee_meminfo()
  *
  * @brief Returns the size of the DMA memory needed by CEE module
  *
@@ -161,13 +161,13 @@ bfa_cee_reset_stats_isr(struct bfa_cee *cee, enum bfa_status status)
  * @return Size of DMA region
  */
 u32
-bfa_cee_meminfo(void)
+bfa_nw_cee_meminfo(void)
 {
 	return bfa_cee_attr_meminfo() + bfa_cee_stats_meminfo();
 }
 
 /**
- * bfa_cee_mem_claim()
+ * bfa_nw_cee_mem_claim()
  *
  * @brief Initialized CEE DMA Memory
  *
@@ -178,7 +178,7 @@ bfa_cee_meminfo(void)
  * @return void
  */
 void
-bfa_cee_mem_claim(struct bfa_cee *cee, u8 *dma_kva, u64 dma_pa)
+bfa_nw_cee_mem_claim(struct bfa_cee *cee, u8 *dma_kva, u64 dma_pa)
 {
 	cee->attr_dma.kva = dma_kva;
 	cee->attr_dma.pa = dma_pa;
@@ -190,108 +190,6 @@ bfa_cee_mem_claim(struct bfa_cee *cee, u8 *dma_kva, u64 dma_pa)
 }
 
 /**
- * bfa_cee_get_attr()
- *
- * @brief
- *   Send the request to the f/w to fetch CEE attributes.
- *
- * @param[in] Pointer to the CEE module data structure.
- *
- * @return Status
- */
-
-enum bfa_status
-bfa_cee_get_attr(struct bfa_cee *cee, struct bfa_cee_attr *attr,
-		     bfa_cee_get_attr_cbfn_t cbfn, void *cbarg)
-{
-	struct bfi_cee_get_req *cmd;
-
-	BUG_ON(!((cee != NULL) && (cee->ioc != NULL)));
-	if (!bfa_ioc_is_operational(cee->ioc))
-		return BFA_STATUS_IOC_FAILURE;
-	if (cee->get_attr_pending == true)
-		return 	BFA_STATUS_DEVBUSY;
-	cee->get_attr_pending = true;
-	cmd = (struct bfi_cee_get_req *) cee->get_cfg_mb.msg;
-	cee->attr = attr;
-	cee->cbfn.get_attr_cbfn = cbfn;
-	cee->cbfn.get_attr_cbarg = cbarg;
-	bfi_h2i_set(cmd->mh, BFI_MC_CEE, BFI_CEE_H2I_GET_CFG_REQ,
-	    bfa_ioc_portid(cee->ioc));
-	bfa_dma_be_addr_set(cmd->dma_addr, cee->attr_dma.pa);
-	bfa_ioc_mbox_queue(cee->ioc, &cee->get_cfg_mb);
-
-	return BFA_STATUS_OK;
-}
-
-/**
- * bfa_cee_get_stats()
- *
- * @brief
- *   Send the request to the f/w to fetch CEE statistics.
- *
- * @param[in] Pointer to the CEE module data structure.
- *
- * @return Status
- */
-
-enum bfa_status
-bfa_cee_get_stats(struct bfa_cee *cee, struct bfa_cee_stats *stats,
-		      bfa_cee_get_stats_cbfn_t cbfn, void *cbarg)
-{
-	struct bfi_cee_get_req *cmd;
-
-	BUG_ON(!((cee != NULL) && (cee->ioc != NULL)));
-
-	if (!bfa_ioc_is_operational(cee->ioc))
-		return BFA_STATUS_IOC_FAILURE;
-	if (cee->get_stats_pending == true)
-		return 	BFA_STATUS_DEVBUSY;
-	cee->get_stats_pending = true;
-	cmd = (struct bfi_cee_get_req *) cee->get_stats_mb.msg;
-	cee->stats = stats;
-	cee->cbfn.get_stats_cbfn = cbfn;
-	cee->cbfn.get_stats_cbarg = cbarg;
-	bfi_h2i_set(cmd->mh, BFI_MC_CEE, BFI_CEE_H2I_GET_STATS_REQ,
-	    bfa_ioc_portid(cee->ioc));
-	bfa_dma_be_addr_set(cmd->dma_addr, cee->stats_dma.pa);
-	bfa_ioc_mbox_queue(cee->ioc, &cee->get_stats_mb);
-
-	return BFA_STATUS_OK;
-}
-
-/**
- * bfa_cee_reset_stats()
- *
- * @brief Clears CEE Stats in the f/w.
- *
- * @param[in] Pointer to the CEE module data structure.
- *
- * @return Status
- */
-
-enum bfa_status
-bfa_cee_reset_stats(struct bfa_cee *cee, bfa_cee_reset_stats_cbfn_t cbfn,
-			void *cbarg)
-{
-	struct bfi_cee_reset_stats *cmd;
-
-	BUG_ON(!((cee != NULL) && (cee->ioc != NULL)));
-	if (!bfa_ioc_is_operational(cee->ioc))
-		return BFA_STATUS_IOC_FAILURE;
-	if (cee->reset_stats_pending == true)
-		return 	BFA_STATUS_DEVBUSY;
-	cee->reset_stats_pending = true;
-	cmd = (struct bfi_cee_reset_stats *) cee->reset_stats_mb.msg;
-	cee->cbfn.reset_stats_cbfn = cbfn;
-	cee->cbfn.reset_stats_cbarg = cbarg;
-	bfi_h2i_set(cmd->mh, BFI_MC_CEE, BFI_CEE_H2I_RESET_STATS,
-	    bfa_ioc_portid(cee->ioc));
-	bfa_ioc_mbox_queue(cee->ioc, &cee->reset_stats_mb);
-	return BFA_STATUS_OK;
-}
-
-/**
  * bfa_cee_isrs()
  *
  * @brief Handles Mail-box interrupts for CEE module.
@@ -301,7 +199,7 @@ bfa_cee_reset_stats(struct bfa_cee *cee, bfa_cee_reset_stats_cbfn_t cbfn,
  * @return void
  */
 
-void
+static void
 bfa_cee_isr(void *cbarg, struct bfi_mbmsg *m)
 {
 	union bfi_cee_i2h_msg_u *msg;
@@ -334,7 +232,7 @@ bfa_cee_isr(void *cbarg, struct bfi_mbmsg *m)
  * @return void
  */
 
-void
+static void
 bfa_cee_hbfail(void *arg)
 {
 	struct bfa_cee *cee;
@@ -367,7 +265,7 @@ bfa_cee_hbfail(void *arg)
 }
 
 /**
- * bfa_cee_attach()
+ * bfa_nw_cee_attach()
  *
  * @brief CEE module-attach API
  *
@@ -380,28 +278,14 @@ bfa_cee_hbfail(void *arg)
  * @return void
  */
 void
-bfa_cee_attach(struct bfa_cee *cee, struct bfa_ioc *ioc,
+bfa_nw_cee_attach(struct bfa_cee *cee, struct bfa_ioc *ioc,
 		void *dev)
 {
 	BUG_ON(!(cee != NULL));
 	cee->dev = dev;
 	cee->ioc = ioc;
 
-	bfa_ioc_mbox_regisr(cee->ioc, BFI_MC_CEE, bfa_cee_isr, cee);
+	bfa_nw_ioc_mbox_regisr(cee->ioc, BFI_MC_CEE, bfa_cee_isr, cee);
 	bfa_ioc_hbfail_init(&cee->hbfail, bfa_cee_hbfail, cee);
-	bfa_ioc_hbfail_register(cee->ioc, &cee->hbfail);
-}
-
-/**
- * bfa_cee_detach()
- *
- * @brief CEE module-detach API
- *
- * @param[in] cee - Pointer to the CEE module data structure
- *
- * @return void
- */
-void
-bfa_cee_detach(struct bfa_cee *cee)
-{
+	bfa_nw_ioc_hbfail_register(cee->ioc, &cee->hbfail);
 }
diff --git a/drivers/net/bna/bfa_cee.h b/drivers/net/bna/bfa_cee.h
index 1208cad..20543d1 100644
--- a/drivers/net/bna/bfa_cee.h
+++ b/drivers/net/bna/bfa_cee.h
@@ -56,17 +56,9 @@ struct bfa_cee {
 	struct bfa_mbox_cmd reset_stats_mb;
 };
 
-u32 bfa_cee_meminfo(void);
-void bfa_cee_mem_claim(struct bfa_cee *cee, u8 *dma_kva,
+u32 bfa_nw_cee_meminfo(void);
+void bfa_nw_cee_mem_claim(struct bfa_cee *cee, u8 *dma_kva,
 	u64 dma_pa);
-void bfa_cee_attach(struct bfa_cee *cee, struct bfa_ioc *ioc, void *dev);
-void bfa_cee_detach(struct bfa_cee *cee);
-enum bfa_status bfa_cee_get_attr(struct bfa_cee *cee,
-	struct bfa_cee_attr *attr, bfa_cee_get_attr_cbfn_t cbfn, void *cbarg);
-enum bfa_status bfa_cee_get_stats(struct bfa_cee *cee,
-	struct bfa_cee_stats *stats, bfa_cee_get_stats_cbfn_t cbfn,
-	void *cbarg);
-enum bfa_status bfa_cee_reset_stats(struct bfa_cee *cee,
-	bfa_cee_reset_stats_cbfn_t cbfn, void *cbarg);
+void bfa_nw_cee_attach(struct bfa_cee *cee, struct bfa_ioc *ioc, void *dev);
 
 #endif /* __BFA_CEE_H__ */
diff --git a/drivers/net/bna/bfa_ioc.c b/drivers/net/bna/bfa_ioc.c
index cdc2cb1..caa45c2 100644
--- a/drivers/net/bna/bfa_ioc.c
+++ b/drivers/net/bna/bfa_ioc.c
@@ -65,7 +65,7 @@
 			(!list_empty(&((__ioc)->mbox_mod.cmd_q)) || \
 			readl((__ioc)->ioc_regs.hfn_mbox_cmd))
 
-bool bfa_auto_recover = true;
+bool bfa_nw_auto_recover = true;
 
 /*
  * forward declarations
@@ -85,6 +85,23 @@ static void bfa_ioc_recover(struct bfa_ioc *ioc);
 static void bfa_ioc_check_attr_wwns(struct bfa_ioc *ioc);
 static void bfa_ioc_disable_comp(struct bfa_ioc *ioc);
 static void bfa_ioc_lpu_stop(struct bfa_ioc *ioc);
+static void bfa_ioc_boot(struct bfa_ioc *ioc, u32 boot_type,
+			 u32 boot_param);
+static u32 bfa_ioc_smem_pgnum(struct bfa_ioc *ioc, u32 fmaddr);
+static u32 bfa_ioc_smem_pgoff(struct bfa_ioc *ioc, u32 fmaddr);
+static void bfa_ioc_get_adapter_serial_num(struct bfa_ioc *ioc,
+						char *serial_num);
+static void bfa_ioc_get_adapter_fw_ver(struct bfa_ioc *ioc,
+						char *fw_ver);
+static void bfa_ioc_get_pci_chip_rev(struct bfa_ioc *ioc,
+						char *chip_rev);
+static void bfa_ioc_get_adapter_optrom_ver(struct bfa_ioc *ioc,
+						char *optrom_ver);
+static void bfa_ioc_get_adapter_manufacturer(struct bfa_ioc *ioc,
+						char *manufacturer);
+static void bfa_ioc_get_adapter_model(struct bfa_ioc *ioc, char *model);
+static u64 bfa_ioc_get_pwwn(struct bfa_ioc *ioc);
+static mac_t bfa_ioc_get_mfg_mac(struct bfa_ioc *ioc);
 
 /**
  * IOC state machine events
@@ -138,7 +155,7 @@ static void
 bfa_ioc_sm_reset_entry(struct bfa_ioc *ioc)
 {
 	ioc->retry_count = 0;
-	ioc->auto_recover = bfa_auto_recover;
+	ioc->auto_recover = bfa_nw_auto_recover;
 }
 
 /**
@@ -185,7 +202,7 @@ bfa_ioc_sm_fwcheck(struct bfa_ioc *ioc, enum ioc_event event)
 			ioc->retry_count = 0;
 			bfa_fsm_set_state(ioc, bfa_ioc_sm_hwinit);
 		} else {
-			bfa_ioc_hw_sem_release(ioc);
+			bfa_nw_ioc_hw_sem_release(ioc);
 			bfa_fsm_set_state(ioc, bfa_ioc_sm_mismatch);
 		}
 		break;
@@ -314,12 +331,12 @@ bfa_ioc_sm_hwinit(struct bfa_ioc *ioc, enum ioc_event event)
 			break;
 		}
 
-		bfa_ioc_hw_sem_release(ioc);
+		bfa_nw_ioc_hw_sem_release(ioc);
 		bfa_fsm_set_state(ioc, bfa_ioc_sm_initfail);
 		break;
 
 	case IOC_E_DISABLE:
-		bfa_ioc_hw_sem_release(ioc);
+		bfa_nw_ioc_hw_sem_release(ioc);
 		bfa_ioc_timer_stop(ioc);
 		bfa_fsm_set_state(ioc, bfa_ioc_sm_disabled);
 		break;
@@ -346,7 +363,7 @@ bfa_ioc_sm_enabling(struct bfa_ioc *ioc, enum ioc_event event)
 	switch (event) {
 	case IOC_E_FWRSP_ENABLE:
 		bfa_ioc_timer_stop(ioc);
-		bfa_ioc_hw_sem_release(ioc);
+		bfa_nw_ioc_hw_sem_release(ioc);
 		bfa_fsm_set_state(ioc, bfa_ioc_sm_getattr);
 		break;
 
@@ -363,13 +380,13 @@ bfa_ioc_sm_enabling(struct bfa_ioc *ioc, enum ioc_event event)
 			break;
 		}
 
-		bfa_ioc_hw_sem_release(ioc);
+		bfa_nw_ioc_hw_sem_release(ioc);
 		bfa_fsm_set_state(ioc, bfa_ioc_sm_initfail);
 		break;
 
 	case IOC_E_DISABLE:
 		bfa_ioc_timer_stop(ioc);
-		bfa_ioc_hw_sem_release(ioc);
+		bfa_nw_ioc_hw_sem_release(ioc);
 		bfa_fsm_set_state(ioc, bfa_ioc_sm_disabled);
 		break;
 
@@ -662,7 +679,7 @@ bfa_ioc_disable_comp(struct bfa_ioc *ioc)
 }
 
 void
-bfa_ioc_sem_timeout(void *ioc_arg)
+bfa_nw_ioc_sem_timeout(void *ioc_arg)
 {
 	struct bfa_ioc *ioc = (struct bfa_ioc *) ioc_arg;
 
@@ -670,7 +687,7 @@ bfa_ioc_sem_timeout(void *ioc_arg)
 }
 
 bool
-bfa_ioc_sem_get(void __iomem *sem_reg)
+bfa_nw_ioc_sem_get(void __iomem *sem_reg)
 {
 	u32 r32;
 	int cnt = 0;
@@ -692,7 +709,7 @@ bfa_ioc_sem_get(void __iomem *sem_reg)
 }
 
 void
-bfa_ioc_sem_release(void __iomem *sem_reg)
+bfa_nw_ioc_sem_release(void __iomem *sem_reg)
 {
 	writel(1, sem_reg);
 }
@@ -717,7 +734,7 @@ bfa_ioc_hw_sem_get(struct bfa_ioc *ioc)
 }
 
 void
-bfa_ioc_hw_sem_release(struct bfa_ioc *ioc)
+bfa_nw_ioc_hw_sem_release(struct bfa_ioc *ioc)
 {
 	writel(1, ioc->ioc_regs.ioc_sem_reg);
 }
@@ -800,7 +817,7 @@ bfa_ioc_lpu_stop(struct bfa_ioc *ioc)
  * Get driver and firmware versions.
  */
 void
-bfa_ioc_fwver_get(struct bfa_ioc *ioc, struct bfi_ioc_image_hdr *fwhdr)
+bfa_nw_ioc_fwver_get(struct bfa_ioc *ioc, struct bfi_ioc_image_hdr *fwhdr)
 {
 	u32	pgnum, pgoff;
 	u32	loff = 0;
@@ -823,7 +840,7 @@ bfa_ioc_fwver_get(struct bfa_ioc *ioc, struct bfi_ioc_image_hdr *fwhdr)
  * Returns TRUE if same.
  */
 bool
-bfa_ioc_fwver_cmp(struct bfa_ioc *ioc, struct bfi_ioc_image_hdr *fwhdr)
+bfa_nw_ioc_fwver_cmp(struct bfa_ioc *ioc, struct bfi_ioc_image_hdr *fwhdr)
 {
 	struct bfi_ioc_image_hdr *drv_fwhdr;
 	int i;
@@ -854,7 +871,7 @@ bfa_ioc_fwver_valid(struct bfa_ioc *ioc)
 	if (bfa_ioc_is_optrom(ioc))
 		return true;
 
-	bfa_ioc_fwver_get(ioc, &fwhdr);
+	bfa_nw_ioc_fwver_get(ioc, &fwhdr);
 	drv_fwhdr = (struct bfi_ioc_image_hdr *)
 		bfa_cb_image_get_chunk(BFA_IOC_FWIMG_TYPE(ioc), 0);
 
@@ -864,7 +881,7 @@ bfa_ioc_fwver_valid(struct bfa_ioc *ioc)
 	if (fwhdr.exec != drv_fwhdr->exec)
 		return false;
 
-	return bfa_ioc_fwver_cmp(ioc, &fwhdr);
+	return bfa_nw_ioc_fwver_cmp(ioc, &fwhdr);
 }
 
 /**
@@ -941,14 +958,14 @@ bfa_ioc_hwinit(struct bfa_ioc *ioc, bool force)
 }
 
 void
-bfa_ioc_timeout(void *ioc_arg)
+bfa_nw_ioc_timeout(void *ioc_arg)
 {
 	struct bfa_ioc *ioc = (struct bfa_ioc *) ioc_arg;
 
 	bfa_fsm_send_event(ioc, IOC_E_TIMEOUT);
 }
 
-void
+static void
 bfa_ioc_mbox_send(struct bfa_ioc *ioc, void *ioc_msg, int len)
 {
 	u32 *msgp = (u32 *) ioc_msg;
@@ -1009,7 +1026,7 @@ bfa_ioc_send_getattr(struct bfa_ioc *ioc)
 }
 
 void
-bfa_ioc_hb_check(void *cbarg)
+bfa_nw_ioc_hb_check(void *cbarg)
 {
 	struct bfa_ioc *ioc = cbarg;
 	u32	hb_count;
@@ -1195,13 +1212,13 @@ bfa_ioc_mbox_hbfail(struct bfa_ioc *ioc)
 /**
  * IOC public
  */
-enum bfa_status
+static enum bfa_status
 bfa_ioc_pll_init(struct bfa_ioc *ioc)
 {
 	/*
 	 *  Hold semaphore so that nobody can access the chip during init.
 	 */
-	bfa_ioc_sem_get(ioc->ioc_regs.ioc_init_sem_reg);
+	bfa_nw_ioc_sem_get(ioc->ioc_regs.ioc_init_sem_reg);
 
 	bfa_ioc_pll_init_asic(ioc);
 
@@ -1209,7 +1226,7 @@ bfa_ioc_pll_init(struct bfa_ioc *ioc)
 	/*
 	 *  release semaphore.
 	 */
-	bfa_ioc_sem_release(ioc->ioc_regs.ioc_init_sem_reg);
+	bfa_nw_ioc_sem_release(ioc->ioc_regs.ioc_init_sem_reg);
 
 	return BFA_STATUS_OK;
 }
@@ -1218,7 +1235,7 @@ bfa_ioc_pll_init(struct bfa_ioc *ioc)
  * Interface used by diag module to do firmware boot with memory test
  * as the entry vector.
  */
-void
+static void
 bfa_ioc_boot(struct bfa_ioc *ioc, u32 boot_type, u32 boot_param)
 {
 	void __iomem *rb;
@@ -1254,28 +1271,18 @@ bfa_ioc_boot(struct bfa_ioc *ioc, u32 boot_type, u32 boot_param)
  * Enable/disable IOC failure auto recovery.
  */
 void
-bfa_ioc_auto_recover(bool auto_recover)
+bfa_nw_ioc_auto_recover(bool auto_recover)
 {
-	bfa_auto_recover = auto_recover;
+	bfa_nw_auto_recover = auto_recover;
 }
 
 bool
-bfa_ioc_is_operational(struct bfa_ioc *ioc)
+bfa_nw_ioc_is_operational(struct bfa_ioc *ioc)
 {
 	return bfa_fsm_cmp_state(ioc, bfa_ioc_sm_op);
 }
 
-bool
-bfa_ioc_is_initialized(struct bfa_ioc *ioc)
-{
-	u32 r32 = readl(ioc->ioc_regs.ioc_fwstate);
-
-	return ((r32 != BFI_IOC_UNINIT) &&
-		(r32 != BFI_IOC_INITING) &&
-		(r32 != BFI_IOC_MEMTEST));
-}
-
-void
+static void
 bfa_ioc_msgget(struct bfa_ioc *ioc, void *mbmsg)
 {
 	u32	*msgp = mbmsg;
@@ -1299,7 +1306,7 @@ bfa_ioc_msgget(struct bfa_ioc *ioc, void *mbmsg)
 	readl(ioc->ioc_regs.lpu_mbox_cmd);
 }
 
-void
+static void
 bfa_ioc_isr(struct bfa_ioc *ioc, struct bfi_mbmsg *m)
 {
 	union bfi_ioc_i2h_msg_u	*msg;
@@ -1340,7 +1347,7 @@ bfa_ioc_isr(struct bfa_ioc *ioc, struct bfi_mbmsg *m)
  * @param[in]	bfa	driver instance structure
  */
 void
-bfa_ioc_attach(struct bfa_ioc *ioc, void *bfa, struct bfa_ioc_cbfn *cbfn)
+bfa_nw_ioc_attach(struct bfa_ioc *ioc, void *bfa, struct bfa_ioc_cbfn *cbfn)
 {
 	ioc->bfa	= bfa;
 	ioc->cbfn	= cbfn;
@@ -1358,7 +1365,7 @@ bfa_ioc_attach(struct bfa_ioc *ioc, void *bfa, struct bfa_ioc_cbfn *cbfn)
  * Driver detach time IOC cleanup.
  */
 void
-bfa_ioc_detach(struct bfa_ioc *ioc)
+bfa_nw_ioc_detach(struct bfa_ioc *ioc)
 {
 	bfa_fsm_send_event(ioc, IOC_E_DETACH);
 }
@@ -1369,7 +1376,7 @@ bfa_ioc_detach(struct bfa_ioc *ioc)
  * @param[in]	pcidev	PCI device information for this IOC
  */
 void
-bfa_ioc_pci_init(struct bfa_ioc *ioc, struct bfa_pcidev *pcidev,
+bfa_nw_ioc_pci_init(struct bfa_ioc *ioc, struct bfa_pcidev *pcidev,
 		 enum bfi_mclass mc)
 {
 	ioc->ioc_mc	= mc;
@@ -1377,7 +1384,7 @@ bfa_ioc_pci_init(struct bfa_ioc *ioc, struct bfa_pcidev *pcidev,
 	ioc->ctdev	= bfa_asic_id_ct(ioc->pcidev.device_id);
 	ioc->cna	= ioc->ctdev && !ioc->fcmode;
 
-	bfa_ioc_set_ct_hwif(ioc);
+	bfa_nw_ioc_set_ct_hwif(ioc);
 
 	bfa_ioc_map_port(ioc);
 	bfa_ioc_reg_init(ioc);
@@ -1390,7 +1397,7 @@ bfa_ioc_pci_init(struct bfa_ioc *ioc, struct bfa_pcidev *pcidev,
  * @param[in]	dm_pa	physical address of IOC dma memory
  */
 void
-bfa_ioc_mem_claim(struct bfa_ioc *ioc,  u8 *dm_kva, u64 dm_pa)
+bfa_nw_ioc_mem_claim(struct bfa_ioc *ioc,  u8 *dm_kva, u64 dm_pa)
 {
 	/**
 	 * dma memory for firmware attribute
@@ -1404,13 +1411,13 @@ bfa_ioc_mem_claim(struct bfa_ioc *ioc,  u8 *dm_kva, u64 dm_pa)
  * Return size of dma memory required.
  */
 u32
-bfa_ioc_meminfo(void)
+bfa_nw_ioc_meminfo(void)
 {
 	return roundup(sizeof(struct bfi_ioc_attr), BFA_DMA_ALIGN_SZ);
 }
 
 void
-bfa_ioc_enable(struct bfa_ioc *ioc)
+bfa_nw_ioc_enable(struct bfa_ioc *ioc)
 {
 	bfa_ioc_stats(ioc, ioc_enables);
 	ioc->dbg_fwsave_once = true;
@@ -1419,45 +1426,29 @@ bfa_ioc_enable(struct bfa_ioc *ioc)
 }
 
 void
-bfa_ioc_disable(struct bfa_ioc *ioc)
+bfa_nw_ioc_disable(struct bfa_ioc *ioc)
 {
 	bfa_ioc_stats(ioc, ioc_disables);
 	bfa_fsm_send_event(ioc, IOC_E_DISABLE);
 }
 
-u32
+static u32
 bfa_ioc_smem_pgnum(struct bfa_ioc *ioc, u32 fmaddr)
 {
 	return PSS_SMEM_PGNUM(ioc->ioc_regs.smem_pg0, fmaddr);
 }
 
-u32
+static u32
 bfa_ioc_smem_pgoff(struct bfa_ioc *ioc, u32 fmaddr)
 {
 	return PSS_SMEM_PGOFF(fmaddr);
 }
 
 /**
- * Register mailbox message handler functions
- *
- * @param[in]	ioc		IOC instance
- * @param[in]	mcfuncs		message class handler functions
- */
-void
-bfa_ioc_mbox_register(struct bfa_ioc *ioc, bfa_ioc_mbox_mcfunc_t *mcfuncs)
-{
-	struct bfa_ioc_mbox_mod *mod = &ioc->mbox_mod;
-	int				mc;
-
-	for (mc = 0; mc < BFI_MC_MAX; mc++)
-		mod->mbhdlr[mc].cbfn = mcfuncs[mc];
-}
-
-/**
  * Register mailbox message handler function, to be called by common modules
  */
 void
-bfa_ioc_mbox_regisr(struct bfa_ioc *ioc, enum bfi_mclass mc,
+bfa_nw_ioc_mbox_regisr(struct bfa_ioc *ioc, enum bfi_mclass mc,
 		    bfa_ioc_mbox_mcfunc_t cbfn, void *cbarg)
 {
 	struct bfa_ioc_mbox_mod *mod = &ioc->mbox_mod;
@@ -1474,7 +1465,7 @@ bfa_ioc_mbox_regisr(struct bfa_ioc *ioc, enum bfi_mclass mc,
  * @param[i]	cmd	Mailbox command
  */
 void
-bfa_ioc_mbox_queue(struct bfa_ioc *ioc, struct bfa_mbox_cmd *cmd)
+bfa_nw_ioc_mbox_queue(struct bfa_ioc *ioc, struct bfa_mbox_cmd *cmd)
 {
 	struct bfa_ioc_mbox_mod *mod = &ioc->mbox_mod;
 	u32			stat;
@@ -1506,7 +1497,7 @@ bfa_ioc_mbox_queue(struct bfa_ioc *ioc, struct bfa_mbox_cmd *cmd)
  * Handle mailbox interrupts
  */
 void
-bfa_ioc_mbox_isr(struct bfa_ioc *ioc)
+bfa_nw_ioc_mbox_isr(struct bfa_ioc *ioc)
 {
 	struct bfa_ioc_mbox_mod *mod = &ioc->mbox_mod;
 	struct bfi_mbmsg m;
@@ -1530,86 +1521,24 @@ bfa_ioc_mbox_isr(struct bfa_ioc *ioc)
 }
 
 void
-bfa_ioc_error_isr(struct bfa_ioc *ioc)
+bfa_nw_ioc_error_isr(struct bfa_ioc *ioc)
 {
 	bfa_fsm_send_event(ioc, IOC_E_HWERROR);
 }
 
-void
-bfa_ioc_set_fcmode(struct bfa_ioc *ioc)
-{
-	ioc->fcmode  = true;
-	ioc->port_id = bfa_ioc_pcifn(ioc);
-}
-
-/**
- * return true if IOC is disabled
- */
-bool
-bfa_ioc_is_disabled(struct bfa_ioc *ioc)
-{
-	return bfa_fsm_cmp_state(ioc, bfa_ioc_sm_disabling) ||
-		bfa_fsm_cmp_state(ioc, bfa_ioc_sm_disabled);
-}
-
-/**
- * return true if IOC firmware is different.
- */
-bool
-bfa_ioc_fw_mismatch(struct bfa_ioc *ioc)
-{
-	return bfa_fsm_cmp_state(ioc, bfa_ioc_sm_reset) ||
-		bfa_fsm_cmp_state(ioc, bfa_ioc_sm_fwcheck) ||
-		bfa_fsm_cmp_state(ioc, bfa_ioc_sm_mismatch);
-}
-
-#define bfa_ioc_state_disabled(__sm)		\
-	(((__sm) == BFI_IOC_UNINIT) ||		\
-	 ((__sm) == BFI_IOC_INITING) ||		\
-	 ((__sm) == BFI_IOC_HWINIT) ||		\
-	 ((__sm) == BFI_IOC_DISABLED) ||	\
-	 ((__sm) == BFI_IOC_FAIL) ||		\
-	 ((__sm) == BFI_IOC_CFG_DISABLED))
-
-/**
- * Check if adapter is disabled -- both IOCs should be in a disabled
- * state.
- */
-bool
-bfa_ioc_adapter_is_disabled(struct bfa_ioc *ioc)
-{
-	u32	ioc_state;
-	void __iomem *rb = ioc->pcidev.pci_bar_kva;
-
-	if (!bfa_fsm_cmp_state(ioc, bfa_ioc_sm_disabled))
-		return false;
-
-	ioc_state = readl(rb + BFA_IOC0_STATE_REG);
-	if (!bfa_ioc_state_disabled(ioc_state))
-		return false;
-
-	if (ioc->pcidev.device_id != PCI_DEVICE_ID_BROCADE_FC_8G1P) {
-		ioc_state = readl(rb + BFA_IOC1_STATE_REG);
-		if (!bfa_ioc_state_disabled(ioc_state))
-			return false;
-	}
-
-	return true;
-}
-
 /**
  * Add to IOC heartbeat failure notification queue. To be used by common
  * modules such as cee, port, diag.
  */
 void
-bfa_ioc_hbfail_register(struct bfa_ioc *ioc,
+bfa_nw_ioc_hbfail_register(struct bfa_ioc *ioc,
 			struct bfa_ioc_hbfail_notify *notify)
 {
 	list_add_tail(&notify->qe, &ioc->hb_notify_q);
 }
 
 #define BFA_MFG_NAME "Brocade"
-void
+static void
 bfa_ioc_get_adapter_attr(struct bfa_ioc *ioc,
 			 struct bfa_adapter_attr *ad_attr)
 {
@@ -1640,7 +1569,7 @@ bfa_ioc_get_adapter_attr(struct bfa_ioc *ioc,
 		ad_attr->prototype = 0;
 
 	ad_attr->pwwn = bfa_ioc_get_pwwn(ioc);
-	ad_attr->mac  = bfa_ioc_get_mac(ioc);
+	ad_attr->mac  = bfa_nw_ioc_get_mac(ioc);
 
 	ad_attr->pcie_gen = ioc_attr->pcie_gen;
 	ad_attr->pcie_lanes = ioc_attr->pcie_lanes;
@@ -1653,7 +1582,7 @@ bfa_ioc_get_adapter_attr(struct bfa_ioc *ioc,
 	ad_attr->trunk_capable = (ad_attr->nports > 1) && !ioc->cna;
 }
 
-enum bfa_ioc_type
+static enum bfa_ioc_type
 bfa_ioc_get_type(struct bfa_ioc *ioc)
 {
 	if (!ioc->ctdev || ioc->fcmode)
@@ -1668,7 +1597,7 @@ bfa_ioc_get_type(struct bfa_ioc *ioc)
 	}
 }
 
-void
+static void
 bfa_ioc_get_adapter_serial_num(struct bfa_ioc *ioc, char *serial_num)
 {
 	memset(serial_num, 0, BFA_ADAPTER_SERIAL_NUM_LEN);
@@ -1677,14 +1606,14 @@ bfa_ioc_get_adapter_serial_num(struct bfa_ioc *ioc, char *serial_num)
 			BFA_ADAPTER_SERIAL_NUM_LEN);
 }
 
-void
+static void
 bfa_ioc_get_adapter_fw_ver(struct bfa_ioc *ioc, char *fw_ver)
 {
 	memset(fw_ver, 0, BFA_VERSION_LEN);
 	memcpy(fw_ver, ioc->attr->fw_version, BFA_VERSION_LEN);
 }
 
-void
+static void
 bfa_ioc_get_pci_chip_rev(struct bfa_ioc *ioc, char *chip_rev)
 {
 	BUG_ON(!(chip_rev));
@@ -1699,7 +1628,7 @@ bfa_ioc_get_pci_chip_rev(struct bfa_ioc *ioc, char *chip_rev)
 	chip_rev[5] = '\0';
 }
 
-void
+static void
 bfa_ioc_get_adapter_optrom_ver(struct bfa_ioc *ioc, char *optrom_ver)
 {
 	memset(optrom_ver, 0, BFA_VERSION_LEN);
@@ -1707,14 +1636,14 @@ bfa_ioc_get_adapter_optrom_ver(struct bfa_ioc *ioc, char *optrom_ver)
 		      BFA_VERSION_LEN);
 }
 
-void
+static void
 bfa_ioc_get_adapter_manufacturer(struct bfa_ioc *ioc, char *manufacturer)
 {
 	memset(manufacturer, 0, BFA_ADAPTER_MFG_NAME_LEN);
 	memcpy(manufacturer, BFA_MFG_NAME, BFA_ADAPTER_MFG_NAME_LEN);
 }
 
-void
+static void
 bfa_ioc_get_adapter_model(struct bfa_ioc *ioc, char *model)
 {
 	struct bfi_ioc_attr *ioc_attr;
@@ -1731,14 +1660,14 @@ bfa_ioc_get_adapter_model(struct bfa_ioc *ioc, char *model)
 		BFA_MFG_NAME, ioc_attr->card_type);
 }
 
-enum bfa_ioc_state
+static enum bfa_ioc_state
 bfa_ioc_get_state(struct bfa_ioc *ioc)
 {
 	return bfa_sm_to_state(ioc_sm_table, ioc->fsm);
 }
 
 void
-bfa_ioc_get_attr(struct bfa_ioc *ioc, struct bfa_ioc_attr *ioc_attr)
+bfa_nw_ioc_get_attr(struct bfa_ioc *ioc, struct bfa_ioc_attr *ioc_attr)
 {
 	memset((void *)ioc_attr, 0, sizeof(struct bfa_ioc_attr));
 
@@ -1757,26 +1686,14 @@ bfa_ioc_get_attr(struct bfa_ioc *ioc, struct bfa_ioc_attr *ioc_attr)
 /**
  * WWN public
  */
-u64
+static u64
 bfa_ioc_get_pwwn(struct bfa_ioc *ioc)
 {
 	return ioc->attr->pwwn;
 }
 
-u64
-bfa_ioc_get_nwwn(struct bfa_ioc *ioc)
-{
-	return ioc->attr->nwwn;
-}
-
-u64
-bfa_ioc_get_adid(struct bfa_ioc *ioc)
-{
-	return ioc->attr->mfg_pwwn;
-}
-
 mac_t
-bfa_ioc_get_mac(struct bfa_ioc *ioc)
+bfa_nw_ioc_get_mac(struct bfa_ioc *ioc)
 {
 	/*
 	 * Currently mfg mac is used as FCoE enode mac (not configured by PBC)
@@ -1787,19 +1704,7 @@ bfa_ioc_get_mac(struct bfa_ioc *ioc)
 		return ioc->attr->mac;
 }
 
-u64
-bfa_ioc_get_mfg_pwwn(struct bfa_ioc *ioc)
-{
-	return ioc->attr->mfg_pwwn;
-}
-
-u64
-bfa_ioc_get_mfg_nwwn(struct bfa_ioc *ioc)
-{
-	return ioc->attr->mfg_nwwn;
-}
-
-mac_t
+static mac_t
 bfa_ioc_get_mfg_mac(struct bfa_ioc *ioc)
 {
 	mac_t	m;
@@ -1814,12 +1719,6 @@ bfa_ioc_get_mfg_mac(struct bfa_ioc *ioc)
 	return m;
 }
 
-bool
-bfa_ioc_get_fcmode(struct bfa_ioc *ioc)
-{
-	return ioc->fcmode || !bfa_asic_id_ct(ioc->pcidev.device_id);
-}
-
 /**
  * Firmware failure detected. Start recovery actions.
  */
diff --git a/drivers/net/bna/bfa_ioc.h b/drivers/net/bna/bfa_ioc.h
index 2e5c0ad..7f0719e 100644
--- a/drivers/net/bna/bfa_ioc.h
+++ b/drivers/net/bna/bfa_ioc.h
@@ -239,13 +239,9 @@ struct bfa_ioc_hwif {
 /**
  * IOC mailbox interface
  */
-void bfa_ioc_mbox_queue(struct bfa_ioc *ioc, struct bfa_mbox_cmd *cmd);
-void bfa_ioc_mbox_register(struct bfa_ioc *ioc,
-		bfa_ioc_mbox_mcfunc_t *mcfuncs);
-void bfa_ioc_mbox_isr(struct bfa_ioc *ioc);
-void bfa_ioc_mbox_send(struct bfa_ioc *ioc, void *ioc_msg, int len);
-void bfa_ioc_msgget(struct bfa_ioc *ioc, void *mbmsg);
-void bfa_ioc_mbox_regisr(struct bfa_ioc *ioc, enum bfi_mclass mc,
+void bfa_nw_ioc_mbox_queue(struct bfa_ioc *ioc, struct bfa_mbox_cmd *cmd);
+void bfa_nw_ioc_mbox_isr(struct bfa_ioc *ioc);
+void bfa_nw_ioc_mbox_regisr(struct bfa_ioc *ioc, enum bfi_mclass mc,
 		bfa_ioc_mbox_mcfunc_t cbfn, void *cbarg);
 
 /**
@@ -256,83 +252,45 @@ void bfa_ioc_mbox_regisr(struct bfa_ioc *ioc, enum bfi_mclass mc,
 	((__ioc)->ioc_hwif->ioc_pll_init((__ioc)->pcidev.pci_bar_kva, \
 			   (__ioc)->fcmode))
 
-enum bfa_status bfa_ioc_pll_init(struct bfa_ioc *ioc);
-enum bfa_status bfa_ioc_cb_pll_init(void __iomem *rb, bool fcmode);
-enum bfa_status bfa_ioc_ct_pll_init(void __iomem *rb, bool fcmode);
-
 #define	bfa_ioc_isr_mode_set(__ioc, __msix)			\
 			((__ioc)->ioc_hwif->ioc_isr_mode_set(__ioc, __msix))
 #define	bfa_ioc_ownership_reset(__ioc)				\
 			((__ioc)->ioc_hwif->ioc_ownership_reset(__ioc))
 
-void bfa_ioc_set_ct_hwif(struct bfa_ioc *ioc);
+void bfa_nw_ioc_set_ct_hwif(struct bfa_ioc *ioc);
 
-void bfa_ioc_attach(struct bfa_ioc *ioc, void *bfa,
+void bfa_nw_ioc_attach(struct bfa_ioc *ioc, void *bfa,
 		struct bfa_ioc_cbfn *cbfn);
-void bfa_ioc_auto_recover(bool auto_recover);
-void bfa_ioc_detach(struct bfa_ioc *ioc);
-void bfa_ioc_pci_init(struct bfa_ioc *ioc, struct bfa_pcidev *pcidev,
+void bfa_nw_ioc_auto_recover(bool auto_recover);
+void bfa_nw_ioc_detach(struct bfa_ioc *ioc);
+void bfa_nw_ioc_pci_init(struct bfa_ioc *ioc, struct bfa_pcidev *pcidev,
 		enum bfi_mclass mc);
-u32 bfa_ioc_meminfo(void);
-void bfa_ioc_mem_claim(struct bfa_ioc *ioc,  u8 *dm_kva, u64 dm_pa);
-void bfa_ioc_enable(struct bfa_ioc *ioc);
-void bfa_ioc_disable(struct bfa_ioc *ioc);
-bool bfa_ioc_intx_claim(struct bfa_ioc *ioc);
-
-void bfa_ioc_boot(struct bfa_ioc *ioc, u32 boot_type,
-		u32 boot_param);
-void bfa_ioc_isr(struct bfa_ioc *ioc, struct bfi_mbmsg *msg);
-void bfa_ioc_error_isr(struct bfa_ioc *ioc);
-bool bfa_ioc_is_operational(struct bfa_ioc *ioc);
-bool bfa_ioc_is_initialized(struct bfa_ioc *ioc);
-bool bfa_ioc_is_disabled(struct bfa_ioc *ioc);
-bool bfa_ioc_fw_mismatch(struct bfa_ioc *ioc);
-bool bfa_ioc_adapter_is_disabled(struct bfa_ioc *ioc);
-void bfa_ioc_cfg_complete(struct bfa_ioc *ioc);
-enum bfa_ioc_type bfa_ioc_get_type(struct bfa_ioc *ioc);
-void bfa_ioc_get_adapter_serial_num(struct bfa_ioc *ioc, char *serial_num);
-void bfa_ioc_get_adapter_fw_ver(struct bfa_ioc *ioc, char *fw_ver);
-void bfa_ioc_get_adapter_optrom_ver(struct bfa_ioc *ioc, char *optrom_ver);
-void bfa_ioc_get_adapter_model(struct bfa_ioc *ioc, char *model);
-void bfa_ioc_get_adapter_manufacturer(struct bfa_ioc *ioc,
-		char *manufacturer);
-void bfa_ioc_get_pci_chip_rev(struct bfa_ioc *ioc, char *chip_rev);
-enum bfa_ioc_state bfa_ioc_get_state(struct bfa_ioc *ioc);
-
-void bfa_ioc_get_attr(struct bfa_ioc *ioc, struct bfa_ioc_attr *ioc_attr);
-void bfa_ioc_get_adapter_attr(struct bfa_ioc *ioc,
-		struct bfa_adapter_attr *ad_attr);
-u32 bfa_ioc_smem_pgnum(struct bfa_ioc *ioc, u32 fmaddr);
-u32 bfa_ioc_smem_pgoff(struct bfa_ioc *ioc, u32 fmaddr);
-void bfa_ioc_set_fcmode(struct bfa_ioc *ioc);
-bool bfa_ioc_get_fcmode(struct bfa_ioc *ioc);
-void bfa_ioc_hbfail_register(struct bfa_ioc *ioc,
+u32 bfa_nw_ioc_meminfo(void);
+void bfa_nw_ioc_mem_claim(struct bfa_ioc *ioc,  u8 *dm_kva, u64 dm_pa);
+void bfa_nw_ioc_enable(struct bfa_ioc *ioc);
+void bfa_nw_ioc_disable(struct bfa_ioc *ioc);
+
+void bfa_nw_ioc_error_isr(struct bfa_ioc *ioc);
+bool bfa_nw_ioc_is_operational(struct bfa_ioc *ioc);
+
+void bfa_nw_ioc_get_attr(struct bfa_ioc *ioc, struct bfa_ioc_attr *ioc_attr);
+void bfa_nw_ioc_hbfail_register(struct bfa_ioc *ioc,
 	struct bfa_ioc_hbfail_notify *notify);
-bool bfa_ioc_sem_get(void __iomem *sem_reg);
-void bfa_ioc_sem_release(void __iomem *sem_reg);
-void bfa_ioc_hw_sem_release(struct bfa_ioc *ioc);
-void bfa_ioc_fwver_get(struct bfa_ioc *ioc,
+bool bfa_nw_ioc_sem_get(void __iomem *sem_reg);
+void bfa_nw_ioc_sem_release(void __iomem *sem_reg);
+void bfa_nw_ioc_hw_sem_release(struct bfa_ioc *ioc);
+void bfa_nw_ioc_fwver_get(struct bfa_ioc *ioc,
 			struct bfi_ioc_image_hdr *fwhdr);
-bool bfa_ioc_fwver_cmp(struct bfa_ioc *ioc,
+bool bfa_nw_ioc_fwver_cmp(struct bfa_ioc *ioc,
 			struct bfi_ioc_image_hdr *fwhdr);
+mac_t bfa_nw_ioc_get_mac(struct bfa_ioc *ioc);
 
 /*
  * Timeout APIs
  */
-void bfa_ioc_timeout(void *ioc);
-void bfa_ioc_hb_check(void *ioc);
-void bfa_ioc_sem_timeout(void *ioc);
-
-/*
- * bfa mfg wwn API functions
- */
-u64 bfa_ioc_get_pwwn(struct bfa_ioc *ioc);
-u64 bfa_ioc_get_nwwn(struct bfa_ioc *ioc);
-mac_t bfa_ioc_get_mac(struct bfa_ioc *ioc);
-u64 bfa_ioc_get_mfg_pwwn(struct bfa_ioc *ioc);
-u64 bfa_ioc_get_mfg_nwwn(struct bfa_ioc *ioc);
-mac_t bfa_ioc_get_mfg_mac(struct bfa_ioc *ioc);
-u64 bfa_ioc_get_adid(struct bfa_ioc *ioc);
+void bfa_nw_ioc_timeout(void *ioc);
+void bfa_nw_ioc_hb_check(void *ioc);
+void bfa_nw_ioc_sem_timeout(void *ioc);
 
 /*
  * F/W Image Size & Chunk
diff --git a/drivers/net/bna/bfa_ioc_ct.c b/drivers/net/bna/bfa_ioc_ct.c
index 870046e..462857c 100644
--- a/drivers/net/bna/bfa_ioc_ct.c
+++ b/drivers/net/bna/bfa_ioc_ct.c
@@ -32,25 +32,26 @@ static void bfa_ioc_ct_map_port(struct bfa_ioc *ioc);
 static void bfa_ioc_ct_isr_mode_set(struct bfa_ioc *ioc, bool msix);
 static void bfa_ioc_ct_notify_hbfail(struct bfa_ioc *ioc);
 static void bfa_ioc_ct_ownership_reset(struct bfa_ioc *ioc);
+static enum bfa_status bfa_ioc_ct_pll_init(void __iomem *rb, bool fcmode);
 
-struct bfa_ioc_hwif hwif_ct;
+struct bfa_ioc_hwif nw_hwif_ct;
 
 /**
  * Called from bfa_ioc_attach() to map asic specific calls.
  */
 void
-bfa_ioc_set_ct_hwif(struct bfa_ioc *ioc)
+bfa_nw_ioc_set_ct_hwif(struct bfa_ioc *ioc)
 {
-	hwif_ct.ioc_pll_init = bfa_ioc_ct_pll_init;
-	hwif_ct.ioc_firmware_lock = bfa_ioc_ct_firmware_lock;
-	hwif_ct.ioc_firmware_unlock = bfa_ioc_ct_firmware_unlock;
-	hwif_ct.ioc_reg_init = bfa_ioc_ct_reg_init;
-	hwif_ct.ioc_map_port = bfa_ioc_ct_map_port;
-	hwif_ct.ioc_isr_mode_set = bfa_ioc_ct_isr_mode_set;
-	hwif_ct.ioc_notify_hbfail = bfa_ioc_ct_notify_hbfail;
-	hwif_ct.ioc_ownership_reset = bfa_ioc_ct_ownership_reset;
-
-	ioc->ioc_hwif = &hwif_ct;
+	nw_hwif_ct.ioc_pll_init = bfa_ioc_ct_pll_init;
+	nw_hwif_ct.ioc_firmware_lock = bfa_ioc_ct_firmware_lock;
+	nw_hwif_ct.ioc_firmware_unlock = bfa_ioc_ct_firmware_unlock;
+	nw_hwif_ct.ioc_reg_init = bfa_ioc_ct_reg_init;
+	nw_hwif_ct.ioc_map_port = bfa_ioc_ct_map_port;
+	nw_hwif_ct.ioc_isr_mode_set = bfa_ioc_ct_isr_mode_set;
+	nw_hwif_ct.ioc_notify_hbfail = bfa_ioc_ct_notify_hbfail;
+	nw_hwif_ct.ioc_ownership_reset = bfa_ioc_ct_ownership_reset;
+
+	ioc->ioc_hwif = &nw_hwif_ct;
 }
 
 /**
@@ -76,7 +77,7 @@ bfa_ioc_ct_firmware_lock(struct bfa_ioc *ioc)
 						BFA_IOC_FWIMG_MINSZ)
 		return true;
 
-	bfa_ioc_sem_get(ioc->ioc_regs.ioc_usage_sem_reg);
+	bfa_nw_ioc_sem_get(ioc->ioc_regs.ioc_usage_sem_reg);
 	usecnt = readl(ioc->ioc_regs.ioc_usage_reg);
 
 	/**
@@ -84,7 +85,7 @@ bfa_ioc_ct_firmware_lock(struct bfa_ioc *ioc)
 	 */
 	if (usecnt == 0) {
 		writel(1, ioc->ioc_regs.ioc_usage_reg);
-		bfa_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);
+		bfa_nw_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);
 		return true;
 	}
 
@@ -98,9 +99,9 @@ bfa_ioc_ct_firmware_lock(struct bfa_ioc *ioc)
 	/**
 	 * Check if another driver with a different firmware is active
 	 */
-	bfa_ioc_fwver_get(ioc, &fwhdr);
-	if (!bfa_ioc_fwver_cmp(ioc, &fwhdr)) {
-		bfa_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);
+	bfa_nw_ioc_fwver_get(ioc, &fwhdr);
+	if (!bfa_nw_ioc_fwver_cmp(ioc, &fwhdr)) {
+		bfa_nw_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);
 		return false;
 	}
 
@@ -109,7 +110,7 @@ bfa_ioc_ct_firmware_lock(struct bfa_ioc *ioc)
 	 */
 	usecnt++;
 	writel(usecnt, ioc->ioc_regs.ioc_usage_reg);
-	bfa_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);
+	bfa_nw_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);
 	return true;
 }
 
@@ -134,14 +135,14 @@ bfa_ioc_ct_firmware_unlock(struct bfa_ioc *ioc)
 	/**
 	 * decrement usage count
 	 */
-	bfa_ioc_sem_get(ioc->ioc_regs.ioc_usage_sem_reg);
+	bfa_nw_ioc_sem_get(ioc->ioc_regs.ioc_usage_sem_reg);
 	usecnt = readl(ioc->ioc_regs.ioc_usage_reg);
 	BUG_ON(!(usecnt > 0));
 
 	usecnt--;
 	writel(usecnt, ioc->ioc_regs.ioc_usage_reg);
 
-	bfa_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);
+	bfa_nw_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);
 }
 
 /**
@@ -302,9 +303,9 @@ static void
 bfa_ioc_ct_ownership_reset(struct bfa_ioc *ioc)
 {
 	if (ioc->cna) {
-		bfa_ioc_sem_get(ioc->ioc_regs.ioc_usage_sem_reg);
+		bfa_nw_ioc_sem_get(ioc->ioc_regs.ioc_usage_sem_reg);
 		writel(0, ioc->ioc_regs.ioc_usage_reg);
-		bfa_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);
+		bfa_nw_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);
 	}
 
 	/*
@@ -313,10 +314,10 @@ bfa_ioc_ct_ownership_reset(struct bfa_ioc *ioc)
 	 * will lock it instead of clearing it.
 	 */
 	readl(ioc->ioc_regs.ioc_sem_reg);
-	bfa_ioc_hw_sem_release(ioc);
+	bfa_nw_ioc_hw_sem_release(ioc);
 }
 
-enum bfa_status
+static enum bfa_status
 bfa_ioc_ct_pll_init(void __iomem *rb, bool fcmode)
 {
 	u32	pll_sclk, pll_fclk, r32;
diff --git a/drivers/net/bna/bna_ctrl.c b/drivers/net/bna/bna_ctrl.c
index 9d41ebf..f3034d6 100644
--- a/drivers/net/bna/bna_ctrl.c
+++ b/drivers/net/bna/bna_ctrl.c
@@ -81,7 +81,7 @@ bna_ll_isr(void *llarg, struct bfi_mbmsg *msg)
 			/* Post the next entry, if needed */
 			if (to_post) {
 				mb_qe = bfa_q_first(&bna->mbox_mod.posted_q);
-				bfa_ioc_mbox_queue(&bna->device.ioc,
+				bfa_nw_ioc_mbox_queue(&bna->device.ioc,
 							&mb_qe->cmd);
 			}
 		} else {
@@ -107,7 +107,7 @@ bna_err_handler(struct bna *bna, u32 intr_status)
 		writel(init_halt, bna->device.ioc.ioc_regs.ll_halt);
 	}
 
-	bfa_ioc_error_isr(&bna->device.ioc);
+	bfa_nw_ioc_error_isr(&bna->device.ioc);
 }
 
 void
@@ -118,7 +118,7 @@ bna_mbox_handler(struct bna *bna, u32 intr_status)
 		return;
 	}
 	if (BNA_IS_MBOX_INTR(intr_status))
-		bfa_ioc_mbox_isr(&bna->device.ioc);
+		bfa_nw_ioc_mbox_isr(&bna->device.ioc);
 }
 
 void
@@ -133,7 +133,7 @@ bna_mbox_send(struct bna *bna, struct bna_mbox_qe *mbox_qe)
 	bna->mbox_mod.msg_pending++;
 	if (bna->mbox_mod.state == BNA_MBOX_FREE) {
 		list_add_tail(&mbox_qe->qe, &bna->mbox_mod.posted_q);
-		bfa_ioc_mbox_queue(&bna->device.ioc, &mbox_qe->cmd);
+		bfa_nw_ioc_mbox_queue(&bna->device.ioc, &mbox_qe->cmd);
 		bna->mbox_mod.state = BNA_MBOX_POSTED;
 	} else {
 		list_add_tail(&mbox_qe->qe, &bna->mbox_mod.posted_q);
@@ -180,7 +180,7 @@ bna_mbox_mod_stop(struct bna_mbox_mod *mbox_mod)
 void
 bna_mbox_mod_init(struct bna_mbox_mod *mbox_mod, struct bna *bna)
 {
-	bfa_ioc_mbox_regisr(&bna->device.ioc, BFI_MC_LL, bna_ll_isr, bna);
+	bfa_nw_ioc_mbox_regisr(&bna->device.ioc, BFI_MC_LL, bna_ll_isr, bna);
 	mbox_mod->state = BNA_MBOX_FREE;
 	mbox_mod->msg_ctr = mbox_mod->msg_pending = 0;
 	INIT_LIST_HEAD(&mbox_mod->posted_q);
@@ -1289,7 +1289,7 @@ bna_port_mtu_set(struct bna_port *port, int mtu,
 void
 bna_port_mac_get(struct bna_port *port, mac_t *mac)
 {
-	*mac = bfa_ioc_get_mac(&port->bna->device.ioc);
+	*mac = bfa_nw_ioc_get_mac(&port->bna->device.ioc);
 }
 
 /**
@@ -1427,7 +1427,7 @@ bna_device_sm_stopped(struct bna_device *device,
 	case DEVICE_E_ENABLE:
 		if (device->intr_type == BNA_INTR_T_MSIX)
 			bna_mbox_msix_idx_set(device);
-		bfa_ioc_enable(&device->ioc);
+		bfa_nw_ioc_enable(&device->ioc);
 		bfa_fsm_set_state(device, bna_device_sm_ioc_ready_wait);
 		break;
 
@@ -1547,7 +1547,7 @@ bna_device_sm_port_stop_wait(struct bna_device *device,
 static void
 bna_device_sm_ioc_disable_wait_entry(struct bna_device *device)
 {
-	bfa_ioc_disable(&device->ioc);
+	bfa_nw_ioc_disable(&device->ioc);
 }
 
 static void
@@ -1655,12 +1655,12 @@ bna_device_init(struct bna_device *device, struct bna *bna,
 	 *	1. DMA memory for IOC attributes
 	 *	2. Kernel memory for FW trace
 	 */
-	bfa_ioc_attach(&device->ioc, device, &bfa_iocll_cbfn);
-	bfa_ioc_pci_init(&device->ioc, &bna->pcidev, BFI_MC_LL);
+	bfa_nw_ioc_attach(&device->ioc, device, &bfa_iocll_cbfn);
+	bfa_nw_ioc_pci_init(&device->ioc, &bna->pcidev, BFI_MC_LL);
 
 	BNA_GET_DMA_ADDR(
 		&res_info[BNA_RES_MEM_T_ATTR].res_u.mem_info.mdl[0].dma, dma);
-	bfa_ioc_mem_claim(&device->ioc,
+	bfa_nw_ioc_mem_claim(&device->ioc,
 		res_info[BNA_RES_MEM_T_ATTR].res_u.mem_info.mdl[0].kva,
 			  dma);
 
@@ -1686,9 +1686,7 @@ bna_device_uninit(struct bna_device *device)
 {
 	bna_mbox_mod_uninit(&device->bna->mbox_mod);
 
-	bfa_cee_detach(&device->bna->cee);
-
-	bfa_ioc_detach(&device->ioc);
+	bfa_nw_ioc_detach(&device->ioc);
 
 	device->bna = NULL;
 }
@@ -1783,10 +1781,10 @@ bna_adv_device_init(struct bna_device *device, struct bna *bna,
 		&res_info[BNA_RES_MEM_T_COM].res_u.mem_info.mdl[0].dma, dma);
 	kva = res_info[BNA_RES_MEM_T_COM].res_u.mem_info.mdl[0].kva;
 
-	bfa_cee_attach(&bna->cee, &device->ioc, bna);
-	bfa_cee_mem_claim(&bna->cee, kva, dma);
-	kva += bfa_cee_meminfo();
-	dma += bfa_cee_meminfo();
+	bfa_nw_cee_attach(&bna->cee, &device->ioc, bna);
+	bfa_nw_cee_mem_claim(&bna->cee, kva, dma);
+	kva += bfa_nw_cee_meminfo();
+	dma += bfa_nw_cee_meminfo();
 
 }
 
@@ -1800,7 +1798,7 @@ bna_adv_res_req(struct bna_res_info *res_info)
 	res_info[BNA_RES_MEM_T_COM].res_u.mem_info.mem_type = BNA_MEM_T_DMA;
 	res_info[BNA_RES_MEM_T_COM].res_u.mem_info.num = 1;
 	res_info[BNA_RES_MEM_T_COM].res_u.mem_info.len = ALIGN(
-				bfa_cee_meminfo(), PAGE_SIZE);
+				bfa_nw_cee_meminfo(), PAGE_SIZE);
 
 	/* Virtual memory for retreiving fw_trc */
 	res_info[BNA_RES_MEM_T_FWTRC].res_type = BNA_RES_T_MEM;
@@ -3333,7 +3331,7 @@ bna_res_req(struct bna_res_info *res_info)
 	res_info[BNA_RES_MEM_T_ATTR].res_u.mem_info.mem_type = BNA_MEM_T_DMA;
 	res_info[BNA_RES_MEM_T_ATTR].res_u.mem_info.num = 1;
 	res_info[BNA_RES_MEM_T_ATTR].res_u.mem_info.len =
-				ALIGN(bfa_ioc_meminfo(), PAGE_SIZE);
+				ALIGN(bfa_nw_ioc_meminfo(), PAGE_SIZE);
 
 	/* DMA memory for index segment of an IB */
 	res_info[BNA_RES_MEM_T_IBIDX].res_type = BNA_RES_T_MEM;
diff --git a/drivers/net/bna/bnad.c b/drivers/net/bna/bnad.c
index 491d148..cbc1d56 100644
--- a/drivers/net/bna/bnad.c
+++ b/drivers/net/bna/bnad.c
@@ -1365,7 +1365,7 @@ bnad_ioc_timeout(unsigned long data)
 	unsigned long flags;
 
 	spin_lock_irqsave(&bnad->bna_lock, flags);
-	bfa_ioc_timeout((void *) &bnad->bna.device.ioc);
+	bfa_nw_ioc_timeout((void *) &bnad->bna.device.ioc);
 	spin_unlock_irqrestore(&bnad->bna_lock, flags);
 }
 
@@ -1376,7 +1376,7 @@ bnad_ioc_hb_check(unsigned long data)
 	unsigned long flags;
 
 	spin_lock_irqsave(&bnad->bna_lock, flags);
-	bfa_ioc_hb_check((void *) &bnad->bna.device.ioc);
+	bfa_nw_ioc_hb_check((void *) &bnad->bna.device.ioc);
 	spin_unlock_irqrestore(&bnad->bna_lock, flags);
 }
 
@@ -1387,7 +1387,7 @@ bnad_ioc_sem_timeout(unsigned long data)
 	unsigned long flags;
 
 	spin_lock_irqsave(&bnad->bna_lock, flags);
-	bfa_ioc_sem_timeout((void *) &bnad->bna.device.ioc);
+	bfa_nw_ioc_sem_timeout((void *) &bnad->bna.device.ioc);
 	spin_unlock_irqrestore(&bnad->bna_lock, flags);
 }
 
@@ -3067,7 +3067,6 @@ bnad_pci_probe(struct pci_dev *pdev,
 	}
 	bnad = netdev_priv(netdev);
 
-
 	/*
 	 * PCI initialization
 	 * 	Output : using_dac = 1 for 64 bit DMA
@@ -3239,7 +3238,7 @@ bnad_module_init(void)
 
 	pr_info("Brocade 10G Ethernet driver\n");
 
-	bfa_ioc_auto_recover(bnad_ioc_auto_recover);
+	bfa_nw_ioc_auto_recover(bnad_ioc_auto_recover);
 
 	err = pci_register_driver(&bnad_pci_driver);
 	if (err < 0) {
diff --git a/drivers/net/bna/bnad_ethtool.c b/drivers/net/bna/bnad_ethtool.c
index 7e630f5..b337bd9 100644
--- a/drivers/net/bna/bnad_ethtool.c
+++ b/drivers/net/bna/bnad_ethtool.c
@@ -276,7 +276,7 @@ bnad_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo)
 	if (ioc_attr) {
 		memset(ioc_attr, 0, sizeof(*ioc_attr));
 		spin_lock_irqsave(&bnad->bna_lock, flags);
-		bfa_ioc_get_attr(&bnad->bna.device.ioc, ioc_attr);
+		bfa_nw_ioc_get_attr(&bnad->bna.device.ioc, ioc_attr);
 		spin_unlock_irqrestore(&bnad->bna_lock, flags);
 
 		strncpy(drvinfo->fw_version, ioc_attr->adapter_attr.fw_ver,
-- 
1.7.4.4

