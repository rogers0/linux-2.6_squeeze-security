From b58bb2ada8e7d16c2929fe05f40511269b0c9656 Mon Sep 17 00:00:00 2001
From: Manu Abraham <abraham.manu@gmail.com>
Date: Fri, 4 Dec 2009 05:41:11 -0300
Subject: [PATCH 095/120] V4L/DVB (13795): [Mantis/Hopper] Code overhaul, add Hopper devices into the PCI ID list
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Manu Abraham <manu@linuxtv.org>
Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>
(cherry picked from commit b3b961448f702339444036f94252ff2ba7a99feb)

Signed-off-by: Bj√∏rn Mork <bjorn@mork.no>
---
 drivers/media/dvb/mantis/Kconfig         |   22 ++-
 drivers/media/dvb/mantis/Makefile        |   42 ++--
 drivers/media/dvb/mantis/hopper_cards.c  |  260 +++++++++++++++++++++
 drivers/media/dvb/mantis/hopper_vp3028.c |   76 ++++++
 drivers/media/dvb/mantis/hopper_vp3028.h |   10 +
 drivers/media/dvb/mantis/mantis_ca.c     |   69 ++++--
 drivers/media/dvb/mantis/mantis_ca.h     |    7 +
 drivers/media/dvb/mantis/mantis_cards.c  |  279 +++++++++++++++++++++++
 drivers/media/dvb/mantis/mantis_common.h |   68 +++---
 drivers/media/dvb/mantis/mantis_dma.c    |   55 +++--
 drivers/media/dvb/mantis/mantis_dma.h    |   10 +
 drivers/media/dvb/mantis/mantis_dvb.c    |  364 +++++++++++++-----------------
 drivers/media/dvb/mantis/mantis_dvb.h    |   15 ++
 drivers/media/dvb/mantis/mantis_evm.c    |   38 ++-
 drivers/media/dvb/mantis/mantis_hif.c    |   60 ++++--
 drivers/media/dvb/mantis/mantis_hif.h    |    2 +-
 drivers/media/dvb/mantis/mantis_i2c.c    |   75 ++++---
 drivers/media/dvb/mantis/mantis_i2c.h    |    7 +
 drivers/media/dvb/mantis/mantis_ioc.c    |  145 ++++++++++++
 drivers/media/dvb/mantis/mantis_link.h   |    3 +-
 drivers/media/dvb/mantis/mantis_pci.c    |  310 ++++++++-----------------
 drivers/media/dvb/mantis/mantis_pci.h    |    7 +
 drivers/media/dvb/mantis/mantis_pcmcia.c |   22 ++-
 drivers/media/dvb/mantis/mantis_reg.h    |   40 +++-
 drivers/media/dvb/mantis/mantis_uart.c   |   37 +++-
 drivers/media/dvb/mantis/mantis_uart.h   |    2 +-
 drivers/media/dvb/mantis/mantis_vp1033.c |   98 ++++++---
 drivers/media/dvb/mantis/mantis_vp1033.h |   13 +-
 drivers/media/dvb/mantis/mantis_vp1034.c |   66 +++++--
 drivers/media/dvb/mantis/mantis_vp1034.h |    6 +-
 drivers/media/dvb/mantis/mantis_vp1041.c |   79 ++++++-
 drivers/media/dvb/mantis/mantis_vp1041.h |   14 +-
 drivers/media/dvb/mantis/mantis_vp2033.c |   95 +++++++--
 drivers/media/dvb/mantis/mantis_vp2033.h |   11 +-
 drivers/media/dvb/mantis/mantis_vp2040.c |  141 +++++++++++-
 drivers/media/dvb/mantis/mantis_vp2040.h |   11 +-
 drivers/media/dvb/mantis/mantis_vp3030.c |   49 ++++-
 drivers/media/dvb/mantis/mantis_vp3030.h |    8 +-
 38 files changed, 1881 insertions(+), 735 deletions(-)
 create mode 100644 drivers/media/dvb/mantis/hopper_cards.c
 create mode 100644 drivers/media/dvb/mantis/hopper_vp3028.c
 create mode 100644 drivers/media/dvb/mantis/hopper_vp3028.h
 create mode 100644 drivers/media/dvb/mantis/mantis_ca.h
 create mode 100644 drivers/media/dvb/mantis/mantis_cards.c
 create mode 100644 drivers/media/dvb/mantis/mantis_dma.h
 create mode 100644 drivers/media/dvb/mantis/mantis_dvb.h
 create mode 100644 drivers/media/dvb/mantis/mantis_i2c.h
 create mode 100644 drivers/media/dvb/mantis/mantis_ioc.c
 create mode 100644 drivers/media/dvb/mantis/mantis_pci.h

diff --git a/drivers/media/dvb/mantis/Kconfig b/drivers/media/dvb/mantis/Kconfig
index 4ba16d0..aaf0250 100644
--- a/drivers/media/dvb/mantis/Kconfig
+++ b/drivers/media/dvb/mantis/Kconfig
@@ -1,6 +1,15 @@
+config MANTIS_CORE
+	tristate "Mantis/Hopper PCI bridge based devices"
+	depends on PCI && I2C
+
+	help
+	  Support for PCI cards based on the Mantis and Hopper PCi bridge.
+
+	  Say Y if you own such a device and want to use it.
+
 config DVB_MANTIS
 	tristate "MANTIS based cards"
-	depends on DVB_CORE && PCI && I2C
+	depends on MANTIS_CORE && DVB_CORE && PCI && I2C
 	select DVB_MB86A16
 	select DVB_CU1216
 	select DVB_ZL10353
@@ -11,3 +20,14 @@ config DVB_MANTIS
 	  Say Y when you have a Mantis based DVB card and want to use it.
 
 	  If unsure say N.
+
+config DVB_HOPPER
+	tristate "HOPPER based cards"
+	depends on MANTIS_CORE && DVB_CORE && PCI && I2C
+	select DVB_ZL10353
+	select DVB_PLL
+	help
+	  Support for PCI cards based on the Hopper  PCI bridge.
+	  Say Y when you have a Hopper based DVB card and want to use it.
+
+	  If unsure say N
diff --git a/drivers/media/dvb/mantis/Makefile b/drivers/media/dvb/mantis/Makefile
index bb88cdc..399c901 100644
--- a/drivers/media/dvb/mantis/Makefile
+++ b/drivers/media/dvb/mantis/Makefile
@@ -1,21 +1,27 @@
-mantis-objs = 	mantis_core.o	\
-		mantis_uart.o	\
-		mantis_dma.o	\
-		mantis_pci.o	\
-		mantis_i2c.o	\
-		mantis_dvb.o	\
-		mantis_evm.o	\
-		mantis_hif.o	\
-		mantis_ca.o	\
-		mantis_pcmcia.o	\
-		mantis_vp1033.o	\
-		mantis_vp1034.o	\
-		mantis_vp1041.o	\
-		mantis_vp2033.o	\
-		mantis_vp2040.o	\
-		mantis_vp3028.o	\
-		mantis_vp3030.o
+mantis_core-objs :=	mantis_ioc.o	\
+			mantis_uart.o	\
+			mantis_dma.o	\
+			mantis_pci.o	\
+			mantis_i2c.o	\
+			mantis_dvb.o	\
+			mantis_evm.o	\
+			mantis_hif.o	\
+			mantis_ca.o	\
+			mantis_pcmcia.o
 
-obj-$(CONFIG_DVB_MANTIS) += mantis.o
+mantis-objs	:=	mantis_cards.o	\
+			mantis_vp1033.o	\
+			mantis_vp1034.o	\
+			mantis_vp1041.o	\
+			mantis_vp2033.o	\
+			mantis_vp2040.o	\
+			mantis_vp3030.o
+
+hopper-objs	:=	hopper_cards.o	\
+			hopper_vp3028.o
+
+obj-$(CONFIG_MANTIS_CORE)	+= mantis_core.o
+obj-$(CONFIG_DVB_MANTIS)	+= mantis.o
+obj-$(CONFIG_DVB_HOPPER)	+= hopper.o
 
 EXTRA_CFLAGS = -Idrivers/media/dvb/dvb-core/ -Idrivers/media/dvb/frontends/
diff --git a/drivers/media/dvb/mantis/hopper_cards.c b/drivers/media/dvb/mantis/hopper_cards.c
new file mode 100644
index 0000000..749e3f3
--- /dev/null
+++ b/drivers/media/dvb/mantis/hopper_cards.c
@@ -0,0 +1,260 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <asm/irq.h>
+#include <linux/interrupt.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
+#include "mantis_common.h"
+#include "hopper_vp3028.h"
+#include "mantis_dma.h"
+#include "mantis_dvb.h"
+#include "mantis_uart.h"
+#include "mantis_ioc.h"
+#include "mantis_pci.h"
+#include "mantis_i2c.h"
+#include "mantis_reg.h"
+
+static unsigned int verbose;
+module_param(verbose, int, 0644);
+MODULE_PARM_DESC(verbose, "verbose startup messages, default is 1 (yes)");
+
+#define DRIVER_NAME	"Hopper"
+
+static char *label[10] = {
+	"DMA",
+	"IRQ-0",
+	"IRQ-1",
+	"OCERR",
+	"PABRT",
+	"RIPRR",
+	"PPERR",
+	"FTRGT",
+	"RISCI",
+	"RACK"
+};
+
+static int devs;
+
+static irqreturn_t hopper_irq_handler(int irq, void *dev_id)
+{
+	u32 stat = 0, mask = 0, lstat = 0, mstat = 0;
+	u32 rst_stat = 0, rst_mask = 0;
+
+	struct mantis_pci *mantis;
+	struct mantis_ca *ca;
+
+	mantis = (struct mantis_pci *) dev_id;
+	if (unlikely(mantis == NULL)) {
+		dprintk(MANTIS_ERROR, 1, "Mantis == NULL");
+		return IRQ_NONE;
+	}
+	ca = mantis->mantis_ca;
+
+	stat = mmread(MANTIS_INT_STAT);
+	mask = mmread(MANTIS_INT_MASK);
+	mstat = lstat = stat & ~MANTIS_INT_RISCSTAT;
+	if (!(stat & mask))
+		return IRQ_NONE;
+
+	rst_mask  = MANTIS_GPIF_WRACK  |
+		    MANTIS_GPIF_OTHERR |
+		    MANTIS_SBUF_WSTO   |
+		    MANTIS_GPIF_EXTIRQ;
+
+	rst_stat  = mmread(MANTIS_GPIF_STATUS);
+	rst_stat &= rst_mask;
+	mmwrite(rst_stat, MANTIS_GPIF_STATUS);
+
+	mantis->mantis_int_stat = stat;
+	mantis->mantis_int_mask = mask;
+	dprintk(MANTIS_DEBUG, 0, "\n-- Stat=<%02x> Mask=<%02x> --", stat, mask);
+	if (stat & MANTIS_INT_RISCEN) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[0]);
+	}
+	if (stat & MANTIS_INT_IRQ0) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[1]);
+		mantis->gpif_status = rst_stat;
+		wake_up(&ca->hif_write_wq);
+		schedule_work(&ca->hif_evm_work);
+	}
+	if (stat & MANTIS_INT_IRQ1) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[2]);
+		schedule_work(&mantis->uart_work);
+	}
+	if (stat & MANTIS_INT_OCERR) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[3]);
+	}
+	if (stat & MANTIS_INT_PABORT) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[4]);
+	}
+	if (stat & MANTIS_INT_RIPERR) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[5]);
+	}
+	if (stat & MANTIS_INT_PPERR) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[6]);
+	}
+	if (stat & MANTIS_INT_FTRGT) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[7]);
+	}
+	if (stat & MANTIS_INT_RISCI) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[8]);
+		mantis->finished_block = (stat & MANTIS_INT_RISCSTAT) >> 28;
+		tasklet_schedule(&mantis->tasklet);
+	}
+	if (stat & MANTIS_INT_I2CDONE) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[9]);
+		wake_up(&mantis->i2c_wq);
+	}
+	mmwrite(stat, MANTIS_INT_STAT);
+	stat &= ~(MANTIS_INT_RISCEN   | MANTIS_INT_I2CDONE |
+		  MANTIS_INT_I2CRACK  | MANTIS_INT_PCMCIA7 |
+		  MANTIS_INT_PCMCIA6  | MANTIS_INT_PCMCIA5 |
+		  MANTIS_INT_PCMCIA4  | MANTIS_INT_PCMCIA3 |
+		  MANTIS_INT_PCMCIA2  | MANTIS_INT_PCMCIA1 |
+		  MANTIS_INT_PCMCIA0  | MANTIS_INT_IRQ1	   |
+		  MANTIS_INT_IRQ0     | MANTIS_INT_OCERR   |
+		  MANTIS_INT_PABORT   | MANTIS_INT_RIPERR  |
+		  MANTIS_INT_PPERR    | MANTIS_INT_FTRGT   |
+		  MANTIS_INT_RISCI);
+
+	if (stat)
+		dprintk(MANTIS_DEBUG, 0, "<Unknown> Stat=<%02x> Mask=<%02x>", stat, mask);
+
+	dprintk(MANTIS_DEBUG, 0, "\n");
+	return IRQ_HANDLED;
+}
+
+static int __devinit hopper_pci_probe(struct pci_dev *pdev, const struct pci_device_id *pci_id)
+{
+	struct mantis_pci *mantis;
+	struct mantis_hwconfig *config;
+	int err = 0;
+
+	mantis = kzalloc(sizeof (struct mantis_pci), GFP_KERNEL);
+	if (mantis == NULL) {
+		printk(KERN_ERR "%s ERROR: Out of memory\n", __func__);
+		err = -ENOMEM;
+		goto fail0;
+	}
+
+	mantis->num		= devs;
+	mantis->verbose		= verbose;
+	mantis->pdev		= pdev;
+	config			= (struct mantis_hwconfig *) pci_id->driver_data;
+	config->irq_handler	= &hopper_irq_handler;
+	mantis->hwconfig	= config;
+
+	err = mantis_pci_init(mantis);
+	if (err) {
+		dprintk(MANTIS_ERROR, 1, "ERROR: Mantis PCI initialization failed <%d>", err);
+		goto fail1;
+	}
+
+	err = mantis_stream_control(mantis, STREAM_TO_HIF);
+	if (err < 0) {
+		dprintk(MANTIS_ERROR, 1, "ERROR: Mantis stream control failed <%d>", err);
+		goto fail1;
+	}
+
+	err = mantis_i2c_init(mantis);
+	if (err < 0) {
+		dprintk(MANTIS_ERROR, 1, "ERROR: Mantis I2C initialization failed <%d>", err);
+		goto fail2;
+	}
+
+	err = mantis_get_mac(mantis);
+	if (err < 0) {
+		dprintk(MANTIS_ERROR, 1, "ERROR: Mantis MAC address read failed <%d>", err);
+		goto fail2;
+	}
+
+	err = mantis_dma_init(mantis);
+	if (err < 0) {
+		dprintk(MANTIS_ERROR, 1, "ERROR: Mantis DMA initialization failed <%d>", err);
+		goto fail3;
+	}
+
+	err = mantis_dvb_init(mantis);
+	if (err < 0) {
+		dprintk(MANTIS_ERROR, 1, "ERROR: Mantis DVB initialization failed <%d>", err);
+		goto fail4;
+	}
+	devs++;
+
+	return err;
+
+fail5:
+	dprintk(MANTIS_ERROR, 1, "ERROR: Mantis DVB exit! <%d>", err);
+	mantis_dvb_exit(mantis);
+
+fail4:
+	dprintk(MANTIS_ERROR, 1, "ERROR: Mantis DMA exit! <%d>", err);
+	mantis_dma_exit(mantis);
+
+fail3:
+	dprintk(MANTIS_ERROR, 1, "ERROR: Mantis I2C exit! <%d>", err);
+	mantis_i2c_exit(mantis);
+
+fail2:
+	dprintk(MANTIS_ERROR, 1, "ERROR: Mantis PCI exit! <%d>", err);
+	mantis_pci_exit(mantis);
+
+fail1:
+	dprintk(MANTIS_ERROR, 1, "ERROR: Mantis free! <%d>", err);
+	kfree(mantis);
+
+fail0:
+	return err;
+}
+
+static void __devexit hopper_pci_remove(struct pci_dev *pdev)
+{
+	struct mantis_pci *mantis = pci_get_drvdata(pdev);
+
+	if (mantis) {
+//		mantis_uart_exit(mantis);
+		mantis_dvb_exit(mantis);
+		mantis_dma_exit(mantis);
+		mantis_i2c_exit(mantis);
+		mantis_pci_exit(mantis);
+		kfree(mantis);
+	}
+	return;
+
+}
+
+static struct pci_device_id hopper_pci_table[] = {
+	MAKE_ENTRY(TWINHAN_TECHNOLOGIES, MANTIS_VP_3028_DVB_T, &vp3028_config),
+	{ }
+};
+
+static struct pci_driver hopper_pci_driver = {
+	.name		= DRIVER_NAME,
+	.id_table	= hopper_pci_table,
+	.probe		= hopper_pci_probe,
+	.remove		= hopper_pci_remove,
+};
+
+static int __devinit hopper_init(void)
+{
+	return pci_register_driver(&hopper_pci_driver);
+}
+
+static void __devexit hopper_exit(void)
+{
+	return pci_unregister_driver(&hopper_pci_driver);
+}
+
+module_init(hopper_init);
+module_exit(hopper_exit);
+
+MODULE_DESCRIPTION("HOPPER driver");
+MODULE_AUTHOR("Manu Abraham");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/dvb/mantis/hopper_vp3028.c b/drivers/media/dvb/mantis/hopper_vp3028.c
new file mode 100644
index 0000000..ba0c7e5
--- /dev/null
+++ b/drivers/media/dvb/mantis/hopper_vp3028.c
@@ -0,0 +1,76 @@
+/*
+	Mantis VP-3028 driver
+
+	Copyright (C) 2005, 2006 Manu Abraham (abraham.manu@gmail.com)
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <asm/irq.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
+#include "zl10353.h"
+#include "mantis_common.h"
+#include "mantis_ioc.h"
+#include "mantis_dvb.h"
+#include "hopper_vp3028.h"
+
+struct zl10353_config hopper_vp3028_config = {
+	.demod_address	= 0x0f,
+};
+
+#define MANTIS_MODEL_NAME	"VP-3028"
+#define MANTIS_DEV_TYPE		"DVB-T"
+
+static int vp3028_frontend_init(struct mantis_pci *mantis, struct dvb_frontend *fe)
+{
+	struct i2c_adapter *adapter	= &mantis->adapter;
+	int err = 0;
+
+	err = mantis_frontend_power(mantis, POWER_ON);
+	mantis_frontend_soft_reset(mantis);
+
+	dprintk(MANTIS_ERROR, 1, "Probing for 10353 (DVB-T)");
+	fe = zl10353_attach(&hopper_vp3028_config, adapter);
+
+	if (!fe)
+		return -1;
+
+	dprintk(MANTIS_ERROR, 1, "Done!");
+
+	return 0;
+}
+
+struct mantis_hwconfig vp3028_config = {
+	.model_name	= MANTIS_MODEL_NAME,
+	.dev_type	= MANTIS_DEV_TYPE,
+	.ts_size	= MANTIS_TS_188,
+
+	.baud_rate	= MANTIS_BAUD_9600,
+	.parity		= MANTIS_PARITY_NONE,
+	.bytes		= 0,
+
+	.frontend_init	= vp3028_frontend_init,
+	.power		= GPIF_A00,
+	.reset		= GPIF_A03,
+};
diff --git a/drivers/media/dvb/mantis/hopper_vp3028.h b/drivers/media/dvb/mantis/hopper_vp3028.h
new file mode 100644
index 0000000..e8a3c22
--- /dev/null
+++ b/drivers/media/dvb/mantis/hopper_vp3028.h
@@ -0,0 +1,10 @@
+#ifndef __MANTIS_VP3028_H
+#define __MANTIS_VP3028_H
+
+#include "mantis_common.h"
+
+#define MANTIS_VP_3028_DVB_T	0x0028
+
+extern struct mantis_hwconfig vp3028_config;
+
+#endif /* __MANTIS_VP3028_H */
diff --git a/drivers/media/dvb/mantis/mantis_ca.c b/drivers/media/dvb/mantis/mantis_ca.c
index 7aa27e0..4151cba 100644
--- a/drivers/media/dvb/mantis/mantis_ca.c
+++ b/drivers/media/dvb/mantis/mantis_ca.c
@@ -18,16 +18,30 @@
 	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
+#include <asm/irq.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
 #include "mantis_common.h"
 #include "mantis_link.h"
 #include "mantis_hif.h"
+#include "mantis_reg.h"
+
+#include "mantis_ca.h"
 
 static int mantis_ca_read_attr_mem(struct dvb_ca_en50221 *en50221, int slot, int addr)
 {
 	struct mantis_ca *ca = en50221->data;
 	struct mantis_pci *mantis = ca->ca_priv;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Slot(%d): Request Attribute Mem Read", slot);
+	dprintk(MANTIS_DEBUG, 1, "Slot(%d): Request Attribute Mem Read", slot);
 
 	if (slot != 0)
 		return -EINVAL;
@@ -40,7 +54,7 @@ static int mantis_ca_write_attr_mem(struct dvb_ca_en50221 *en50221, int slot, in
 	struct mantis_ca *ca = en50221->data;
 	struct mantis_pci *mantis = ca->ca_priv;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Slot(%d): Request Attribute Mem Write", slot);
+	dprintk(MANTIS_DEBUG, 1, "Slot(%d): Request Attribute Mem Write", slot);
 
 	if (slot != 0)
 		return -EINVAL;
@@ -53,7 +67,7 @@ static int mantis_ca_read_cam_ctl(struct dvb_ca_en50221 *en50221, int slot, u8 a
 	struct mantis_ca *ca = en50221->data;
 	struct mantis_pci *mantis = ca->ca_priv;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Slot(%d): Request CAM control Read", slot);
+	dprintk(MANTIS_DEBUG, 1, "Slot(%d): Request CAM control Read", slot);
 
 	if (slot != 0)
 		return -EINVAL;
@@ -66,7 +80,7 @@ static int mantis_ca_write_cam_ctl(struct dvb_ca_en50221 *en50221, int slot, u8
 	struct mantis_ca *ca = en50221->data;
 	struct mantis_pci *mantis = ca->ca_priv;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Slot(%d): Request CAM control Write", slot);
+	dprintk(MANTIS_DEBUG, 1, "Slot(%d): Request CAM control Write", slot);
 
 	if (slot != 0)
 		return -EINVAL;
@@ -79,7 +93,7 @@ static int mantis_ca_slot_reset(struct dvb_ca_en50221 *en50221, int slot)
 	struct mantis_ca *ca = en50221->data;
 	struct mantis_pci *mantis = ca->ca_priv;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Slot(%d): Slot RESET", slot);
+	dprintk(MANTIS_DEBUG, 1, "Slot(%d): Slot RESET", slot);
 	udelay(500); /* Wait.. */
 	mmwrite(0xda, MANTIS_PCMCIA_RESET); /* Leading edge assert */
 	udelay(500);
@@ -95,7 +109,7 @@ static int mantis_ca_slot_shutdown(struct dvb_ca_en50221 *en50221, int slot)
 	struct mantis_ca *ca = en50221->data;
 	struct mantis_pci *mantis = ca->ca_priv;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Slot(%d): Slot shutdown", slot);
+	dprintk(MANTIS_DEBUG, 1, "Slot(%d): Slot shutdown", slot);
 
 	return 0;
 }
@@ -105,8 +119,8 @@ static int mantis_ts_control(struct dvb_ca_en50221 *en50221, int slot)
 	struct mantis_ca *ca = en50221->data;
 	struct mantis_pci *mantis = ca->ca_priv;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Slot(%d): TS control", slot);
-	mantis_set_direction(mantis, 1); /* Enable TS through CAM */
+	dprintk(MANTIS_DEBUG, 1, "Slot(%d): TS control", slot);
+//	mantis_set_direction(mantis, 1); /* Enable TS through CAM */
 
 	return 0;
 }
@@ -116,13 +130,13 @@ static int mantis_slot_status(struct dvb_ca_en50221 *en50221, int slot, int open
 	struct mantis_ca *ca = en50221->data;
 	struct mantis_pci *mantis = ca->ca_priv;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Slot(%d): Poll Slot status", slot);
+	dprintk(MANTIS_DEBUG, 1, "Slot(%d): Poll Slot status", slot);
 
 	if (ca->slot_state == MODULE_INSERTED) {
-		dprintk(verbose, MANTIS_DEBUG, 1, "CA Module present and ready");
+		dprintk(MANTIS_DEBUG, 1, "CA Module present and ready");
 		return DVB_CA_EN50221_POLL_CAM_PRESENT | DVB_CA_EN50221_POLL_CAM_READY;
 	} else {
-		dprintk(verbose, MANTIS_DEBUG, 1, "CA Module not present or not ready");
+		dprintk(MANTIS_DEBUG, 1, "CA Module not present or not ready");
 	}
 
 	return 0;
@@ -130,20 +144,21 @@ static int mantis_slot_status(struct dvb_ca_en50221 *en50221, int slot, int open
 
 int mantis_ca_init(struct mantis_pci *mantis)
 {
-	struct dvb_adapter *dvb_adapter = &mantis->dvb_adapter;
+	struct dvb_adapter *dvb_adapter	= &mantis->dvb_adapter;
 	struct mantis_ca *ca;
 	int ca_flags = 0, result;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Initializing Mantis CA");
-	if (!(ca = kzalloc(sizeof (struct mantis_ca), GFP_KERNEL))) {
-		dprintk(verbose, MANTIS_ERROR, 1, "Out of memory!, exiting ..");
+	dprintk(MANTIS_DEBUG, 1, "Initializing Mantis CA");
+	ca = kzalloc(sizeof (struct mantis_ca), GFP_KERNEL);
+	if (!ca) {
+		dprintk(MANTIS_ERROR, 1, "Out of memory!, exiting ..");
 		result = -ENOMEM;
 		goto err;
 	}
 
-	ca->ca_priv = mantis;
-	mantis->mantis_ca = ca;
-	ca_flags = DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE;
+	ca->ca_priv		= mantis;
+	mantis->mantis_ca	= ca;
+	ca_flags		= DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE;
 	/* register CA interface */
 	ca->en50221.owner		= THIS_MODULE;
 	ca->en50221.read_attribute_mem	= mantis_ca_read_attr_mem;
@@ -162,28 +177,32 @@ int mantis_ca_init(struct mantis_pci *mantis)
 	init_waitqueue_head(&ca->hif_opdone_wq);
 	init_waitqueue_head(&ca->hif_write_wq);
 
-	dprintk(verbose, MANTIS_ERROR, 1, "Registering EN50221 device");
-	if ((result = dvb_ca_en50221_init(dvb_adapter, &ca->en50221, ca_flags, 1)) != 0) {
-		dprintk(verbose, MANTIS_ERROR, 1, "EN50221: Initialization failed");
+	dprintk(MANTIS_ERROR, 1, "Registering EN50221 device");
+	result = dvb_ca_en50221_init(dvb_adapter, &ca->en50221, ca_flags, 1);
+	if (result != 0) {
+		dprintk(MANTIS_ERROR, 1, "EN50221: Initialization failed <%d>", result);
 		goto err;
 	}
-	dprintk(verbose, MANTIS_ERROR, 1, "Registered EN50221 device");
+	dprintk(MANTIS_ERROR, 1, "Registered EN50221 device");
 	mantis_evmgr_init(ca);
 	return 0;
 err:
 	kfree(ca);
 	return result;
 }
+EXPORT_SYMBOL_GPL(mantis_ca_init);
 
 void mantis_ca_exit(struct mantis_pci *mantis)
 {
 	struct mantis_ca *ca = mantis->mantis_ca;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Mantis CA exit");
+	dprintk(MANTIS_DEBUG, 1, "Mantis CA exit");
 
 	mantis_evmgr_exit(ca);
-	dprintk(verbose, MANTIS_ERROR, 1, "Unregistering EN50221 device");
-	dvb_ca_en50221_release(&ca->en50221);
+	dprintk(MANTIS_ERROR, 1, "Unregistering EN50221 device");
+	if (ca)
+		dvb_ca_en50221_release(&ca->en50221);
 
 	kfree(ca);
 }
+EXPORT_SYMBOL_GPL(mantis_ca_exit);
diff --git a/drivers/media/dvb/mantis/mantis_ca.h b/drivers/media/dvb/mantis/mantis_ca.h
new file mode 100644
index 0000000..b7e48ee
--- /dev/null
+++ b/drivers/media/dvb/mantis/mantis_ca.h
@@ -0,0 +1,7 @@
+#ifndef __MANTIS_CA_H
+#define __MANTIS_CA_H
+
+extern int mantis_ca_init(struct mantis_pci *mantis);
+extern void mantis_ca_exit(struct mantis_pci *mantis);
+
+#endif /* __MANTIS_CA_H */
diff --git a/drivers/media/dvb/mantis/mantis_cards.c b/drivers/media/dvb/mantis/mantis_cards.c
new file mode 100644
index 0000000..d486c7f
--- /dev/null
+++ b/drivers/media/dvb/mantis/mantis_cards.c
@@ -0,0 +1,279 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <asm/irq.h>
+#include <linux/interrupt.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
+#include "mantis_common.h"
+
+#include "mantis_vp1033.h"
+#include "mantis_vp1034.h"
+#include "mantis_vp1041.h"
+#include "mantis_vp2033.h"
+#include "mantis_vp2040.h"
+#include "mantis_vp3030.h"
+
+#include "mantis_dma.h"
+#include "mantis_ca.h"
+#include "mantis_dvb.h"
+#include "mantis_uart.h"
+#include "mantis_ioc.h"
+#include "mantis_pci.h"
+#include "mantis_i2c.h"
+#include "mantis_reg.h"
+
+static unsigned int verbose;
+module_param(verbose, int, 0644);
+MODULE_PARM_DESC(verbose, "verbose startup messages, default is 1 (yes)");
+
+static int devs;
+
+#define DRIVER_NAME	"Mantis"
+
+static char *label[10] = {
+	"DMA",
+	"IRQ-0",
+	"IRQ-1",
+	"OCERR",
+	"PABRT",
+	"RIPRR",
+	"PPERR",
+	"FTRGT",
+	"RISCI",
+	"RACK"
+};
+
+
+static irqreturn_t mantis_irq_handler(int irq, void *dev_id)
+{
+	u32 stat = 0, mask = 0, lstat = 0, mstat = 0;
+	u32 rst_stat = 0, rst_mask = 0;
+
+	struct mantis_pci *mantis;
+	struct mantis_ca *ca;
+
+	mantis = (struct mantis_pci *) dev_id;
+	if (unlikely(mantis == NULL)) {
+		dprintk(MANTIS_ERROR, 1, "Mantis == NULL");
+		return IRQ_NONE;
+	}
+	ca = mantis->mantis_ca;
+
+	stat = mmread(MANTIS_INT_STAT);
+	mask = mmread(MANTIS_INT_MASK);
+	mstat = lstat = stat & ~MANTIS_INT_RISCSTAT;
+	if (!(stat & mask))
+		return IRQ_NONE;
+
+	rst_mask  = MANTIS_GPIF_WRACK  |
+		    MANTIS_GPIF_OTHERR |
+		    MANTIS_SBUF_WSTO   |
+		    MANTIS_GPIF_EXTIRQ;
+
+	rst_stat  = mmread(MANTIS_GPIF_STATUS);
+	rst_stat &= rst_mask;
+	mmwrite(rst_stat, MANTIS_GPIF_STATUS);
+
+	mantis->mantis_int_stat = stat;
+	mantis->mantis_int_mask = mask;
+	dprintk(MANTIS_DEBUG, 0, "\n-- Stat=<%02x> Mask=<%02x> --", stat, mask);
+	if (stat & MANTIS_INT_RISCEN) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[0]);
+	}
+	if (stat & MANTIS_INT_IRQ0) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[1]);
+		mantis->gpif_status = rst_stat;
+		wake_up(&ca->hif_write_wq);
+		schedule_work(&ca->hif_evm_work);
+	}
+	if (stat & MANTIS_INT_IRQ1) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[2]);
+		schedule_work(&mantis->uart_work);
+	}
+	if (stat & MANTIS_INT_OCERR) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[3]);
+	}
+	if (stat & MANTIS_INT_PABORT) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[4]);
+	}
+	if (stat & MANTIS_INT_RIPERR) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[5]);
+	}
+	if (stat & MANTIS_INT_PPERR) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[6]);
+	}
+	if (stat & MANTIS_INT_FTRGT) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[7]);
+	}
+	if (stat & MANTIS_INT_RISCI) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[8]);
+		mantis->finished_block = (stat & MANTIS_INT_RISCSTAT) >> 28;
+		tasklet_schedule(&mantis->tasklet);
+	}
+	if (stat & MANTIS_INT_I2CDONE) {
+		dprintk(MANTIS_DEBUG, 0, "<%s>", label[9]);
+		wake_up(&mantis->i2c_wq);
+	}
+	mmwrite(stat, MANTIS_INT_STAT);
+	stat &= ~(MANTIS_INT_RISCEN   | MANTIS_INT_I2CDONE |
+		  MANTIS_INT_I2CRACK  | MANTIS_INT_PCMCIA7 |
+		  MANTIS_INT_PCMCIA6  | MANTIS_INT_PCMCIA5 |
+		  MANTIS_INT_PCMCIA4  | MANTIS_INT_PCMCIA3 |
+		  MANTIS_INT_PCMCIA2  | MANTIS_INT_PCMCIA1 |
+		  MANTIS_INT_PCMCIA0  | MANTIS_INT_IRQ1	   |
+		  MANTIS_INT_IRQ0     | MANTIS_INT_OCERR   |
+		  MANTIS_INT_PABORT   | MANTIS_INT_RIPERR  |
+		  MANTIS_INT_PPERR    | MANTIS_INT_FTRGT   |
+		  MANTIS_INT_RISCI);
+
+	if (stat)
+		dprintk(MANTIS_DEBUG, 0, "<Unknown> Stat=<%02x> Mask=<%02x>", stat, mask);
+
+	dprintk(MANTIS_DEBUG, 0, "\n");
+	return IRQ_HANDLED;
+}
+
+static int __devinit mantis_pci_probe(struct pci_dev *pdev, const struct pci_device_id *pci_id)
+{
+	struct mantis_pci *mantis;
+	struct mantis_hwconfig *config;
+	int err = 0;
+
+	mantis = kzalloc(sizeof (struct mantis_pci), GFP_KERNEL);
+	if (mantis == NULL) {
+		printk(KERN_ERR "%s ERROR: Out of memory\n", __func__);
+		err = -ENOMEM;
+		goto fail0;
+	}
+
+	mantis->num		= devs;
+	mantis->verbose		= verbose;
+	mantis->pdev		= pdev;
+	config			= (struct mantis_hwconfig *) pci_id->driver_data;
+	config->irq_handler	= &mantis_irq_handler;
+	mantis->hwconfig	= config;
+
+	err = mantis_pci_init(mantis);
+	if (err) {
+		dprintk(MANTIS_ERROR, 1, "ERROR: Mantis PCI initialization failed <%d>", err);
+		goto fail1;
+	}
+
+	err = mantis_stream_control(mantis, STREAM_TO_HIF);
+	if (err < 0) {
+		dprintk(MANTIS_ERROR, 1, "ERROR: Mantis stream control failed <%d>", err);
+		goto fail1;
+	}
+
+	err = mantis_i2c_init(mantis);
+	if (err < 0) {
+		dprintk(MANTIS_ERROR, 1, "ERROR: Mantis I2C initialization failed <%d>", err);
+		goto fail2;
+	}
+
+	err = mantis_get_mac(mantis);
+	if (err < 0) {
+		dprintk(MANTIS_ERROR, 1, "ERROR: Mantis MAC address read failed <%d>", err);
+		goto fail2;
+	}
+
+	err = mantis_dma_init(mantis);
+	if (err < 0) {
+		dprintk(MANTIS_ERROR, 1, "ERROR: Mantis DMA initialization failed <%d>", err);
+		goto fail3;
+	}
+
+	err = mantis_dvb_init(mantis);
+	if (err < 0) {
+		dprintk(MANTIS_ERROR, 1, "ERROR: Mantis DVB initialization failed <%d>", err);
+		goto fail4;
+	}
+	devs++;
+
+	return err;
+
+fail5:
+	dprintk(MANTIS_ERROR, 1, "ERROR: Mantis DVB exit! <%d>", err);
+	mantis_dvb_exit(mantis);
+
+fail4:
+	dprintk(MANTIS_ERROR, 1, "ERROR: Mantis DMA exit! <%d>", err);
+	mantis_dma_exit(mantis);
+
+fail3:
+	dprintk(MANTIS_ERROR, 1, "ERROR: Mantis I2C exit! <%d>", err);
+	mantis_i2c_exit(mantis);
+
+fail2:
+	dprintk(MANTIS_ERROR, 1, "ERROR: Mantis PCI exit! <%d>", err);
+	mantis_pci_exit(mantis);
+
+fail1:
+	dprintk(MANTIS_ERROR, 1, "ERROR: Mantis free! <%d>", err);
+	kfree(mantis);
+
+fail0:
+	return err;
+}
+
+static void __devexit mantis_pci_remove(struct pci_dev *pdev)
+{
+	struct mantis_pci *mantis = pci_get_drvdata(pdev);
+
+	if (mantis) {
+		mantis_uart_exit(mantis);
+//		mantis_ca_exit(mantis);
+		mantis_dvb_exit(mantis);
+		mantis_dma_exit(mantis);
+		mantis_i2c_exit(mantis);
+		mantis_pci_exit(mantis);
+		kfree(mantis);
+	}
+	return;
+}
+
+static struct pci_device_id mantis_pci_table[] = {
+	MAKE_ENTRY(TWINHAN_TECHNOLOGIES, MANTIS_VP_1033_DVB_S, &vp1033_config),
+	MAKE_ENTRY(TWINHAN_TECHNOLOGIES, MANTIS_VP_1034_DVB_S, &vp1034_config),
+	MAKE_ENTRY(TWINHAN_TECHNOLOGIES, MANTIS_VP_1041_DVB_S2, &vp1041_config),
+	MAKE_ENTRY(TECHNISAT, SKYSTAR_HD2_10, &vp1041_config),
+	MAKE_ENTRY(TECHNISAT, SKYSTAR_HD2_20, &vp1041_config),
+	MAKE_ENTRY(TERRATEC, CINERGY_S2_PCI_HD, &vp1041_config),
+	MAKE_ENTRY(TWINHAN_TECHNOLOGIES, MANTIS_VP_2033_DVB_C, &vp2033_config),
+	MAKE_ENTRY(TWINHAN_TECHNOLOGIES, MANTIS_VP_2040_DVB_C, &vp2040_config),
+	MAKE_ENTRY(TECHNISAT, CABLESTAR_HD2, &vp2040_config),
+	MAKE_ENTRY(TERRATEC, CINERGY_C, &vp2033_config),
+	MAKE_ENTRY(TWINHAN_TECHNOLOGIES, MANTIS_VP_3030_DVB_T, &vp3030_config),
+	{ }
+};
+
+static struct pci_driver mantis_pci_driver = {
+	.name		= DRIVER_NAME,
+	.id_table	= mantis_pci_table,
+	.probe		= mantis_pci_probe,
+	.remove		= mantis_pci_remove,
+};
+
+static int __devinit mantis_init(void)
+{
+	return pci_register_driver(&mantis_pci_driver);
+}
+
+static void __devexit mantis_exit(void)
+{
+	return pci_unregister_driver(&mantis_pci_driver);
+}
+
+module_init(mantis_init);
+module_exit(mantis_exit);
+
+MODULE_DESCRIPTION("MANTIS driver");
+MODULE_AUTHOR("Manu Abraham");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/dvb/mantis/mantis_common.h b/drivers/media/dvb/mantis/mantis_common.h
index 6a02adf..e912c59 100644
--- a/drivers/media/dvb/mantis/mantis_common.h
+++ b/drivers/media/dvb/mantis/mantis_common.h
@@ -21,20 +21,9 @@
 #ifndef __MANTIS_COMMON_H
 #define __MANTIS_COMMON_H
 
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/pci.h>
 #include <linux/mutex.h>
 #include <linux/workqueue.h>
 
-#include "dvbdev.h"
-#include "dvb_demux.h"
-#include "dmxdev.h"
-#include "dvb_frontend.h"
-#include "dvb_net.h"
-#include <linux/i2c.h>
-#include "mantis_reg.h"
 #include "mantis_uart.h"
 
 #include "mantis_link.h"
@@ -44,18 +33,18 @@
 #define MANTIS_INFO		2
 #define MANTIS_DEBUG		3
 
-#define dprintk(x, y, z, format, arg...) do {								\
+#define dprintk(y, z, format, arg...) do {								\
 	if (z) {											\
-		if	((x > MANTIS_ERROR) && (x > y))							\
+		if	((mantis->verbose > MANTIS_ERROR) && (mantis->verbose > y))			\
 			printk(KERN_ERR "%s (%d): " format "\n" , __func__ , mantis->num , ##arg);	\
-		else if	((x > MANTIS_NOTICE) && (x > y))						\
+		else if	((mantis->verbose > MANTIS_NOTICE) && (mantis->verbose > y))			\
 			printk(KERN_NOTICE "%s (%d): " format "\n" , __func__ , mantis->num , ##arg);	\
-		else if ((x > MANTIS_INFO) && (x > y))							\
+		else if ((mantis->verbose > MANTIS_INFO) && (mantis->verbose > y))			\
 			printk(KERN_INFO "%s (%d): " format "\n" , __func__ , mantis->num , ##arg);	\
-		else if ((x > MANTIS_DEBUG) && (x > y))							\
+		else if ((mantis->verbose > MANTIS_DEBUG) && (mantis->verbose > y))			\
 			printk(KERN_DEBUG "%s (%d): " format "\n" , __func__ , mantis->num , ##arg);	\
 	} else {											\
-		if (x > y)										\
+		if (mantis->verbose > y)								\
 			printk(format , ##arg);								\
 	}												\
 } while(0)
@@ -63,8 +52,8 @@
 #define mwrite(dat, addr)	writel((dat), addr)
 #define mread(addr)		readl(addr)
 
-#define mmwrite(dat, addr)	mwrite((dat), (mantis->mantis_mmio + (addr)))
-#define mmread(addr)		mread(mantis->mantis_mmio + (addr))
+#define mmwrite(dat, addr)	mwrite((dat), (mantis->mmio + (addr)))
+#define mmread(addr)		mread(mantis->mmio + (addr))
 #define mmand(dat, addr)	mmwrite((dat) & mmread(addr), addr)
 #define mmor(dat, addr)		mmwrite((dat) | mmread(addr), addr)
 #define mmaor(dat, addr)	mmwrite((dat) | ((mask) & mmread(addr)), addr)
@@ -72,6 +61,22 @@
 #define MANTIS_TS_188		0
 #define MANTIS_TS_204		1
 
+#define TWINHAN_TECHNOLOGIES	0x1822
+#define MANTIS			0x4e35
+
+#define TECHNISAT		0x1ae4
+#define TERRATEC		0x153b
+
+#define MAKE_ENTRY(__subven, __subdev, __configptr) {			\
+		.vendor		= TWINHAN_TECHNOLOGIES,			\
+		.device		= MANTIS,				\
+		.subvendor	= (__subven),				\
+		.subdevice	= (__subdev),				\
+		.driver_data	= (unsigned long) (__configptr)		\
+}
+
+struct mantis_pci;
+
 struct mantis_hwconfig {
 	char			*model_name;
 	char			*dev_type;
@@ -80,6 +85,12 @@ struct mantis_hwconfig {
 	enum mantis_baud	baud_rate;
 	enum mantis_parity	parity;
 	u32			bytes;
+
+	irqreturn_t (*irq_handler)(int irq, void *dev_id);
+	int (*frontend_init)(struct mantis_pci *mantis, struct dvb_frontend *fe);
+
+	u8			power;
+	u8			reset;
 };
 
 struct mantis_pci {
@@ -96,7 +107,7 @@ struct mantis_pci {
 	struct pci_dev		*pdev;
 
 	unsigned long		mantis_addr;
-	volatile void __iomem	*mantis_mmio;
+	void __iomem		*mmio;
 
 	u8			irq;
 	u8			revision;
@@ -156,19 +167,4 @@ struct mantis_pci {
 
 #define MANTIS_HIF_STATUS	(mantis->gpio_status)
 
-extern unsigned int verbose;
-extern unsigned int devs;
-extern unsigned int i2c;
-extern int mantis_dvb_init(struct mantis_pci *mantis);
-extern int mantis_frontend_init(struct mantis_pci *mantis);
-extern int mantis_dvb_exit(struct mantis_pci *mantis);
-extern void mantis_dma_xfer(unsigned long data);
-extern void gpio_set_bits(struct mantis_pci *mantis, u32 bitpos, u8 value);
-
-extern void mantis_set_direction(struct mantis_pci *mantis, int direction);
-
-extern int mantis_ca_init(struct mantis_pci *mantis);
-extern void mantis_ca_exit(struct mantis_pci *mantis);
-
-
-#endif //__MANTIS_COMMON_H
+#endif /* __MANTIS_COMMON_H */
diff --git a/drivers/media/dvb/mantis/mantis_dma.c b/drivers/media/dvb/mantis/mantis_dma.c
index d15a1eb..8ebcd96 100644
--- a/drivers/media/dvb/mantis/mantis_dma.c
+++ b/drivers/media/dvb/mantis/mantis_dma.c
@@ -18,9 +18,25 @@
 	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
+#include <linux/kernel.h>
 #include <asm/page.h>
 #include <linux/vmalloc.h>
+#include <linux/pci.h>
+
+#include <asm/irq.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
 #include "mantis_common.h"
+#include "mantis_reg.h"
+#include "mantis_dma.h"
 
 #define RISC_WRITE		(0x01 << 28)
 #define RISC_JUMP		(0x07 << 28)
@@ -38,7 +54,7 @@
 int mantis_dma_exit(struct mantis_pci *mantis)
 {
 	if (mantis->buf_cpu) {
-		dprintk(verbose, MANTIS_ERROR, 1,
+		dprintk(MANTIS_ERROR, 1,
 			"DMA=0x%lx cpu=0x%p size=%d",
 			(unsigned long) mantis->buf_dma,
 			 mantis->buf_cpu,
@@ -50,7 +66,7 @@ int mantis_dma_exit(struct mantis_pci *mantis)
 		mantis->buf_cpu = NULL;
 	}
 	if (mantis->risc_cpu) {
-		dprintk(verbose, MANTIS_ERROR, 1,
+		dprintk(MANTIS_ERROR, 1,
 			"RISC=0x%lx cpu=0x%p size=%lx",
 			(unsigned long) mantis->risc_dma,
 			mantis->risc_cpu,
@@ -64,6 +80,7 @@ int mantis_dma_exit(struct mantis_pci *mantis)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(mantis_dma_exit);
 
 static inline int mantis_alloc_buffers(struct mantis_pci *mantis)
 {
@@ -72,12 +89,12 @@ static inline int mantis_alloc_buffers(struct mantis_pci *mantis)
 						       MANTIS_BUF_SIZE,
 						       &mantis->buf_dma);
 		if (!mantis->buf_cpu) {
-			dprintk(verbose, MANTIS_ERROR, 1,
+			dprintk(MANTIS_ERROR, 1,
 				"DMA buffer allocation failed");
 
 			goto err;
 		}
-		dprintk(verbose, MANTIS_ERROR, 1,
+		dprintk(MANTIS_ERROR, 1,
 			"DMA=0x%lx cpu=0x%p size=%d",
 			(unsigned long) mantis->buf_dma,
 			mantis->buf_cpu, MANTIS_BUF_SIZE);
@@ -88,14 +105,14 @@ static inline int mantis_alloc_buffers(struct mantis_pci *mantis)
 							&mantis->risc_dma);
 
 		if (!mantis->risc_cpu) {
-			dprintk(verbose, MANTIS_ERROR, 1,
+			dprintk(MANTIS_ERROR, 1,
 				"RISC program allocation failed");
 
 			mantis_dma_exit(mantis);
 
 			goto err;
 		}
-		dprintk(verbose, MANTIS_ERROR, 1,
+		dprintk(MANTIS_ERROR, 1,
 			"RISC=0x%lx cpu=0x%p size=%lx",
 			(unsigned long) mantis->risc_dma,
 			mantis->risc_cpu, MANTIS_RISC_SIZE);
@@ -103,7 +120,7 @@ static inline int mantis_alloc_buffers(struct mantis_pci *mantis)
 
 	return 0;
 err:
-	dprintk(verbose, MANTIS_ERROR, 1, "Out of memory (?) .....");
+	dprintk(MANTIS_ERROR, 1, "Out of memory (?) .....");
 	return -ENOMEM;
 }
 
@@ -117,12 +134,11 @@ static inline int mantis_calc_lines(struct mantis_pci *mantis)
 		mantis->line_count <<= 1;
 	}
 
-	dprintk(verbose, MANTIS_DEBUG, 1,
-		"Mantis RISC block bytes=[%d], line bytes=[%d], line count=[%d]",
+	dprintk(MANTIS_DEBUG, 1, "Mantis RISC block bytes=[%d], line bytes=[%d], line count=[%d]",
 		MANTIS_BLOCK_BYTES, mantis->line_bytes, mantis->line_count);
 
 	if (mantis->line_count > 255) {
-		dprintk(verbose, MANTIS_ERROR, 1, "Buffer size error");
+		dprintk(MANTIS_ERROR, 1, "Buffer size error");
 		return -EINVAL;
 	}
 
@@ -133,9 +149,9 @@ int mantis_dma_init(struct mantis_pci *mantis)
 {
 	int err = 0;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Mantis DMA init");
+	dprintk(MANTIS_DEBUG, 1, "Mantis DMA init");
 	if (mantis_alloc_buffers(mantis) < 0) {
-		dprintk(verbose, MANTIS_ERROR, 1, "Error allocating DMA buffer");
+		dprintk(MANTIS_ERROR, 1, "Error allocating DMA buffer");
 
 		// Stop RISC Engine
 //		mmwrite(mmread(MANTIS_DMA_CTL) & ~MANTIS_RISC_EN, MANTIS_DMA_CTL);
@@ -144,7 +160,7 @@ int mantis_dma_init(struct mantis_pci *mantis)
 		goto err;
 	}
 	if ((err = mantis_calc_lines(mantis)) < 0) {
-		dprintk(verbose, MANTIS_ERROR, 1, "Mantis calc lines failed");
+		dprintk(MANTIS_ERROR, 1, "Mantis calc lines failed");
 
 		goto err;
 	}
@@ -153,20 +169,21 @@ int mantis_dma_init(struct mantis_pci *mantis)
 err:
 	return err;
 }
+EXPORT_SYMBOL_GPL(mantis_dma_init);
 
 static inline void mantis_risc_program(struct mantis_pci *mantis)
 {
 	u32 buf_pos = 0;
 	u32 line;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Mantis create RISC program");
+	dprintk(MANTIS_DEBUG, 1, "Mantis create RISC program");
 	RISC_FLUSH();
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "risc len lines %u, bytes per line %u",
+	dprintk(MANTIS_DEBUG, 1, "risc len lines %u, bytes per line %u",
 		mantis->line_count, mantis->line_bytes);
 
 	for (line = 0; line < mantis->line_count; line++) {
-		dprintk(verbose, MANTIS_DEBUG, 1, "RISC PROG line=[%d]", line);
+		dprintk(MANTIS_DEBUG, 1, "RISC PROG line=[%d]", line);
 		if (!(buf_pos % MANTIS_BLOCK_BYTES)) {
 			RISC_INSTR(RISC_WRITE	|
 				   RISC_IRQ	|
@@ -186,7 +203,7 @@ static inline void mantis_risc_program(struct mantis_pci *mantis)
 
 void mantis_dma_start(struct mantis_pci *mantis)
 {
-	dprintk(verbose, MANTIS_DEBUG, 1, "Mantis Start DMA engine");
+	dprintk(MANTIS_DEBUG, 1, "Mantis Start DMA engine");
 
 	mantis_risc_program(mantis);
 	mmwrite(mantis->risc_dma, MANTIS_RISC_START);
@@ -208,7 +225,7 @@ void mantis_dma_stop(struct mantis_pci *mantis)
 
 	stat = mmread(MANTIS_INT_STAT);
 	mask = mmread(MANTIS_INT_MASK);
-	dprintk(verbose, MANTIS_DEBUG, 1, "Mantis Stop DMA engine");
+	dprintk(MANTIS_DEBUG, 1, "Mantis Stop DMA engine");
 
 	mmwrite((mmread(MANTIS_GPIF_ADDR) & (~(MANTIS_GPIF_HIFRDWRN))), MANTIS_GPIF_ADDR);
 
@@ -229,7 +246,7 @@ void mantis_dma_xfer(unsigned long data)
 	struct mantis_hwconfig *config = mantis->hwconfig;
 
 	while (mantis->last_block != mantis->finished_block) {
-		dprintk(verbose, MANTIS_DEBUG, 1, "last block=[%d] finished block=[%d]",
+		dprintk(MANTIS_DEBUG, 1, "last block=[%d] finished block=[%d]",
 			mantis->last_block, mantis->finished_block);
 
 		(config->ts_size ? dvb_dmx_swfilter_204: dvb_dmx_swfilter)
diff --git a/drivers/media/dvb/mantis/mantis_dma.h b/drivers/media/dvb/mantis/mantis_dma.h
new file mode 100644
index 0000000..4cba876
--- /dev/null
+++ b/drivers/media/dvb/mantis/mantis_dma.h
@@ -0,0 +1,10 @@
+#ifndef __MANTIS_DMA_H
+#define __MANTIS_DMA_H
+
+extern int mantis_dma_init(struct mantis_pci *mantis);
+extern int mantis_dma_exit(struct mantis_pci *mantis);
+extern void mantis_dma_start(struct mantis_pci *mantis);
+extern void mantis_dma_stop(struct mantis_pci *mantis);
+extern void mantis_dma_xfer(unsigned long data);
+
+#endif /* __MANTIS_DMA_H */
diff --git a/drivers/media/dvb/mantis/mantis_dvb.c b/drivers/media/dvb/mantis/mantis_dvb.c
index de18bb9..be911d7 100644
--- a/drivers/media/dvb/mantis/mantis_dvb.c
+++ b/drivers/media/dvb/mantis/mantis_dvb.c
@@ -17,65 +17,86 @@
 	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
+#include <linux/kernel.h>
 #include <linux/bitops.h>
-#include "mantis_common.h"
-#include "mantis_core.h"
+
+#include <asm/irq.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/i2c.h>
 
 #include "dmxdev.h"
 #include "dvbdev.h"
 #include "dvb_demux.h"
 #include "dvb_frontend.h"
-#include "mantis_vp1033.h"
-#include "mantis_vp1034.h"
-#include "mantis_vp1041.h"
-#include "mantis_vp2033.h"
-#include "mantis_vp2040.h"
-#include "mantis_vp3030.h"
+#include "dvb_net.h"
 
-DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+#include "mantis_common.h"
+#include "mantis_dma.h"
+#include "mantis_ca.h"
+#include "mantis_ioc.h"
+#include "mantis_dvb.h"
 
-/*	Tuner power supply control	*/
-void mantis_fe_powerup(struct mantis_pci *mantis)
-{
-	dprintk(verbose, MANTIS_DEBUG, 1, "Frontend Power ON");
-	gpio_set_bits(mantis, 0x0c, 1);
-	msleep_interruptible(100);
-	gpio_set_bits(mantis, 0x0c, 1);
-	msleep_interruptible(100);
-}
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
 
-void mantis_fe_powerdown(struct mantis_pci *mantis)
+int mantis_frontend_power(struct mantis_pci *mantis, enum mantis_power power)
 {
-	dprintk(verbose, MANTIS_DEBUG, 1, "Frontend Power OFF");
-	gpio_set_bits(mantis, 0x0c, 0);
-}
+	struct mantis_hwconfig *config = mantis->hwconfig;
+
+	switch (power) {
+	case POWER_ON:
+		dprintk(MANTIS_DEBUG, 1, "Power ON");
+		gpio_set_bits(mantis, config->power, POWER_ON);
+		msleep(100);
+		gpio_set_bits(mantis, config->power, POWER_ON);
+		msleep(100);
+		break;
 
-static int mantis_fe_reset(struct dvb_frontend *fe)
-{
-	struct mantis_pci *mantis = fe->dvb->priv;
+	case POWER_OFF:
+		dprintk(MANTIS_DEBUG, 1, "Power OFF");
+		gpio_set_bits(mantis, config->power, POWER_OFF);
+		msleep(100);
+		break;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Frontend Reset");
-	gpio_set_bits(mantis, 13, 0);
-	msleep_interruptible(100);
-	gpio_set_bits(mantis, 13, 0);
-	msleep_interruptible(100);
-	gpio_set_bits(mantis, 13, 1);
-	msleep_interruptible(100);
-	gpio_set_bits(mantis, 13, 1);
+	default:
+		dprintk(MANTIS_DEBUG, 1, "Unknown state <%02x>", power);
+		return -1;
+	}
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(mantis_frontend_power);
 
-static int mantis_frontend_reset(struct mantis_pci *mantis)
+void mantis_frontend_soft_reset(struct mantis_pci *mantis)
 {
-	dprintk(verbose, MANTIS_DEBUG, 1, "Frontend Reset");
-	gpio_set_bits(mantis, 13, 0);
-	msleep_interruptible(100);
-	gpio_set_bits(mantis, 13, 0);
-	msleep_interruptible(100);
-	gpio_set_bits(mantis, 13, 1);
-	msleep_interruptible(100);
-	gpio_set_bits(mantis, 13, 1);
+	struct mantis_hwconfig *config = mantis->hwconfig;
+
+	dprintk(MANTIS_DEBUG, 1, "Frontend RESET");
+	gpio_set_bits(mantis, config->reset, 0);
+	msleep(100);
+	gpio_set_bits(mantis, config->reset, 0);
+	msleep(100);
+	gpio_set_bits(mantis, config->reset, 1);
+	msleep(100);
+	gpio_set_bits(mantis, config->reset, 1);
+	msleep(100);
+
+	return;
+}
+EXPORT_SYMBOL_GPL(mantis_frontend_soft_reset);
+
+static int mantis_frontend_shutdown(struct mantis_pci *mantis)
+{
+	int err;
+
+	mantis_frontend_soft_reset(mantis);
+	err = mantis_frontend_power(mantis, POWER_OFF);
+	if (err != 0) {
+		dprintk(MANTIS_ERROR, 1, "Frontend POWER OFF failed! <%d>", err);
+		return 1;
+	}
 
 	return 0;
 }
@@ -85,18 +106,17 @@ static int mantis_dvb_start_feed(struct dvb_demux_feed *dvbdmxfeed)
 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 	struct mantis_pci *mantis = dvbdmx->priv;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Mantis DVB Start feed");
+	dprintk(MANTIS_DEBUG, 1, "Mantis DVB Start feed");
 	if (!dvbdmx->dmx.frontend) {
-		dprintk(verbose, MANTIS_DEBUG, 1, "no frontend ?");
+		dprintk(MANTIS_DEBUG, 1, "no frontend ?");
 		return -EINVAL;
 	}
+
 	mantis->feeds++;
-	dprintk(verbose, MANTIS_DEBUG, 1,
-		"mantis start feed, feeds=%d",
-		mantis->feeds);
+	dprintk(MANTIS_DEBUG, 1, "mantis start feed, feeds=%d",	mantis->feeds);
 
 	if (mantis->feeds == 1)	 {
-		dprintk(verbose, MANTIS_DEBUG, 1, "mantis start feed & dma");
+		dprintk(MANTIS_DEBUG, 1, "mantis start feed & dma");
 		printk("mantis start feed & dma\n");
 		mantis_dma_start(mantis);
 	}
@@ -109,95 +129,129 @@ static int mantis_dvb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)
 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 	struct mantis_pci *mantis = dvbdmx->priv;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Mantis DVB Stop feed");
+	dprintk(MANTIS_DEBUG, 1, "Mantis DVB Stop feed");
 	if (!dvbdmx->dmx.frontend) {
-		dprintk(verbose, MANTIS_DEBUG, 1, "no frontend ?");
+		dprintk(MANTIS_DEBUG, 1, "no frontend ?");
 		return -EINVAL;
 	}
+
 	mantis->feeds--;
 	if (mantis->feeds == 0) {
-		dprintk(verbose, MANTIS_DEBUG, 1, "mantis stop feed and dma");
+		dprintk(MANTIS_DEBUG, 1, "mantis stop feed and dma");
 		printk("mantis stop feed and dma\n");
 		mantis_dma_stop(mantis);
 	}
+
 	return 0;
 }
 
 int __devinit mantis_dvb_init(struct mantis_pci *mantis)
 {
-	int result;
+	struct mantis_hwconfig *config = mantis->hwconfig;
+	int result = -1;
+
+	dprintk(MANTIS_DEBUG, 1, "dvb_register_adapter");
+
+	result = dvb_register_adapter(&mantis->dvb_adapter,
+				      "Mantis DVB adapter",
+				      THIS_MODULE,
+				      &mantis->pdev->dev,
+				      adapter_nr);
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "dvb_register_adapter");
-	if (dvb_register_adapter(&mantis->dvb_adapter,
-				 "Mantis dvb adapter", THIS_MODULE,
-				 &mantis->pdev->dev,
-				 adapter_nr) < 0) {
+	if (result < 0) {
 
-		dprintk(verbose, MANTIS_ERROR, 1, "Error registering adapter");
+		dprintk(MANTIS_ERROR, 1, "Error registering adapter");
 		return -ENODEV;
 	}
-	mantis->dvb_adapter.priv = mantis;
-	mantis->demux.dmx.capabilities = DMX_TS_FILTERING	|
+
+	mantis->dvb_adapter.priv	= mantis;
+	mantis->demux.dmx.capabilities	= DMX_TS_FILTERING	|
 					 DMX_SECTION_FILTERING	|
 					 DMX_MEMORY_BASED_FILTERING;
 
-	mantis->demux.priv = mantis;
-	mantis->demux.filternum = 256;
-	mantis->demux.feednum = 256;
-	mantis->demux.start_feed = mantis_dvb_start_feed;
-	mantis->demux.stop_feed = mantis_dvb_stop_feed;
-	mantis->demux.write_to_decoder = NULL;
-	dprintk(verbose, MANTIS_DEBUG, 1, "dvb_dmx_init");
-	if ((result = dvb_dmx_init(&mantis->demux)) < 0) {
-		dprintk(verbose, MANTIS_ERROR, 1,
-			"dvb_dmx_init failed, ERROR=%d", result);
+	mantis->demux.priv		= mantis;
+	mantis->demux.filternum		= 256;
+	mantis->demux.feednum		= 256;
+	mantis->demux.start_feed	= mantis_dvb_start_feed;
+	mantis->demux.stop_feed		= mantis_dvb_stop_feed;
+	mantis->demux.write_to_decoder	= NULL;
+
+	dprintk(MANTIS_DEBUG, 1, "dvb_dmx_init");
+	result = dvb_dmx_init(&mantis->demux);
+	if (result < 0) {
+		dprintk(MANTIS_ERROR, 1, "dvb_dmx_init failed, ERROR=%d", result);
 
 		goto err0;
 	}
-	mantis->dmxdev.filternum = 256;
-	mantis->dmxdev.demux = &mantis->demux.dmx;
-	mantis->dmxdev.capabilities = 0;
-	dprintk(verbose, MANTIS_DEBUG, 1, "dvb_dmxdev_init");
-	if ((result = dvb_dmxdev_init(&mantis->dmxdev,
-				      &mantis->dvb_adapter)) < 0) {
-
-		dprintk(verbose, MANTIS_ERROR, 1,
-			"dvb_dmxdev_init failed, ERROR=%d", result);
+
+	mantis->dmxdev.filternum	= 256;
+	mantis->dmxdev.demux		= &mantis->demux.dmx;
+	mantis->dmxdev.capabilities	= 0;
+	dprintk(MANTIS_DEBUG, 1, "dvb_dmxdev_init");
+
+	result = dvb_dmxdev_init(&mantis->dmxdev, &mantis->dvb_adapter);
+	if (result < 0) {
+
+		dprintk(MANTIS_ERROR, 1, "dvb_dmxdev_init failed, ERROR=%d", result);
 		goto err1;
 	}
-	mantis->fe_hw.source = DMX_FRONTEND_0;
-	if ((result = mantis->demux.dmx.add_frontend(&mantis->demux.dmx,
-						     &mantis->fe_hw)) < 0) {
 
-		dprintk(verbose, MANTIS_ERROR, 1,
-			"dvb_dmx_init failed, ERROR=%d", result);
+	mantis->fe_hw.source		= DMX_FRONTEND_0;
+	result = mantis->demux.dmx.add_frontend(&mantis->demux.dmx, &mantis->fe_hw);
+	if (result < 0) {
 
+		dprintk(MANTIS_ERROR, 1, "dvb_dmx_init failed, ERROR=%d", result);
 		goto err2;
 	}
-	mantis->fe_mem.source = DMX_MEMORY_FE;
-	if ((result = mantis->demux.dmx.add_frontend(&mantis->demux.dmx,
-						     &mantis->fe_mem)) < 0) {
-		dprintk(verbose, MANTIS_ERROR, 1,
-			"dvb_dmx_init failed, ERROR=%d", result);
 
+	mantis->fe_mem.source		= DMX_MEMORY_FE;
+	result = mantis->demux.dmx.add_frontend(&mantis->demux.dmx,&mantis->fe_mem);
+	if (result < 0) {
+		dprintk(MANTIS_ERROR, 1,"dvb_dmx_init failed, ERROR=%d", result);
 		goto err3;
 	}
-	if ((result = mantis->demux.dmx.connect_frontend(&mantis->demux.dmx,
-							 &mantis->fe_hw)) < 0) {
-
-		dprintk(verbose, MANTIS_ERROR, 1,
-			"dvb_dmx_init failed, ERROR=%d", result);
 
+	result = mantis->demux.dmx.connect_frontend(&mantis->demux.dmx, &mantis->fe_hw);
+	if (result < 0) {
+		dprintk(MANTIS_ERROR, 1, "dvb_dmx_init failed, ERROR=%d", result);
 		goto err4;
 	}
+
 	dvb_net_init(&mantis->dvb_adapter, &mantis->dvbnet, &mantis->demux.dmx);
 	tasklet_init(&mantis->tasklet, mantis_dma_xfer, (unsigned long) mantis);
-	mantis_frontend_init(mantis);
-	mantis_ca_init(mantis);
+	if (mantis->hwconfig) {
+		result = config->frontend_init(mantis, mantis->fe);
+		if (result < 0) {
+			dprintk(MANTIS_ERROR, 1, "!!! NO Frontends found !!!");
+			goto err5;
+		} else {
+//			if (mantis->dvb_adapter == NULL) {
+//				dprintk(MANTIS_ERROR, 1, "DVB adapter <NULL>");
+//				goto err5;
+//			}
+			if (mantis->fe == NULL) {
+				dprintk(MANTIS_ERROR, 1, "FE <NULL>");
+				goto err5;
+			}
+
+			if (dvb_register_frontend(&mantis->dvb_adapter, mantis->fe)) {
+				dprintk(MANTIS_ERROR, 1, "ERROR: Frontend registration failed");
+
+				if (mantis->fe->ops.release)
+					mantis->fe->ops.release(mantis->fe);
+
+				mantis->fe = NULL;
+				goto err5;
+			}
+		}
+	}
 
 	return 0;
 
-	/*	Error conditions ..	*/
+	/* Error conditions ..	*/
+err5:
+	tasklet_kill(&mantis->tasklet);
+	dvb_net_release(&mantis->dvbnet);
 err4:
 	mantis->demux.dmx.remove_frontend(&mantis->demux.dmx, &mantis->fe_mem);
 err3:
@@ -211,115 +265,17 @@ err0:
 
 	return result;
 }
+EXPORT_SYMBOL_GPL(mantis_dvb_init);
 
-int __devinit mantis_frontend_init(struct mantis_pci *mantis)
+int __devexit mantis_dvb_exit(struct mantis_pci *mantis)
 {
-	dprintk(verbose, MANTIS_DEBUG, 1, "Mantis frontend Init");
-	mantis_fe_powerup(mantis);
-	mantis_frontend_reset(mantis);
-	dprintk(verbose, MANTIS_DEBUG, 1, "Device ID=%02x", mantis->subsystem_device);
-	switch (mantis->subsystem_device) {
-	case MANTIS_VP_1033_DVB_S:	// VP-1033
-		dprintk(verbose, MANTIS_ERROR, 1, "Probing for STV0299 (DVB-S)");
-		mantis->fe = stv0299_attach(&lgtdqcs001f_config,
-					    &mantis->adapter);
-
-		if (mantis->fe) {
-			mantis->fe->ops.tuner_ops.set_params = lgtdqcs001f_tuner_set;
-			dprintk(verbose, MANTIS_ERROR, 1,
-				"found STV0299 DVB-S frontend @ 0x%02x",
-				lgtdqcs001f_config.demod_address);
-
-			dprintk(verbose, MANTIS_ERROR, 1,
-				"Mantis DVB-S STV0299 frontend attach success");
-		}
-		break;
-	case MANTIS_VP_1034_DVB_S:	// VP-1034
-		dprintk(verbose, MANTIS_ERROR, 1, "Probing for MB86A16 (DVB-S/DSS)");
-		mantis->fe = mb86a16_attach(&vp1034_config, &mantis->adapter);
-		if (mantis->fe) {
-			dprintk(verbose, MANTIS_ERROR, 1,
-			"found MB86A16 DVB-S/DSS frontend @0x%02x",
-			vp1034_config.demod_address);
+	int err;
 
-		}
-		break;
-	case MANTIS_VP_1041_DVB_S2:
-	case TECHNISAT_SKYSTAR_HD2:
-		mantis->fe = stb0899_attach(&vp1041_config, &mantis->adapter);
-		if (mantis->fe) {
-			dprintk(verbose, MANTIS_ERROR, 1,
-			"found STB0899 DVB-S/DVB-S2 frontend @0x%02x",
-			vp1041_config.demod_address);
-
-			if (stb6100_attach(mantis->fe, &vp1041_stb6100_config, &mantis->adapter)) {
-				if (!lnbp21_attach(mantis->fe, &mantis->adapter, 0, 0)) {
-					printk("%s: No LNBP21 found!\n", __FUNCTION__);
-					mantis->fe = NULL;
-				}
-			} else {
-				mantis->fe = NULL;
-			}
-		}
-		break;
-	case MANTIS_VP_2033_DVB_C:	// VP-2033
-	case MANTIS_VP_2040_DVB_C:	// VP-2040
-	case TERRATEC_CINERGY_C_PCI:
-	case TECHNISAT_CABLESTAR_HD2:
-		dprintk(verbose, MANTIS_ERROR, 1, "Probing for CU1216 (DVB-C)");
-		mantis->fe = tda10021_attach(&philips_cu1216_config,
-					     &mantis->adapter,
-					     read_pwm(mantis));
-
-		if (mantis->fe) {
-			dprintk(verbose, MANTIS_ERROR, 1,
-				"found Philips CU1216 DVB-C frontend (TDA10021) @ 0x%02x",
-				philips_cu1216_config.demod_address);
-		} else {
-			mantis->fe = tda10023_attach(&tda10023_cu1216_config,
-						     &mantis->adapter,
-						     read_pwm(mantis));
-
-			if (mantis->fe) {
-				dprintk(verbose, MANTIS_ERROR, 1,
-					"found Philips CU1216 DVB-C frontend (TDA10023) @ 0x%02x",
-					philips_cu1216_config.demod_address);
-			}
-		}
-		if (mantis->fe) {
-			mantis->fe->ops.tuner_ops.set_params = philips_cu1216_tuner_set;
-			dprintk(verbose, MANTIS_ERROR, 1,
-				"Mantis DVB-C Philips CU1216 frontend attach success");
-		}
-		break;
-	default:
-		dprintk(verbose, MANTIS_DEBUG, 1, "Unknown frontend:[0x%02x]",
-			mantis->sub_device_id);
+	err = mantis_frontend_shutdown(mantis);
+	if (err != 0)
+		dprintk(MANTIS_ERROR, 1, "Frontend exit while POWER ON! <%d>", err);
 
-		return -ENODEV;
-	}
-	if (mantis->fe == NULL) {
-		dprintk(verbose, MANTIS_ERROR, 1, "!!! NO Frontends found !!!");
-		return -ENODEV;
-	} else {
-		if (dvb_register_frontend(&mantis->dvb_adapter, mantis->fe)) {
-			dprintk(verbose, MANTIS_ERROR, 1,
-				"ERROR: Frontend registration failed");
-
-			if (mantis->fe->ops.release)
-				mantis->fe->ops.release(mantis->fe);
-
-			mantis->fe = NULL;
-			return -ENODEV;
-		}
-	}
-
-	return 0;
-}
-
-int __devexit mantis_dvb_exit(struct mantis_pci *mantis)
-{
-	mantis_ca_exit(mantis);
+//	mantis_ca_exit(mantis);
 	tasklet_kill(&mantis->tasklet);
 	dvb_net_release(&mantis->dvbnet);
 	mantis->demux.dmx.remove_frontend(&mantis->demux.dmx, &mantis->fe_mem);
@@ -329,8 +285,10 @@ int __devexit mantis_dvb_exit(struct mantis_pci *mantis)
 
 	if (mantis->fe)
 		dvb_unregister_frontend(mantis->fe);
-	dprintk(verbose, MANTIS_DEBUG, 1, "dvb_unregister_adapter");
+
+	dprintk(MANTIS_DEBUG, 1, "dvb_unregister_adapter");
 	dvb_unregister_adapter(&mantis->dvb_adapter);
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(mantis_dvb_exit);
diff --git a/drivers/media/dvb/mantis/mantis_dvb.h b/drivers/media/dvb/mantis/mantis_dvb.h
new file mode 100644
index 0000000..31ebbb4
--- /dev/null
+++ b/drivers/media/dvb/mantis/mantis_dvb.h
@@ -0,0 +1,15 @@
+#ifndef __MANTIS_DVB_H
+#define __MANTIS_DVB_H
+
+enum mantis_power {
+	POWER_OFF	= 0,
+	POWER_ON	= 1
+};
+
+extern int mantis_frontend_power(struct mantis_pci *mantis, enum mantis_power power);
+extern void mantis_frontend_soft_reset(struct mantis_pci *mantis);
+
+extern int mantis_dvb_init(struct mantis_pci *mantis);
+extern int mantis_dvb_exit(struct mantis_pci *mantis);
+
+#endif /* __MANTIS_DVB_H */
diff --git a/drivers/media/dvb/mantis/mantis_evm.c b/drivers/media/dvb/mantis/mantis_evm.c
index 9be55f7..2005b24 100644
--- a/drivers/media/dvb/mantis/mantis_evm.c
+++ b/drivers/media/dvb/mantis/mantis_evm.c
@@ -18,9 +18,23 @@
 	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
+#include <linux/kernel.h>
+
+#include <asm/irq.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
 #include "mantis_common.h"
 #include "mantis_link.h"
 #include "mantis_hif.h"
+#include "mantis_reg.h"
 
 static void mantis_hifevm_work(struct work_struct *work)
 {
@@ -34,7 +48,7 @@ static void mantis_hifevm_work(struct work_struct *work)
 
 	if (gpif_stat & MANTIS_GPIF_DETSTAT) {
 		if (gpif_stat & MANTIS_CARD_PLUGIN) {
-			dprintk(verbose, MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): CAM Plugin", mantis->num);
+			dprintk(MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): CAM Plugin", mantis->num);
 			mmwrite(0xdada0000, MANTIS_CARD_RESET);
 			mantis_event_cam_plugin(ca);
 			dvb_ca_en50221_camchange_irq(&ca->en50221,
@@ -43,7 +57,7 @@ static void mantis_hifevm_work(struct work_struct *work)
 		}
 	} else {
 		if (gpif_stat & MANTIS_CARD_PLUGOUT) {
-			dprintk(verbose, MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): CAM Unplug", mantis->num);
+			dprintk(MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): CAM Unplug", mantis->num);
 			mmwrite(0xdada0000, MANTIS_CARD_RESET);
 			mantis_event_cam_unplug(ca);
 			dvb_ca_en50221_camchange_irq(&ca->en50221,
@@ -53,28 +67,28 @@ static void mantis_hifevm_work(struct work_struct *work)
 	}
 
 	if (mantis->gpif_status & MANTIS_GPIF_EXTIRQ)
-		dprintk(verbose, MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): Ext IRQ", mantis->num);
+		dprintk(MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): Ext IRQ", mantis->num);
 
 	if (mantis->gpif_status & MANTIS_SBUF_WSTO)
-		dprintk(verbose, MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): Smart Buffer Timeout", mantis->num);
+		dprintk(MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): Smart Buffer Timeout", mantis->num);
 
 	if (mantis->gpif_status & MANTIS_GPIF_OTHERR)
-		dprintk(verbose, MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): Alignment Error", mantis->num);
+		dprintk(MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): Alignment Error", mantis->num);
 
 	if (gpif_stat & MANTIS_SBUF_OVFLW)
-		dprintk(verbose, MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): Smart Buffer Overflow", mantis->num);
+		dprintk(MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): Smart Buffer Overflow", mantis->num);
 
 	if (gpif_stat & MANTIS_GPIF_BRRDY)
-		dprintk(verbose, MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): Smart Buffer Read Ready", mantis->num);
+		dprintk(MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): Smart Buffer Read Ready", mantis->num);
 
 	if (gpif_stat & MANTIS_GPIF_INTSTAT)
-		dprintk(verbose, MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): GPIF IRQ", mantis->num);
+		dprintk(MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): GPIF IRQ", mantis->num);
 
 	if (gpif_stat & MANTIS_SBUF_EMPTY)
-		dprintk(verbose, MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): Smart Buffer Empty", mantis->num);
+		dprintk(MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): Smart Buffer Empty", mantis->num);
 
 	if (gpif_stat & MANTIS_SBUF_OPDONE) {
-		dprintk(verbose, MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): Smart Buffer operation complete", mantis->num);
+		dprintk(MANTIS_DEBUG, 1, "Event Mgr: Adapter(%d) Slot(0): Smart Buffer operation complete", mantis->num);
 		ca->sbuf_status = MANTIS_SBUF_DATA_AVAIL;
 		ca->hif_event = MANTIS_SBUF_OPDONE;
 		wake_up(&ca->hif_opdone_wq);
@@ -85,7 +99,7 @@ int mantis_evmgr_init(struct mantis_ca *ca)
 {
 	struct mantis_pci *mantis = ca->ca_priv;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Initializing Mantis Host I/F Event manager");
+	dprintk(MANTIS_DEBUG, 1, "Initializing Mantis Host I/F Event manager");
 	INIT_WORK(&ca->hif_evm_work, mantis_hifevm_work);
 	mantis_pcmcia_init(ca);
 	schedule_work(&ca->hif_evm_work);
@@ -97,7 +111,7 @@ void mantis_evmgr_exit(struct mantis_ca *ca)
 {
 	struct mantis_pci *mantis = ca->ca_priv;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Mantis Host I/F Event manager exiting");
+	dprintk(MANTIS_DEBUG, 1, "Mantis Host I/F Event manager exiting");
 	flush_scheduled_work();
 	mantis_hif_exit(ca);
 	mantis_pcmcia_exit(ca);
diff --git a/drivers/media/dvb/mantis/mantis_hif.c b/drivers/media/dvb/mantis/mantis_hif.c
index 99a9724..bb05427 100644
--- a/drivers/media/dvb/mantis/mantis_hif.c
+++ b/drivers/media/dvb/mantis/mantis_hif.c
@@ -18,10 +18,28 @@
 	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
+#include <linux/kernel.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+
+#include <asm/irq.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
 #include "mantis_common.h"
+
 #include "mantis_hif.h"
 #include "mantis_link.h" /* temporary due to physical layer stuff */
 
+#include "mantis_reg.h"
+
 static int mantis_hif_data_available(struct mantis_ca *ca)
 {
 	struct mantis_pci *mantis = ca->ca_priv;
@@ -31,7 +49,7 @@ static int mantis_hif_data_available(struct mantis_ca *ca)
 					     ca->sbuf_status & MANTIS_SBUF_DATA_AVAIL,
 					     msecs_to_jiffies(500)) == -ERESTARTSYS) {
 
-		dprintk(verbose, MANTIS_ERROR, 1, "Adapter(%d) Slot(0): HIF Read wait event timeout !", mantis->num);
+		dprintk(MANTIS_ERROR, 1, "Adapter(%d) Slot(0): HIF Read wait event timeout !", mantis->num);
 		rc = -EREMOTEIO;
 	}
 	ca->sbuf_status &= ~MANTIS_SBUF_DATA_AVAIL;
@@ -48,10 +66,10 @@ static int mantis_hif_sbuf_opdone_wait(struct mantis_ca *ca)
 			       ca->hif_event & MANTIS_SBUF_OPDONE,
 			       msecs_to_jiffies(500)) == -ERESTARTSYS) {
 
-		dprintk(verbose, MANTIS_ERROR, 1, "Adapter(%d) Slot(0): Smart buffer operation timeout !", mantis->num);
+		dprintk(MANTIS_ERROR, 1, "Adapter(%d) Slot(0): Smart buffer operation timeout !", mantis->num);
 		rc = -EREMOTEIO;
 	}
-	dprintk(verbose, MANTIS_DEBUG, 1, "Smart Buffer Operation complete");
+	dprintk(MANTIS_DEBUG, 1, "Smart Buffer Operation complete");
 	ca->hif_event &= ~MANTIS_SBUF_OPDONE;
 	return rc;
 }
@@ -66,22 +84,22 @@ static int mantis_hif_write_wait(struct mantis_ca *ca)
 			       mantis->gpif_status & MANTIS_GPIF_WRACK,
 			       msecs_to_jiffies(500)) == -ERESTARTSYS) {
 
-		dprintk(verbose, MANTIS_ERROR, 1, "Adapter(%d) Slot(0): Write ACK timed out !", mantis->num);
+		dprintk(MANTIS_ERROR, 1, "Adapter(%d) Slot(0): Write ACK timed out !", mantis->num);
 		rc = -EREMOTEIO;
 	}
-	dprintk(verbose, MANTIS_DEBUG, 1, "Write Acknowledged");
+	dprintk(MANTIS_DEBUG, 1, "Write Acknowledged");
 	mantis->gpif_status &= ~MANTIS_GPIF_WRACK;
 	while (!opdone) {
 		opdone = (mmread(MANTIS_GPIF_STATUS) & MANTIS_SBUF_OPDONE);
 		udelay(500);
 		timeout++;
 		if (timeout > 100) {
-			dprintk(verbose, MANTIS_ERROR, 1, "Adater(%d) Slot(0): Write operation timed out!", mantis->num);
+			dprintk(MANTIS_ERROR, 1, "Adater(%d) Slot(0): Write operation timed out!", mantis->num);
 			rc = -ETIMEDOUT;
 			break;
 		}
 	}
-	dprintk(verbose, MANTIS_DEBUG, 1, "HIF Write success");
+	dprintk(MANTIS_DEBUG, 1, "HIF Write success");
 	return rc;
 }
 
@@ -91,7 +109,7 @@ int mantis_hif_read_mem(struct mantis_ca *ca, u32 addr)
 	struct mantis_pci *mantis = ca->ca_priv;
 	u32 hif_addr = 0, data, count = 4;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Adapter(%d) Slot(0): Request HIF Mem Read", mantis->num);
+	dprintk(MANTIS_DEBUG, 1, "Adapter(%d) Slot(0): Request HIF Mem Read", mantis->num);
 	mutex_lock(&ca->ca_lock);
 	hif_addr &= ~MANTIS_GPIF_PCMCIAREG;
 	hif_addr &= ~MANTIS_GPIF_PCMCIAIOM;
@@ -104,13 +122,13 @@ int mantis_hif_read_mem(struct mantis_ca *ca, u32 addr)
 	mmwrite(hif_addr | MANTIS_GPIF_HIFRDWRN, MANTIS_GPIF_ADDR);
 
 	if (mantis_hif_sbuf_opdone_wait(ca) != 0) {
-		dprintk(verbose, MANTIS_ERROR, 1, "Adapter(%d) Slot(0): GPIF Smart Buffer operation failed", mantis->num);
+		dprintk(MANTIS_ERROR, 1, "Adapter(%d) Slot(0): GPIF Smart Buffer operation failed", mantis->num);
 		mutex_unlock(&ca->ca_lock);
 		return -EREMOTEIO;
 	}
 	data = mmread(MANTIS_GPIF_DIN);
 	mutex_unlock(&ca->ca_lock);
-	dprintk(verbose, MANTIS_DEBUG, 1, "Mem Read: 0x%02x", data);
+	dprintk(MANTIS_DEBUG, 1, "Mem Read: 0x%02x", data);
 	return (data >> 24) & 0xff;
 }
 
@@ -120,7 +138,7 @@ int mantis_hif_write_mem(struct mantis_ca *ca, u32 addr, u8 data)
 	struct mantis_pci *mantis = ca->ca_priv;
 	u32 hif_addr = 0;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Adapter(%d) Slot(0): Request HIF Mem Write", mantis->num);
+	dprintk(MANTIS_DEBUG, 1, "Adapter(%d) Slot(0): Request HIF Mem Write", mantis->num);
 	mutex_lock(&ca->ca_lock);
 	hif_addr &= ~MANTIS_GPIF_HIFRDWRN;
 	hif_addr &= ~MANTIS_GPIF_PCMCIAREG;
@@ -133,11 +151,11 @@ int mantis_hif_write_mem(struct mantis_ca *ca, u32 addr, u8 data)
 	mmwrite(data, MANTIS_GPIF_DOUT);
 
 	if (mantis_hif_write_wait(ca) != 0) {
-		dprintk(verbose, MANTIS_ERROR, 1, "Adapter(%d) Slot(0): HIF Smart Buffer operation failed", mantis->num);
+		dprintk(MANTIS_ERROR, 1, "Adapter(%d) Slot(0): HIF Smart Buffer operation failed", mantis->num);
 		mutex_unlock(&ca->ca_lock);
 		return -EREMOTEIO;
 	}
-	dprintk(verbose, MANTIS_DEBUG, 1, "Mem Write: (0x%02x to 0x%02x)", data, addr);
+	dprintk(MANTIS_DEBUG, 1, "Mem Write: (0x%02x to 0x%02x)", data, addr);
 	mutex_unlock(&ca->ca_lock);
 
 	return 0;
@@ -148,7 +166,7 @@ int mantis_hif_read_iom(struct mantis_ca *ca, u32 addr)
 	struct mantis_pci *mantis = ca->ca_priv;
 	u32 data, hif_addr = 0;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Adapter(%d) Slot(0): Request HIF I/O Read", mantis->num);
+	dprintk(MANTIS_DEBUG, 1, "Adapter(%d) Slot(0): Request HIF I/O Read", mantis->num);
 	mutex_lock(&ca->ca_lock);
 	hif_addr &= ~MANTIS_GPIF_PCMCIAREG;
 	hif_addr |=  MANTIS_GPIF_PCMCIAIOM;
@@ -161,12 +179,12 @@ int mantis_hif_read_iom(struct mantis_ca *ca, u32 addr)
 	mmwrite(hif_addr | MANTIS_GPIF_HIFRDWRN, MANTIS_GPIF_ADDR);
 
 	if (mantis_hif_sbuf_opdone_wait(ca) != 0) {
-		dprintk(verbose, MANTIS_ERROR, 1, "Adapter(%d) Slot(0): HIF Smart Buffer operation failed", mantis->num);
+		dprintk(MANTIS_ERROR, 1, "Adapter(%d) Slot(0): HIF Smart Buffer operation failed", mantis->num);
 		mutex_unlock(&ca->ca_lock);
 		return -EREMOTEIO;
 	}
 	data = mmread(MANTIS_GPIF_DIN);
-	dprintk(verbose, MANTIS_DEBUG, 1, "I/O Read: 0x%02x", data);
+	dprintk(MANTIS_DEBUG, 1, "I/O Read: 0x%02x", data);
 	udelay(50);
 	mutex_unlock(&ca->ca_lock);
 
@@ -178,7 +196,7 @@ int mantis_hif_write_iom(struct mantis_ca *ca, u32 addr, u8 data)
 	struct mantis_pci *mantis = ca->ca_priv;
 	u32 hif_addr = 0;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Adapter(%d) Slot(0): Request HIF I/O Write", mantis->num);
+	dprintk(MANTIS_DEBUG, 1, "Adapter(%d) Slot(0): Request HIF I/O Write", mantis->num);
 	mutex_lock(&ca->ca_lock);
 	hif_addr &= ~MANTIS_GPIF_PCMCIAREG;
 	hif_addr &= ~MANTIS_GPIF_HIFRDWRN;
@@ -190,11 +208,11 @@ int mantis_hif_write_iom(struct mantis_ca *ca, u32 addr, u8 data)
 	mmwrite(data, MANTIS_GPIF_DOUT);
 
 	if (mantis_hif_write_wait(ca) != 0) {
-		dprintk(verbose, MANTIS_ERROR, 1, "Adapter(%d) Slot(0): HIF Smart Buffer operation failed", mantis->num);
+		dprintk(MANTIS_ERROR, 1, "Adapter(%d) Slot(0): HIF Smart Buffer operation failed", mantis->num);
 		mutex_unlock(&ca->ca_lock);
 		return -EREMOTEIO;
 	}
-	dprintk(verbose, MANTIS_DEBUG, 1, "I/O Write: (0x%02x to 0x%02x)", data, addr);
+	dprintk(MANTIS_DEBUG, 1, "I/O Write: (0x%02x to 0x%02x)", data, addr);
 	mutex_unlock(&ca->ca_lock);
 	udelay(50);
 
@@ -208,7 +226,7 @@ int mantis_hif_init(struct mantis_ca *ca)
 	u32 irqcfg;
 
 	slot[0].slave_cfg = 0x70773028;
-	dprintk(verbose, MANTIS_ERROR, 1, "Adapter(%d) Initializing Mantis Host Interface", mantis->num);
+	dprintk(MANTIS_ERROR, 1, "Adapter(%d) Initializing Mantis Host Interface", mantis->num);
 
 	mutex_lock(&ca->ca_lock);
 	irqcfg = mmread(MANTIS_GPIF_IRQCFG);
@@ -230,7 +248,7 @@ void mantis_hif_exit(struct mantis_ca *ca)
 	struct mantis_pci *mantis = ca->ca_priv;
 	u32 irqcfg;
 
-	dprintk(verbose, MANTIS_ERROR, 1, "Adapter(%d) Exiting Mantis Host Interface", mantis->num);
+	dprintk(MANTIS_ERROR, 1, "Adapter(%d) Exiting Mantis Host Interface", mantis->num);
 	mutex_lock(&ca->ca_lock);
 	irqcfg = mmread(MANTIS_GPIF_IRQCFG);
 	irqcfg &= ~MANTIS_MASK_BRRDY;
diff --git a/drivers/media/dvb/mantis/mantis_hif.h b/drivers/media/dvb/mantis/mantis_hif.h
index 7ef45ce..f960c0a 100644
--- a/drivers/media/dvb/mantis/mantis_hif.h
+++ b/drivers/media/dvb/mantis/mantis_hif.h
@@ -26,4 +26,4 @@
 #define MANTIS_HIF_IOMRD		3
 #define MANTIS_HIF_IOMWR		4
 
-#endif // __MANTIS_HIF_H
+#endif /* __MANTIS_HIF_H */
diff --git a/drivers/media/dvb/mantis/mantis_i2c.c b/drivers/media/dvb/mantis/mantis_i2c.c
index 45d9e6b..ba55f0a 100644
--- a/drivers/media/dvb/mantis/mantis_i2c.c
+++ b/drivers/media/dvb/mantis/mantis_i2c.c
@@ -18,15 +18,20 @@
 	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-#include <linux/delay.h>
 #include <asm/io.h>
 #include <linux/ioport.h>
-#include <asm/pgtable.h>
-#include <asm/page.h>
+#include <linux/pci.h>
+#include <linux/i2c.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
 #include "mantis_common.h"
+#include "mantis_reg.h"
+#include "mantis_i2c.h"
 
 #define I2C_HW_B_MANTIS		0x1c
 
@@ -35,20 +40,21 @@ static int mantis_ack_wait(struct mantis_pci *mantis)
 	int rc = 0;
 	u32 timeout = 0;
 
-	if (wait_event_interruptible_timeout(mantis->i2c_wq,
-					     mantis->mantis_int_stat & MANTIS_INT_I2CDONE,
-					     msecs_to_jiffies(50)) == -ERESTARTSYS) {
+	if (wait_event_timeout(mantis->i2c_wq,
+			       mantis->mantis_int_stat & MANTIS_INT_I2CDONE,
+			       msecs_to_jiffies(50)) == -ERESTARTSYS) {
 
-		dprintk(verbose, MANTIS_DEBUG, 1, "Master !I2CDONE");
+		dprintk(MANTIS_DEBUG, 1, "Master !I2CDONE");
 		rc = -EREMOTEIO;
 	}
+
 	while (!(mantis->mantis_int_stat & MANTIS_INT_I2CRACK)) {
-		dprintk(verbose, MANTIS_DEBUG, 1, "Waiting for Slave RACK");
+		dprintk(MANTIS_DEBUG, 1, "Waiting for Slave RACK");
 		mantis->mantis_int_stat = mmread(MANTIS_INT_STAT);
 		msleep(5);
 		timeout++;
 		if (timeout > 500) {
-			dprintk(verbose, MANTIS_ERROR, 1, "Slave RACK Fail !");
+			dprintk(MANTIS_ERROR, 1, "Slave RACK Fail !");
 			rc = -EREMOTEIO;
 			break;
 		}
@@ -62,7 +68,7 @@ static int mantis_i2c_read(struct mantis_pci *mantis, const struct i2c_msg *msg)
 {
 	u32 rxd, i;
 
-	dprintk(verbose, MANTIS_INFO, 0, "        %s:  Address=[0x%02x] <R>[ ",
+	dprintk(MANTIS_INFO, 0, "        %s:  Address=[0x%02x] <R>[ ",
 		__func__, msg->addr);
 
 	for (i = 0; i < msg->len; i++) {
@@ -77,14 +83,14 @@ static int mantis_i2c_read(struct mantis_pci *mantis, const struct i2c_msg *msg)
 		mmwrite(MANTIS_INT_I2CDONE, MANTIS_INT_STAT);
 		mmwrite(rxd, MANTIS_I2CDATA_CTL);
 		if (mantis_ack_wait(mantis) != 0) {
-			dprintk(verbose, MANTIS_DEBUG, 1, "ACK failed<R>");
+			dprintk(MANTIS_DEBUG, 1, "ACK failed<R>");
 			return -EREMOTEIO;
 		}
 		rxd = mmread(MANTIS_I2CDATA_CTL);
 		msg->buf[i] = (u8)((rxd >> 8) & 0xFF);
-		dprintk(verbose, MANTIS_INFO, 0, "%02x ", msg->buf[i]);
+		dprintk(MANTIS_INFO, 0, "%02x ", msg->buf[i]);
 	}
-	dprintk(verbose, MANTIS_INFO, 0, "]\n");
+	dprintk(MANTIS_INFO, 0, "]\n");
 
 	return 0;
 }
@@ -94,11 +100,11 @@ static int mantis_i2c_write(struct mantis_pci *mantis, const struct i2c_msg *msg
 	int i;
 	u32 txd = 0;
 
-	dprintk(verbose, MANTIS_INFO, 0, "        %s: Address=[0x%02x] <W>[ ",
+	dprintk(MANTIS_INFO, 0, "        %s: Address=[0x%02x] <W>[ ",
 		__func__, msg->addr);
 
 	for (i = 0; i < msg->len; i++) {
-		dprintk(verbose, MANTIS_INFO, 0, "%02x ", msg->buf[i]);
+		dprintk(MANTIS_INFO, 0, "%02x ", msg->buf[i]);
 		txd = (msg->addr << 25) | (msg->buf[i] << 8)
 					| MANTIS_I2C_RATE_3
 					| MANTIS_I2C_STOP
@@ -110,11 +116,11 @@ static int mantis_i2c_write(struct mantis_pci *mantis, const struct i2c_msg *msg
 		mmwrite(MANTIS_INT_I2CDONE, MANTIS_INT_STAT);
 		mmwrite(txd, MANTIS_I2CDATA_CTL);
 		if (mantis_ack_wait(mantis) != 0) {
-			dprintk(verbose, MANTIS_DEBUG, 1, "ACK failed<W>");
+			dprintk(MANTIS_DEBUG, 1, "ACK failed<W>");
 			return -EREMOTEIO;
 		}
 	}
-	dprintk(verbose, MANTIS_INFO, 0, "]\n");
+	dprintk(MANTIS_INFO, 0, "]\n");
 
 	return 0;
 }
@@ -154,43 +160,46 @@ static struct i2c_algorithm mantis_algo = {
 	.functionality		= mantis_i2c_func,
 };
 
-static struct i2c_adapter mantis_i2c_adapter = {
-	.owner			= THIS_MODULE,
-	.name			= "Mantis I2C",
-	.id			= I2C_HW_B_MANTIS,
-	.class			= I2C_CLASS_TV_DIGITAL,
-	.algo			= &mantis_algo,
-};
-
 int __devinit mantis_i2c_init(struct mantis_pci *mantis)
 {
 	u32 intstat, intmask;
 	struct i2c_adapter *i2c_adapter = &mantis->adapter;
 	struct pci_dev *pdev		= mantis->pdev;
 
+	init_waitqueue_head(&mantis->i2c_wq);
 	mutex_init(&mantis->i2c_lock);
-	memcpy(i2c_adapter, &mantis_i2c_adapter, sizeof (mantis_i2c_adapter));
+	strncpy(i2c_adapter->name, "Mantis I2C", sizeof (i2c_adapter->name));
 	i2c_set_adapdata(i2c_adapter, mantis);
 
-	i2c_adapter->dev.parent = &pdev->dev;
+	i2c_adapter->owner	= THIS_MODULE;
+	i2c_adapter->class	= I2C_CLASS_TV_DIGITAL;
+	i2c_adapter->algo	= &mantis_algo;
+	i2c_adapter->algo_data	= NULL;
+	i2c_adapter->id		= I2C_HW_B_MANTIS;
+	i2c_adapter->timeout	= 500;
+	i2c_adapter->retries	= 3;
+	i2c_adapter->dev.parent	= &pdev->dev;
+
 	mantis->i2c_rc		= i2c_add_adapter(i2c_adapter);
 	if (mantis->i2c_rc < 0)
 		return mantis->i2c_rc;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Initializing I2C ..");
+	dprintk(MANTIS_DEBUG, 1, "Initializing I2C ..");
 
 	intstat = mmread(MANTIS_INT_STAT);
 	intmask = mmread(MANTIS_INT_MASK);
 	mmwrite(intstat, MANTIS_INT_STAT);
 	mmwrite(intmask | MANTIS_INT_I2CDONE, MANTIS_INT_MASK);
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "[0x%08x/%08x]", intstat, intmask);
+	dprintk(MANTIS_DEBUG, 1, "Status=<%02x> Mask=<%02x>", intstat, intmask);
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(mantis_i2c_init);
 
 int __devexit mantis_i2c_exit(struct mantis_pci *mantis)
 {
-	dprintk(verbose, MANTIS_DEBUG, 1, "Removing I2C adapter");
+	dprintk(MANTIS_DEBUG, 1, "Removing I2C adapter");
 	return i2c_del_adapter(&mantis->adapter);
 }
+EXPORT_SYMBOL_GPL(mantis_i2c_exit);
diff --git a/drivers/media/dvb/mantis/mantis_i2c.h b/drivers/media/dvb/mantis/mantis_i2c.h
new file mode 100644
index 0000000..1e49ecf
--- /dev/null
+++ b/drivers/media/dvb/mantis/mantis_i2c.h
@@ -0,0 +1,7 @@
+#ifndef __MANTIS_I2C_H
+#define __MANTIS_I2C_H
+
+extern int mantis_i2c_init(struct mantis_pci *mantis);
+extern int mantis_i2c_exit(struct mantis_pci *mantis);
+
+#endif /* __MANTIS_I2C_H */
diff --git a/drivers/media/dvb/mantis/mantis_ioc.c b/drivers/media/dvb/mantis/mantis_ioc.c
new file mode 100644
index 0000000..4700088
--- /dev/null
+++ b/drivers/media/dvb/mantis/mantis_ioc.c
@@ -0,0 +1,145 @@
+/*
+	Mantis PCI bridge driver
+
+	Copyright (C) 2005, 2006 Manu Abraham (abraham.manu@gmail.com)
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+
+#include <asm/irq.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
+#include "mantis_common.h"
+#include "mantis_reg.h"
+#include "mantis_ioc.h"
+
+static int read_eeprom_byte(struct mantis_pci *mantis, u8 *data, u8 length)
+{
+	struct i2c_adapter *adapter = &mantis->adapter;
+
+	int err;
+	struct i2c_msg msg[] = {
+		{ .addr = 0x50, .flags = 0, .buf = data, .len = 1 },
+		{ .addr = 0x50, .flags = I2C_M_RD, .buf = data, .len = length },
+	};
+
+	err = i2c_transfer(adapter, msg, 2);
+	if (err < 0) {
+		dprintk(MANTIS_ERROR, 1, "ERROR: i2c read: < err=%i d0=0x%02x d1=0x%02x >",
+			err, data[0], data[1]);
+
+		return err;
+	}
+
+	return 0;
+}
+
+static int write_eeprom_byte(struct mantis_pci *mantis, u8 *data, u8 length)
+{
+	struct i2c_adapter *adapter = &mantis->adapter;
+	int err;
+
+	struct i2c_msg msg = { .addr = 0x50, .flags = 0, .buf = data, .len = length };
+
+	err = i2c_transfer(adapter, &msg, 1);
+	if (err < 0) {
+		dprintk(MANTIS_ERROR, 1, "ERROR: i2c write: < err=%i length=0x%02x d0=0x%02x, d1=0x%02x >",
+			err, length, data[0], data[1]);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int mantis_get_mac(struct mantis_pci *mantis)
+{
+	int err;
+
+	mantis->mac_address[0] = 0x08;
+
+	err = read_eeprom_byte(mantis, &mantis->mac_address[0], 6);
+	if (err < 0) {
+		dprintk(MANTIS_ERROR, 1, "ERROR: Mantis EEPROM read error <%d>", err);
+
+		return err;
+	}
+
+	dprintk(MANTIS_ERROR, 0,
+		"    MAC Address=[%02x:%02x:%02x:%02x:%02x:%02x]\n",
+		mantis->mac_address[0], mantis->mac_address[1],
+		mantis->mac_address[2],	mantis->mac_address[3],
+		mantis->mac_address[4], mantis->mac_address[5]);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mantis_get_mac);
+
+/* Turn the given bit on or off. */
+void gpio_set_bits(struct mantis_pci *mantis, u32 bitpos, u8 value)
+{
+	u32 cur;
+
+	cur = mmread(MANTIS_GPIF_ADDR);
+	if (value)
+		mantis->gpio_status = cur | (1 << bitpos);
+	else
+		mantis->gpio_status = cur & (~(1 << bitpos));
+
+	mmwrite(mantis->gpio_status, MANTIS_GPIF_ADDR);
+	mmwrite(0x00, MANTIS_GPIF_DOUT);
+}
+EXPORT_SYMBOL_GPL(gpio_set_bits);
+
+int mantis_stream_control(struct mantis_pci *mantis, enum mantis_stream_control stream_ctl)
+{
+	u32 reg;
+
+	reg = mmread(MANTIS_CONTROL);
+	switch (stream_ctl) {
+	case STREAM_TO_HIF:
+		dprintk(MANTIS_DEBUG, 1, "Set stream to HIF");
+		reg &= 0xff - MANTIS_BYPASS;
+		mmwrite(reg, MANTIS_CONTROL);
+		reg |= MANTIS_BYPASS;
+		mmwrite(reg, MANTIS_CONTROL);
+		break;
+
+	case STREAM_TO_CAM:
+		dprintk(MANTIS_DEBUG, 1, "Set stream to CAM");
+		reg |= MANTIS_BYPASS;
+		mmwrite(reg, MANTIS_CONTROL);
+		reg &= 0xff - MANTIS_BYPASS;
+		mmwrite(reg, MANTIS_CONTROL);
+		break;
+	default:
+		dprintk(MANTIS_ERROR, 1, "Unknown MODE <%02x>", stream_ctl);
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mantis_stream_control);
diff --git a/drivers/media/dvb/mantis/mantis_link.h b/drivers/media/dvb/mantis/mantis_link.h
index f9aaaa5..f6030c9 100644
--- a/drivers/media/dvb/mantis/mantis_link.h
+++ b/drivers/media/dvb/mantis/mantis_link.h
@@ -58,7 +58,6 @@ struct mantis_ca {
 
 	enum mantis_slot_state		slot_state;
 
-//	struct dvb_device		*ca_dev;
 	void				*ca_priv;
 
 	struct dvb_ca_en50221		en50221;
@@ -81,4 +80,4 @@ extern int mantis_hif_write_mem(struct mantis_ca *ca, u32 addr, u8 data);
 extern int mantis_hif_read_iom(struct mantis_ca *ca, u32 addr);
 extern int mantis_hif_write_iom(struct mantis_ca *ca, u32 addr, u8 data);
 
-#endif // __MANTIS_LINK_H
+#endif /* __MANTIS_LINK_H */
diff --git a/drivers/media/dvb/mantis/mantis_pci.c b/drivers/media/dvb/mantis/mantis_pci.c
index d1eac40..5165a39 100644
--- a/drivers/media/dvb/mantis/mantis_pci.c
+++ b/drivers/media/dvb/mantis/mantis_pci.c
@@ -18,6 +18,9 @@
 	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
 #include <asm/io.h>
 #include <asm/pgtable.h>
 #include <asm/page.h>
@@ -25,264 +28,149 @@
 #include <linux/vmalloc.h>
 #include <linux/init.h>
 #include <linux/device.h>
-#include "mantis_common.h"
-#include "mantis_core.h"
-#include "mantis_uart.h"
+#include <linux/pci.h>
 
 #include <asm/irq.h>
 #include <linux/signal.h>
 #include <linux/sched.h>
 #include <linux/interrupt.h>
 
-unsigned int verbose = 1;
-module_param(verbose, int, 0644);
-MODULE_PARM_DESC(verbose, "verbose startup messages, default is 1 (yes)");
-
-unsigned int devs;
-
-#define PCI_VENDOR_ID_MANTIS			0x1822
-#define PCI_DEVICE_ID_MANTIS_R11		0x4e35
-#define DRIVER_NAME				"Mantis"
-
-static struct pci_device_id mantis_pci_table[] = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_MANTIS, PCI_DEVICE_ID_MANTIS_R11) },
-	{ 0 },
-};
-
-MODULE_DEVICE_TABLE(pci, mantis_pci_table);
-
-static irqreturn_t mantis_pci_irq(int irq, void *dev_id)
-{
-	u32 stat = 0, mask = 0, lstat = 0, mstat = 0;
-	u32 rst_stat = 0, rst_mask = 0;
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
 
-	struct mantis_pci *mantis;
-	struct mantis_ca *ca;
+#include <asm/irq.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
 
-	mantis = (struct mantis_pci *) dev_id;
-	if (unlikely(mantis == NULL)) {
-		dprintk(verbose, MANTIS_ERROR, 1, "Mantis == NULL");
-		return IRQ_NONE;
-	}
-	ca = mantis->mantis_ca;
-
-	stat = mmread(MANTIS_INT_STAT);
-	mask = mmread(MANTIS_INT_MASK);
-	mstat = lstat = stat & ~MANTIS_INT_RISCSTAT;
-	if (!(stat & mask))
-		return IRQ_NONE;
-
-	rst_mask  = MANTIS_GPIF_WRACK  |
-		    MANTIS_GPIF_OTHERR |
-		    MANTIS_SBUF_WSTO   |
-		    MANTIS_GPIF_EXTIRQ;
-
-	rst_stat  = mmread(MANTIS_GPIF_STATUS);
-	rst_stat &= rst_mask;
-	mmwrite(rst_stat, MANTIS_GPIF_STATUS);
-
-	mantis->mantis_int_stat = stat;
-	mantis->mantis_int_mask = mask;
-	dprintk(verbose, MANTIS_DEBUG, 0, "=== Interrupts[%04x/%04x]= [", stat, mask);
-	if (stat & MANTIS_INT_RISCEN) {
-		dprintk(verbose, MANTIS_DEBUG, 0, "* DMA enabl *");
-	}
-	if (stat & MANTIS_INT_IRQ0) {
-		dprintk(verbose, MANTIS_DEBUG, 0, "* INT IRQ-0 *");
-		mantis->gpif_status = rst_stat;
-		wake_up(&ca->hif_write_wq);
-		schedule_work(&ca->hif_evm_work);
-	}
-	if (stat & MANTIS_INT_IRQ1) {
-		dprintk(verbose, MANTIS_DEBUG, 0, "* INT IRQ-1 *");
-		schedule_work(&mantis->uart_work);
-	}
-	if (stat & MANTIS_INT_OCERR) {
-		dprintk(verbose, MANTIS_DEBUG, 0, "* INT OCERR *");
-	}
-	if (stat & MANTIS_INT_PABORT) {
-		dprintk(verbose, MANTIS_DEBUG, 0, "* INT PABRT *");
-	}
-	if (stat & MANTIS_INT_RIPERR) {
-		dprintk(verbose, MANTIS_DEBUG, 0, "* INT RIPRR *");
-	}
-	if (stat & MANTIS_INT_PPERR) {
-		dprintk(verbose, MANTIS_DEBUG, 0, "* INT PPERR *");
-	}
-	if (stat & MANTIS_INT_FTRGT) {
-		dprintk(verbose, MANTIS_DEBUG, 0, "* INT FTRGT *");
-	}
-	if (stat & MANTIS_INT_RISCI) {
-		dprintk(verbose, MANTIS_DEBUG, 0, "* INT RISCI *");
-		mantis->finished_block = (stat & MANTIS_INT_RISCSTAT) >> 28;
-		tasklet_schedule(&mantis->tasklet);
-	}
-	if (stat & MANTIS_INT_I2CDONE) {
-		dprintk(verbose, MANTIS_DEBUG, 0, "* I2C DONE  *");
-		wake_up(&mantis->i2c_wq);
-	}
-	mmwrite(stat, MANTIS_INT_STAT);
-	stat &= ~(MANTIS_INT_RISCEN   | MANTIS_INT_I2CDONE |
-		  MANTIS_INT_I2CRACK  | MANTIS_INT_PCMCIA7 |
-		  MANTIS_INT_PCMCIA6  | MANTIS_INT_PCMCIA5 |
-		  MANTIS_INT_PCMCIA4  | MANTIS_INT_PCMCIA3 |
-		  MANTIS_INT_PCMCIA2  | MANTIS_INT_PCMCIA1 |
-		  MANTIS_INT_PCMCIA0  | MANTIS_INT_IRQ1	   |
-		  MANTIS_INT_IRQ0     | MANTIS_INT_OCERR   |
-		  MANTIS_INT_PABORT   | MANTIS_INT_RIPERR  |
-		  MANTIS_INT_PPERR    | MANTIS_INT_FTRGT   |
-		  MANTIS_INT_RISCI);
-
-	if (stat)
-		dprintk(verbose, MANTIS_DEBUG, 0, "* Unknown [%04x] *", stat);
-
-	dprintk(verbose, MANTIS_DEBUG, 0, "] ===\n");
-
-	return IRQ_HANDLED;
-}
+#include "mantis_common.h"
+#include "mantis_reg.h"
+#include "mantis_pci.h"
 
+#define DRIVER_NAME		"Mantis Core"
 
-static int __devinit mantis_pci_probe(struct pci_dev *pdev,
-				      const struct pci_device_id *mantis_pci_table)
+int __devinit mantis_pci_init(struct mantis_pci *mantis)
 {
 	u8 revision, latency;
-	struct mantis_pci *mantis;
-	int ret = 0;
+	struct mantis_hwconfig *config	= mantis->hwconfig;
+	struct pci_dev *pdev		= mantis->pdev;
+	int err, ret = 0;
+
+	dprintk(MANTIS_ERROR, 0, "found a %s PCI %s device on (%02x:%02x.%x),\n",
+		config->model_name,
+		config->dev_type,
+		mantis->pdev->bus->number,
+		PCI_SLOT(mantis->pdev->devfn),
+		PCI_FUNC(mantis->pdev->devfn));
+
+	err = pci_enable_device(pdev);
+	if (err != 0) {
+		ret = -ENODEV;
+		dprintk(MANTIS_ERROR, 1, "ERROR: PCI enable failed <%i>", err);
+		goto fail0;
+	}
 
-	mantis = kmalloc(sizeof (struct mantis_pci), GFP_KERNEL);
-	if (mantis == NULL) {
-		printk("%s: Out of memory\n", __func__);
+	err = pci_set_consistent_dma_mask(pdev, DMA_32BIT_MASK);
+	if (err != 0) {
+		dprintk(MANTIS_ERROR, 1, "ERROR: Unable to obtain 32 bit DMA <%i>", err);
 		ret = -ENOMEM;
-		goto err;
+		goto fail1;
 	}
-	memset(mantis, 0, sizeof (struct mantis_pci));
-	mantis->num = devs;
-	devs++;
 
-	if (pci_enable_device(pdev)) {
-		dprintk(verbose, MANTIS_ERROR, 1, "Mantis PCI enable failed");
-		ret = -ENODEV;
-		goto err;
-	}
-	mantis->mantis_addr = pci_resource_start(pdev, 0);
-	if (!request_mem_region(pci_resource_start(pdev, 0),
-			pci_resource_len(pdev, 0), DRIVER_NAME)) {
-		ret = -ENODEV;
-		goto err0;
-	}
+	pci_set_master(pdev);
 
-	mantis->mantis_mmio = ioremap(pci_resource_start(pdev, 0),
-				      pci_resource_len(pdev, 0));
+	if (!request_mem_region(pci_resource_start(pdev, 0),
+				pci_resource_len(pdev, 0),
+				DRIVER_NAME)) {
 
-	if (!mantis->mantis_mmio) {
-		dprintk(verbose, MANTIS_ERROR, 1, "IO remap failed");
+		dprintk(MANTIS_ERROR, 1, "ERROR: BAR0 Request failed !");
 		ret = -ENODEV;
-		goto err1;
+		goto fail1;
 	}
 
-	// Clear and disable all interrupts at startup
-	// to avoid lockup situations
-	mmwrite(0x00, MANTIS_INT_MASK);
-	if (request_irq(pdev->irq,
-			mantis_pci_irq,
-			IRQF_SHARED,
-			DRIVER_NAME,
-			mantis) < 0) {
+	mantis->mmio = ioremap(pci_resource_start(pdev, 0),
+			       pci_resource_len(pdev, 0));
 
-		dprintk(verbose, MANTIS_ERROR, 1, "Mantis IRQ reg failed");
+	if (!mantis->mmio) {
+		dprintk(MANTIS_ERROR, 1, "ERROR: BAR0 remap failed !");
 		ret = -ENODEV;
-		goto err2;
+		goto fail2;
 	}
-	pci_set_master(pdev);
-	pci_set_drvdata(pdev, mantis);
+
 	pci_read_config_byte(pdev, PCI_LATENCY_TIMER, &latency);
 	pci_read_config_byte(pdev, PCI_CLASS_REVISION, &revision);
 	mantis->latency = latency;
 	mantis->revision = revision;
-	mantis->pdev = pdev;
-	mantis->subsystem_vendor = pdev->subsystem_vendor;
-	mantis->subsystem_device = pdev->subsystem_device;
-	init_waitqueue_head(&mantis->i2c_wq);
 
-	mantis_set_direction(mantis, 0); /* CAM bypass */
+	dprintk(MANTIS_ERROR, 0, "    Mantis Rev %d [%04x:%04x], ",
+		mantis->revision,
+		mantis->pdev->subsystem_vendor,
+		mantis->pdev->subsystem_device);
+
+	dprintk(MANTIS_ERROR, 0,
+		"irq: %d, latency: %d\n    memory: 0x%lx, mmio: 0x%p\n",
+		mantis->pdev->irq,
+		mantis->latency,
+		mantis->mantis_addr,
+		mantis->mmio);
 
-	if (!latency)
-		pci_write_config_byte(pdev, PCI_LATENCY_TIMER, 32);
+	err = request_irq(pdev->irq,
+			  config->irq_handler,
+			  IRQF_SHARED,
+			  DRIVER_NAME,
+			  mantis);
 
-	dprintk(verbose, MANTIS_ERROR, 0,
-		"irq: %d, latency: %d\n memory: 0x%lx, mmio: 0x%p\n",
-		pdev->irq, mantis->latency,
-		mantis->mantis_addr, mantis->mantis_mmio);
+	if (err != 0) {
 
-	// No more PCI specific stuff !
-	if (mantis_core_init(mantis) < 0) {
-		dprintk(verbose, MANTIS_ERROR, 1, "Mantis core init failed");
+		dprintk(MANTIS_ERROR, 1, "ERROR: IRQ registration failed ! <%d>", err);
 		ret = -ENODEV;
-		goto err2;
+		goto fail3;
 	}
 
-	return 0;
+	pci_set_drvdata(pdev, mantis);
+	return ret;
 
-	// Error conditions ..
-err2:
-	dprintk(verbose, MANTIS_DEBUG, 1, "Err: IO Unmap");
-	if (mantis->mantis_mmio)
-		iounmap(mantis->mantis_mmio);
-err1:
-	dprintk(verbose, MANTIS_DEBUG, 1, "Err: Release regions");
+	/* Error conditions */
+fail3:
+	dprintk(MANTIS_ERROR, 1, "ERROR: <%d> I/O unmap", ret);
+	if (mantis->mmio)
+		iounmap(mantis->mmio);
+
+fail2:
+	dprintk(MANTIS_ERROR, 1, "ERROR: <%d> releasing regions", ret);
 	release_mem_region(pci_resource_start(pdev, 0),
-				pci_resource_len(pdev, 0));
+			   pci_resource_len(pdev, 0));
+
+fail1:
+	dprintk(MANTIS_ERROR, 1, "ERROR: <%d> disabling device", ret);
 	pci_disable_device(pdev);
-err0:
-	dprintk(verbose, MANTIS_DEBUG, 1, "Err: Free");
-	kfree(mantis);
-err:
-	dprintk(verbose, MANTIS_DEBUG, 1, "Err:");
+
+fail0:
+	dprintk(MANTIS_ERROR, 1, "ERROR: <%d> exiting", ret);
+	pci_set_drvdata(pdev, NULL);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(mantis_pci_init);
 
-static void __devexit mantis_pci_remove(struct pci_dev *pdev)
+void __devexit mantis_pci_exit(struct mantis_pci *mantis)
 {
-	struct mantis_pci *mantis = pci_get_drvdata(pdev);
-
-	if (mantis == NULL) {
-		dprintk(verbose, MANTIS_ERROR, 1, "Aeio, Mantis NULL ptr");
-		return;
-	}
-	mantis_core_exit(mantis);
-	dprintk(verbose, MANTIS_ERROR, 1, "Removing -->Mantis irq: %d, latency: %d\n memory: 0x%lx, mmio: 0x%p",
-		pdev->irq, mantis->latency, mantis->mantis_addr,
-		mantis->mantis_mmio);
+	struct pci_dev *pdev = mantis->pdev;
 
+	dprintk(MANTIS_NOTICE, 1, " mem: 0x%p", mantis->mmio);
 	free_irq(pdev->irq, mantis);
-	pci_release_regions(pdev);
-	if (mantis_dma_exit(mantis) < 0)
-		dprintk(verbose, MANTIS_ERROR, 1, "DMA exit failed");
+	if (mantis->mmio) {
+		iounmap(mantis->mmio);
+		release_mem_region(pci_resource_start(pdev, 0),
+				   pci_resource_len(pdev, 0));
+	}
 
-	pci_set_drvdata(pdev, NULL);
 	pci_disable_device(pdev);
-	kfree(mantis);
-}
-
-static struct pci_driver mantis_pci_driver = {
-	.name = DRIVER_NAME,
-	.id_table = mantis_pci_table,
-	.probe = mantis_pci_probe,
-	.remove = mantis_pci_remove,
-};
-
-static int __devinit mantis_pci_init(void)
-{
-	return pci_register_driver(&mantis_pci_driver);
-}
-
-static void __devexit mantis_pci_exit(void)
-{
-	pci_unregister_driver(&mantis_pci_driver);
+	pci_set_drvdata(pdev, NULL);
 }
-
-module_init(mantis_pci_init);
-module_exit(mantis_pci_exit);
+EXPORT_SYMBOL_GPL(mantis_pci_exit);
 
 MODULE_DESCRIPTION("Mantis PCI DTV bridge driver");
 MODULE_AUTHOR("Manu Abraham");
diff --git a/drivers/media/dvb/mantis/mantis_pci.h b/drivers/media/dvb/mantis/mantis_pci.h
new file mode 100644
index 0000000..5ce776f
--- /dev/null
+++ b/drivers/media/dvb/mantis/mantis_pci.h
@@ -0,0 +1,7 @@
+#ifndef __MANTIS_PCI_H
+#define __MANTIS_PCI_H
+
+extern int mantis_pci_init(struct mantis_pci *mantis);
+extern void mantis_pci_exit(struct mantis_pci *mantis);
+
+#endif /* __MANTIS_PCI_H */
diff --git a/drivers/media/dvb/mantis/mantis_pcmcia.c b/drivers/media/dvb/mantis/mantis_pcmcia.c
index 4156a08..90ca356 100644
--- a/drivers/media/dvb/mantis/mantis_pcmcia.c
+++ b/drivers/media/dvb/mantis/mantis_pcmcia.c
@@ -18,8 +18,22 @@
 	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
+#include <linux/kernel.h>
+
+#include <asm/irq.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
 #include "mantis_common.h"
 #include "mantis_link.h" /* temporary due to physical layer stuff */
+#include "mantis_reg.h"
 
 /*
  * If Slot state is already PLUG_IN event and we are called
@@ -32,7 +46,7 @@ void mantis_event_cam_plugin(struct mantis_ca *ca)
 	u32 gpif_irqcfg;
 
 	if (ca->slot_state == MODULE_XTRACTED) {
-		dprintk(verbose, MANTIS_DEBUG, 1, "Event: CAM Plugged IN: Adapter(%d) Slot(0)", mantis->num);
+		dprintk(MANTIS_DEBUG, 1, "Event: CAM Plugged IN: Adapter(%d) Slot(0)", mantis->num);
 		udelay(50);
 		mmwrite(0xda000000, MANTIS_CARD_RESET);
 		gpif_irqcfg  = mmread(MANTIS_GPIF_IRQCFG);
@@ -56,7 +70,7 @@ void mantis_event_cam_unplug(struct mantis_ca *ca)
 	u32 gpif_irqcfg;
 
 	if (ca->slot_state == MODULE_INSERTED) {
-		dprintk(verbose, MANTIS_DEBUG, 1, "Event: CAM Unplugged: Adapter(%d) Slot(0)", mantis->num);
+		dprintk(MANTIS_DEBUG, 1, "Event: CAM Unplugged: Adapter(%d) Slot(0)", mantis->num);
 		udelay(50);
 		mmwrite(0x00da0000, MANTIS_CARD_RESET);
 		gpif_irqcfg  = mmread(MANTIS_GPIF_IRQCFG);
@@ -80,14 +94,14 @@ int mantis_pcmcia_init(struct mantis_ca *ca)
 	card_stat = mmread(MANTIS_GPIF_IRQCFG);
 
 	if (gpif_stat & MANTIS_GPIF_DETSTAT) {
-		dprintk(verbose, MANTIS_DEBUG, 1, "CAM found on Adapter(%d) Slot(0)", mantis->num);
+		dprintk(MANTIS_DEBUG, 1, "CAM found on Adapter(%d) Slot(0)", mantis->num);
 		mmwrite(card_stat | MANTIS_MASK_PLUGOUT, MANTIS_GPIF_IRQCFG);
 		ca->slot_state = MODULE_INSERTED;
 		dvb_ca_en50221_camchange_irq(&ca->en50221,
 					     0,
 					     DVB_CA_EN50221_CAMCHANGE_INSERTED);
 	} else {
-		dprintk(verbose, MANTIS_DEBUG, 1, "Empty Slot on Adapter(%d) Slot(0)", mantis->num);
+		dprintk(MANTIS_DEBUG, 1, "Empty Slot on Adapter(%d) Slot(0)", mantis->num);
 		mmwrite(card_stat | MANTIS_MASK_PLUGIN, MANTIS_GPIF_IRQCFG);
 		ca->slot_state = MODULE_XTRACTED;
 		dvb_ca_en50221_camchange_irq(&ca->en50221,
diff --git a/drivers/media/dvb/mantis/mantis_reg.h b/drivers/media/dvb/mantis/mantis_reg.h
index 6f5cd49..0072e14 100644
--- a/drivers/media/dvb/mantis/mantis_reg.h
+++ b/drivers/media/dvb/mantis/mantis_reg.h
@@ -21,7 +21,7 @@
 #ifndef __MANTIS_REG_H
 #define __MANTIS_REG_H
 
-// Interrupts
+/* Interrupts */
 #define MANTIS_INT_STAT			0x00
 #define MANTIS_INT_MASK			0x04
 
@@ -49,8 +49,12 @@
 #define MANTIS_INT_RISCI		(0x01 <<  1)
 #define MANTIS_INT_I2CDONE		(0x01 <<  0)
 
-// DMA
+/* DMA */
 #define MANTIS_DMA_CTL			0x08
+#define MANTIS_GPIF_RD			(0xff << 24)
+#define MANTIS_GPIF_WR			(0xff << 16)
+#define MANTIS_CPU_DO			(0x01 << 10)
+#define MANTIS_DRV_DO			(0x01 <<  9)
 #define	MANTIS_I2C_RD			(0x01 <<  7)
 #define MANTIS_I2C_WR			(0x01 <<  6)
 #define MANTIS_DCAP_MODE		(0x01 <<  5)
@@ -61,10 +65,16 @@
 #define MANTIS_DCAP_EN			(0x01 <<  1)
 #define MANTIS_RISC_EN			(0x01 <<  0)
 
+/* DEBUG */
+#define MANTIS_DEBUGREG			0x0c
+#define MANTIS_DATINV			(0x0e <<  7)
+#define MANTIS_TOP_DEBUGSEL		(0x07 <<  4)
+#define MANTIS_PCMCIA_DEBUGSEL		(0x0f <<  0)
+
 #define MANTIS_RISC_START		0x10
 #define MANTIS_RISC_PC			0x14
 
-// I2C
+/* I2C */
 #define MANTIS_I2CDATA_CTL		0x18
 #define MANTIS_I2C_RATE_1		(0x00 <<  6)
 #define MANTIS_I2C_RATE_2		(0x01 <<  6)
@@ -73,6 +83,28 @@
 #define MANTIS_I2C_STOP			(0x01 <<  5)
 #define MANTIS_I2C_PGMODE		(0x01 <<  3)
 
+/* DATA */
+#define MANTIS_CMD_DATA_R1		0x20
+#define MANTIS_CMD_DATA_3		(0xff << 24)
+#define MANTIS_CMD_DATA_2		(0xff << 16)
+#define MANTIS_CMD_DATA_1		(0xff <<  8)
+#define MANTIS_CMD_DATA_0		(0xff <<  0)
+
+#define MANTIS_CMD_DATA_R2		0x24
+#define MANTIS_CMD_DATA_7		(0xff << 24)
+#define MANTIS_CMD_DATA_6		(0xff << 16)
+#define MANTIS_CMD_DATA_5		(0xff <<  8)
+#define MANTIS_CMD_DATA_4		(0xff <<  0)
+
+#define MANTIS_CONTROL			0x28
+#define MANTIS_DET			(0x01 <<  7)
+#define MANTIS_DAT_CF_EN		(0x01 <<  6)
+#define MANTIS_ACS			(0x03 <<  4)
+#define MANTIS_VCCEN			(0x01 <<  3)
+#define MANTIS_BYPASS			(0x01 <<  2)
+#define MANTIS_MRST			(0x01 <<  1)
+#define MANTIS_CRST_INT			(0x01 <<  0)
+
 #define MANTIS_GPIF_CFGSLA		0x84
 #define MANTIS_GPIF_WAITSMPL		(0x07 << 28)
 #define MANTIS_GPIF_BYTEADDRSUB		(0x01 << 25)
@@ -162,4 +194,4 @@
 #define MANTIS_GPIF_LOGICRD		(0xffff		<< 16)
 #define MANTIS_GPIF_LOGICRW		(0xffff		<<  0)
 
-#endif //__MANTIS_REG_H
+#endif /* __MANTIS_REG_H */
diff --git a/drivers/media/dvb/mantis/mantis_uart.c b/drivers/media/dvb/mantis/mantis_uart.c
index 786fcc3..fb423b0 100644
--- a/drivers/media/dvb/mantis/mantis_uart.c
+++ b/drivers/media/dvb/mantis/mantis_uart.c
@@ -1,5 +1,20 @@
+#include <linux/kernel.h>
 #include <linux/spinlock.h>
+
+#include <asm/irq.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
 #include "mantis_common.h"
+#include "mantis_reg.h"
+#include "mantis_uart.h"
 
 struct mantis_uart_params {
 	enum mantis_baud	baud_rate;
@@ -18,20 +33,20 @@ int mantis_uart_read(struct mantis_pci *mantis, u8 *data)
 	for (i = 0; i < (config->bytes + 1); i++) {
 
 		if (stat & MANTIS_UART_RXFIFO_FULL) {
-			dprintk(verbose, MANTIS_ERROR, 1, "RX Fifo FULL");
+			dprintk(MANTIS_ERROR, 1, "RX Fifo FULL");
 		}
 		data[i] = mmread(MANTIS_UART_RXD) & 0x3f;
 
 		stat = mmread(MANTIS_UART_STAT);
 
-		dprintk(verbose, MANTIS_DEBUG, 1, "Reading ... <%02x>", data[i] & 0x3f);
+		dprintk(MANTIS_DEBUG, 1, "Reading ... <%02x>", data[i] & 0x3f);
 
 		if (data[i] & (1 << 7)) {
-			dprintk(verbose, MANTIS_ERROR, 1, "UART framing error");
+			dprintk(MANTIS_ERROR, 1, "UART framing error");
 			return -EINVAL;
 		}
 		if (data[i] & (1 << 6)) {
-			dprintk(verbose, MANTIS_ERROR, 1, "UART parity error");
+			dprintk(MANTIS_ERROR, 1, "UART parity error");
 			return -EINVAL;
 		}
 	}
@@ -46,14 +61,14 @@ static void mantis_uart_work(struct work_struct *work)
 	u8 buf[16];
 	int i;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "UART read");
+	dprintk(MANTIS_DEBUG, 1, "UART read");
 	mantis_uart_read(mantis, buf);
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "UART: ");
+	dprintk(MANTIS_DEBUG, 1, "UART: ");
 	for (i = 0; i < (config->bytes + 1); i++)
-		dprintk(verbose, MANTIS_DEBUG, 0, "<%02x> ", buf[i]);
+		dprintk(MANTIS_DEBUG, 0, "<%02x> ", buf[i]);
 
-	dprintk(verbose, MANTIS_DEBUG, 0, "\n");
+	dprintk(MANTIS_DEBUG, 0, "\n");
 }
 
 static int mantis_uart_setup(struct mantis_pci *mantis,
@@ -64,7 +79,7 @@ static int mantis_uart_setup(struct mantis_pci *mantis,
 
 	u32 reg;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Set Parity <%s> Baud Rate <%s>",
+	dprintk(MANTIS_DEBUG, 1, "Set Parity <%s> Baud Rate <%s>",
 		parity[params->parity],
 		rates[params->baud_rate]);
 
@@ -102,7 +117,7 @@ int mantis_uart_init(struct mantis_pci *mantis)
 	struct mantis_hwconfig *config = mantis->hwconfig;
 	struct mantis_uart_params params;
 
-	dprintk(verbose, MANTIS_DEBUG, 1, "Initializing UART ..");
+	dprintk(MANTIS_DEBUG, 1, "Initializing UART ..");
 	/* default parity: */
 	params.baud_rate = config->baud_rate;
 	params.parity = config->parity;
@@ -131,9 +146,11 @@ int mantis_uart_init(struct mantis_pci *mantis)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(mantis_uart_init);
 
 void mantis_uart_exit(struct mantis_pci *mantis)
 {
 	/* disable interrupt */
 	mmwrite(mmread(MANTIS_UART_CTL) & 0xffef, MANTIS_UART_CTL);
 }
+EXPORT_SYMBOL_GPL(mantis_uart_exit);
diff --git a/drivers/media/dvb/mantis/mantis_uart.h b/drivers/media/dvb/mantis/mantis_uart.h
index e9f938d..0a42cd0 100644
--- a/drivers/media/dvb/mantis/mantis_uart.h
+++ b/drivers/media/dvb/mantis/mantis_uart.h
@@ -56,4 +56,4 @@ struct mantis_pci;
 extern int mantis_uart_init(struct mantis_pci *mantis);
 extern void mantis_uart_exit(struct mantis_pci *mantis);
 
-#endif // __MANTIS_UART_H
+#endif /* __MANTIS_UART_H */
diff --git a/drivers/media/dvb/mantis/mantis_vp1033.c b/drivers/media/dvb/mantis/mantis_vp1033.c
index 64cdfb8..f2092ce 100644
--- a/drivers/media/dvb/mantis/mantis_vp1033.c
+++ b/drivers/media/dvb/mantis/mantis_vp1033.c
@@ -18,6 +18,18 @@
 	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
+#include <asm/irq.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
+#include "stv0299.h"
 #include "mantis_common.h"
 #include "mantis_vp1033.h"
 
@@ -66,47 +78,21 @@ u8 lgtdqcs001f_inittab[] = {
 	0xff, 0xff,
 };
 
-struct stv0299_config lgtdqcs001f_config = {
-	.demod_address		= 0x68,
-	.inittab		= lgtdqcs001f_inittab,
-	.mclk			= 88000000UL,
-//	.invert = 0,
-	.invert			= 1,
-//	.enhanced_tuning = 0,
-	.skip_reinit		= 0,
-//	.lock_output		= STV0229_LOCKOUTPUT_0,
-	.volt13_op0_op1		= STV0299_VOLT13_OP0,
-	.min_delay_ms		= 100,
-	.set_symbol_rate	= lgtdqcs001f_set_symbol_rate,
-//	.pll_set		= lgtdqcs001f_pll_set,
-};
-
 #define MANTIS_MODEL_NAME	"VP-1033"
 #define MANTIS_DEV_TYPE		"DVB-S/DSS"
 
-struct mantis_hwconfig vp1033_mantis_config = {
-	.model_name		= MANTIS_MODEL_NAME,
-	.dev_type		= MANTIS_DEV_TYPE,
-	.ts_size		= MANTIS_TS_204,
-	.baud_rate		= MANTIS_BAUD_9600,
-	.parity			= MANTIS_PARITY_NONE,
-	.bytes			= 0,
-};
-
 int lgtdqcs001f_tuner_set(struct dvb_frontend *fe,
 			  struct dvb_frontend_parameters *params)
 {
+	struct mantis_pci *mantis	= fe->dvb->priv;
+	struct i2c_adapter *adapter	= &mantis->adapter;
+
 	u8 buf[4];
 	u32 div;
 
-	struct mantis_pci *mantis = fe->dvb->priv;
 
-	struct i2c_msg msg = {
-		.addr = 0x61,
-		.flags = 0,
-		.buf = buf,
-		.len = sizeof (buf)
-	};
+	struct i2c_msg msg = {.addr = 0x61, .flags = 0, .buf = buf, .len = sizeof (buf) };
+
 	div = params->frequency / 250;
 
 	buf[0] = (div >> 8) & 0x7f;
@@ -118,8 +104,8 @@ int lgtdqcs001f_tuner_set(struct dvb_frontend *fe,
 		buf[3] |= 0x04;
 	else
 		buf[3] &= ~0x04;
-	if (i2c_transfer(&mantis->adapter, &msg, 1) < 0) {
-		dprintk(verbose, MANTIS_ERROR, 1, "Write: I2C Transfer failed");
+	if (i2c_transfer(adapter, &msg, 1) < 0) {
+		dprintk(MANTIS_ERROR, 1, "Write: I2C Transfer failed");
 		return -EIO;
 	}
 	msleep_interruptible(100);
@@ -161,3 +147,49 @@ int lgtdqcs001f_set_symbol_rate(struct dvb_frontend *fe,
 
 	return 0;
 }
+
+struct stv0299_config lgtdqcs001f_config = {
+	.demod_address		= 0x68,
+	.inittab		= lgtdqcs001f_inittab,
+	.mclk			= 88000000UL,
+	.invert			= 0,
+	.skip_reinit		= 0,
+	.volt13_op0_op1		= STV0299_VOLT13_OP0,
+	.min_delay_ms		= 100,
+	.set_symbol_rate	= lgtdqcs001f_set_symbol_rate,
+};
+
+static int vp1033_frontend_init(struct mantis_pci *mantis, struct dvb_frontend *fe)
+{
+	struct i2c_adapter *adapter	= &mantis->adapter;
+
+	dprintk(MANTIS_ERROR, 1, "Probing for STV0299 (DVB-S)");
+	fe = stv0299_attach(&lgtdqcs001f_config, adapter);
+
+	if (fe) {
+		fe->ops.tuner_ops.set_params = lgtdqcs001f_tuner_set;
+		dprintk(MANTIS_ERROR, 1, "found STV0299 DVB-S frontend @ 0x%02x",
+			lgtdqcs001f_config.demod_address);
+
+		dprintk(MANTIS_ERROR, 1, "Mantis DVB-S STV0299 frontend attach success");
+	} else {
+		return -1;
+	}
+
+	mantis->fe = fe;
+	dprintk(MANTIS_ERROR, 1, "Done!");
+
+	return 0;
+}
+
+struct mantis_hwconfig vp1033_config = {
+	.model_name		= MANTIS_MODEL_NAME,
+	.dev_type		= MANTIS_DEV_TYPE,
+	.ts_size		= MANTIS_TS_204,
+
+	.baud_rate		= MANTIS_BAUD_9600,
+	.parity			= MANTIS_PARITY_NONE,
+	.bytes			= 0,
+
+	.frontend_init		= vp1033_frontend_init,
+};
diff --git a/drivers/media/dvb/mantis/mantis_vp1033.h b/drivers/media/dvb/mantis/mantis_vp1033.h
index e245706..2c18d21 100644
--- a/drivers/media/dvb/mantis/mantis_vp1033.h
+++ b/drivers/media/dvb/mantis/mantis_vp1033.h
@@ -21,19 +21,10 @@
 #ifndef __MANTIS_VP1033_H
 #define __MANTIS_VP1033_H
 
-#include "dvb_frontend.h"
 #include "mantis_common.h"
-#include "stv0299.h"
 
 #define MANTIS_VP_1033_DVB_S	0x0016
 
-extern struct stv0299_config lgtdqcs001f_config;
-extern struct mantis_hwconfig vp1033_mantis_config;
+extern struct mantis_hwconfig vp1033_config;
 
-extern int lgtdqcs001f_tuner_set(struct dvb_frontend *fe,
-				 struct dvb_frontend_parameters *params);
-
-extern int lgtdqcs001f_set_symbol_rate(struct dvb_frontend *fe, u32 srate, u32 ratio);
-
-
-#endif // __MANTIS_VP1033_H
+#endif /* __MANTIS_VP1033_H */
diff --git a/drivers/media/dvb/mantis/mantis_vp1034.c b/drivers/media/dvb/mantis/mantis_vp1034.c
index 28f3420..40778ec 100644
--- a/drivers/media/dvb/mantis/mantis_vp1034.c
+++ b/drivers/media/dvb/mantis/mantis_vp1034.c
@@ -18,10 +18,24 @@
 	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
+#include <asm/irq.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
+#include "mb86a16.h"
 #include "mantis_common.h"
+#include "mantis_ioc.h"
 #include "mantis_vp1034.h"
+#include "mantis_reg.h"
 
-struct mb86a16_config vp1034_config = {
+struct mb86a16_config vp1034_mb86a16_config = {
 	.demod_address	= 0x08,
 	.set_voltage	= vp1034_set_voltage,
 };
@@ -29,38 +43,62 @@ struct mb86a16_config vp1034_config = {
 #define MANTIS_MODEL_NAME	"VP-1034"
 #define MANTIS_DEV_TYPE		"DVB-S/DSS"
 
-struct mantis_hwconfig vp1034_mantis_config = {
-	.model_name	= MANTIS_MODEL_NAME,
-	.dev_type	= MANTIS_DEV_TYPE,
-	.ts_size	= MANTIS_TS_204,
-	.baud_rate	= MANTIS_BAUD_9600,
-	.parity		= MANTIS_PARITY_NONE,
-	.bytes		= 0,
-};
-
 int vp1034_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
 {
 	struct mantis_pci *mantis = fe->dvb->priv;
 
 	switch (voltage) {
 	case SEC_VOLTAGE_13:
-		dprintk(verbose, MANTIS_ERROR, 1, "Polarization=[13V]");
+		dprintk(MANTIS_ERROR, 1, "Polarization=[13V]");
 		gpio_set_bits(mantis, 13, 1);
 		gpio_set_bits(mantis, 14, 0);
 		break;
 	case SEC_VOLTAGE_18:
-		dprintk(verbose, MANTIS_ERROR, 1, "Polarization=[18V]");
+		dprintk(MANTIS_ERROR, 1, "Polarization=[18V]");
 		gpio_set_bits(mantis, 13, 1);
 		gpio_set_bits(mantis, 14, 1);
 		break;
 	case SEC_VOLTAGE_OFF:
-		dprintk(verbose, MANTIS_ERROR, 1, "Frontend (dummy) POWERDOWN");
+		dprintk(MANTIS_ERROR, 1, "Frontend (dummy) POWERDOWN");
 		break;
 	default:
-		dprintk(verbose, MANTIS_ERROR, 1, "Invalid = (%d)", (u32 ) voltage);
+		dprintk(MANTIS_ERROR, 1, "Invalid = (%d)", (u32 ) voltage);
 		return -EINVAL;
 	}
 	mmwrite(0x00, MANTIS_GPIF_DOUT);
 
 	return 0;
 }
+
+static int vp1034_frontend_init(struct mantis_pci *mantis, struct dvb_frontend *fe)
+{
+	struct i2c_adapter *adapter	= &mantis->adapter;
+
+	dprintk(MANTIS_ERROR, 1, "Probing for MB86A16 (DVB-S/DSS)");
+	fe = mb86a16_attach(&vp1034_mb86a16_config, adapter);
+	if (fe) {
+		dprintk(MANTIS_ERROR, 1,
+		"found MB86A16 DVB-S/DSS frontend @0x%02x",
+		vp1034_mb86a16_config.demod_address);
+
+	} else {
+		return -1;
+	}
+
+	mantis->fe = fe;
+	dprintk(MANTIS_ERROR, 1, "Done!");
+
+	return 0;
+}
+
+struct mantis_hwconfig vp1034_config = {
+	.model_name	= MANTIS_MODEL_NAME,
+	.dev_type	= MANTIS_DEV_TYPE,
+	.ts_size	= MANTIS_TS_204,
+
+	.baud_rate	= MANTIS_BAUD_9600,
+	.parity		= MANTIS_PARITY_NONE,
+	.bytes		= 0,
+
+	.frontend_init	= vp1034_frontend_init,
+};
diff --git a/drivers/media/dvb/mantis/mantis_vp1034.h b/drivers/media/dvb/mantis/mantis_vp1034.h
index 2194857..3026912 100644
--- a/drivers/media/dvb/mantis/mantis_vp1034.h
+++ b/drivers/media/dvb/mantis/mantis_vp1034.h
@@ -23,13 +23,11 @@
 
 #include "dvb_frontend.h"
 #include "mantis_common.h"
-#include "mb86a16.h"
 
 
 #define MANTIS_VP_1034_DVB_S	0x0014
 
-extern struct mantis_hwconfig vp1034_mantis_config;
-extern struct mb86a16_config vp1034_config;
+extern struct mantis_hwconfig vp1034_config;
 extern int vp1034_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage);
 
-#endif // __MANTIS_VP1034_H
+#endif /* __MANTIS_VP1034_H */
diff --git a/drivers/media/dvb/mantis/mantis_vp1041.c b/drivers/media/dvb/mantis/mantis_vp1041.c
index 90df80b..1181fad 100644
--- a/drivers/media/dvb/mantis/mantis_vp1041.c
+++ b/drivers/media/dvb/mantis/mantis_vp1041.c
@@ -18,24 +18,31 @@
 	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
+#include <asm/irq.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
 #include "mantis_common.h"
+#include "mantis_ioc.h"
+#include "mantis_dvb.h"
 #include "mantis_vp1041.h"
 #include "stb0899_reg.h"
+#include "stb0899_drv.h"
 #include "stb0899_cfg.h"
 #include "stb6100_cfg.h"
+#include "stb6100.h"
+#include "lnbp21.h"
 
 #define MANTIS_MODEL_NAME	"VP-1041"
 #define MANTIS_DEV_TYPE		"DSS/DVB-S/DVB-S2"
 
-struct mantis_hwconfig vp1041_mantis_config = {
-	.model_name	= MANTIS_MODEL_NAME,
-	.dev_type	= MANTIS_DEV_TYPE,
-	.ts_size	= MANTIS_TS_188,
-	.baud_rate	= MANTIS_BAUD_9600,
-	.parity		= MANTIS_PARITY_NONE,
-	.bytes		= 0,
-};
-
 static const struct stb0899_s1_reg vp1041_stb0899_s1_init_1[] = {
 
 //	 0x0000000b ,	/* SYSREG */
@@ -258,7 +265,7 @@ static const struct stb0899_s1_reg vp1041_stb0899_s1_init_3[] = {
 	{ 0xffff			, 0xff },
 };
 
-struct stb0899_config vp1041_config = {
+struct stb0899_config vp1041_stb0899_config = {
 	.init_dev		= vp1041_stb0899_s1_init_1,
 	.init_s2_demod		= stb0899_s2_init_2,
 	.init_s1_demod		= vp1041_stb0899_s1_init_3,
@@ -299,3 +306,55 @@ struct stb6100_config vp1041_stb6100_config = {
 	.tuner_address	= 0x60,
 	.refclock	= 27000000,
 };
+
+static int vp1041_frontend_init(struct mantis_pci *mantis, struct dvb_frontend *fe)
+{
+	struct i2c_adapter *adapter	= &mantis->adapter;
+
+	int err = 0;
+
+	err = mantis_frontend_power(mantis, POWER_ON);
+	if (err == 0) {
+		mantis_frontend_soft_reset(mantis);
+		msleep(250);
+		mantis->fe = stb0899_attach(&vp1041_stb0899_config, adapter);
+		if (mantis->fe) {
+			dprintk(MANTIS_ERROR, 1,
+				"found STB0899 DVB-S/DVB-S2 frontend @0x%02x",
+				vp1041_stb0899_config.demod_address);
+
+			if (stb6100_attach(mantis->fe, &vp1041_stb6100_config, adapter)) {
+				if (!lnbp21_attach(mantis->fe, adapter, 0, 0)) {
+					printk("%s: No LNBP21 found!\n", __func__);
+				}
+			}
+		} else {
+			return -EREMOTEIO;
+		}
+	} else {
+		dprintk(MANTIS_ERROR, 1, "Frontend on <%s> POWER ON failed! <%d>",
+			adapter->name,
+			err);
+
+		return -EIO;
+	}
+
+
+	dprintk(MANTIS_ERROR, 1, "Done!");
+
+	return 0;
+}
+
+struct mantis_hwconfig vp1041_config = {
+	.model_name	= MANTIS_MODEL_NAME,
+	.dev_type	= MANTIS_DEV_TYPE,
+	.ts_size	= MANTIS_TS_188,
+
+	.baud_rate	= MANTIS_BAUD_9600,
+	.parity		= MANTIS_PARITY_NONE,
+	.bytes		= 0,
+
+	.frontend_init	= vp1041_frontend_init,
+	.power		= GPIF_A12,
+	.reset		= GPIF_A13,
+};
diff --git a/drivers/media/dvb/mantis/mantis_vp1041.h b/drivers/media/dvb/mantis/mantis_vp1041.h
index 2cc83a6..1ae5b3d 100644
--- a/drivers/media/dvb/mantis/mantis_vp1041.h
+++ b/drivers/media/dvb/mantis/mantis_vp1041.h
@@ -21,17 +21,13 @@
 #ifndef __MANTIS_VP1041_H
 #define __MANTIS_VP1041_H
 
-#include "dvb_frontend.h"
 #include "mantis_common.h"
-#include "stb0899_drv.h"
-#include "stb6100.h"
-#include "lnbp21.h"
 
 #define MANTIS_VP_1041_DVB_S2	0x0031
-#define TECHNISAT_SKYSTAR_HD2	0x0001
+#define SKYSTAR_HD2_10		0x0001
+#define SKYSTAR_HD2_20		0x0003
+#define CINERGY_S2_PCI_HD	0x1179
 
-extern struct mantis_hwconfig vp1041_mantis_config;
-extern struct stb0899_config vp1041_config;
-extern struct stb6100_config vp1041_stb6100_config;
+extern struct mantis_hwconfig vp1041_config;
 
-#endif // __MANTIS_VP1041_H
+#endif /* __MANTIS_VP1041_H */
diff --git a/drivers/media/dvb/mantis/mantis_vp2033.c b/drivers/media/dvb/mantis/mantis_vp2033.c
index 1171e69..8773291 100644
--- a/drivers/media/dvb/mantis/mantis_vp2033.c
+++ b/drivers/media/dvb/mantis/mantis_vp2033.c
@@ -18,48 +18,59 @@
 	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
+#include <asm/irq.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
+#include "tda1002x.h"
 #include "mantis_common.h"
 #include "mantis_vp2033.h"
 
 #define MANTIS_MODEL_NAME	"VP-2033"
 #define MANTIS_DEV_TYPE		"DVB-C"
 
-struct mantis_hwconfig vp2033_mantis_config = {
-	.model_name	= MANTIS_MODEL_NAME,
-	.dev_type	= MANTIS_DEV_TYPE,
-	.ts_size	= MANTIS_TS_204,
-	.baud_rate	= MANTIS_BAUD_9600,
-	.parity		= MANTIS_PARITY_NONE,
-	.bytes		= 0,
+struct tda1002x_config vp2033_tda1002x_cu1216_config = {
+	.demod_address = 0x18 >> 1,
+	.invert = 1,
 };
 
-struct tda1002x_config philips_cu1216_config = {
+struct tda10023_config vp2033_tda10023_cu1216_config = {
 	.demod_address = 0x18 >> 1,
 	.invert = 1,
 };
 
-u8 read_pwm(struct mantis_pci *mantis)
+static u8 read_pwm(struct mantis_pci *mantis)
 {
+	struct i2c_adapter *adapter = &mantis->adapter;
+
 	u8 b = 0xff;
 	u8 pwm;
 	struct i2c_msg msg[] = {
-		{.addr = 0x50,.flags = 0,.buf = &b,.len = 1},
-		{.addr = 0x50,.flags = I2C_M_RD,.buf = &pwm,.len = 1}
+		{.addr = 0x50, .flags = 0, .buf = &b, .len = 1},
+		{.addr = 0x50, .flags = I2C_M_RD, .buf = &pwm, .len = 1}
 	};
 
-	if ((i2c_transfer(&mantis->adapter, msg, 2) != 2)
+	if ((i2c_transfer(adapter, msg, 2) != 2)
 	    || (pwm == 0xff))
 		pwm = 0x48;
 
 	return pwm;
 }
 
-int philips_cu1216_tuner_set(struct dvb_frontend *fe, struct dvb_frontend_parameters *params)
+static int tda1002x_cu1216_tuner_set(struct dvb_frontend *fe, struct dvb_frontend_parameters *params)
 {
 	struct mantis_pci *mantis = fe->dvb->priv;
+	struct i2c_adapter *adapter = &mantis->adapter;
 
 	u8 buf[6];
-	struct i2c_msg msg = {.addr = 0x60,.flags = 0,.buf = buf,.len = sizeof(buf) };
+	struct i2c_msg msg = {.addr = 0x60, .flags = 0, .buf = buf, .len = sizeof (buf) };
 	int i;
 
 #define CU1216_IF 36125000
@@ -78,7 +89,7 @@ int philips_cu1216_tuner_set(struct dvb_frontend *fe, struct dvb_frontend_parame
 	if (fe->ops.i2c_gate_ctrl)
 		fe->ops.i2c_gate_ctrl(fe, 1);
 
-	if (i2c_transfer(&mantis->adapter, &msg, 1) != 1)
+	if (i2c_transfer(adapter, &msg, 1) != 1)
 		return -EIO;
 
 	/* wait for the pll lock */
@@ -88,7 +99,7 @@ int philips_cu1216_tuner_set(struct dvb_frontend *fe, struct dvb_frontend_parame
 		if (fe->ops.i2c_gate_ctrl)
 			fe->ops.i2c_gate_ctrl(fe, 1);
 
-		if (i2c_transfer(&mantis->adapter, &msg, 1) == 1 && (buf[0] & 0x40))
+		if (i2c_transfer(adapter, &msg, 1) == 1 && (buf[0] & 0x40))
 			break;
 
 		msleep(10);
@@ -102,8 +113,58 @@ int philips_cu1216_tuner_set(struct dvb_frontend *fe, struct dvb_frontend_parame
 	if (fe->ops.i2c_gate_ctrl)
 		fe->ops.i2c_gate_ctrl(fe, 1);
 
-	if (i2c_transfer(&mantis->adapter, &msg, 1) != 1)
+	if (i2c_transfer(adapter, &msg, 1) != 1)
 		return -EIO;
 
 	return 0;
 }
+
+static int vp2033_frontend_init(struct mantis_pci *mantis, struct dvb_frontend *fe)
+{
+	struct i2c_adapter *adapter = &mantis->adapter;
+
+	dprintk(MANTIS_ERROR, 1, "Probing for CU1216 (DVB-C)");
+	fe = tda10021_attach(&vp2033_tda1002x_cu1216_config,
+			     adapter,
+			     read_pwm(mantis));
+
+	if (fe) {
+		dprintk(MANTIS_ERROR, 1,
+			"found Philips CU1216 DVB-C frontend (TDA10021) @ 0x%02x",
+			vp2033_tda1002x_cu1216_config.demod_address);
+	} else {
+		fe = tda10023_attach(&vp2033_tda10023_cu1216_config,
+				     adapter,
+				     read_pwm(mantis));
+
+		if (fe) {
+			dprintk(MANTIS_ERROR, 1,
+				"found Philips CU1216 DVB-C frontend (TDA10023) @ 0x%02x",
+				vp2033_tda1002x_cu1216_config.demod_address);
+		}
+	}
+
+	if (fe) {
+		fe->ops.tuner_ops.set_params = tda1002x_cu1216_tuner_set;
+		dprintk(MANTIS_ERROR, 1, "Mantis DVB-C Philips CU1216 frontend attach success");
+	} else {
+		return -1;
+	}
+
+	mantis->fe = fe;
+	dprintk(MANTIS_DEBUG, 1, "Done!");
+
+	return 0;
+}
+
+struct mantis_hwconfig vp2033_config = {
+	.model_name	= MANTIS_MODEL_NAME,
+	.dev_type	= MANTIS_DEV_TYPE,
+	.ts_size	= MANTIS_TS_204,
+
+	.baud_rate	= MANTIS_BAUD_9600,
+	.parity		= MANTIS_PARITY_NONE,
+	.bytes		= 0,
+
+	.frontend_init	= vp2033_frontend_init,
+};
diff --git a/drivers/media/dvb/mantis/mantis_vp2033.h b/drivers/media/dvb/mantis/mantis_vp2033.h
index fcf8b85..e6c5fe8 100644
--- a/drivers/media/dvb/mantis/mantis_vp2033.h
+++ b/drivers/media/dvb/mantis/mantis_vp2033.h
@@ -21,17 +21,10 @@
 #ifndef __MANTIS_VP2033_H
 #define __MANTIS_VP2033_H
 
-#include "dvb_frontend.h"
 #include "mantis_common.h"
-#include "tda1002x.h"
 
 #define MANTIS_VP_2033_DVB_C	0x0008
 
-extern struct tda1002x_config philips_cu1216_config;
-extern struct mantis_hwconfig vp2033_mantis_config;
+extern struct mantis_hwconfig vp2033_config;
 
-extern int philips_cu1216_tuner_set(struct dvb_frontend *fe, struct dvb_frontend_parameters *params);
-
-extern u8 read_pwm(struct mantis_pci *mantis);
-
-#endif // __MANTIS_VP2033_H
+#endif /* __MANTIS_VP2033_H */
diff --git a/drivers/media/dvb/mantis/mantis_vp2040.c b/drivers/media/dvb/mantis/mantis_vp2040.c
index ce73d6b..51b082f 100644
--- a/drivers/media/dvb/mantis/mantis_vp2040.c
+++ b/drivers/media/dvb/mantis/mantis_vp2040.c
@@ -18,22 +18,153 @@
 	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
+#include <asm/irq.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
+#include "tda1002x.h"
 #include "mantis_common.h"
 #include "mantis_vp2040.h"
 
 #define MANTIS_MODEL_NAME	"VP-2040"
 #define MANTIS_DEV_TYPE		"DVB-C"
 
-struct mantis_hwconfig vp2040_mantis_config = {
+struct tda1002x_config vp2040_tda1002x_cu1216_config = {
+	.demod_address	= 0x18 >> 1,
+	.invert		= 1,
+};
+
+struct tda10023_config vp2040_tda10023_cu1216_config = {
+	.demod_address	= 0x18 >> 1,
+	.invert		= 1,
+};
+
+static int tda1002x_cu1216_tuner_set(struct dvb_frontend *fe, struct dvb_frontend_parameters *params)
+{
+	struct mantis_pci *mantis	= fe->dvb->priv;
+	struct i2c_adapter *adapter	= &mantis->adapter;
+
+	u8 buf[6];
+	struct i2c_msg msg = {.addr = 0x60,.flags = 0,.buf = buf,.len = sizeof (buf) };
+	int i;
+
+#define CU1216_IF 36125000
+#define TUNER_MUL 62500
+
+	u32 div = (params->frequency + CU1216_IF + TUNER_MUL / 2) / TUNER_MUL;
+
+	buf[0] = (div >> 8) & 0x7f;
+	buf[1] = div & 0xff;
+	buf[2] = 0xce;
+	buf[3] = (params->frequency < 150000000 ? 0x01 :
+		  params->frequency < 445000000 ? 0x02 : 0x04);
+	buf[4] = 0xde;
+	buf[5] = 0x20;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	if (i2c_transfer(adapter, &msg, 1) != 1)
+		return -EIO;
+
+	/* wait for the pll lock */
+	msg.flags = I2C_M_RD;
+	msg.len = 1;
+	for (i = 0; i < 20; i++) {
+		if (fe->ops.i2c_gate_ctrl)
+			fe->ops.i2c_gate_ctrl(fe, 1);
+
+		if (i2c_transfer(adapter, &msg, 1) == 1 && (buf[0] & 0x40))
+			break;
+
+		msleep(10);
+	}
+
+	/* switch the charge pump to the lower current */
+	msg.flags = 0;
+	msg.len = 2;
+	msg.buf = &buf[2];
+	buf[2] &= ~0x40;
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	if (i2c_transfer(adapter, &msg, 1) != 1)
+		return -EIO;
+
+	return 0;
+}
+
+static u8 read_pwm(struct mantis_pci *mantis)
+{
+	struct i2c_adapter *adapter = &mantis->adapter;
+
+	u8 b = 0xff;
+	u8 pwm;
+	struct i2c_msg msg[] = {
+		{.addr = 0x50, .flags = 0, .buf = &b, .len = 1},
+		{.addr = 0x50, .flags = I2C_M_RD, .buf = &pwm, .len = 1}
+	};
+
+	if ((i2c_transfer(adapter, msg, 2) != 2)
+	    || (pwm == 0xff))
+		pwm = 0x48;
+
+	return pwm;
+}
+
+static int vp2040_frontend_init(struct mantis_pci *mantis, struct dvb_frontend *fe)
+{
+	struct i2c_adapter *adapter = &mantis->adapter;
+
+	dprintk(MANTIS_ERROR, 1, "Probing for CU1216 (DVB-C)");
+	fe = tda10021_attach(&vp2040_tda1002x_cu1216_config,
+			     adapter,
+			     read_pwm(mantis));
+
+	if (fe) {
+		dprintk(MANTIS_ERROR, 1,
+			"found Philips CU1216 DVB-C frontend (TDA10021) @ 0x%02x",
+			vp2040_tda1002x_cu1216_config.demod_address);
+	} else {
+		fe = tda10023_attach(&vp2040_tda10023_cu1216_config,
+				     adapter,
+				     read_pwm(mantis));
+
+		if (fe) {
+			dprintk(MANTIS_ERROR, 1,
+				"found Philips CU1216 DVB-C frontend (TDA10023) @ 0x%02x",
+				vp2040_tda1002x_cu1216_config.demod_address);
+		}
+	}
+
+	if (fe) {
+		fe->ops.tuner_ops.set_params = tda1002x_cu1216_tuner_set;
+		dprintk(MANTIS_ERROR, 1, "Mantis DVB-C Philips CU1216 frontend attach success");
+	} else {
+		return -1;
+	}
+
+	mantis->fe = fe;
+	dprintk(MANTIS_DEBUG, 1, "Done!");
+
+	return 0;
+}
+
+struct mantis_hwconfig vp2040_config = {
 	.model_name	= MANTIS_MODEL_NAME,
 	.dev_type	= MANTIS_DEV_TYPE,
 	.ts_size	= MANTIS_TS_204,
+
 	.baud_rate	= MANTIS_BAUD_9600,
 	.parity		= MANTIS_PARITY_NONE,
 	.bytes		= 0,
-};
 
-struct tda10023_config tda10023_cu1216_config = {
-	.demod_address = 0x18 >> 1,
-	.invert = 1,
+	.frontend_init	= vp2040_frontend_init,
 };
diff --git a/drivers/media/dvb/mantis/mantis_vp2040.h b/drivers/media/dvb/mantis/mantis_vp2040.h
index c745754..d125e21 100644
--- a/drivers/media/dvb/mantis/mantis_vp2040.h
+++ b/drivers/media/dvb/mantis/mantis_vp2040.h
@@ -21,15 +21,12 @@
 #ifndef __MANTIS_VP2040_H
 #define __MANTIS_VP2040_H
 
-#include "dvb_frontend.h"
 #include "mantis_common.h"
-#include "tda1002x.h"
 
 #define MANTIS_VP_2040_DVB_C	0x0043
-#define TERRATEC_CINERGY_C_PCI	0x1178
-#define TECHNISAT_CABLESTAR_HD2	0x0002
+#define CINERGY_C		0x1178
+#define CABLESTAR_HD2		0x0002
 
-extern struct tda10023_config tda10023_cu1216_config;
-extern struct mantis_hwconfig vp2040_mantis_config;
+extern struct mantis_hwconfig vp2040_config;
 
-#endif //__MANTIS_VP2040_H
+#endif /* __MANTIS_VP2040_H */
diff --git a/drivers/media/dvb/mantis/mantis_vp3030.c b/drivers/media/dvb/mantis/mantis_vp3030.c
index 9ca8040..4b974ee 100644
--- a/drivers/media/dvb/mantis/mantis_vp3030.c
+++ b/drivers/media/dvb/mantis/mantis_vp3030.c
@@ -18,6 +18,18 @@
 	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
+#include <asm/irq.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
+#include "zl10353.h"
 #include "mantis_common.h"
 #include "mantis_vp3030.h"
 
@@ -28,15 +40,6 @@ struct zl10353_config mantis_vp3030_config = {
 #define MANTIS_MODEL_NAME	"VP-3030"
 #define MANTIS_DEV_TYPE		"DVB-T"
 
-struct mantis_hwconfig vp3030_mantis_config = {
-	.model_name	= MANTIS_MODEL_NAME,
-	.dev_type	= MANTIS_DEV_TYPE,
-	.ts_size	= MANTIS_TS_188,
-	.baud_rate	= MANTIS_BAUD_9600,
-	.parity		= MANTIS_PARITY_NONE,
-	.bytes		= 0,
-};
-
 int panasonic_en57h12d5_set_params(struct dvb_frontend *fe,
 				   struct dvb_frontend_parameters *params)
 {
@@ -63,3 +66,31 @@ int panasonic_en57h12d5_set_params(struct dvb_frontend *fe,
 
 	return 0;
 }
+
+static int vp3030_frontend_init(struct mantis_pci *mantis, struct dvb_frontend *fe)
+{
+	struct i2c_adapter *adapter	= &mantis->adapter;
+
+	dprintk(MANTIS_ERROR, 1, "Probing for 10353 (DVB-T)");
+	fe = zl10353_attach(&mantis_vp3030_config, adapter);
+
+	if (!fe)
+		return -1;
+
+	mantis->fe = fe;
+	dprintk(MANTIS_ERROR, 1, "Done!");
+
+	return 0;
+}
+
+struct mantis_hwconfig vp3030_config = {
+	.model_name	= MANTIS_MODEL_NAME,
+	.dev_type	= MANTIS_DEV_TYPE,
+	.ts_size	= MANTIS_TS_188,
+
+	.baud_rate	= MANTIS_BAUD_9600,
+	.parity		= MANTIS_PARITY_NONE,
+	.bytes		= 0,
+
+	.frontend_init	= vp3030_frontend_init,
+};
diff --git a/drivers/media/dvb/mantis/mantis_vp3030.h b/drivers/media/dvb/mantis/mantis_vp3030.h
index acc50a4..0a110ba 100644
--- a/drivers/media/dvb/mantis/mantis_vp3030.h
+++ b/drivers/media/dvb/mantis/mantis_vp3030.h
@@ -21,14 +21,10 @@
 #ifndef __MANTIS_VP3030_H
 #define __MANTIS_VP3030_H
 
-#include "dvb_frontend.h"
 #include "mantis_common.h"
-#include "dvb-pll.h"
-#include "zl10353.h"
 
 #define MANTIS_VP_3030_DVB_T	0x0024
 
-extern struct zl10353_config mantis_vp3030_config;
-extern struct mantis_hwconfig vp3030_mantis_config;
+extern struct mantis_hwconfig vp3030_config;
 
-#endif // __MANTIS_VP3030_H
+#endif /* __MANTIS_VP3030_H */
-- 
1.7.1

